<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Adverse Event Workflow Examples</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>
<script>/*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */
!function(e,t){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],r=Object.getPrototypeOf,s=t.slice,g=t.flat?function(e){return t.flat.call(e)}:function(e){return t.concat.apply([],e)},u=t.push,i=t.indexOf,n={},o=n.toString,v=n.hasOwnProperty,a=v.toString,l=a.call(Object),y={},m=function(e){return"function"==typeof e&&"number"!=typeof e.nodeType&&"function"!=typeof e.item},x=function(e){return null!=e&&e===e.window},E=C.document,c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement("script");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?n[o.call(e)]||"object":typeof e}var f="3.6.0",S=function(e,t){return new S.fn.init(e,t)};function p(e){var t=!!e&&"length"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&("array"===n||0===t||"number"==typeof t&&0<t&&t-1 in e)}S.fn=S.prototype={jquery:f,constructor:S,length:0,toArray:function(){return s.call(this)},get:function(e){return null==e?s.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=S.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return S.each(this,e)},map:function(n){return this.pushStack(S.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(s.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},even:function(){return this.pushStack(S.grep(this,function(e,t){return(t+1)%2}))},odd:function(){return this.pushStack(S.grep(this,function(e,t){return t%2}))},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(0<=n&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:u,sort:t.sort,splice:t.splice},S.extend=S.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for("boolean"==typeof a&&(l=a,a=arguments[s]||{},s++),"object"==typeof a||m(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],"__proto__"!==t&&a!==r&&(l&&r&&(S.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i&&!Array.isArray(n)?[]:i||S.isPlainObject(n)?n:{},i=!1,a[t]=S.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},S.extend({expando:"jQuery"+(f+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||"[object Object]"!==o.call(e))&&(!(t=r(e))||"function"==typeof(n=v.call(t,"constructor")&&t.constructor)&&a.call(n)===l)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t,n){b(e,{nonce:t&&t.nonce},n)},each:function(e,t){var n,r=0;if(p(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},makeArray:function(e,t){var n=t||[];return null!=e&&(p(Object(e))?S.merge(n,"string"==typeof e?[e]:e):u.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:i.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(p(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&a.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&a.push(i);return g(a)},guid:1,support:y}),"function"==typeof Symbol&&(S.fn[Symbol.iterator]=t[Symbol.iterator]),S.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(e,t){n["[object "+t+"]"]=t.toLowerCase()});var d=function(n){var e,d,b,o,i,h,f,g,w,u,l,T,C,a,E,v,s,c,y,S="sizzle"+1*new Date,p=n.document,k=0,r=0,m=ue(),x=ue(),A=ue(),N=ue(),j=function(e,t){return e===t&&(l=!0),0},D={}.hasOwnProperty,t=[],q=t.pop,L=t.push,H=t.push,O=t.slice,P=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},R="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",I="(?:\\\\[\\da-fA-F]{1,6}"+M+"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",W="\\["+M+"*("+I+")(?:"+M+"*([*^$|!~]?=)"+M+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+I+"))|)"+M+"*\\]",F=":("+I+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+W+")*)|.*)\\)|)",B=new RegExp(M+"+","g"),$=new RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),_=new RegExp("^"+M+"*,"+M+"*"),z=new RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),U=new RegExp(M+"|>"),X=new RegExp(F),V=new RegExp("^"+I+"$"),G={ID:new RegExp("^#("+I+")"),CLASS:new RegExp("^\\.("+I+")"),TAG:new RegExp("^("+I+"|[*])"),ATTR:new RegExp("^"+W),PSEUDO:new RegExp("^"+F),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:new RegExp("^(?:"+R+")$","i"),needsContext:new RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},Y=/HTML$/i,Q=/^(?:input|select|textarea|button)$/i,J=/^h\d$/i,K=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ee=/[+~]/,te=new RegExp("\\\\[\\da-fA-F]{1,6}"+M+"?|\\\\([^\\r\\n\\f])","g"),ne=function(e,t){var n="0x"+e.slice(1)-65536;return t||(n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,1023&n|56320))},re=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ie=function(e,t){return t?"\0"===e?"\ufffd":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e},oe=function(){T()},ae=be(function(e){return!0===e.disabled&&"fieldset"===e.nodeName.toLowerCase()},{dir:"parentNode",next:"legend"});try{H.apply(t=O.call(p.childNodes),p.childNodes),t[p.childNodes.length].nodeType}catch(e){H={apply:t.length?function(e,t){L.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function se(t,e,n,r){var i,o,a,s,u,l,c,f=e&&e.ownerDocument,p=e?e.nodeType:9;if(n=n||[],"string"!=typeof t||!t||1!==p&&9!==p&&11!==p)return n;if(!r&&(T(e),e=e||C,E)){if(11!==p&&(u=Z.exec(t)))if(i=u[1]){if(9===p){if(!(a=e.getElementById(i)))return n;if(a.id===i)return n.push(a),n}else if(f&&(a=f.getElementById(i))&&y(e,a)&&a.id===i)return n.push(a),n}else{if(u[2])return H.apply(n,e.getElementsByTagName(t)),n;if((i=u[3])&&d.getElementsByClassName&&e.getElementsByClassName)return H.apply(n,e.getElementsByClassName(i)),n}if(d.qsa&&!N[t+" "]&&(!v||!v.test(t))&&(1!==p||"object"!==e.nodeName.toLowerCase())){if(c=t,f=e,1===p&&(U.test(t)||z.test(t))){(f=ee.test(t)&&ye(e.parentNode)||e)===e&&d.scope||((s=e.getAttribute("id"))?s=s.replace(re,ie):e.setAttribute("id",s=S)),o=(l=h(t)).length;while(o--)l[o]=(s?"#"+s:":scope")+" "+xe(l[o]);c=l.join(",")}try{return H.apply(n,f.querySelectorAll(c)),n}catch(e){N(t,!0)}finally{s===S&&e.removeAttribute("id")}}}return g(t.replace($,"$1"),e,n,r)}function ue(){var r=[];return function e(t,n){return r.push(t+" ")>b.cacheLength&&delete e[r.shift()],e[t+" "]=n}}function le(e){return e[S]=!0,e}function ce(e){var t=C.createElement("fieldset");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function fe(e,t){var n=e.split("|"),r=n.length;while(r--)b.attrHandle[n[r]]=t}function pe(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function de(t){return function(e){return"input"===e.nodeName.toLowerCase()&&e.type===t}}function he(n){return function(e){var t=e.nodeName.toLowerCase();return("input"===t||"button"===t)&&e.type===n}}function ge(t){return function(e){return"form"in e?e.parentNode&&!1===e.disabled?"label"in e?"label"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&ae(e)===t:e.disabled===t:"label"in e&&e.disabled===t}}function ve(a){return le(function(o){return o=+o,le(function(e,t){var n,r=a([],e.length,o),i=r.length;while(i--)e[n=r[i]]&&(e[n]=!(t[n]=e[n]))})})}function ye(e){return e&&"undefined"!=typeof e.getElementsByTagName&&e}for(e in d=se.support={},i=se.isXML=function(e){var t=e&&e.namespaceURI,n=e&&(e.ownerDocument||e).documentElement;return!Y.test(t||n&&n.nodeName||"HTML")},T=se.setDocument=function(e){var t,n,r=e?e.ownerDocument||e:p;return r!=C&&9===r.nodeType&&r.documentElement&&(a=(C=r).documentElement,E=!i(C),p!=C&&(n=C.defaultView)&&n.top!==n&&(n.addEventListener?n.addEventListener("unload",oe,!1):n.attachEvent&&n.attachEvent("onunload",oe)),d.scope=ce(function(e){return a.appendChild(e).appendChild(C.createElement("div")),"undefined"!=typeof e.querySelectorAll&&!e.querySelectorAll(":scope fieldset div").length}),d.attributes=ce(function(e){return e.className="i",!e.getAttribute("className")}),d.getElementsByTagName=ce(function(e){return e.appendChild(C.createComment("")),!e.getElementsByTagName("*").length}),d.getElementsByClassName=K.test(C.getElementsByClassName),d.getById=ce(function(e){return a.appendChild(e).id=S,!C.getElementsByName||!C.getElementsByName(S).length}),d.getById?(b.filter.ID=function(e){var t=e.replace(te,ne);return function(e){return e.getAttribute("id")===t}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n=t.getElementById(e);return n?[n]:[]}}):(b.filter.ID=function(e){var n=e.replace(te,ne);return function(e){var t="undefined"!=typeof e.getAttributeNode&&e.getAttributeNode("id");return t&&t.value===n}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode("id"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode("id"))&&n.value===e)return[o]}return[]}}),b.find.TAG=d.getElementsByTagName?function(e,t){return"undefined"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):d.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},b.find.CLASS=d.getElementsByClassName&&function(e,t){if("undefined"!=typeof t.getElementsByClassName&&E)return t.getElementsByClassName(e)},s=[],v=[],(d.qsa=K.test(C.querySelectorAll))&&(ce(function(e){var t;a.appendChild(e).innerHTML="<a id='"+S+"'></a><select id='"+S+"-\r\\' msallowcapture=''><option selected=''></option></select>",e.querySelectorAll("[msallowcapture^='']").length&&v.push("[*^$]="+M+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||v.push("\\["+M+"*(?:value|"+R+")"),e.querySelectorAll("[id~="+S+"-]").length||v.push("~="),(t=C.createElement("input")).setAttribute("name",""),e.appendChild(t),e.querySelectorAll("[name='']").length||v.push("\\["+M+"*name"+M+"*="+M+"*(?:''|\"\")"),e.querySelectorAll(":checked").length||v.push(":checked"),e.querySelectorAll("a#"+S+"+*").length||v.push(".#.+[+~]"),e.querySelectorAll("\\\f"),v.push("[\\r\\n\\f]")}),ce(function(e){e.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var t=C.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&v.push("name"+M+"*[*^$|!~]?="),2!==e.querySelectorAll(":enabled").length&&v.push(":enabled",":disabled"),a.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&v.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),v.push(",.*:")})),(d.matchesSelector=K.test(c=a.matches||a.webkitMatchesSelector||a.mozMatchesSelector||a.oMatchesSelector||a.msMatchesSelector))&&ce(function(e){d.disconnectedMatch=c.call(e,"*"),c.call(e,"[s!='']:x"),s.push("!=",F)}),v=v.length&&new RegExp(v.join("|")),s=s.length&&new RegExp(s.join("|")),t=K.test(a.compareDocumentPosition),y=t||K.test(a.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},j=t?function(e,t){if(e===t)return l=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(1&(n=(e.ownerDocument||e)==(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!d.sortDetached&&t.compareDocumentPosition(e)===n?e==C||e.ownerDocument==p&&y(p,e)?-1:t==C||t.ownerDocument==p&&y(p,t)?1:u?P(u,e)-P(u,t):0:4&n?-1:1)}:function(e,t){if(e===t)return l=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e==C?-1:t==C?1:i?-1:o?1:u?P(u,e)-P(u,t):0;if(i===o)return pe(e,t);n=e;while(n=n.parentNode)a.unshift(n);n=t;while(n=n.parentNode)s.unshift(n);while(a[r]===s[r])r++;return r?pe(a[r],s[r]):a[r]==p?-1:s[r]==p?1:0}),C},se.matches=function(e,t){return se(e,null,null,t)},se.matchesSelector=function(e,t){if(T(e),d.matchesSelector&&E&&!N[t+" "]&&(!s||!s.test(t))&&(!v||!v.test(t)))try{var n=c.call(e,t);if(n||d.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){N(t,!0)}return 0<se(t,C,null,[e]).length},se.contains=function(e,t){return(e.ownerDocument||e)!=C&&T(e),y(e,t)},se.attr=function(e,t){(e.ownerDocument||e)!=C&&T(e);var n=b.attrHandle[t.toLowerCase()],r=n&&D.call(b.attrHandle,t.toLowerCase())?n(e,t,!E):void 0;return void 0!==r?r:d.attributes||!E?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},se.escape=function(e){return(e+"").replace(re,ie)},se.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},se.uniqueSort=function(e){var t,n=[],r=0,i=0;if(l=!d.detectDuplicates,u=!d.sortStable&&e.slice(0),e.sort(j),l){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)e.splice(n[r],1)}return u=null,e},o=se.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else while(t=e[r++])n+=o(t);return n},(b=se.selectors={cacheLength:50,createPseudo:le,match:G,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,ne),e[3]=(e[3]||e[4]||e[5]||"").replace(te,ne),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||se.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&se.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return G.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&X.test(n)&&(t=h(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(te,ne).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=m[e+" "];return t||(t=new RegExp("(^|"+M+")"+e+"("+M+"|$)"))&&m(e,function(e){return t.test("string"==typeof e.className&&e.className||"undefined"!=typeof e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(n,r,i){return function(e){var t=se.attr(e,n);return null==t?"!="===r:!r||(t+="","="===r?t===i:"!="===r?t!==i:"^="===r?i&&0===t.indexOf(i):"*="===r?i&&-1<t.indexOf(i):"$="===r?i&&t.slice(-i.length)===i:"~="===r?-1<(" "+t.replace(B," ")+" ").indexOf(i):"|="===r&&(t===i||t.slice(0,i.length+1)===i+"-"))}},CHILD:function(h,e,t,g,v){var y="nth"!==h.slice(0,3),m="last"!==h.slice(-4),x="of-type"===e;return 1===g&&0===v?function(e){return!!e.parentNode}:function(e,t,n){var r,i,o,a,s,u,l=y!==m?"nextSibling":"previousSibling",c=e.parentNode,f=x&&e.nodeName.toLowerCase(),p=!n&&!x,d=!1;if(c){if(y){while(l){a=e;while(a=a[l])if(x?a.nodeName.toLowerCase()===f:1===a.nodeType)return!1;u=l="only"===h&&!u&&"nextSibling"}return!0}if(u=[m?c.firstChild:c.lastChild],m&&p){d=(s=(r=(i=(o=(a=c)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1])&&r[2],a=s&&c.childNodes[s];while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if(1===a.nodeType&&++d&&a===e){i[h]=[k,s,d];break}}else if(p&&(d=s=(r=(i=(o=(a=e)[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===k&&r[1]),!1===d)while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if((x?a.nodeName.toLowerCase()===f:1===a.nodeType)&&++d&&(p&&((i=(o=a[S]||(a[S]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]=[k,d]),a===e))break;return(d-=v)===g||d%g==0&&0<=d/g}}},PSEUDO:function(e,o){var t,a=b.pseudos[e]||b.setFilters[e.toLowerCase()]||se.error("unsupported pseudo: "+e);return a[S]?a(o):1<a.length?(t=[e,e,"",o],b.setFilters.hasOwnProperty(e.toLowerCase())?le(function(e,t){var n,r=a(e,o),i=r.length;while(i--)e[n=P(e,r[i])]=!(t[n]=r[i])}):function(e){return a(e,0,t)}):a}},pseudos:{not:le(function(e){var r=[],i=[],s=f(e.replace($,"$1"));return s[S]?le(function(e,t,n,r){var i,o=s(e,null,r,[]),a=e.length;while(a--)(i=o[a])&&(e[a]=!(t[a]=i))}):function(e,t,n){return r[0]=e,s(r,null,n,i),r[0]=null,!i.pop()}}),has:le(function(t){return function(e){return 0<se(t,e).length}}),contains:le(function(t){return t=t.replace(te,ne),function(e){return-1<(e.textContent||o(e)).indexOf(t)}}),lang:le(function(n){return V.test(n||"")||se.error("unsupported lang: "+n),n=n.replace(te,ne).toLowerCase(),function(e){var t;do{if(t=E?e.lang:e.getAttribute("xml:lang")||e.getAttribute("lang"))return(t=t.toLowerCase())===n||0===t.indexOf(n+"-")}while((e=e.parentNode)&&1===e.nodeType);return!1}}),target:function(e){var t=n.location&&n.location.hash;return t&&t.slice(1)===e.id},root:function(e){return e===a},focus:function(e){return e===C.activeElement&&(!C.hasFocus||C.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:ge(!1),disabled:ge(!0),checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!b.pseudos.empty(e)},header:function(e){return J.test(e.nodeName)},input:function(e){return Q.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:ve(function(){return[0]}),last:ve(function(e,t){return[t-1]}),eq:ve(function(e,t,n){return[n<0?n+t:n]}),even:ve(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:ve(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:ve(function(e,t,n){for(var r=n<0?n+t:t<n?t:n;0<=--r;)e.push(r);return e}),gt:ve(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=b.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})b.pseudos[e]=de(e);for(e in{submit:!0,reset:!0})b.pseudos[e]=he(e);function me(){}function xe(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function be(s,e,t){var u=e.dir,l=e.next,c=l||u,f=t&&"parentNode"===c,p=r++;return e.first?function(e,t,n){while(e=e[u])if(1===e.nodeType||f)return s(e,t,n);return!1}:function(e,t,n){var r,i,o,a=[k,p];if(n){while(e=e[u])if((1===e.nodeType||f)&&s(e,t,n))return!0}else while(e=e[u])if(1===e.nodeType||f)if(i=(o=e[S]||(e[S]={}))[e.uniqueID]||(o[e.uniqueID]={}),l&&l===e.nodeName.toLowerCase())e=e[u]||e;else{if((r=i[c])&&r[0]===k&&r[1]===p)return a[2]=r[2];if((i[c]=a)[2]=s(e,t,n))return!0}return!1}}function we(i){return 1<i.length?function(e,t,n){var r=i.length;while(r--)if(!i[r](e,t,n))return!1;return!0}:i[0]}function Te(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function Ce(d,h,g,v,y,e){return v&&!v[S]&&(v=Ce(v)),y&&!y[S]&&(y=Ce(y,e)),le(function(e,t,n,r){var i,o,a,s=[],u=[],l=t.length,c=e||function(e,t,n){for(var r=0,i=t.length;r<i;r++)se(e,t[r],n);return n}(h||"*",n.nodeType?[n]:n,[]),f=!d||!e&&h?c:Te(c,s,d,n,r),p=g?y||(e?d:l||v)?[]:t:f;if(g&&g(f,p,n,r),v){i=Te(p,u),v(i,[],n,r),o=i.length;while(o--)(a=i[o])&&(p[u[o]]=!(f[u[o]]=a))}if(e){if(y||d){if(y){i=[],o=p.length;while(o--)(a=p[o])&&i.push(f[o]=a);y(null,p=[],i,r)}o=p.length;while(o--)(a=p[o])&&-1<(i=y?P(e,a):s[o])&&(e[i]=!(t[i]=a))}}else p=Te(p===t?p.splice(l,p.length):p),y?y(null,t,p,r):H.apply(t,p)})}function Ee(e){for(var i,t,n,r=e.length,o=b.relative[e[0].type],a=o||b.relative[" "],s=o?1:0,u=be(function(e){return e===i},a,!0),l=be(function(e){return-1<P(i,e)},a,!0),c=[function(e,t,n){var r=!o&&(n||t!==w)||((i=t).nodeType?u(e,t,n):l(e,t,n));return i=null,r}];s<r;s++)if(t=b.relative[e[s].type])c=[be(we(c),t)];else{if((t=b.filter[e[s].type].apply(null,e[s].matches))[S]){for(n=++s;n<r;n++)if(b.relative[e[n].type])break;return Ce(1<s&&we(c),1<s&&xe(e.slice(0,s-1).concat({value:" "===e[s-2].type?"*":""})).replace($,"$1"),t,s<n&&Ee(e.slice(s,n)),n<r&&Ee(e=e.slice(n)),n<r&&xe(e))}c.push(t)}return we(c)}return me.prototype=b.filters=b.pseudos,b.setFilters=new me,h=se.tokenize=function(e,t){var n,r,i,o,a,s,u,l=x[e+" "];if(l)return t?0:l.slice(0);a=e,s=[],u=b.preFilter;while(a){for(o in n&&!(r=_.exec(a))||(r&&(a=a.slice(r[0].length)||a),s.push(i=[])),n=!1,(r=z.exec(a))&&(n=r.shift(),i.push({value:n,type:r[0].replace($," ")}),a=a.slice(n.length)),b.filter)!(r=G[o].exec(a))||u[o]&&!(r=u[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?se.error(e):x(e,s).slice(0)},f=se.compile=function(e,t){var n,v,y,m,x,r,i=[],o=[],a=A[e+" "];if(!a){t||(t=h(e)),n=t.length;while(n--)(a=Ee(t[n]))[S]?i.push(a):o.push(a);(a=A(e,(v=o,m=0<(y=i).length,x=0<v.length,r=function(e,t,n,r,i){var o,a,s,u=0,l="0",c=e&&[],f=[],p=w,d=e||x&&b.find.TAG("*",i),h=k+=null==p?1:Math.random()||.1,g=d.length;for(i&&(w=t==C||t||i);l!==g&&null!=(o=d[l]);l++){if(x&&o){a=0,t||o.ownerDocument==C||(T(o),n=!E);while(s=v[a++])if(s(o,t||C,n)){r.push(o);break}i&&(k=h)}m&&((o=!s&&o)&&u--,e&&c.push(o))}if(u+=l,m&&l!==u){a=0;while(s=y[a++])s(c,f,t,n);if(e){if(0<u)while(l--)c[l]||f[l]||(f[l]=q.call(r));f=Te(f)}H.apply(r,f),i&&!e&&0<f.length&&1<u+y.length&&se.uniqueSort(r)}return i&&(k=h,w=p),c},m?le(r):r))).selector=e}return a},g=se.select=function(e,t,n,r){var i,o,a,s,u,l="function"==typeof e&&e,c=!r&&h(e=l.selector||e);if(n=n||[],1===c.length){if(2<(o=c[0]=c[0].slice(0)).length&&"ID"===(a=o[0]).type&&9===t.nodeType&&E&&b.relative[o[1].type]){if(!(t=(b.find.ID(a.matches[0].replace(te,ne),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}i=G.needsContext.test(e)?0:o.length;while(i--){if(a=o[i],b.relative[s=a.type])break;if((u=b.find[s])&&(r=u(a.matches[0].replace(te,ne),ee.test(o[0].type)&&ye(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&xe(o)))return H.apply(n,r),n;break}}}return(l||f(e,c))(r,t,!E,n,!t||ee.test(e)&&ye(t.parentNode)||t),n},d.sortStable=S.split("").sort(j).join("")===S,d.detectDuplicates=!!l,T(),d.sortDetached=ce(function(e){return 1&e.compareDocumentPosition(C.createElement("fieldset"))}),ce(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||fe("type|href|height|width",function(e,t,n){if(!n)return e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),d.attributes&&ce(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||fe("value",function(e,t,n){if(!n&&"input"===e.nodeName.toLowerCase())return e.defaultValue}),ce(function(e){return null==e.getAttribute("disabled")})||fe(R,function(e,t,n){var r;if(!n)return!0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),se}(C);S.find=d,S.expr=d.selectors,S.expr[":"]=S.expr.pseudos,S.uniqueSort=S.unique=d.uniqueSort,S.text=d.getText,S.isXMLDoc=d.isXML,S.contains=d.contains,S.escapeSelector=d.escape;var h=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&S(e).is(n))break;r.push(e)}return r},T=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},k=S.expr.match.needsContext;function A(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}var N=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function j(e,n,r){return m(n)?S.grep(e,function(e,t){return!!n.call(e,t,e)!==r}):n.nodeType?S.grep(e,function(e){return e===n!==r}):"string"!=typeof n?S.grep(e,function(e){return-1<i.call(n,e)!==r}):S.filter(n,e,r)}S.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?S.find.matchesSelector(r,e)?[r]:[]:S.find.matches(e,S.grep(t,function(e){return 1===e.nodeType}))},S.fn.extend({find:function(e){var t,n,r=this.length,i=this;if("string"!=typeof e)return this.pushStack(S(e).filter(function(){for(t=0;t<r;t++)if(S.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)S.find(e,i[t],n);return 1<r?S.uniqueSort(n):n},filter:function(e){return this.pushStack(j(this,e||[],!1))},not:function(e){return this.pushStack(j(this,e||[],!0))},is:function(e){return!!j(this,"string"==typeof e&&k.test(e)?S(e):e||[],!1).length}});var D,q=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(S.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||D,"string"==typeof e){if(!(r="<"===e[0]&&">"===e[e.length-1]&&3<=e.length?[null,e,null]:q.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof S?t[0]:t,S.merge(this,S.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:E,!0)),N.test(r[1])&&S.isPlainObject(t))for(r in t)m(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return(i=E.getElementById(r[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):m(e)?void 0!==n.ready?n.ready(e):e(S):S.makeArray(e,this)}).prototype=S.fn,D=S(E);var L=/^(?:parents|prev(?:Until|All))/,H={children:!0,contents:!0,next:!0,prev:!0};function O(e,t){while((e=e[t])&&1!==e.nodeType);return e}S.fn.extend({has:function(e){var t=S(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(S.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a="string"!=typeof e&&S(e);if(!k.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?-1<a.index(n):1===n.nodeType&&S.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(1<o.length?S.uniqueSort(o):o)},index:function(e){return e?"string"==typeof e?i.call(S(e),this[0]):i.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(S.uniqueSort(S.merge(this.get(),S(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),S.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return h(e,"parentNode")},parentsUntil:function(e,t,n){return h(e,"parentNode",n)},next:function(e){return O(e,"nextSibling")},prev:function(e){return O(e,"previousSibling")},nextAll:function(e){return h(e,"nextSibling")},prevAll:function(e){return h(e,"previousSibling")},nextUntil:function(e,t,n){return h(e,"nextSibling",n)},prevUntil:function(e,t,n){return h(e,"previousSibling",n)},siblings:function(e){return T((e.parentNode||{}).firstChild,e)},children:function(e){return T(e.firstChild)},contents:function(e){return null!=e.contentDocument&&r(e.contentDocument)?e.contentDocument:(A(e,"template")&&(e=e.content||e),S.merge([],e.childNodes))}},function(r,i){S.fn[r]=function(e,t){var n=S.map(this,i,e);return"Until"!==r.slice(-5)&&(t=e),t&&"string"==typeof t&&(n=S.filter(t,n)),1<this.length&&(H[r]||S.uniqueSort(n),L.test(r)&&n.reverse()),this.pushStack(n)}});var P=/[^\x20\t\r\n\f]+/g;function R(e){return e}function M(e){throw e}function I(e,t,n,r){var i;try{e&&m(i=e.promise)?i.call(e).done(t).fail(n):e&&m(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}S.Callbacks=function(r){var e,n;r="string"==typeof r?(e=r,n={},S.each(e.match(P)||[],function(e,t){n[t]=!0}),n):S.extend({},r);var i,t,o,a,s=[],u=[],l=-1,c=function(){for(a=a||r.once,o=i=!0;u.length;l=-1){t=u.shift();while(++l<s.length)!1===s[l].apply(t[0],t[1])&&r.stopOnFalse&&(l=s.length,t=!1)}r.memory||(t=!1),i=!1,a&&(s=t?[]:"")},f={add:function(){return s&&(t&&!i&&(l=s.length-1,u.push(t)),function n(e){S.each(e,function(e,t){m(t)?r.unique&&f.has(t)||s.push(t):t&&t.length&&"string"!==w(t)&&n(t)})}(arguments),t&&!i&&c()),this},remove:function(){return S.each(arguments,function(e,t){var n;while(-1<(n=S.inArray(t,s,n)))s.splice(n,1),n<=l&&l--}),this},has:function(e){return e?-1<S.inArray(e,s):0<s.length},empty:function(){return s&&(s=[]),this},disable:function(){return a=u=[],s=t="",this},disabled:function(){return!s},lock:function(){return a=u=[],t||i||(s=t=""),this},locked:function(){return!!a},fireWith:function(e,t){return a||(t=[e,(t=t||[]).slice?t.slice():t],u.push(t),i||c()),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!o}};return f},S.extend({Deferred:function(e){var o=[["notify","progress",S.Callbacks("memory"),S.Callbacks("memory"),2],["resolve","done",S.Callbacks("once memory"),S.Callbacks("once memory"),0,"resolved"],["reject","fail",S.Callbacks("once memory"),S.Callbacks("once memory"),1,"rejected"]],i="pending",a={state:function(){return i},always:function(){return s.done(arguments).fail(arguments),this},"catch":function(e){return a.then(null,e)},pipe:function(){var i=arguments;return S.Deferred(function(r){S.each(o,function(e,t){var n=m(i[t[4]])&&i[t[4]];s[t[1]](function(){var e=n&&n.apply(this,arguments);e&&m(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[t[0]+"With"](this,n?[e]:arguments)})}),i=null}).promise()},then:function(t,n,r){var u=0;function l(i,o,a,s){return function(){var n=this,r=arguments,e=function(){var e,t;if(!(i<u)){if((e=a.apply(n,r))===o.promise())throw new TypeError("Thenable self-resolution");t=e&&("object"==typeof e||"function"==typeof e)&&e.then,m(t)?s?t.call(e,l(u,o,R,s),l(u,o,M,s)):(u++,t.call(e,l(u,o,R,s),l(u,o,M,s),l(u,o,R,o.notifyWith))):(a!==R&&(n=void 0,r=[e]),(s||o.resolveWith)(n,r))}},t=s?e:function(){try{e()}catch(e){S.Deferred.exceptionHook&&S.Deferred.exceptionHook(e,t.stackTrace),u<=i+1&&(a!==M&&(n=void 0,r=[e]),o.rejectWith(n,r))}};i?t():(S.Deferred.getStackHook&&(t.stackTrace=S.Deferred.getStackHook()),C.setTimeout(t))}}return S.Deferred(function(e){o[0][3].add(l(0,e,m(r)?r:R,e.notifyWith)),o[1][3].add(l(0,e,m(t)?t:R)),o[2][3].add(l(0,e,m(n)?n:M))}).promise()},promise:function(e){return null!=e?S.extend(e,a):a}},s={};return S.each(o,function(e,t){var n=t[2],r=t[5];a[t[1]]=n.add,r&&n.add(function(){i=r},o[3-e][2].disable,o[3-e][3].disable,o[0][2].lock,o[0][3].lock),n.add(t[3].fire),s[t[0]]=function(){return s[t[0]+"With"](this===s?void 0:this,arguments),this},s[t[0]+"With"]=n.fireWith}),a.promise(s),e&&e.call(s,s),s},when:function(e){var n=arguments.length,t=n,r=Array(t),i=s.call(arguments),o=S.Deferred(),a=function(t){return function(e){r[t]=this,i[t]=1<arguments.length?s.call(arguments):e,--n||o.resolveWith(r,i)}};if(n<=1&&(I(e,o.done(a(t)).resolve,o.reject,!n),"pending"===o.state()||m(i[t]&&i[t].then)))return o.then();while(t--)I(i[t],a(t),o.reject);return o.promise()}});var W=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;S.Deferred.exceptionHook=function(e,t){C.console&&C.console.warn&&e&&W.test(e.name)&&C.console.warn("jQuery.Deferred exception: "+e.message,e.stack,t)},S.readyException=function(e){C.setTimeout(function(){throw e})};var F=S.Deferred();function B(){E.removeEventListener("DOMContentLoaded",B),C.removeEventListener("load",B),S.ready()}S.fn.ready=function(e){return F.then(e)["catch"](function(e){S.readyException(e)}),this},S.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--S.readyWait:S.isReady)||(S.isReady=!0)!==e&&0<--S.readyWait||F.resolveWith(E,[S])}}),S.ready.then=F.then,"complete"===E.readyState||"loading"!==E.readyState&&!E.documentElement.doScroll?C.setTimeout(S.ready):(E.addEventListener("DOMContentLoaded",B),C.addEventListener("load",B));var $=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if("object"===w(n))for(s in i=!0,n)$(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,m(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(S(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},_=/^-ms-/,z=/-([a-z])/g;function U(e,t){return t.toUpperCase()}function X(e){return e.replace(_,"ms-").replace(z,U)}var V=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function G(){this.expando=S.expando+G.uid++}G.uid=1,G.prototype={cache:function(e){var t=e[this.expando];return t||(t={},V(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if("string"==typeof t)i[X(t)]=n;else for(r in t)i[X(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][X(t)]},access:function(e,t,n){return void 0===t||t&&"string"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(X):(t=X(t))in r?[t]:t.match(P)||[]).length;while(n--)delete r[t[n]]}(void 0===t||S.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!S.isEmptyObject(t)}};var Y=new G,Q=new G,J=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,K=/[A-Z]/g;function Z(e,t,n){var r,i;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(K,"-$&").toLowerCase(),"string"==typeof(n=e.getAttribute(r))){try{n="true"===(i=n)||"false"!==i&&("null"===i?null:i===+i+""?+i:J.test(i)?JSON.parse(i):i)}catch(e){}Q.set(e,t,n)}else n=void 0;return n}S.extend({hasData:function(e){return Q.hasData(e)||Y.hasData(e)},data:function(e,t,n){return Q.access(e,t,n)},removeData:function(e,t){Q.remove(e,t)},_data:function(e,t,n){return Y.access(e,t,n)},_removeData:function(e,t){Y.remove(e,t)}}),S.fn.extend({data:function(n,e){var t,r,i,o=this[0],a=o&&o.attributes;if(void 0===n){if(this.length&&(i=Q.get(o),1===o.nodeType&&!Y.get(o,"hasDataAttrs"))){t=a.length;while(t--)a[t]&&0===(r=a[t].name).indexOf("data-")&&(r=X(r.slice(5)),Z(o,r,i[r]));Y.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof n?this.each(function(){Q.set(this,n)}):$(this,function(e){var t;if(o&&void 0===e)return void 0!==(t=Q.get(o,n))?t:void 0!==(t=Z(o,n))?t:void 0;this.each(function(){Q.set(this,n,e)})},null,e,1<arguments.length,null,!0)},removeData:function(e){return this.each(function(){Q.remove(this,e)})}}),S.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=Y.get(e,t),n&&(!r||Array.isArray(n)?r=Y.access(e,t,S.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=S.queue(e,t),r=n.length,i=n.shift(),o=S._queueHooks(e,t);"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,function(){S.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return Y.get(e,n)||Y.access(e,n,{empty:S.Callbacks("once memory").add(function(){Y.remove(e,[t+"queue",n])})})}}),S.fn.extend({queue:function(t,n){var e=2;return"string"!=typeof t&&(n=t,t="fx",e--),arguments.length<e?S.queue(this[0],t):void 0===n?this:this.each(function(){var e=S.queue(this,t,n);S._queueHooks(this,t),"fx"===t&&"inprogress"!==e[0]&&S.dequeue(this,t)})},dequeue:function(e){return this.each(function(){S.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=S.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};"string"!=typeof e&&(t=e,e=void 0),e=e||"fx";while(a--)(n=Y.get(o[a],e+"queueHooks"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var ee=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,te=new RegExp("^(?:([+-])=|)("+ee+")([a-z%]*)$","i"),ne=["Top","Right","Bottom","Left"],re=E.documentElement,ie=function(e){return S.contains(e.ownerDocument,e)},oe={composed:!0};re.getRootNode&&(ie=function(e){return S.contains(e.ownerDocument,e)||e.getRootNode(oe)===e.ownerDocument});var ae=function(e,t){return"none"===(e=t||e).style.display||""===e.style.display&&ie(e)&&"none"===S.css(e,"display")};function se(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return S.css(e,t,"")},u=s(),l=n&&n[3]||(S.cssNumber[t]?"":"px"),c=e.nodeType&&(S.cssNumber[t]||"px"!==l&&+u)&&te.exec(S.css(e,t));if(c&&c[3]!==l){u/=2,l=l||c[3],c=+u||1;while(a--)S.style(e,t,c+l),(1-o)*(1-(o=s()/u||.5))<=0&&(a=0),c/=o;c*=2,S.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ue={};function le(e,t){for(var n,r,i,o,a,s,u,l=[],c=0,f=e.length;c<f;c++)(r=e[c]).style&&(n=r.style.display,t?("none"===n&&(l[c]=Y.get(r,"display")||null,l[c]||(r.style.display="")),""===r.style.display&&ae(r)&&(l[c]=(u=a=o=void 0,a=(i=r).ownerDocument,s=i.nodeName,(u=ue[s])||(o=a.body.appendChild(a.createElement(s)),u=S.css(o,"display"),o.parentNode.removeChild(o),"none"===u&&(u="block"),ue[s]=u)))):"none"!==n&&(l[c]="none",Y.set(r,"display",n)));for(c=0;c<f;c++)null!=l[c]&&(e[c].style.display=l[c]);return e}S.fn.extend({show:function(){return le(this,!0)},hide:function(){return le(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){ae(this)?S(this).show():S(this).hide()})}});var ce,fe,pe=/^(?:checkbox|radio)$/i,de=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i,he=/^$|^module$|\/(?:java|ecma)script/i;ce=E.createDocumentFragment().appendChild(E.createElement("div")),(fe=E.createElement("input")).setAttribute("type","radio"),fe.setAttribute("checked","checked"),fe.setAttribute("name","t"),ce.appendChild(fe),y.checkClone=ce.cloneNode(!0).cloneNode(!0).lastChild.checked,ce.innerHTML="<textarea>x</textarea>",y.noCloneChecked=!!ce.cloneNode(!0).lastChild.defaultValue,ce.innerHTML="<option></option>",y.option=!!ce.lastChild;var ge={thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};function ve(e,t){var n;return n="undefined"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||"*"):"undefined"!=typeof e.querySelectorAll?e.querySelectorAll(t||"*"):[],void 0===t||t&&A(e,t)?S.merge([e],n):n}function ye(e,t){for(var n=0,r=e.length;n<r;n++)Y.set(e[n],"globalEval",!t||Y.get(t[n],"globalEval"))}ge.tbody=ge.tfoot=ge.colgroup=ge.caption=ge.thead,ge.th=ge.td,y.option||(ge.optgroup=ge.option=[1,"<select multiple='multiple'>","</select>"]);var me=/<|&#?\w+;/;function xe(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if("object"===w(o))S.merge(p,o.nodeType?[o]:o);else if(me.test(o)){a=a||f.appendChild(t.createElement("div")),s=(de.exec(o)||["",""])[1].toLowerCase(),u=ge[s]||ge._default,a.innerHTML=u[1]+S.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;S.merge(p,a.childNodes),(a=f.firstChild).textContent=""}else p.push(t.createTextNode(o));f.textContent="",d=0;while(o=p[d++])if(r&&-1<S.inArray(o,r))i&&i.push(o);else if(l=ie(o),a=ve(f.appendChild(o),"script"),l&&ye(a),n){c=0;while(o=a[c++])he.test(o.type||"")&&n.push(o)}return f}var be=/^([^.]*)(?:\.(.+)|)/;function we(){return!0}function Te(){return!1}function Ce(e,t){return e===function(){try{return E.activeElement}catch(e){}}()==("focus"===t)}function Ee(e,t,n,r,i,o){var a,s;if("object"==typeof t){for(s in"string"!=typeof n&&(r=r||n,n=void 0),t)Ee(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&("string"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=Te;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return S().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=S.guid++)),e.each(function(){S.event.add(this,t,i,r,n)})}function Se(e,i,o){o?(Y.set(e,i,!1),S.event.add(e,i,{namespace:!1,handler:function(e){var t,n,r=Y.get(this,i);if(1&e.isTrigger&&this[i]){if(r.length)(S.event.special[i]||{}).delegateType&&e.stopPropagation();else if(r=s.call(arguments),Y.set(this,i,r),t=o(this,i),this[i](),r!==(n=Y.get(this,i))||t?Y.set(this,i,!1):n={},r!==n)return e.stopImmediatePropagation(),e.preventDefault(),n&&n.value}else r.length&&(Y.set(this,i,{value:S.event.trigger(S.extend(r[0],S.Event.prototype),r.slice(1),this)}),e.stopImmediatePropagation())}})):void 0===Y.get(e,i)&&S.event.add(e,i,we)}S.event={global:{},add:function(t,e,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Y.get(t);if(V(t)){n.handler&&(n=(o=n).handler,i=o.selector),i&&S.find.matchesSelector(re,i),n.guid||(n.guid=S.guid++),(u=v.events)||(u=v.events=Object.create(null)),(a=v.handle)||(a=v.handle=function(e){return"undefined"!=typeof S&&S.event.triggered!==e.type?S.event.dispatch.apply(t,arguments):void 0}),l=(e=(e||"").match(P)||[""]).length;while(l--)d=g=(s=be.exec(e[l])||[])[1],h=(s[2]||"").split(".").sort(),d&&(f=S.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=S.event.special[d]||{},c=S.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&S.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(t,r,h,a)||t.addEventListener&&t.addEventListener(d,a)),f.add&&(f.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),S.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Y.hasData(e)&&Y.get(e);if(v&&(u=v.events)){l=(t=(t||"").match(P)||[""]).length;while(l--)if(d=g=(s=be.exec(t[l])||[])[1],h=(s[2]||"").split(".").sort(),d){f=S.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,v.handle)||S.removeEvent(e,d,v.handle),delete u[d])}else for(d in u)S.event.remove(e,d+t[l],n,r,!0);S.isEmptyObject(u)&&Y.remove(e,"handle events")}},dispatch:function(e){var t,n,r,i,o,a,s=new Array(arguments.length),u=S.event.fix(e),l=(Y.get(this,"events")||Object.create(null))[u.type]||[],c=S.event.special[u.type]||{};for(s[0]=u,t=1;t<arguments.length;t++)s[t]=arguments[t];if(u.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,u)){a=S.event.handlers.call(this,u,l),t=0;while((i=a[t++])&&!u.isPropagationStopped()){u.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!u.isImmediatePropagationStopped())u.rnamespace&&!1!==o.namespace&&!u.rnamespace.test(o.namespace)||(u.handleObj=o,u.data=o.data,void 0!==(r=((S.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,s))&&!1===(u.result=r)&&(u.preventDefault(),u.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,u),u.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!("click"===e.type&&1<=e.button))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&("click"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+" "]&&(a[i]=r.needsContext?-1<S(i,this).index(l):S.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(t,e){Object.defineProperty(S.Event.prototype,t,{enumerable:!0,configurable:!0,get:m(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(e){return e[S.expando]?e:new S.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&Se(t,"click",we),!1},trigger:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&Se(t,"click"),!0},_default:function(e){var t=e.target;return pe.test(t.type)&&t.click&&A(t,"input")&&Y.get(t,"click")||A(t,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},S.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},S.Event=function(e,t){if(!(this instanceof S.Event))return new S.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?we:Te,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&S.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[S.expando]=!0},S.Event.prototype={constructor:S.Event,isDefaultPrevented:Te,isPropagationStopped:Te,isImmediatePropagationStopped:Te,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=we,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=we,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=we,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},S.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:!0},S.event.addProp),S.each({focus:"focusin",blur:"focusout"},function(e,t){S.event.special[e]={setup:function(){return Se(this,e,Ce),!1},trigger:function(){return Se(this,e),!0},_default:function(){return!0},delegateType:t}}),S.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(e,i){S.event.special[e]={delegateType:i,bindType:i,handle:function(e){var t,n=e.relatedTarget,r=e.handleObj;return n&&(n===this||S.contains(this,n))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=i),t}}}),S.fn.extend({on:function(e,t,n,r){return Ee(this,e,t,n,r)},one:function(e,t,n,r){return Ee(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,S(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&"function"!=typeof t||(n=t,t=void 0),!1===n&&(n=Te),this.each(function(){S.event.remove(this,e,n,t)})}});var ke=/<script|<style|<link/i,Ae=/checked\s*(?:[^=]|=\s*.checked.)/i,Ne=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function je(e,t){return A(e,"table")&&A(11!==t.nodeType?t:t.firstChild,"tr")&&S(e).children("tbody")[0]||e}function De(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function qe(e){return"true/"===(e.type||"").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute("type"),e}function Le(e,t){var n,r,i,o,a,s;if(1===t.nodeType){if(Y.hasData(e)&&(s=Y.get(e).events))for(i in Y.remove(t,"handle events"),s)for(n=0,r=s[i].length;n<r;n++)S.event.add(t,i,s[i][n]);Q.hasData(e)&&(o=Q.access(e),a=S.extend({},o),Q.set(t,a))}}function He(n,r,i,o){r=g(r);var e,t,a,s,u,l,c=0,f=n.length,p=f-1,d=r[0],h=m(d);if(h||1<f&&"string"==typeof d&&!y.checkClone&&Ae.test(d))return n.each(function(e){var t=n.eq(e);h&&(r[0]=d.call(this,e,t.html())),He(t,r,i,o)});if(f&&(t=(e=xe(r,n[0].ownerDocument,!1,n,o)).firstChild,1===e.childNodes.length&&(e=t),t||o)){for(s=(a=S.map(ve(e,"script"),De)).length;c<f;c++)u=e,c!==p&&(u=S.clone(u,!0,!0),s&&S.merge(a,ve(u,"script"))),i.call(n[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,S.map(a,qe),c=0;c<s;c++)u=a[c],he.test(u.type||"")&&!Y.access(u,"globalEval")&&S.contains(l,u)&&(u.src&&"module"!==(u.type||"").toLowerCase()?S._evalUrl&&!u.noModule&&S._evalUrl(u.src,{nonce:u.nonce||u.getAttribute("nonce")},l):b(u.textContent.replace(Ne,""),u,l))}return n}function Oe(e,t,n){for(var r,i=t?S.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||S.cleanData(ve(r)),r.parentNode&&(n&&ie(r)&&ye(ve(r,"script")),r.parentNode.removeChild(r));return e}S.extend({htmlPrefilter:function(e){return e},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=ie(e);if(!(y.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||S.isXMLDoc(e)))for(a=ve(c),r=0,i=(o=ve(e)).length;r<i;r++)s=o[r],u=a[r],void 0,"input"===(l=u.nodeName.toLowerCase())&&pe.test(s.type)?u.checked=s.checked:"input"!==l&&"textarea"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||ve(e),a=a||ve(c),r=0,i=o.length;r<i;r++)Le(o[r],a[r]);else Le(e,c);return 0<(a=ve(c,"script")).length&&ye(a,!f&&ve(e,"script")),c},cleanData:function(e){for(var t,n,r,i=S.event.special,o=0;void 0!==(n=e[o]);o++)if(V(n)){if(t=n[Y.expando]){if(t.events)for(r in t.events)i[r]?S.event.remove(n,r):S.removeEvent(n,r,t.handle);n[Y.expando]=void 0}n[Q.expando]&&(n[Q.expando]=void 0)}}}),S.fn.extend({detach:function(e){return Oe(this,e,!0)},remove:function(e){return Oe(this,e)},text:function(e){return $(this,function(e){return void 0===e?S.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return He(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||je(this,e).appendChild(e)})},prepend:function(){return He(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=je(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return He(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return He(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(S.cleanData(ve(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return S.clone(this,e,t)})},html:function(e){return $(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!ke.test(e)&&!ge[(de.exec(e)||["",""])[1].toLowerCase()]){e=S.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(S.cleanData(ve(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var n=[];return He(this,arguments,function(e){var t=this.parentNode;S.inArray(this,n)<0&&(S.cleanData(ve(this)),t&&t.replaceChild(e,this))},n)}}),S.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,a){S.fn[e]=function(e){for(var t,n=[],r=S(e),i=r.length-1,o=0;o<=i;o++)t=o===i?this:this.clone(!0),S(r[o])[a](t),u.apply(n,t.get());return this.pushStack(n)}});var Pe=new RegExp("^("+ee+")(?!px)[a-z%]+$","i"),Re=function(e){var t=e.ownerDocument.defaultView;return t&&t.opener||(t=C),t.getComputedStyle(e)},Me=function(e,t,n){var r,i,o={};for(i in t)o[i]=e.style[i],e.style[i]=t[i];for(i in r=n.call(e),t)e.style[i]=o[i];return r},Ie=new RegExp(ne.join("|"),"i");function We(e,t,n){var r,i,o,a,s=e.style;return(n=n||Re(e))&&(""!==(a=n.getPropertyValue(t)||n[t])||ie(e)||(a=S.style(e,t)),!y.pixelBoxStyles()&&Pe.test(a)&&Ie.test(t)&&(r=s.width,i=s.minWidth,o=s.maxWidth,s.minWidth=s.maxWidth=s.width=a,a=n.width,s.width=r,s.minWidth=i,s.maxWidth=o)),void 0!==a?a+"":a}function Fe(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function e(){if(l){u.style.cssText="position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",l.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",re.appendChild(u).appendChild(l);var e=C.getComputedStyle(l);n="1%"!==e.top,s=12===t(e.marginLeft),l.style.right="60%",o=36===t(e.right),r=36===t(e.width),l.style.position="absolute",i=12===t(l.offsetWidth/3),re.removeChild(u),l=null}}function t(e){return Math.round(parseFloat(e))}var n,r,i,o,a,s,u=E.createElement("div"),l=E.createElement("div");l.style&&(l.style.backgroundClip="content-box",l.cloneNode(!0).style.backgroundClip="",y.clearCloneStyle="content-box"===l.style.backgroundClip,S.extend(y,{boxSizingReliable:function(){return e(),r},pixelBoxStyles:function(){return e(),o},pixelPosition:function(){return e(),n},reliableMarginLeft:function(){return e(),s},scrollboxSize:function(){return e(),i},reliableTrDimensions:function(){var e,t,n,r;return null==a&&(e=E.createElement("table"),t=E.createElement("tr"),n=E.createElement("div"),e.style.cssText="position:absolute;left:-11111px;border-collapse:separate",t.style.cssText="border:1px solid",t.style.height="1px",n.style.height="9px",n.style.display="block",re.appendChild(e).appendChild(t).appendChild(n),r=C.getComputedStyle(t),a=parseInt(r.height,10)+parseInt(r.borderTopWidth,10)+parseInt(r.borderBottomWidth,10)===t.offsetHeight,re.removeChild(e)),a}}))}();var Be=["Webkit","Moz","ms"],$e=E.createElement("div").style,_e={};function ze(e){var t=S.cssProps[e]||_e[e];return t||(e in $e?e:_e[e]=function(e){var t=e[0].toUpperCase()+e.slice(1),n=Be.length;while(n--)if((e=Be[n]+t)in $e)return e}(e)||e)}var Ue=/^(none|table(?!-c[ea]).+)/,Xe=/^--/,Ve={position:"absolute",visibility:"hidden",display:"block"},Ge={letterSpacing:"0",fontWeight:"400"};function Ye(e,t,n){var r=te.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||"px"):t}function Qe(e,t,n,r,i,o){var a="width"===t?1:0,s=0,u=0;if(n===(r?"border":"content"))return 0;for(;a<4;a+=2)"margin"===n&&(u+=S.css(e,n+ne[a],!0,i)),r?("content"===n&&(u-=S.css(e,"padding"+ne[a],!0,i)),"margin"!==n&&(u-=S.css(e,"border"+ne[a]+"Width",!0,i))):(u+=S.css(e,"padding"+ne[a],!0,i),"padding"!==n?u+=S.css(e,"border"+ne[a]+"Width",!0,i):s+=S.css(e,"border"+ne[a]+"Width",!0,i));return!r&&0<=o&&(u+=Math.max(0,Math.ceil(e["offset"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))||0),u}function Je(e,t,n){var r=Re(e),i=(!y.boxSizingReliable()||n)&&"border-box"===S.css(e,"boxSizing",!1,r),o=i,a=We(e,t,r),s="offset"+t[0].toUpperCase()+t.slice(1);if(Pe.test(a)){if(!n)return a;a="auto"}return(!y.boxSizingReliable()&&i||!y.reliableTrDimensions()&&A(e,"tr")||"auto"===a||!parseFloat(a)&&"inline"===S.css(e,"display",!1,r))&&e.getClientRects().length&&(i="border-box"===S.css(e,"boxSizing",!1,r),(o=s in e)&&(a=e[s])),(a=parseFloat(a)||0)+Qe(e,t,n||(i?"border":"content"),o,r,a)+"px"}function Ke(e,t,n,r,i){return new Ke.prototype.init(e,t,n,r,i)}S.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=We(e,"opacity");return""===n?"1":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=X(t),u=Xe.test(t),l=e.style;if(u||(t=ze(s)),a=S.cssHooks[t]||S.cssHooks[s],void 0===n)return a&&"get"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];"string"===(o=typeof n)&&(i=te.exec(n))&&i[1]&&(n=se(e,t,i),o="number"),null!=n&&n==n&&("number"!==o||u||(n+=i&&i[3]||(S.cssNumber[s]?"":"px")),y.clearCloneStyle||""!==n||0!==t.indexOf("background")||(l[t]="inherit"),a&&"set"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=X(t);return Xe.test(t)||(t=ze(s)),(a=S.cssHooks[t]||S.cssHooks[s])&&"get"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=We(e,t,r)),"normal"===i&&t in Ge&&(i=Ge[t]),""===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),S.each(["height","width"],function(e,u){S.cssHooks[u]={get:function(e,t,n){if(t)return!Ue.test(S.css(e,"display"))||e.getClientRects().length&&e.getBoundingClientRect().width?Je(e,u,n):Me(e,Ve,function(){return Je(e,u,n)})},set:function(e,t,n){var r,i=Re(e),o=!y.scrollboxSize()&&"absolute"===i.position,a=(o||n)&&"border-box"===S.css(e,"boxSizing",!1,i),s=n?Qe(e,u,n,a,i):0;return a&&o&&(s-=Math.ceil(e["offset"+u[0].toUpperCase()+u.slice(1)]-parseFloat(i[u])-Qe(e,u,"border",!1,i)-.5)),s&&(r=te.exec(t))&&"px"!==(r[3]||"px")&&(e.style[u]=t,t=S.css(e,u)),Ye(0,t,s)}}}),S.cssHooks.marginLeft=Fe(y.reliableMarginLeft,function(e,t){if(t)return(parseFloat(We(e,"marginLeft"))||e.getBoundingClientRect().left-Me(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+"px"}),S.each({margin:"",padding:"",border:"Width"},function(i,o){S.cssHooks[i+o]={expand:function(e){for(var t=0,n={},r="string"==typeof e?e.split(" "):[e];t<4;t++)n[i+ne[t]+o]=r[t]||r[t-2]||r[0];return n}},"margin"!==i&&(S.cssHooks[i+o].set=Ye)}),S.fn.extend({css:function(e,t){return $(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Re(e),i=t.length;a<i;a++)o[t[a]]=S.css(e,t[a],!1,r);return o}return void 0!==n?S.style(e,t,n):S.css(e,t)},e,t,1<arguments.length)}}),((S.Tween=Ke).prototype={constructor:Ke,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||S.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(S.cssNumber[n]?"":"px")},cur:function(){var e=Ke.propHooks[this.prop];return e&&e.get?e.get(this):Ke.propHooks._default.get(this)},run:function(e){var t,n=Ke.propHooks[this.prop];return this.options.duration?this.pos=t=S.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):Ke.propHooks._default.set(this),this}}).init.prototype=Ke.prototype,(Ke.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=S.css(e.elem,e.prop,""))&&"auto"!==t?t:0},set:function(e){S.fx.step[e.prop]?S.fx.step[e.prop](e):1!==e.elem.nodeType||!S.cssHooks[e.prop]&&null==e.elem.style[ze(e.prop)]?e.elem[e.prop]=e.now:S.style(e.elem,e.prop,e.now+e.unit)}}}).scrollTop=Ke.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},S.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:"swing"},S.fx=Ke.prototype.init,S.fx.step={};var Ze,et,tt,nt,rt=/^(?:toggle|show|hide)$/,it=/queueHooks$/;function ot(){et&&(!1===E.hidden&&C.requestAnimationFrame?C.requestAnimationFrame(ot):C.setTimeout(ot,S.fx.interval),S.fx.tick())}function at(){return C.setTimeout(function(){Ze=void 0}),Ze=Date.now()}function st(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i["margin"+(n=ne[r])]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function ut(e,t,n){for(var r,i=(lt.tweeners[t]||[]).concat(lt.tweeners["*"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function lt(o,e,t){var n,a,r=0,i=lt.prefilters.length,s=S.Deferred().always(function(){delete u.elem}),u=function(){if(a)return!1;for(var e=Ze||at(),t=Math.max(0,l.startTime+l.duration-e),n=1-(t/l.duration||0),r=0,i=l.tweens.length;r<i;r++)l.tweens[r].run(n);return s.notifyWith(o,[l,n,t]),n<1&&i?t:(i||s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l]),!1)},l=s.promise({elem:o,props:S.extend({},e),opts:S.extend(!0,{specialEasing:{},easing:S.easing._default},t),originalProperties:e,originalOptions:t,startTime:Ze||at(),duration:t.duration,tweens:[],createTween:function(e,t){var n=S.Tween(o,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(n),n},stop:function(e){var t=0,n=e?l.tweens.length:0;if(a)return this;for(a=!0;t<n;t++)l.tweens[t].run(1);return e?(s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l,e])):s.rejectWith(o,[l,e]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=X(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=S.cssHooks[r])&&"expand"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);r<i;r++)if(n=lt.prefilters[r].call(l,o,c,l.opts))return m(n.stop)&&(S._queueHooks(l.elem,l.opts.queue).stop=n.stop.bind(n)),n;return S.map(c,ut,l),m(l.opts.start)&&l.opts.start.call(o,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),S.fx.timer(S.extend(u,{elem:o,anim:l,queue:l.opts.queue})),l}S.Animation=S.extend(lt,{tweeners:{"*":[function(e,t){var n=this.createTween(e,t);return se(n.elem,e,te.exec(t),n),n}]},tweener:function(e,t){m(e)?(t=e,e=["*"]):e=e.match(P);for(var n,r=0,i=e.length;r<i;r++)n=e[r],lt.tweeners[n]=lt.tweeners[n]||[],lt.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f="width"in t||"height"in t,p=this,d={},h=e.style,g=e.nodeType&&ae(e),v=Y.get(e,"fxshow");for(r in n.queue||(null==(a=S._queueHooks(e,"fx")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,S.queue(e,"fx").length||a.empty.fire()})})),t)if(i=t[r],rt.test(i)){if(delete t[r],o=o||"toggle"===i,i===(g?"hide":"show")){if("show"!==i||!v||void 0===v[r])continue;g=!0}d[r]=v&&v[r]||S.style(e,r)}if((u=!S.isEmptyObject(t))||!S.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=v&&v.display)&&(l=Y.get(e,"display")),"none"===(c=S.css(e,"display"))&&(l?c=l:(le([e],!0),l=e.style.display||l,c=S.css(e,"display"),le([e]))),("inline"===c||"inline-block"===c&&null!=l)&&"none"===S.css(e,"float")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l="none"===c?"":c)),h.display="inline-block")),n.overflow&&(h.overflow="hidden",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(v?"hidden"in v&&(g=v.hidden):v=Y.access(e,"fxshow",{display:l}),o&&(v.hidden=!g),g&&le([e],!0),p.done(function(){for(r in g||le([e]),Y.remove(e,"fxshow"),d)S.style(e,r,d[r])})),u=ut(g?v[r]:0,r,p),r in v||(v[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?lt.prefilters.unshift(e):lt.prefilters.push(e)}}),S.speed=function(e,t,n){var r=e&&"object"==typeof e?S.extend({},e):{complete:n||!n&&t||m(e)&&e,duration:e,easing:n&&t||t&&!m(t)&&t};return S.fx.off?r.duration=0:"number"!=typeof r.duration&&(r.duration in S.fx.speeds?r.duration=S.fx.speeds[r.duration]:r.duration=S.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue="fx"),r.old=r.complete,r.complete=function(){m(r.old)&&r.old.call(this),r.queue&&S.dequeue(this,r.queue)},r},S.fn.extend({fadeTo:function(e,t,n,r){return this.filter(ae).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(t,e,n,r){var i=S.isEmptyObject(t),o=S.speed(e,n,r),a=function(){var e=lt(this,S.extend({},t),o);(i||Y.get(this,"finish"))&&e.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(i,e,o){var a=function(e){var t=e.stop;delete e.stop,t(o)};return"string"!=typeof i&&(o=e,e=i,i=void 0),e&&this.queue(i||"fx",[]),this.each(function(){var e=!0,t=null!=i&&i+"queueHooks",n=S.timers,r=Y.get(this);if(t)r[t]&&r[t].stop&&a(r[t]);else for(t in r)r[t]&&r[t].stop&&it.test(t)&&a(r[t]);for(t=n.length;t--;)n[t].elem!==this||null!=i&&n[t].queue!==i||(n[t].anim.stop(o),e=!1,n.splice(t,1));!e&&o||S.dequeue(this,i)})},finish:function(a){return!1!==a&&(a=a||"fx"),this.each(function(){var e,t=Y.get(this),n=t[a+"queue"],r=t[a+"queueHooks"],i=S.timers,o=n?n.length:0;for(t.finish=!0,S.queue(this,a,[]),r&&r.stop&&r.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===a&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)n[e]&&n[e].finish&&n[e].finish.call(this);delete t.finish})}}),S.each(["toggle","show","hide"],function(e,r){var i=S.fn[r];S.fn[r]=function(e,t,n){return null==e||"boolean"==typeof e?i.apply(this,arguments):this.animate(st(r,!0),e,t,n)}}),S.each({slideDown:st("show"),slideUp:st("hide"),slideToggle:st("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,r){S.fn[e]=function(e,t,n){return this.animate(r,e,t,n)}}),S.timers=[],S.fx.tick=function(){var e,t=0,n=S.timers;for(Ze=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||S.fx.stop(),Ze=void 0},S.fx.timer=function(e){S.timers.push(e),S.fx.start()},S.fx.interval=13,S.fx.start=function(){et||(et=!0,ot())},S.fx.stop=function(){et=null},S.fx.speeds={slow:600,fast:200,_default:400},S.fn.delay=function(r,e){return r=S.fx&&S.fx.speeds[r]||r,e=e||"fx",this.queue(e,function(e,t){var n=C.setTimeout(e,r);t.stop=function(){C.clearTimeout(n)}})},tt=E.createElement("input"),nt=E.createElement("select").appendChild(E.createElement("option")),tt.type="checkbox",y.checkOn=""!==tt.value,y.optSelected=nt.selected,(tt=E.createElement("input")).value="t",tt.type="radio",y.radioValue="t"===tt.value;var ct,ft=S.expr.attrHandle;S.fn.extend({attr:function(e,t){return $(this,S.attr,e,t,1<arguments.length)},removeAttr:function(e){return this.each(function(){S.removeAttr(this,e)})}}),S.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return"undefined"==typeof e.getAttribute?S.prop(e,t,n):(1===o&&S.isXMLDoc(e)||(i=S.attrHooks[t.toLowerCase()]||(S.expr.match.bool.test(t)?ct:void 0)),void 0!==n?null===n?void S.removeAttr(e,t):i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+""),n):i&&"get"in i&&null!==(r=i.get(e,t))?r:null==(r=S.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!y.radioValue&&"radio"===t&&A(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(P);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),ct={set:function(e,t,n){return!1===t?S.removeAttr(e,n):e.setAttribute(n,n),n}},S.each(S.expr.match.bool.source.match(/\w+/g),function(e,t){var a=ft[t]||S.find.attr;ft[t]=function(e,t,n){var r,i,o=t.toLowerCase();return n||(i=ft[o],ft[o]=r,r=null!=a(e,t,n)?o:null,ft[o]=i),r}});var pt=/^(?:input|select|textarea|button)$/i,dt=/^(?:a|area)$/i;function ht(e){return(e.match(P)||[]).join(" ")}function gt(e){return e.getAttribute&&e.getAttribute("class")||""}function vt(e){return Array.isArray(e)?e:"string"==typeof e&&e.match(P)||[]}S.fn.extend({prop:function(e,t){return $(this,S.prop,e,t,1<arguments.length)},removeProp:function(e){return this.each(function(){delete this[S.propFix[e]||e]})}}),S.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&S.isXMLDoc(e)||(t=S.propFix[t]||t,i=S.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=S.find.attr(e,"tabindex");return t?parseInt(t,10):pt.test(e.nodeName)||dt.test(e.nodeName)&&e.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),y.optSelected||(S.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),S.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){S.propFix[this.toLowerCase()]=this}),S.fn.extend({addClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){S(this).addClass(t.call(this,e,gt(this)))});if((e=vt(t)).length)while(n=this[u++])if(i=gt(n),r=1===n.nodeType&&" "+ht(i)+" "){a=0;while(o=e[a++])r.indexOf(" "+o+" ")<0&&(r+=o+" ");i!==(s=ht(r))&&n.setAttribute("class",s)}return this},removeClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){S(this).removeClass(t.call(this,e,gt(this)))});if(!arguments.length)return this.attr("class","");if((e=vt(t)).length)while(n=this[u++])if(i=gt(n),r=1===n.nodeType&&" "+ht(i)+" "){a=0;while(o=e[a++])while(-1<r.indexOf(" "+o+" "))r=r.replace(" "+o+" "," ");i!==(s=ht(r))&&n.setAttribute("class",s)}return this},toggleClass:function(i,t){var o=typeof i,a="string"===o||Array.isArray(i);return"boolean"==typeof t&&a?t?this.addClass(i):this.removeClass(i):m(i)?this.each(function(e){S(this).toggleClass(i.call(this,e,gt(this),t),t)}):this.each(function(){var e,t,n,r;if(a){t=0,n=S(this),r=vt(i);while(e=r[t++])n.hasClass(e)?n.removeClass(e):n.addClass(e)}else void 0!==i&&"boolean"!==o||((e=gt(this))&&Y.set(this,"__className__",e),this.setAttribute&&this.setAttribute("class",e||!1===i?"":Y.get(this,"__className__")||""))})},hasClass:function(e){var t,n,r=0;t=" "+e+" ";while(n=this[r++])if(1===n.nodeType&&-1<(" "+ht(gt(n))+" ").indexOf(t))return!0;return!1}});var yt=/\r/g;S.fn.extend({val:function(n){var r,e,i,t=this[0];return arguments.length?(i=m(n),this.each(function(e){var t;1===this.nodeType&&(null==(t=i?n.call(this,e,S(this).val()):n)?t="":"number"==typeof t?t+="":Array.isArray(t)&&(t=S.map(t,function(e){return null==e?"":e+""})),(r=S.valHooks[this.type]||S.valHooks[this.nodeName.toLowerCase()])&&"set"in r&&void 0!==r.set(this,t,"value")||(this.value=t))})):t?(r=S.valHooks[t.type]||S.valHooks[t.nodeName.toLowerCase()])&&"get"in r&&void 0!==(e=r.get(t,"value"))?e:"string"==typeof(e=t.value)?e.replace(yt,""):null==e?"":e:void 0}}),S.extend({valHooks:{option:{get:function(e){var t=S.find.attr(e,"value");return null!=t?t:ht(S.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a="select-one"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!A(n.parentNode,"optgroup"))){if(t=S(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=S.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=-1<S.inArray(S.valHooks.option.get(r),o))&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),S.each(["radio","checkbox"],function(){S.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=-1<S.inArray(S(e).val(),t)}},y.checkOn||(S.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})}),y.focusin="onfocusin"in C;var mt=/^(?:focusinfocus|focusoutblur)$/,xt=function(e){e.stopPropagation()};S.extend(S.event,{trigger:function(e,t,n,r){var i,o,a,s,u,l,c,f,p=[n||E],d=v.call(e,"type")?e.type:e,h=v.call(e,"namespace")?e.namespace.split("."):[];if(o=f=a=n=n||E,3!==n.nodeType&&8!==n.nodeType&&!mt.test(d+S.event.triggered)&&(-1<d.indexOf(".")&&(d=(h=d.split(".")).shift(),h.sort()),u=d.indexOf(":")<0&&"on"+d,(e=e[S.expando]?e:new S.Event(d,"object"==typeof e&&e)).isTrigger=r?2:3,e.namespace=h.join("."),e.rnamespace=e.namespace?new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,e.result=void 0,e.target||(e.target=n),t=null==t?[e]:S.makeArray(t,[e]),c=S.event.special[d]||{},r||!c.trigger||!1!==c.trigger.apply(n,t))){if(!r&&!c.noBubble&&!x(n)){for(s=c.delegateType||d,mt.test(s+d)||(o=o.parentNode);o;o=o.parentNode)p.push(o),a=o;a===(n.ownerDocument||E)&&p.push(a.defaultView||a.parentWindow||C)}i=0;while((o=p[i++])&&!e.isPropagationStopped())f=o,e.type=1<i?s:c.bindType||d,(l=(Y.get(o,"events")||Object.create(null))[e.type]&&Y.get(o,"handle"))&&l.apply(o,t),(l=u&&o[u])&&l.apply&&V(o)&&(e.result=l.apply(o,t),!1===e.result&&e.preventDefault());return e.type=d,r||e.isDefaultPrevented()||c._default&&!1!==c._default.apply(p.pop(),t)||!V(n)||u&&m(n[d])&&!x(n)&&((a=n[u])&&(n[u]=null),S.event.triggered=d,e.isPropagationStopped()&&f.addEventListener(d,xt),n[d](),e.isPropagationStopped()&&f.removeEventListener(d,xt),S.event.triggered=void 0,a&&(n[u]=a)),e.result}},simulate:function(e,t,n){var r=S.extend(new S.Event,n,{type:e,isSimulated:!0});S.event.trigger(r,null,t)}}),S.fn.extend({trigger:function(e,t){return this.each(function(){S.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return S.event.trigger(e,t,n,!0)}}),y.focusin||S.each({focus:"focusin",blur:"focusout"},function(n,r){var i=function(e){S.event.simulate(r,e.target,S.event.fix(e))};S.event.special[r]={setup:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r);t||e.addEventListener(n,i,!0),Y.access(e,r,(t||0)+1)},teardown:function(){var e=this.ownerDocument||this.document||this,t=Y.access(e,r)-1;t?Y.access(e,r,t):(e.removeEventListener(n,i,!0),Y.remove(e,r))}}});var bt=C.location,wt={guid:Date.now()},Tt=/\?/;S.parseXML=function(e){var t,n;if(!e||"string"!=typeof e)return null;try{t=(new C.DOMParser).parseFromString(e,"text/xml")}catch(e){}return n=t&&t.getElementsByTagName("parsererror")[0],t&&!n||S.error("Invalid XML: "+(n?S.map(n.childNodes,function(e){return e.textContent}).join("\n"):e)),t};var Ct=/\[\]$/,Et=/\r?\n/g,St=/^(?:submit|button|image|reset|file)$/i,kt=/^(?:input|select|textarea|keygen)/i;function At(n,e,r,i){var t;if(Array.isArray(e))S.each(e,function(e,t){r||Ct.test(n)?i(n,t):At(n+"["+("object"==typeof t&&null!=t?e:"")+"]",t,r,i)});else if(r||"object"!==w(e))i(n,e);else for(t in e)At(n+"["+t+"]",e[t],r,i)}S.param=function(e,t){var n,r=[],i=function(e,t){var n=m(t)?t():t;r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(null==n?"":n)};if(null==e)return"";if(Array.isArray(e)||e.jquery&&!S.isPlainObject(e))S.each(e,function(){i(this.name,this.value)});else for(n in e)At(n,e[n],t,i);return r.join("&")},S.fn.extend({serialize:function(){return S.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=S.prop(this,"elements");return e?S.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!S(this).is(":disabled")&&kt.test(this.nodeName)&&!St.test(e)&&(this.checked||!pe.test(e))}).map(function(e,t){var n=S(this).val();return null==n?null:Array.isArray(n)?S.map(n,function(e){return{name:t.name,value:e.replace(Et,"\r\n")}}):{name:t.name,value:n.replace(Et,"\r\n")}}).get()}});var Nt=/%20/g,jt=/#.*$/,Dt=/([?&])_=[^&]*/,qt=/^(.*?):[ \t]*([^\r\n]*)$/gm,Lt=/^(?:GET|HEAD)$/,Ht=/^\/\//,Ot={},Pt={},Rt="*/".concat("*"),Mt=E.createElement("a");function It(o){return function(e,t){"string"!=typeof e&&(t=e,e="*");var n,r=0,i=e.toLowerCase().match(P)||[];if(m(t))while(n=i[r++])"+"===n[0]?(n=n.slice(1)||"*",(o[n]=o[n]||[]).unshift(t)):(o[n]=o[n]||[]).push(t)}}function Wt(t,i,o,a){var s={},u=t===Pt;function l(e){var r;return s[e]=!0,S.each(t[e]||[],function(e,t){var n=t(i,o,a);return"string"!=typeof n||u||s[n]?u?!(r=n):void 0:(i.dataTypes.unshift(n),l(n),!1)}),r}return l(i.dataTypes[0])||!s["*"]&&l("*")}function Ft(e,t){var n,r,i=S.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&S.extend(!0,e,r),e}Mt.href=bt.href,S.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:bt.href,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(bt.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Rt,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":S.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?Ft(Ft(e,S.ajaxSettings),t):Ft(S.ajaxSettings,e)},ajaxPrefilter:It(Ot),ajaxTransport:It(Pt),ajax:function(e,t){"object"==typeof e&&(t=e,e=void 0),t=t||{};var c,f,p,n,d,r,h,g,i,o,v=S.ajaxSetup({},t),y=v.context||v,m=v.context&&(y.nodeType||y.jquery)?S(y):S.event,x=S.Deferred(),b=S.Callbacks("once memory"),w=v.statusCode||{},a={},s={},u="canceled",T={readyState:0,getResponseHeader:function(e){var t;if(h){if(!n){n={};while(t=qt.exec(p))n[t[1].toLowerCase()+" "]=(n[t[1].toLowerCase()+" "]||[]).concat(t[2])}t=n[e.toLowerCase()+" "]}return null==t?null:t.join(", ")},getAllResponseHeaders:function(){return h?p:null},setRequestHeader:function(e,t){return null==h&&(e=s[e.toLowerCase()]=s[e.toLowerCase()]||e,a[e]=t),this},overrideMimeType:function(e){return null==h&&(v.mimeType=e),this},statusCode:function(e){var t;if(e)if(h)T.always(e[T.status]);else for(t in e)w[t]=[w[t],e[t]];return this},abort:function(e){var t=e||u;return c&&c.abort(t),l(0,t),this}};if(x.promise(T),v.url=((e||v.url||bt.href)+"").replace(Ht,bt.protocol+"//"),v.type=t.method||t.type||v.method||v.type,v.dataTypes=(v.dataType||"*").toLowerCase().match(P)||[""],null==v.crossDomain){r=E.createElement("a");try{r.href=v.url,r.href=r.href,v.crossDomain=Mt.protocol+"//"+Mt.host!=r.protocol+"//"+r.host}catch(e){v.crossDomain=!0}}if(v.data&&v.processData&&"string"!=typeof v.data&&(v.data=S.param(v.data,v.traditional)),Wt(Ot,v,t,T),h)return T;for(i in(g=S.event&&v.global)&&0==S.active++&&S.event.trigger("ajaxStart"),v.type=v.type.toUpperCase(),v.hasContent=!Lt.test(v.type),f=v.url.replace(jt,""),v.hasContent?v.data&&v.processData&&0===(v.contentType||"").indexOf("application/x-www-form-urlencoded")&&(v.data=v.data.replace(Nt,"+")):(o=v.url.slice(f.length),v.data&&(v.processData||"string"==typeof v.data)&&(f+=(Tt.test(f)?"&":"?")+v.data,delete v.data),!1===v.cache&&(f=f.replace(Dt,"$1"),o=(Tt.test(f)?"&":"?")+"_="+wt.guid+++o),v.url=f+o),v.ifModified&&(S.lastModified[f]&&T.setRequestHeader("If-Modified-Since",S.lastModified[f]),S.etag[f]&&T.setRequestHeader("If-None-Match",S.etag[f])),(v.data&&v.hasContent&&!1!==v.contentType||t.contentType)&&T.setRequestHeader("Content-Type",v.contentType),T.setRequestHeader("Accept",v.dataTypes[0]&&v.accepts[v.dataTypes[0]]?v.accepts[v.dataTypes[0]]+("*"!==v.dataTypes[0]?", "+Rt+"; q=0.01":""):v.accepts["*"]),v.headers)T.setRequestHeader(i,v.headers[i]);if(v.beforeSend&&(!1===v.beforeSend.call(y,T,v)||h))return T.abort();if(u="abort",b.add(v.complete),T.done(v.success),T.fail(v.error),c=Wt(Pt,v,t,T)){if(T.readyState=1,g&&m.trigger("ajaxSend",[T,v]),h)return T;v.async&&0<v.timeout&&(d=C.setTimeout(function(){T.abort("timeout")},v.timeout));try{h=!1,c.send(a,l)}catch(e){if(h)throw e;l(-1,e)}}else l(-1,"No Transport");function l(e,t,n,r){var i,o,a,s,u,l=t;h||(h=!0,d&&C.clearTimeout(d),c=void 0,p=r||"",T.readyState=0<e?4:0,i=200<=e&&e<300||304===e,n&&(s=function(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(v,T,n)),!i&&-1<S.inArray("script",v.dataTypes)&&S.inArray("json",v.dataTypes)<0&&(v.converters["text script"]=function(){}),s=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(!(a=l[u+" "+o]||l["* "+o]))for(i in l)if((s=i.split(" "))[1]===o&&(a=l[u+" "+s[0]]||l["* "+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(e){return{state:"parsererror",error:a?e:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}(v,s,T,i),i?(v.ifModified&&((u=T.getResponseHeader("Last-Modified"))&&(S.lastModified[f]=u),(u=T.getResponseHeader("etag"))&&(S.etag[f]=u)),204===e||"HEAD"===v.type?l="nocontent":304===e?l="notmodified":(l=s.state,o=s.data,i=!(a=s.error))):(a=l,!e&&l||(l="error",e<0&&(e=0))),T.status=e,T.statusText=(t||l)+"",i?x.resolveWith(y,[o,l,T]):x.rejectWith(y,[T,l,a]),T.statusCode(w),w=void 0,g&&m.trigger(i?"ajaxSuccess":"ajaxError",[T,v,i?o:a]),b.fireWith(y,[T,l]),g&&(m.trigger("ajaxComplete",[T,v]),--S.active||S.event.trigger("ajaxStop")))}return T},getJSON:function(e,t,n){return S.get(e,t,n,"json")},getScript:function(e,t){return S.get(e,void 0,t,"script")}}),S.each(["get","post"],function(e,i){S[i]=function(e,t,n,r){return m(t)&&(r=r||n,n=t,t=void 0),S.ajax(S.extend({url:e,type:i,dataType:r,data:t,success:n},S.isPlainObject(e)&&e))}}),S.ajaxPrefilter(function(e){var t;for(t in e.headers)"content-type"===t.toLowerCase()&&(e.contentType=e.headers[t]||"")}),S._evalUrl=function(e,t,n){return S.ajax({url:e,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,converters:{"text script":function(){}},dataFilter:function(e){S.globalEval(e,t,n)}})},S.fn.extend({wrapAll:function(e){var t;return this[0]&&(m(e)&&(e=e.call(this[0])),t=S(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(n){return m(n)?this.each(function(e){S(this).wrapInner(n.call(this,e))}):this.each(function(){var e=S(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)})},wrap:function(t){var n=m(t);return this.each(function(e){S(this).wrapAll(n?t.call(this,e):t)})},unwrap:function(e){return this.parent(e).not("body").each(function(){S(this).replaceWith(this.childNodes)}),this}}),S.expr.pseudos.hidden=function(e){return!S.expr.pseudos.visible(e)},S.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},S.ajaxSettings.xhr=function(){try{return new C.XMLHttpRequest}catch(e){}};var Bt={0:200,1223:204},$t=S.ajaxSettings.xhr();y.cors=!!$t&&"withCredentials"in $t,y.ajax=$t=!!$t,S.ajaxTransport(function(i){var o,a;if(y.cors||$t&&!i.crossDomain)return{send:function(e,t){var n,r=i.xhr();if(r.open(i.type,i.url,i.async,i.username,i.password),i.xhrFields)for(n in i.xhrFields)r[n]=i.xhrFields[n];for(n in i.mimeType&&r.overrideMimeType&&r.overrideMimeType(i.mimeType),i.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest"),e)r.setRequestHeader(n,e[n]);o=function(e){return function(){o&&(o=a=r.onload=r.onerror=r.onabort=r.ontimeout=r.onreadystatechange=null,"abort"===e?r.abort():"error"===e?"number"!=typeof r.status?t(0,"error"):t(r.status,r.statusText):t(Bt[r.status]||r.status,r.statusText,"text"!==(r.responseType||"text")||"string"!=typeof r.responseText?{binary:r.response}:{text:r.responseText},r.getAllResponseHeaders()))}},r.onload=o(),a=r.onerror=r.ontimeout=o("error"),void 0!==r.onabort?r.onabort=a:r.onreadystatechange=function(){4===r.readyState&&C.setTimeout(function(){o&&a()})},o=o("abort");try{r.send(i.hasContent&&i.data||null)}catch(e){if(o)throw e}},abort:function(){o&&o()}}}),S.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),S.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(e){return S.globalEval(e),e}}}),S.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),S.ajaxTransport("script",function(n){var r,i;if(n.crossDomain||n.scriptAttrs)return{send:function(e,t){r=S("<script>").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on("load error",i=function(e){r.remove(),i=null,e&&t("error"===e.type?404:200,e.type)}),E.head.appendChild(r[0])},abort:function(){i&&i()}}});var _t,zt=[],Ut=/(=)\?(?=&|$)|\?\?/;S.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=zt.pop()||S.expando+"_"+wt.guid++;return this[e]=!0,e}}),S.ajaxPrefilter("json jsonp",function(e,t,n){var r,i,o,a=!1!==e.jsonp&&(Ut.test(e.url)?"url":"string"==typeof e.data&&0===(e.contentType||"").indexOf("application/x-www-form-urlencoded")&&Ut.test(e.data)&&"data");if(a||"jsonp"===e.dataTypes[0])return r=e.jsonpCallback=m(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(Ut,"$1"+r):!1!==e.jsonp&&(e.url+=(Tt.test(e.url)?"&":"?")+e.jsonp+"="+r),e.converters["script json"]=function(){return o||S.error(r+" was not called"),o[0]},e.dataTypes[0]="json",i=C[r],C[r]=function(){o=arguments},n.always(function(){void 0===i?S(C).removeProp(r):C[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,zt.push(r)),o&&m(i)&&i(o[0]),o=i=void 0}),"script"}),y.createHTMLDocument=((_t=E.implementation.createHTMLDocument("").body).innerHTML="<form></form><form></form>",2===_t.childNodes.length),S.parseHTML=function(e,t,n){return"string"!=typeof e?[]:("boolean"==typeof t&&(n=t,t=!1),t||(y.createHTMLDocument?((r=(t=E.implementation.createHTMLDocument("")).createElement("base")).href=E.location.href,t.head.appendChild(r)):t=E),o=!n&&[],(i=N.exec(e))?[t.createElement(i[1])]:(i=xe([e],t,o),o&&o.length&&S(o).remove(),S.merge([],i.childNodes)));var r,i,o},S.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(" ");return-1<s&&(r=ht(e.slice(s)),e=e.slice(0,s)),m(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),0<a.length&&S.ajax({url:e,type:i||"GET",dataType:"html",data:t}).done(function(e){o=arguments,a.html(r?S("<div>").append(S.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},S.expr.pseudos.animated=function(t){return S.grep(S.timers,function(e){return t===e.elem}).length},S.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=S.css(e,"position"),c=S(e),f={};"static"===l&&(e.style.position="relative"),s=c.offset(),o=S.css(e,"top"),u=S.css(e,"left"),("absolute"===l||"fixed"===l)&&-1<(o+u).indexOf("auto")?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),m(t)&&(t=t.call(e,n,S.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),"using"in t?t.using.call(e,f):c.css(f)}},S.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each(function(e){S.offset.setOffset(this,t,e)});var e,n,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:e.top+n.pageYOffset,left:e.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if("fixed"===S.css(r,"position"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&"static"===S.css(e,"position"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=S(e).offset()).top+=S.css(e,"borderTopWidth",!0),i.left+=S.css(e,"borderLeftWidth",!0))}return{top:t.top-i.top-S.css(r,"marginTop",!0),left:t.left-i.left-S.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&"static"===S.css(e,"position"))e=e.offsetParent;return e||re})}}),S.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(t,i){var o="pageYOffset"===i;S.fn[t]=function(e){return $(this,function(e,t,n){var r;if(x(e)?r=e:9===e.nodeType&&(r=e.defaultView),void 0===n)return r?r[i]:e[t];r?r.scrollTo(o?r.pageXOffset:n,o?n:r.pageYOffset):e[t]=n},t,e,arguments.length)}}),S.each(["top","left"],function(e,n){S.cssHooks[n]=Fe(y.pixelPosition,function(e,t){if(t)return t=We(e,n),Pe.test(t)?S(e).position()[n]+"px":t})}),S.each({Height:"height",Width:"width"},function(a,s){S.each({padding:"inner"+a,content:s,"":"outer"+a},function(r,o){S.fn[o]=function(e,t){var n=arguments.length&&(r||"boolean"!=typeof e),i=r||(!0===e||!0===t?"margin":"border");return $(this,function(e,t,n){var r;return x(e)?0===o.indexOf("outer")?e["inner"+a]:e.document.documentElement["client"+a]:9===e.nodeType?(r=e.documentElement,Math.max(e.body["scroll"+a],r["scroll"+a],e.body["offset"+a],r["offset"+a],r["client"+a])):void 0===n?S.css(e,t,i):S.style(e,t,n,i)},s,n?e:void 0,n)}})}),S.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){S.fn[t]=function(e){return this.on(t,e)}}),S.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)},hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),S.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(e,n){S.fn[n]=function(e,t){return 0<arguments.length?this.on(n,null,e,t):this.trigger(n)}});var Xt=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;S.proxy=function(e,t){var n,r,i;if("string"==typeof t&&(n=e[t],t=e,e=n),m(e))return r=s.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(s.call(arguments)))}).guid=e.guid=e.guid||S.guid++,i},S.holdReady=function(e){e?S.readyWait++:S.ready(!0)},S.isArray=Array.isArray,S.parseJSON=JSON.parse,S.nodeName=A,S.isFunction=m,S.isWindow=x,S.camelCase=X,S.type=w,S.now=Date.now,S.isNumeric=function(e){var t=S.type(e);return("number"===t||"string"===t)&&!isNaN(e-parseFloat(e))},S.trim=function(e){return null==e?"":(e+"").replace(Xt,"")},"function"==typeof define&&define.amd&&define("jquery",[],function(){return S});var Vt=C.jQuery,Gt=C.$;return S.noConflict=function(e){return C.$===S&&(C.$=Gt),e&&C.jQuery===S&&(C.jQuery=Vt),S},"undefined"==typeof e&&(C.jQuery=C.$=S),S});
</script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style type="text/css">@font-face {
font-family: 'Source Sans Pro';
font-style: normal;
font-weight: 300;
src: url(data:font/ttf;base64,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AAAACQACAAAAAAAAAngAXgAAAAAAxwAAAMcAAAIOAAgCQgBhAjQANwJcAGECAwBhAd0AYQJdADcCfwBhAPAAYQHOACkCLgBhAdMAYQLCAGECfABhAowANwIvAGECjAA3AjAAYQIJAC4CDAAdAnoAXwHrAAQDAgAcAeIAEQG/AAMCGgAyAfMAQQIgAFwBwQA0AiAANAHjADQBBwAhAecANAIQAFwA5QBLAOX/3wHQAFwA7QBcAywAXAIUAFwCFwA0AiAAXAIZADQBPQBcAZUAIAE4ABwCEQBVAbIADAKtABgBlwAOAbQADAGUABsCDgAIAg4ACAIOAAgCDgAIAg4ACAIOAAgDKQAVAjQANwIDAGECAwBhAgMAYQIDAGEA8AAHAPAAUwDwAAMA8AAFAnwAYQKMADcCjAA3AowANwKMADcCjAA3AowAOANBADcCegBfAnoAXwJ6AF8CegBfAb8AAwJxACUCMwBhAfMAQQHzAEEB8wBBAfMAQQHzAEEB8wBBAxAAQQHBADQB4wA0AeMANAHjADQB4wA0AOUAGgDlADoA5QAAAOX//wDlAFwCFABcAhcANAIXADQCFwA0AhcANAIXADQCFwAuA1AANAIeAFwCEQBVAhEAVQIRAFUCEQBVAbQADAG0AAwCFwA8AiAAXAIOACICGwAhAj8AJAHfADAB3wBUAd8AJwHfAB0B3wAQAd8AGgHfADQB3wAsAd8AKAHfACsA2wBDANsAMADbAEMA2wAwAQMAVwEDAFcBkgAlAZIAMwDbAFMBaABTANsAOgDbADoBaAA6AWgAOgDbADoBaAA6AQMAKwEDADYBkAArAZAANgErACgBKwAoAeAAKAMgACgA2wBDARkAKAH0AAwBFwBYARcAIAEXAGIBFwAVARcAIwEXABUBZQAJAOIAXwFlAAUA4gBfAYsARgHfADICAwAqAuUAMwGRABIDLgA0Ad8AJAFqAF4BagAvAWoAKAFqAC4BagAoAWoAXgFqAC8BagAoAWoALgFRACoBaAAhAVEAKgFoACEBNwAqAd8AHgHfADsB3wA2Ad8AHgHfABgB3wA+AFD/WwBQ/1sDJQAoAvwASgMSAEoDDwAoAd8AIgHfACIB3wAzAd8AIgHfACIB3wAiAd8AIgHfACIB3wBCAd8AKAHfACICGQBcAhcAswIXANMCFwCZAhcAjwIXAJgCFwCaAhcAuQIXAMoAAP+oAAD/jwAA/8gAAP/bAAD/jgAA/4sAAP+EAAD/fgAA/48AAP+NAAD/jQAA/64AAP+uAAD/tgAA/7YAxwAAAOUASwABAAAD2P7vAAAEiv9X/zcEYgABAAAAAAAAAAAAAAAAAAAA8QADAbcBLAAFAAACigJYAAAASwKKAlgAAAFeADIBIAAAAgsEAwMEAwICBCAAAAcAAAABAAAAAAAAAABBREJFAAAAAP7/Au7/BgAAA9gBESAAAZMAAAAAAeAClAAAACAAAwAAAAIAAAADAAAAFAADAAEAAAAUAAQB0gAAADwAIAAEABwAAAANAC8AOQBAAFoAYAB6AH4AvwDPAN8A7wD/ATEBUwLGAtoC3CAUIBogHiAiIDogRCB0IKwiEiIV//8AAAAAAA0AIAAwADoAQQBbAGEAewCgAMAA0ADgAPABMQFSAsYC2gLcIBMgGCAcICIgOSBEIHQgrCISIhX//wAB//UAAABMAAD/wwAA/70AAAAA/3gAAP93AAD/NgAA/hT+BP3/4IkAAAAA4H3gXeCC4EHgGN673rIAAQAAAAAAOAAAAFQAAABeAAAAZgBsAAAAqAAAAMQAAADgAAAAAAAAAAAA2gDeAAAAAAAAAAAAAAAAAAAAAAADAIoAjwCxAMEAyAB7AI4AoQCiAKsAzACHAJoAhgCnAIgAiQDRANAA0gCMALAAowCpAKQA1ACgANgApQCoAKYA1QDvAIsAxQDCAMAAwwCqAKwA3ACuALsAmADWAJsArwDdAL8A0wCzALQA2QDXAK0AngDfALIAvACZAMkAygDLAI0AVQBIAEkASgBLAEwATQDOAE4AUABRAFIAUwBUAFYAcAB3AGgAaQBqAGsAbABtAM8AbgBxAHIAcwB0AHUAeAB2AE8AbwCQAJEAlACSAJMAlQAAuAAALEu4AAlQWLEBAY5ZuAH/hbgARB25AAkAA19eLbgAASwgIEVpRLABYC24AAIsuAABKiEtuAADLCBGsAMlRlJYI1kgiiCKSWSKIEYgaGFksAQlRiBoYWRSWCNlilkvILAAU1hpILAAVFghsEBZG2kgsABUWCGwQGVZWTotuAAELCBGsAQlRlJYI4pZIEYgamFksAQlRiBqYWRSWCOKWS/9LbgABSxLILADJlBYUViwgEQbsEBEWRshISBFsMBQWLDARBshWVktuAAGLCAgRWlEsAFgICBFfWkYRLABYC24AAcsuAAGKi24AAgsSyCwAyZTWLBAG7AAWYqKILADJlNYIyGwgIqKG4ojWSCwAyZTWCMhuADAioobiiNZILADJlNYIyG4AQCKihuKI1kgsAMmU1gjIbgBQIqKG4ojWSC4AAMmU1iwAyVFuAGAUFgjIbgBgCMhG7ADJUUjISMhWRshWUQtuAAJLEtTWEVEGyEhWS0AsAArALIBAQIrAbICAgIrAbcCfWNROiMACCu3A3NjUTojAAgrALcBinFROiYACCsAsgQIByuwACBFfWkYREuwYFJYsAEbsABZsAGOAAAUACgALAAwAAAADP8zAAwB5gAMAgYADAI+AAwCfgAMApAADALIAAwAAAAHAFoAAwABBAkAAQAqAAAAAwABBAkAAgAOACoAAwABBAkAAwBIADgAAwABBAkABAAqAAAAAwABBAkABQCCAIAAAwABBAkABgAmAQIAAwABBAkADgBIASgAUwBvAHUAcgBjAGUAIABTAGEAbgBzACAAUAByAG8AIABMAGkAZwBoAHQAUgBlAGcAdQBsAGEAcgAxAC4AMAA1ADAAOwBBAEQAQgBFADsAUwBvAHUAcgBjAGUAUwBhAG4AcwBQAHIAbwAtAEwAaQBnAGgAdAA7AEEARABPAEIARQBWAGUAcgBzAGkAbwBuACAAMQAuADAANQAwADsAUABTACAAVgBlAHIAcwBpAG8AbgAgADEALgAwADAAMAA7AGgAbwB0AGMAbwBuAHYAIAAxAC4AMAAuADcAMAA7AG0AYQBrAGUAbwB0AGYALgBsAGkAYgAyAC4ANQAuADUAOQAwADAAUwBvAHUAcgBjAGUAUwBhAG4AcwBQAHIAbwAtAEwAaQBnAGgAdABoAHQAdABwADoALwAvAHcAdwB3AC4AYQBkAG8AYgBlAC4AYwBvAG0ALwB0AHkAcABlAC8AbABlAGcAYQBsAC4AaAB0AG0AbAAAAAIAAAAAAAD/tQAyAAAAAAAAAAAAAAAAAAAAAAAAAAAA8QAAAQIBAwADACQAJQAmACcAKAApACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA7ADwAPQBEAEUARgBHAEgASQBKAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAWwBcAF0ArQDJAMcArgBiAGMAkABkAMsAZQDIAMoAzwDMAM0AzgBmANMA0ADRAK8AZwCRALAA1gDUANUAaADrAOkA7QBqAGkAawBtAGwAbgCgAG8AcQBwAHIAcwB1AHQAdgB3ANcAeAB6AHkAewB9AHwAoQCxAIkAfwB+AIAAgQDsALoA6gDuAQQBBQAJABMAFAAVABYAFwAYABkAGgAbABwAEQAPAB0AHgAEAKMAIgCiAAoABQC2ALcAtAC1AMQAxQC+AL8AqQCqABABBgCyALMAwwCHAEIACwAMAD4AQABeAGAAEgBfAD8A6AANAIYAiACLAIoAIwAGAQcBCAEJAQoBCwEMAQ0BDgEPAJ0AngEQAREAgwC9AAcAhQCWARIAhAC8ARMACAD1APQA9gAOAO8A8AC4ACAAHwAhAJMAQQBhAKQBFABDAI0A2ADZAI4A2gDdAN4BFQEWARcBGAEZARoBGwEcAR0BHgEfASABIQEiASMBJAElBE5VTEwCQ1IDZl9mA2ZfdAd1bmkwMEFECG9uZS5zdXBzCHR3by5zdXBzCnRocmVlLnN1cHMJZm91ci5zdXBzCXplcm8uZG5vbQhvbmUuZG5vbQh0d28uZG5vbQp0aHJlZS5kbm9tCWZvdXIuZG5vbQZhLnN1cHMGby5zdXBzBEV1cm8HdW5pMjIxNQd1bmkwMEI1B3VuaTAzMDALdW5pMDMwMC5jYXAHdW5pMDMwMQt1bmkwMzAxLmNhcAd1bmkwMzAyC3VuaTAzMDIuY2FwB3VuaTAzMDMLdW5pMDMwMy5jYXAHdW5pMDMwNAd1bmkwMzA4C3VuaTAzMDguY2FwB3VuaTAzMEELdW5pMDMwQS5jYXAHdW5pMDMyNwt1bmkwMzI3LmNhcAd1bmkwMEEwBWkudHJrAAAAAAAAAf//AAIAAQAAAAwAAAAAAAAAAgAIAAQANwABAD4APgABAE4ATwABAGcAZwABAG4AbwABAHgAeAABAHkAegACANoA2gABAAEAAAAKADAARAACREZMVAAObGF0bgAaAAQAAAAA//8AAQAAAAQAAAAA//8AAQABAAJrZXJuAA5rZXJuAA4AAAABAAAAAQAEAAIAAAACAAoBPAABACYABAAAAA4ARgBsAIIApAC6AMgA2gDoAPoBAAEKARgBHgEoAAEADgAJABMAGQAbADMANQBWAHAAiwCNAJ4ApwCpAMIACQAZAAoAG//rADP/9QA1/+wAZQAVAGYAJwCe//UAp/+vAK8AHQAFABv/6wA1//UAnv/1AKf/pgCvACcACAAz//gANf/zAGMABgBlACgAZgArAJ7/8ACn/8YArwA2AAUAM//2ADX/9gCe/9gAq//2AK8AFAADAKf/7ACr//UArwA4AAQAG//2AJ7/7ACr/+oArwA2AAMAp/+2AKn/2ACr/7UABAAz//YANQAJAKn/7ACv/+gAAQAZ/+wAAgAZ/9cAG//mAAMAGf/sABv/7AA1/+wAAQDwACQAAgAZ/8YAM//sAAIAf//3AIH/9wACFIwABAAAFN4WLAA5AC4AAP/c/6D/2//c/7IAJgBO//cAEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9v/iAAAAJgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/8MAAAAA/9cAAAAAAAAAAAAAAAD/6//r/9cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/rv/h/+H/vAAAAEMAAAAAAAAAAP/S/+wAAP/r/+j/0v/zAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//YAJAAAAAAAAAAA/9gAAAAAAAD/6wAA/9f/sAAkABH/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/9j/7wAA//UAAAAAAAD/9f/YAAAAAAAA//X/9gAA//YAAAAAAAD/9f/3/5z/2P/r/7kAAAAAAAAAAP/1AAr/7P/Y/9P/9QAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/6wAAAAD/9QAAAAD/9v/1AAAAAAAA//UAAAAAAAAAAAAA//EAAP/2AAD/4gAA/+wAAAAAAAAAAAAAAAAAAAAAAAAAAP/1//YAAAAAAAAAAAAAAAAAAAAAAAAAAP/r//UAAAAA/+wAAP/2//UAAAAAAAD/6//2/+gAAAAAAAD/9gAA//X/9gAAAAD/2AAUAAAAAAAAAAAAAAAAAAAAAAAA//UAAP/s//UAAAAAAAAAAAAAAAAAAAAA/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+EAAAAAABQAAAAAAAAAAP/1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9v/1//b/9gAA//b/9v/1AAAAAP/2//YAAP/tAAAAAAAAAAAAAP/s//H/9QAA/9gAEwAAAAAAAAAA//cAAAAA//UAAP/1//b/7//2AAAAAP/1AAAAAAAAAAAAAP+I/+j/yf+6AAAAAP/h/+b/wwAAAAj/7QAA/+wAAP/1//UAAAAA//D/9v90/7D/sP+wAAAAAAAAAAD/tQAA/+z/xf/D/+YAAP/E/9gAAAAAAAAAAAAAAAAAAAAA/+wAAP/3/+wAAAAAAAAAAAAAAAD/9gAA/+wAAAAAAAAAAP/hAAAAAAAA/9gAAAAAAAn/7AAAAAAAAP/2//QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7AAAAAD/9f/2AAAAAAAAAAAAAP/2//L/9gAA//YAAP/2/+sAAAAAAAD/9gAA//YAFAAAAAAAAAAA//X/9gAAAAAAAAAA//X/1//iAAAAAP/1//UAAAAAAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAD/9QAAAAAAAAAAAAD/9QAAAAAAAP/rAAD/9QAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAAAAAAAAAAAAAAAAAAA//X/sgAA/9j/2gAA/5z/2P/R/8T/6/+y/+v/xP9/AAD/6//PAAAAAP/DABT/mwAAAAAAAAAA/+wAAAAAAAD/2v/R/7D/1v/P/8b/rv/YAAAAAAAAAAAAAAAAAAD/9f/2AAAAAAAAAAD/9v/r//YAAAAAAAAAAAAA/9YAAAAAAAAAAAAAAAAAAP/XAAAAAAAA//b/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+4AAAAAAAAAAP/hAAD/9//3//f/7QAAAAD/tAAAAAAAAAAAAAAAAAAv/9cAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//YAAAAA//b/9gAAAAAAAAAA//X/9gAAAAD/xAAA/+v/9QAR/7H/9f/x/+P/9f/CAAD/3/+cAAD/9f/hAAAAAP/YACb/sgAAAAAAAAAAAAAAAAAAAAD/9f/h/8T/1P/Y/9//1v/i/+4AAAAAAAAAAP/2//f/9f/xAAD/7f/tAAAAAP/3/+L/9v/s/+3/7P/m/9oAAP/1/+QAAAAA/8QAFAAAAAAAAAAA//cAAAAAAAAAAP/tAAD/2P/YAAAAAAAAAAAAAAAAAAAAAP/rAAAAAP/rAAAAAAAAAAD/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/EAAAAAAAAAAAAAAAAAAD/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+wAAAAA/+v/9gAAAAkACQAAAAAAAAAAAAAAAP/2AAD/7wAAAAAAAAAAAAAAAP/1AB0AAAAAAAAAAP/1AAAAAAAAAAAACQAP//UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7AAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/wwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+c//D/4f+wAAAAFP/x/+z/rwAAAAAAAAAAAAAAAAAA//UAAAAA/+EAAP+HAAAAAAAAAAAAAAAAAAD/xAAAAAD/s//D/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+sAAP/2/+z/9gAAAAwADP/2AAAAAP/sAAAAAP/xAAAAAP/sAAD/9QAA/9j/9QAAAAcAAAAAAAAAAP/2AAAAAAAAAAAADAAAAAkABwAAAAAABQAAAAAAAAAAAAAAMQAAADEAMf/x//YAAAAAACj/1wAAAAAAAAAA/+wAAP/2AAAAAAAA/+oAAABP/+wAWv/sABQAAAAAADMAJgAdACgAKAASAAD/9QAAAAAAAP/1AAAAAAA5AAAAAP/sAAAAAP/1AAAAIAAAAAAAAAAAAAAAAAAAAAD/8QAA//UAAAAAAAAAAP/YAAD/9QAUADwAAAAAAAAAAAAA/+IAAAAAAAAAAAAAAAAAAAAA//UAAAAAABQAAAAA//oAAAAA//n/9v/2AAAAAP/sABQAAAAAAAAAAP/2AAD/9AAAAAD/9f/1/+wAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+v/7AAAAAAAAAAAAAAAAAAAAAD/6wAAAAD/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/2AAAAAAAAAAAAAAAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/IAAAAAP/YAAAAAAAAAAD/7P/2AAAAAAAAAAD/8QAAAAAAAAAAAAAAAAAA/+wAAAAAAAAAAAAAAAD/7gAAAAAAAP/sAAD/9AAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABH/2gAAAAAAAAAA/8X/2AAAAAAAAP/Q//X/2gAAAAAAAAAAAAAAAAAAAAAAAAAA/8b/dgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2//cAEgAbAAD/2f/uAAD/9gAA/+kAAP/2/9QAAAAAAAAAAAAS/+0AT//YAAAAAAAAAAAAAAAAAAAAKAAbAAD/6//sAAD/9v/2AAAAAAAAAAAAAP/rAAAAAP/sAAAAAAAAAAD//QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/DAAAAAAAAAAAAAAAAAAD/9gAA//0AAAAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAA//UAAAAAAAD/9gAAAAAAAAAAABQAAAAAAAAAAP/rAAD/9gAAAAAAAP/3AAAAAP/sACgAFAAAAAAAAAAAAAD/7AAAAAAAAAAA/+z/6wAAAAAAAAAAABQAAAAAAAD/7AAAAAD/4gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/4gAAAAAAAAAAAAAAAAAA//UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/rAAAAAP/9AAD/9gAAAAAAAP/xAAAAAAAAAAD/9gAAAAD/4gAAAAAAAP/1AAAAAAA2//UAAAAAAAAAAP/1AAAAAAAAAAAAAAAAAAAAAAAA//QAAAAAAAAAAAAA/+wAAAAAAAAAAP/2AAAAAAAA/+wAAAAAAAAAAP/sAAAAAP/YAAAAAAAAAAAAAAAAADj/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/6wAAAAAAAAAAAAD/4wAAAAAAAP/3AAAAAAAAAAAAAAAAAAAAAAAA/+QAAP/2AAAAAAAA//YAAAAA//UAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAv/6wAA//b/9gAA/8T/3P/w/+L/9v/hAAD/9f9zAAD/9v/xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7P/s//D/7wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+sAAAAAAAAAAAAAAAAAAP/aAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/4gAAAAD/9v/ZAAAAAAAAAAD/nP/O//b/ogAA/9AAAP/n/2sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/3P/sAAD/9v/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9gAAAAD/6gAA//j/+AAA/8b/9f/t/+7/9v/xAAD/8/+y//wAAP/iAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+7/6v/s//f/5f/yAAAAAAAAAAD/7P/2AAAAAAAAAAD/9f/2AAAAAAAI//UAAP/0//b/9gAAAAAAAP/2//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/6v/1AAAAAP/1AAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/9wAAAAA/8QAAAAAAAAAAAAAAAAAAAAA/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/s/+wAAAAAAAAAAP/1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9f/2/9sAAAAAAAAAAAAAAAAAAAAAAAAAAP/xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2/8L/3QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/YAAD/9P/iAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9AAAAAAAAAAAAAD/7AAAAAAAAAAAAAAAAAAAAAAAAAAA/9gAAP/2/9QAAAAAAAAAAAAAAAAAAP/i/+sAAAAAAAAAAP/iAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/q//UAAAAAAAAAAP/rAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+Y/9QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAD/2gAAAAAAAAAA/4j/0wAAAAAAAP/h/+3/2gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/8cAAAAAAAAAAAAAAAD/7AAAAAAAAAAA//YAAAAAAAD/7P/2AAAAAAAA/+wAAAAA/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/rAAAAAAAAAAAAAP/aAAAAAP/8AAAAAAAA//UAAAAAAAAAAAAA//b/9gAA//QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/1/+sAAAAAAAD/7AAAAAAAAgANAAQAIAAAACIAJQAdACgAKAAhACoAYgAiAGcAdgBbAHgAegBrAIYAkwBuAJYAngB8AKEAoQCFAKMAowCGAKUApQCHAKcApwCIAKkAqQCJAAEABACkAAYABwAIAAwAJgAnAAkAKAApACoACgALACgAKAAMACsADAANAA4ADwAQAC0AEQAuABIAEwAUAB0AFQAAABgAGQAaABwAAAAAABsAAAAcABwAHQAdACIAHwAgACEAIgA3ACMAOAAkACUABgAGAAYABgAGAAYAJgAIACYAJgAmACYAKQApACkAKQAoAAwADAAMAAwADAAMACYAEAAQABAAEAASAAwALAAUABQAFAAUABQAFAAYABUAGAAYABgAGAAAAAAAAAAAACIAHAAdAB0AHQAdAB0AHQAYADEAIgAiACIAIgAkACQAAAAdABkAIQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFwAXABYAFgABAAIANAAEADUANQAeADYAHgA2AAAAAAAyADMAMgAzADAAMAAwADAAAwAAAAAALwAAAC8AAAAvAAAABQACAEgABAAEAAwABgAGAA8ACgAKAA8ADQANABMAEgASAA8AFAAUAA8AFgAWAA0AFwAXAAIAGAAYAAMAGQAZAB8AGgAaAAQAGwAbACAAHAAcAAUAHQAdAA4AHgAeABAAIAAiABIAIwAjABEAJAAkAAYAJgAmABQAJwAnAAcAKgArACgALAAsABIALQAtACgALgAuABIALwAvACgAMAAwACkAMQAxABUAMgAyABYAMwAzACQANAA0AAgANQA1ACUANgA2AAkANwA3ACoAOAA9AAwAPwA/AA8ASQBPAA8AUABTAAMAVABUAAUAVQBVAAEAVwBdABAAXgBiABIAYwBmABQAZwBoACgAaQBvABIAcQB0ABYAdQB2AAkAeQB6ABEAhgCHAAsAiACJACwAigCKABwAiwCLAB0AjACMACEAjQCNAB4AjgCPACIAkACQACMAkQCRAAoAkgCSACMAkwCTAAoAlgCWACcAlwCXACsAmACYACcAmQCZACsAmgCdACYAngCeABkAogCiAC0ApACkAC0ApgCmAC0ApwCnABsAqQCpABgAqwCrABcArwCvABoA8ADwABQAAQAAAAoAYACeAAJERkxUAA5sYXRuABoABAAAAAD//wABAAAAFgADQVpFIAAeQ1JUIAAoVFJLIAAyAAD//wABAAEAAP//AAIAAgAFAAD//wACAAMABgAA//8AAgAEAAcACGxpZ2EAMmxpZ2EAMmxpZ2EAMmxpZ2EAMmxpZ2EAMmxvY2wAOGxvY2wAOGxvY2wAOAAAAAEAAQAAAAEAAAACAAYAGgABAAAAAQAIAAEABgDKAAEAAQAmAAQAAAABAAgAAQAaAAEACAACAAYADAB5AAIAIwB6AAIAMQABAAEAIw==) format('truetype');
}
@font-face {
font-family: 'Source Sans Pro';
font-style: normal;
font-weight: 400;
src: url(data:font/ttf;base64,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AB4AAwABBAkAAwBMACwAAwABBAkABAAeAAAAAwABBAkABQCCAHgAAwABBAkABgAqAPoAAwABBAkADgBIASQAUwBvAHUAcgBjAGUAIABTAGEAbgBzACAAUAByAG8AUgBlAGcAdQBsAGEAcgAxAC4AMAA1ADAAOwBBAEQAQgBFADsAUwBvAHUAcgBjAGUAUwBhAG4AcwBQAHIAbwAtAFIAZQBnAHUAbABhAHIAOwBBAEQATwBCAEUAVgBlAHIAcwBpAG8AbgAgADEALgAwADUAMAA7AFAAUwAgAFYAZQByAHMAaQBvAG4AIAAxAC4AMAAwADAAOwBoAG8AdABjAG8AbgB2ACAAMQAuADAALgA3ADAAOwBtAGEAawBlAG8AdABmAC4AbABpAGIAMgAuADUALgA1ADkAMAAwAFMAbwB1AHIAYwBlAFMAYQBuAHMAUAByAG8ALQBSAGUAZwB1AGwAYQByAGgAdAB0AHAAOgAvAC8AdwB3AHcALgBhAGQAbwBiAGUALgBjAG8AbQAvAHQAeQBwAGUALwBsAGUAZwBhAGwALgBoAHQAbQBsAAAAAgAAAAAAAP+1ADIAAAAAAAAAAAAAAAAAAAAAAAAAAADxAAABAgEDAAMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQCtAMkAxwCuAGIAYwCQAGQAywBlAMgAygDPAMwAzQDOAGYA0wDQANEArwBnAJEAsADWANQA1QBoAOsA6QDtAGoAaQBrAG0AbABuAKAAbwBxAHAAcgBzAHUAdAB2AHcA1wB4AHoAeQB7AH0AfAChALEAiQB/AH4AgACBAOwAugDqAO4BBAEFAAkAEwAUABUAFgAXABgAGQAaABsAHAARAA8AHQAeAAQAowAiAKIACgAFALYAtwC0ALUAxADFAL4AvwCpAKoAEAEGALIAswDDAIcAQgALAAwAPgBAAF4AYAASAF8APwDoAA0AhgCIAIsAigAjAAYBBwEIAQkBCgELAQwBDQEOAQ8AnQCeARABEQCDAL0ABwCFAJYBEgCEALwBEwAIAPUA9AD2AA4A7wDwALgAIAAfACEAkwBBAGEApAEUAEMAjQDY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AAAAAAAAAAAAAP/s/+z/7P/iAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/6AAAAAAAAAAAAAAAAAAA/9kAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/oAAAAAP/2/+IAAAAAAAAAAP+Q/87/9v+yAAD/1QAA/+j/bgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/n/+wAAP/2/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAP/rAAD/9//3AAD/v//y//D/7f/2/+oAAP/x/7f//QAA/+IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7f/r/+z/9P/n/+0AAAAAAAAAAP/s//YAAAAAAAAAAP/y//D/+QAAAAP/8gAA/+//9v/w//n/+wAA//D/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//P/5AAAAAP/l//IAAAAA//L/+QAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/5wAA//z/vgAAAAAAAAAAAAAAAAAAAAD/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+b/5gAAAAAAAP/8//IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/y//D/yAAAAAAAAAAAAAAAAP/8AAAAAAAA//AAAAAA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) format('truetype');
}
@font-face {
font-family: 'Source Sans Pro';
font-style: normal;
font-weight: 700;
src: url(data:font/ttf;base64,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////+gAAAkMDNgImAAQAAAAHAOMBGwAA////+gAAAkMDNgImAAQAAAAHAOUBGwAA////+gAAAkMDRwImAAQAAAAHAOcBGwAA////+gAAAkMDSAImAAQAAAAHAOoBGwAA////+gAAAkMDfQImAAQAAAAHAOwBGwAAAAL/8gAAAxkCjAAGABYAfAC4AABFWLgADi8buQAOABA+WbgAAEVYuAANLxu5AA0ABD5ZuAAARVi4AAkvG7kACQAEPlm6AAIADgANERI5ugAKAA4ADRESObgACi+5AAYAAfS4AAkQuQAHAAH0uAAOELkAEAAB9LoAFQAOAAkREjm4ABUvuQATAAH0MDEBESMOAQ8BBRUhNSMHIwEhFSMVMxUjFQGCBBQnFCoCFP5psUSbATYB5/rT0wEHARYwXitdi3yVlQKMfIN7lgAA//8ALv8jAjACmAImAAYAAAAHAO4BXgAA//8ATQAAAe8DNgImAAgAAAAHAOEBIAAA//8ATQAAAe8DNgImAAgAAAAHAOMBIAAA//8ATQAAAe8DNgImAAgAAAAHAOUBIAAA//8ATQAAAe8DSAImAAgAAAAHAOoBIAAA////9AAAAOEDNgImAAwAAAAHAOEAlgAA//8ASwAAATgDNgImAAwAAAAHAOMAlgAA////7gAAAT4DNgImAAwAAAAHAOUAlgAA////7QAAAT8DSAImAAwAAAAHAOoAlgAA//8ATQAAAkwDRwImABEAAAAHAOcBTQAA//8ALv/0An4DNgImABIAAAAHAOEBVgAA//8ALv/0An4DNgImABIAAAAHAOMBVgAA//8ALv/0An4DNgImABIAAAAHAOUBVgAA//8ALv/0An4DRwImABIAAAAHAOcBVgAA//8ALv/0An4DSAImABIAAAAHAOoBVgAAAAMAKP/XApQCtQAHABAAKgCFALgAAEVYuAAmLxu5ACYAED5ZuAAARVi4ABkvG7kAGQAEPlm6AAAAGQAmERI5uQACAAH0ugAHACYAGRESOboACAAmABkREjm4ACYQuQAKAAH0ugAQABkAJhESOboAEQAmABkREjm6ABsAGQAmERI5ugAeABkAJhESOboAKAAmABkREjkwMSUWMzI2NTQvASYjIgYVFBYXAR4BFRQOAiMiJwcnNy4BNTQ+AjMyFzcXAQgiLUNOCTAkNENOBwYBdRodK05tQl5H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AG8AbABkADsAQQBEAE8AQgBFAFMAbwB1AHIAYwBlACAAUwBhAG4AcwAgAFAAcgBvACAAQgBvAGwAZABWAGUAcgBzAGkAbwBuACAAMQAuADAANQAwADsAUABTACAAVgBlAHIAcwBpAG8AbgAgADEALgAwADAAMAA7AGgAbwB0AGMAbwBuAHYAIAAxAC4AMAAuADcAMAA7AG0AYQBrAGUAbwB0AGYALgBsAGkAYgAyAC4ANQAuADUAOQAwADAAUwBvAHUAcgBjAGUAUwBhAG4AcwBQAHIAbwAtAEIAbwBsAGQAaAB0AHQAcAA6AC8ALwB3AHcAdwAuAGEAZABvAGIAZQAuAGMAbwBtAC8AdAB5AHAAZQAvAGwAZQBnAGEAbAAuAGgAdABtAGwAAgAAAAAAAP+1ADIAAAAAAAAAAAAAAAAAAAAAAAAAAADxAAABAgEDAAMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQCtAMkAxwCuAGIAYwCQAGQAywBlAMgAygDPAMwAzQDOAGYA0wDQANEArwBnAJEAsADWANQA1QBoAOsA6QDtAGoAaQBrAG0AbABuAKAAbwBxAHAAcgBzAHUAdAB2AHcA1wB4AHoAeQB7AH0AfAChALEAiQB/AH4AgACBAOwAugDqAO4BBAEFAAkAEwAUABUAFgAXABgAGQAaABsAHAARAA8AHQAeAAQAowAiAKIACgAFALYAtwC0ALUAxADFAL4AvwCpAKoAEAEGALIAswDDAIcAQgALAAwAPgBAAF4AYAASAF8APwDoAA0AhgCIAIsAigAjAAYBBwEIAQkBCgELAQwBDQEOAQ8AnQCeARABEQCDAL0ABwCFAJYBEgCEALwBEwAIAPUA9AD2AA4A7wDwALgAIAAfACEAkwBBAGEApAEUAEMAjQDYANkAjgDaAN0A3gEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBIwEkASUETlVMTAJDUgNmX2YDZl90B3VuaTAwQUQIb25lLnN1cHMIdHdvLnN1cHMKdGhyZWUuc3Vwcwlmb3VyLnN1cHMJemVyby5kbm9tCG9uZS5kbm9tCHR3by5k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AAAAAAAAABgABQAEAAD/5P/sAAD/9v/2AAAAAAAAAAAAAP/kAAAAAP/sAAAAAAAA/+cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/5AAAAAAAAAAAAAAAAAAA//YAAP/nAAAAAAAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAA/+4AAAAA//j/9gAAAAAAAAAEAAAAAAAAAAD/9AAA//YAAAAAAAAAAAAAAAD/7AAYAAQAAAAAAAAAAAAA/9wAAAAAAAAAAAAA/9z/9AAAAAAAAAAAAAQAAAAAAAD/7AAAAAD/4gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//IAAAAAAAAAAAAAAAAAAP/uAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/kAAAAAP/nAAD/9gAAAAD/rf/4AAAAAAAA//YAAP/4/+IAAAAAAAAAAAAAAAAACwAAAAAAAAAA//j/7gAAAAAAAAAAAAAAAAAAAAAAAAAA/+YAAAAAAAAAAAAA/+wAAAAA//AAAP/2AAAAAP/EAAAAAAAAAAD/7AAA//j/2AAAAAAAAAAAAAAAAAAb//wAAAAAAAD/+P/4AAAAAAAAAAAAAAAAAAAAAAAAAAD/5AAAAAAAAAAAAAD/6gAAAAD/+AAAAAD/+AAAAAAAAAAAAAAAAP/yAAD/9gAAAAAAAP/2AAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAD/+AAAAAD/5gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/6//L/5AAA/+YAAP+k/9n/5f/i//b/2gAA/+7/egAA//b/7QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/5gAAAAD/7P/s/+X/zAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/kAAAAAAAAAAAAAAAAAAD/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/8gAAAAD/9v/wAAAAAAAA/3z/zv/2/80AAP/eAAD/6/9yAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/+f/sAAD/9v/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9gAAAAD/7AAA//YAAP+0/+7/9P/s//b/3QAA/+3/wAAAAAD/4gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9gAA/+z/7P/s/+7/6//lAAAAAAAAAAD/7P/2AAAAAAAAAAD/5v/wAAD/+v/uAAD/5v/2/+b/8P/wAAD/5v/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/4//AAAP/uAAD/3P/uAAAAAP/u//AAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAA/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//kAAP/4/7QAAAAAAAAAAAAAAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/3P/cAAAAAAAA//gAAP/uAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/5v+oAAAAAAAAAAAAAAAA//gAAAAAAAD/7QAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/5v+0/7kAAP/uAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/YAAD/5v+6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+b/8AAAAAAAAAAAAAD/7AAAAAAAAAAAAAAAAAAAAAAAAAAA/8gAAP/2/7cAAAAAAAAAAAAAAAD/4v/0AAAAAAAAAAD/4gAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7P/uAAAAAAAAAAAAAP/kAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/dAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/e/+3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/+AAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAD/6AAAAAAAAP9o/68AAAAAAAD/2v/0/+gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/wAAAAAAAAAAAAAAAAAAAAAAAA/90AAAAAAAAAAAAAAAD/7AAAAAD/8AAA//YAAAAA/8T/8wAA//gAAP/sAAD/+P/YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/8AAAAAAAAP/kAAAAAAAAAAAAAP/oAAAAAP/fAAAAAP/uAAAAAAAA//gAAP/2//YAAP/mAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/u/+QAAAAAAAD/7AAAAAAAAgANAAQAIAAAACIAJQAdACgAKAAhACoAYgAiAGcAdgBbAHgAegBrAIYAkwBuAJYAngB8AKEAoQCFAKMAowCGAKUApQCHAKcApwCIAKkAqQCJAAEABACkAAYABwAIAAwAJgAnAAkAKAApACoACgALACgAKAAMACsADAANAA4ADwAQAC0AEQAuABIAEwAUAB0AFQAAABgAGQAaABwAAAAAABsAAAAcABwAHQAdACIAHwAgACEAIgA3ACMAOAAkACUABgAGAAYABgAGAAYAJgAIACYAJgAmACYAKQApACkAKQAoAAwADAAMAAwADAAMACYAEAAQABAAEAASAAwALAAUABQAFAAUABQAFAAYABUAGAAYABgAGAAAAAAAAAAAACIAHAAdAB0AHQAdAB0AHQAYADEAIgAiACIAIgAkACQAAAAdABkAIQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFwAXABYAFgABAAIANAAEADUANQAeADYAHgA2AAAAAAAyADMAMgAzADAAMAAwADAAAwAAAAAALwAAAC8AAAAvAAAABQACAEgABAAEAAsABgAGAA4ACgAKAA4ADQANABIAEgASAA4AFAAUAA4AFgAWAAwAFwAXAAIAGAAYAAMAGQAZAB4AGgAaAAQAGwAbAB8AHAAcAAUAHQAdAA0AHgAeAA8AIAAiABEAIwAjABAAJAAkAAYAJgAmABMAJwAnAAcAKgArACgALAAsABEALQAtACgALgAuABEALwAvACgAMAAwACkAMQAxABQAMgAyABUAMwAzACMANAA0ACQANQA1ACUANgA2AAgANwA3ACoAOAA9AAsAPwA/AA4ASQBPAA4AUABTAAMAVABUAAUAVQBVAAEAVwBdAA8AXgBiABEAYwBmABMAZwBoACgAaQBvABEAcQB0ABUAdQB2AAgAeQB6ABAAhgCHAAoAiACJACwAigCKABsAiwCLABwAjACMACAAjQCNAB0AjgCPACEAkACQACIAkQCRAAkAkgCSACIAkwCTAAkAlgCWACcAlwCXACsAmACYACcAmQCZACsAmgCdACYAngCeABgAogCiAC0ApACkAC0ApgCmAC0ApwCnABoAqQCpABcAqwCrABYArwCvABkA8ADwABMAAAABAAAACgBgAJ4AAkRGTFQADmxhdG4AGgAEAAAAAP//AAEAAAAWAANBWkUgAB5DUlQgAChUUksgADIAAP//AAEAAQAA//8AAgACAAUAAP//AAIAAwAGAAD//wACAAQABwAIbGlnYQAybGlnYQAybGlnYQAybGlnYQAybGlnYQAybG9jbAA4bG9jbAA4bG9jbAA4AAAAAQABAAAAAQAAAAIABgAaAAEAAAABAAgAAQAGAMoAAQABACYABAAAAAEACAABABoAAQAIAAIABgAMAHkAAgAjAHoAAgAxAAEAAQAj) format('truetype');
}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:bold}dfn{font-style:italic}h1{font-size:2em;margin:0.67em 0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-0.5em}sub{bottom:-0.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace, monospace;font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type="checkbox"],input[type="radio"]{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:0}input[type="number"]::-webkit-inner-spin-button,input[type="number"]::-webkit-outer-spin-button{height:auto}input[type="search"]{-webkit-appearance:textfield;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box}input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}fieldset{border:1px solid #c0c0c0;margin:0 2px;padding:0.35em 0.625em 0.75em}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:bold}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}@media print{*,*:before,*:after{background:transparent !important;color:#000 !important;-webkit-box-shadow:none !important;box-shadow:none !important;text-shadow:none !important}a,a:visited{text-decoration:underline}a[href]:after{content:" (" attr(href) ")"}abbr[title]:after{content:" (" attr(title) ")"}a[href^="#"]:after,a[href^="javascript:"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}p,h2,h3{orphans:3;widows:3}h2,h3{page-break-after:avoid}.navbar{display:none}.btn>.caret,.dropup>.btn>.caret{border-top-color:#000 !important}.label{border:1px solid #000}.table{border-collapse:collapse !important}.table td,.table th{background-color:#fff !important}.table-bordered th,.table-bordered td{border:1px solid #ddd !important}}@font-face{font-family:'Glyphicons Halflings';src:url(data:application/vnd.ms-fontobject;base64,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);src:url(data:application/vnd.ms-fontobject;base64,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) format('embedded-opentype'),url(data:font/woff;base64,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) format('woff'),url(data:font/ttf;base64,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JbwmFCZ+JuYnUCe8J/goNChwKKwpoCnMKiYqSiqEKworeiwILGgsuizsLRwtiC30LiguZi6iLtgvDi9GL34vsi/4MD4whDDSMRIxYDGuMegyJDJeMpoy3jMiMz4zaDO2NBg0YDSoNNI1LDWeNeg2PjZ8Ntw3GjdON5I31DgQOEI4hjjIOQo5SjmIOcw6HDpsOpo63jugO9w8GDxQPKI8+D0yPew+Oj6MPtQ/KD9uP6o/+kBIQIBAxkECQX5CGEKoQu5DGENCQ3ZDoEPKRBBEYESuRPZFWkW2RgZGdEa0RvZHNkd2R7ZH9kgWSDJITkhqSIZIzEkSSThJXkmESapKAkouSlIAAQAAARcApwARAAAAAAACAAAAAQABAAAAQAAuAAAAAAAAABAAxgABAAAAAAATABIAAAADAAEECQAAAGoAEgADAAEECQABACgAfAADAAEECQACAA4ApAADAAEECQADAEwAsgADAAEECQAEADgA/gADAAEECQAFAHgBNgADAAEECQAGADYBrgADAAEECQAIABYB5AADAAEECQAJABYB+gADAAEECQALACQCEAADAAEECQAMACQCNAADAAEECQATACQCWAADAAEECQDIABYCfAADAAEECQDJADACkgADAAEECdkDABoCwnd3dy5nbHlwaGljb25zLmNvbQBDAG8AcAB5AHIAaQBnAGgAdAAgAKkAIAAyADAAMQA0ACAAYgB5ACAASgBhAG4AIABLAG8AdgBhAHIAaQBrAC4AIABBAGwAbAAgAHIAaQBnAGgAdABzACAAcgBlAHMAZQByAHYAZQBkAC4ARwBMAFkAUABIAEkAQwBPAE4AUwAgAEgAYQBsAGYAbABpAG4AZwBzAFIAZQBnAHUAbABhAHIAMQAuADAAMAA5ADsAVQBLAFcATgA7AEcATABZAFAASABJAEMATwBOAFMASABhAGwAZgBsAGkAbgBnAHMALQBSAGUAZwB1AGwAYQByAEcATABZAFAASABJAEMATwBOAFMAIABIAGEAbABmAGwAaQBuAGcAcwAgAFIAZQBnAHUAbABhAHIAVgBlAHIAcwBpAG8AbgAgADEALgAwADAAOQA7AFAAUwAgADAAMAAxAC4AMAAwADkAOwBoAG8AdABjAG8AbgB2ACAAMQAuADAALgA3ADAAOwBtAGEAawBlAG8AdABmAC4AbABpAGIAMgAuADUALgA1ADgAMwAyADkARwBMAFkAUABIAEkAQwBPAE4AUwBIAGEAbABmAGwAaQBuAGcAcwAtAFIAZQBnAHUAbABhAHIASgBhAG4AIABLAG8AdgBhAHIAaQBrAEoAYQBuACAASwBvAHYAYQByAGkAawB3AHcAdwAuAGcAbAB5AHAAaABpAGMAbwBuAHMALgBjAG8AbQB3AHcAdwAuAGcAbAB5AHAAaABpAGMAbwBuAHMALgBjAG8AbQB3AHcAdwAuAGcAbAB5AHAAaABpAGMAbwBuAHMALgBjAG8AbQBXAGUAYgBmAG8AbgB0ACAAMQAuADAAVwBlAGQAIABPAGMAdAAgADIAOQAgADAANgA6ADMANgA6ADAANwAgADIAMAAxADQARgBvAG4AdAAgAFMAcQB1AGkAcgByAGUAbAAAAAIAAAAAAAD/tQAyAAAAAAAAAAAAAAAAAAAAAAAAAAABFwAAAQIBAwADAA0ADgEEAJYBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMA7wEUARUBFgEXARgBGQEaARsBHAEdAR4BHwEgASEBIgEjASQBJQEmAScBKAEpASoBKwEsAS0BLgEvATABMQEyATMBNAE1ATYBNwE4ATkBOgE7ATwBPQE+AT8BQAFBAUIBQwFEAUUBRgFHAUgBSQFKAUsBTAFNAU4BTwFQAVEBUgFTAVQBVQFWAVcBWAFZAVoBWwFcAV0BXgFfAWABYQFiAWMBZAFlAWYBZwFoAWkBagFrAWwBbQFuAW8BcAFxAXIBcwF0AXUBdgF3AXgBeQF6AXsBfAF9AX4BfwGAAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBuAG5AboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBxwHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAdUB1gHXAdgB2QHaAdsB3AHdAd4B3wHgAeEB4gHjAeQB5QHmAecB6AHpAeoB6wHsAe0B7gHvAfAB8QHyAfMB9AH1AfYB9wH4AfkB+gH7AfwB/QH+Af8CAAIBAgICAwIEAgUCBgIHAggCCQIKAgsCDAINAg4CDwIQAhECEgZnbHlwaDEGZ2x5cGgyB3VuaTAwQTAHdW5pMjAwMAd1bmkyMDAxB3VuaTIwMDIHdW5pMjAwMwd1bmkyMDA0B3VuaTIwMDUHdW5pMjAwNgd1bmkyMDA3B3VuaTIwMDgHdW5pMjAwOQd1bmkyMDBBB3VuaTIwMkYHdW5pMjA1RgRFdXJvB3VuaTIwQkQHdW5pMjMxQgd1bmkyNUZDB3VuaTI2MDEHdW5pMjZGQQd1bmkyNzA5B3VuaTI3MEYHdW5pRTAwMQd1bmlFMDAyB3VuaUUwMDMHdW5pRTAwNQd1bmlFMDA2B3VuaUUwMDcHdW5pRTAwOAd1bmlFMDA5B3VuaUUwMTAHdW5pRTAxMQd1bmlFMDEyB3VuaUUwMTMHdW5pRTAxNAd1bmlFMDE1B3VuaUUwMTYHdW5pRTAxNwd1bmlFMDE4B3VuaUUwMTkHdW5pRTAyMAd1bmlFMDIxB3VuaUUwMjIHdW5pRTAyMwd1bmlFMDI0B3VuaUUwMjUHdW5pRTAyNgd1bmlFMDI3B3VuaUUwMjgHdW5pRTAyOQd1bmlFMDMwB3VuaUUwMzEHdW5pRTAzMgd1bmlFMDMzB3VuaUUwMzQHdW5pRTAzNQd1bmlFMDM2B3VuaUUwMzcHdW5pRTAzOAd1bmlFMDM5B3VuaUUwNDAHdW5pRTA0MQd1bmlFMDQyB3VuaUUwNDMHdW5pRTA0NAd1bmlFMDQ1B3VuaUUwNDYHdW5pRTA0Nwd1bmlFMDQ4B3VuaUUwNDkHdW5pRTA1MAd1bmlFMDUxB3VuaUUwNTIHdW5pRTA1Mwd1bmlFMDU0B3VuaUUwNTUHdW5pRTA1Ngd1bmlFMDU3B3VuaUUwNTgHdW5pRTA1OQd1bmlFMDYwB3VuaUUwNjIHdW5pRTA2Mwd1bmlFMDY0B3VuaUUwNjUHdW5pRTA2Ngd1bmlFMDY3B3VuaUUwNjgHdW5pRTA2OQd1bmlFMDcwB3VuaUUwNzEHdW5pRTA3Mgd1bmlFMDczB3VuaUUwNzQHdW5pRTA3NQd1bmlFMDc2B3VuaUUwNzcHdW5pRTA3OAd1bmlFMDc5B3VuaUUwODAHdW5pRTA4MQd1bmlFMDgyB3VuaUUwODMHdW5pRTA4NAd1bmlFMDg1B3VuaUUwODYHdW5pRTA4Nwd1bmlFMDg4B3VuaUUwODkHdW5pRTA5MAd1bmlFMDkxB3VuaUUwOTIHdW5pRTA5Mwd1bmlFMDk0B3VuaUUwOTUHdW5pRTA5Ngd1bmlFMDk3B3VuaUUxMDEHdW5pRTEwMgd1bmlFMTAzB3VuaUUxMDQHdW5pRTEwNQd1bmlFMTA2B3VuaUUxMDcHdW5pRTEwOAd1bmlFMTA5B3VuaUUxMTAHdW5pRTExMQd1bmlFMTEyB3VuaUUxMTMHdW5pRTExNAd1bmlFMTE1B3VuaUUxMTYHdW5pRTExNwd1bmlFMTE4B3VuaUUxMTkHdW5pRTEyMAd1bmlFMTIxB3VuaUUxMjIHdW5pRTEyMwd1bmlFMTI0B3VuaUUxMjUHdW5pRTEyNgd1bmlFMTI3B3VuaUUxMjgHdW5pRTEyOQd1bmlFMTMwB3VuaUUxMzEHdW5pRTEzMgd1bmlFMTMzB3VuaUUxMzQHdW5pRTEzNQd1bmlFMTM2B3VuaUUxMzcHdW5pRTEzOAd1bmlFMTM5B3VuaUUxNDAHdW5pRTE0MQd1bmlFMTQyB3VuaUUxNDMHdW5pRTE0NAd1bmlFMTQ1B3VuaUUxNDYHdW5pRTE0OAd1bmlFMTQ5B3VuaUUxNTAHdW5pRTE1MQd1bmlFMTUyB3VuaUUxNTMHdW5pRTE1NAd1bmlFMTU1B3VuaUUxNTYHdW5pRTE1Nwd1bmlFMTU4B3VuaUUxNTkHdW5pRTE2MAd1bmlFMTYxB3VuaUUxNjIHdW5pRTE2Mwd1bmlFMTY0B3VuaUUxNjUHdW5pRTE2Ngd1bmlFMTY3B3VuaUUxNjgHdW5pRTE2OQd1bmlFMTcwB3VuaUUxNzEHdW5pRTE3Mgd1bmlFMTczB3VuaUUxNzQHdW5pRTE3NQd1bmlFMTc2B3VuaUUxNzcHdW5pRTE3OAd1bmlFMTc5B3VuaUUxODAHdW5pRTE4MQd1bmlFMTgyB3VuaUUxODMHdW5pRTE4NAd1bmlFMTg1B3VuaUUxODYHdW5pRTE4Nwd1bmlFMTg4B3VuaUUxODkHdW5pRTE5MAd1bmlFMTkxB3VuaUUxOTIHdW5pRTE5Mwd1bmlFMTk0B3VuaUUxOTUHdW5pRTE5Nwd1bmlFMTk4B3VuaUUxOTkHdW5pRTIwMAd1bmlFMjAxB3VuaUUyMDIHdW5pRTIwMwd1bmlFMjA0B3VuaUUyMDUHdW5pRTIwNgd1bmlFMjA5B3VuaUUyMTAHdW5pRTIxMQd1bmlFMjEyB3VuaUUyMTMHdW5pRTIxNAd1bmlFMjE1B3VuaUUyMTYHdW5pRTIxOAd1bmlFMjE5B3VuaUUyMjEHdW5pRTIyMwd1bmlFMjI0B3VuaUUyMjUHdW5pRTIyNgd1bmlFMjI3B3VuaUUyMzAHdW5pRTIzMQd1bmlFMjMyB3VuaUUyMzMHdW5pRTIzNAd1bmlFMjM1B3VuaUUyMzYHdW5pRTIzNwd1bmlFMjM4B3VuaUUyMzkHdW5pRTI0MAd1bmlFMjQxB3VuaUUyNDIHdW5pRTI0Mwd1bmlFMjQ0B3VuaUUyNDUHdW5pRTI0Ngd1bmlFMjQ3B3VuaUUyNDgHdW5pRTI0OQd1bmlFMjUwB3VuaUUyNTEHdW5pRTI1Mgd1bmlFMjUzB3VuaUUyNTQHdW5pRTI1NQd1bmlFMjU2B3VuaUUyNTcHdW5pRTI1OAd1bmlFMjU5B3VuaUUyNjAHdW5pRjhGRgZ1MUY1MTEGdTFGNkFBAAAAAAFUUMMXAAA=) format('truetype'),url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiID4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8bWV0YWRhdGE+PC9tZXRhZGF0YT4KPGRlZnM+Cjxmb250IGlkPSJnbHlwaGljb25zX2hhbGZsaW5nc3JlZ3VsYXIiIGhvcml6LWFkdi14PSIxMjAwIiA+Cjxmb250LWZhY2UgdW5pdHMtcGVyLWVtPSIxMjAwIiBhc2NlbnQ9Ijk2MCIgZGVzY2VudD0iLTI0MCIgLz4KPG1pc3NpbmctZ2x5cGggaG9yaXotYWR2LXg9IjUwMCIgLz4KPGdseXBoIGhvcml6LWFkdi14PSIwIiAvPgo8Z2x5cGggaG9yaXotYWR2LXg9IjQwMCIgLz4KPGdseXBoIHVuaWNvZGU9IiAiIC8+CjxnbHlwaCB1bmljb2RlPSIqIiBkPSJNNjAwIDExMDBxMTUgMCAzNCAtMS41dDMwIC0zLjVsMTEgLTFxMTAgLTIgMTcuNSAtMTAuNXQ3LjUgLTE4LjV2LTIyNGwxNTggMTU4cTcgNyAxOCA4dDE5IC02bDEwNiAtMTA2cTcgLTggNiAtMTl0LTggLTE4bC0xNTggLTE1OGgyMjRxMTAgMCAxOC41IC03LjV0MTAuNSAtMTcuNXE2IC00MSA2IC03NXEwIC0xNSAtMS41IC0zNHQtMy41IC0zMGwtMSAtMTFxLTIgLTEwIC0xMC41IC0xNy41dC0xOC41IC03LjVoLTIyNGwxNTggLTE1OCBxNyAtNyA4IC0xOHQtNiAtMTlsLTEwNiAtMTA2cS04IC03IC0xOSAtNnQtMTggOGwtMTU4IDE1OHYtMjI0cTAgLTEwIC03LjUgLTE4LjV0LTE3LjUgLTEwLjVxLTQxIC02IC03NSAtNnEtMTUgMCAtMzQgMS41dC0zMCAzLjVsLTExIDFxLTEwIDIgLTE3LjUgMTAuNXQtNy41IDE4LjV2MjI0bC0xNTggLTE1OHEtNyAtNyAtMTggLTh0LTE5IDZsLTEwNiAxMDZxLTcgOCAtNiAxOXQ4IDE4bDE1OCAxNThoLTIyNHEtMTAgMCAtMTguNSA3LjUgdC0xMC41IDE3LjVxLTYgNDEgLTYgNzVxMCAxNSAxLjUgMzR0My41IDMwbDEgMTFxMiAxMCAxMC41IDE3LjV0MTguNSA3LjVoMjI0bC0xNTggMTU4cS03IDcgLTggMTh0NiAxOWwxMDYgMTA2cTggNyAxOSA2dDE4IC04bDE1OCAtMTU4djIyNHEwIDEwIDcuNSAxOC41dDE3LjUgMTAuNXE0MSA2IDc1IDZ6IiAvPgo8Z2x5cGggdW5pY29kZT0iKyIgZD0iTTQ1MCAxMTAwaDIwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtMzUwaDM1MHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtMjAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC0zNTB2LTM1MHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtMjAwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXYzNTBoLTM1MHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2MjAwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNSBoMzUwdjM1MHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4YTA7IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4YTU7IiBkPSJNODI1IDExMDBoMjUwcTEwIDAgMTIuNSAtNXQtNS41IC0xM2wtMzY0IC0zNjRxLTYgLTYgLTExIC0xOGgyNjhxMTAgMCAxMyAtNnQtMyAtMTRsLTEyMCAtMTYwcS02IC04IC0xOCAtMTR0LTIyIC02aC0xMjV2LTEwMGgyNzVxMTAgMCAxMyAtNnQtMyAtMTRsLTEyMCAtMTYwcS02IC04IC0xOCAtMTR0LTIyIC02aC0xMjV2LTE3NHEwIC0xMSAtNy41IC0xOC41dC0xOC41IC03LjVoLTE0OHEtMTEgMCAtMTguNSA3LjV0LTcuNSAxOC41djE3NCBoLTI3NXEtMTAgMCAtMTMgNnQzIDE0bDEyMCAxNjBxNiA4IDE4IDE0dDIyIDZoMTI1djEwMGgtMjc1cS0xMCAwIC0xMyA2dDMgMTRsMTIwIDE2MHE2IDggMTggMTR0MjIgNmgxMThxLTUgMTIgLTExIDE4bC0zNjQgMzY0cS04IDggLTUuNSAxM3QxMi41IDVoMjUwcTI1IDAgNDMgLTE4bDE2NCAtMTY0cTggLTggMTggLTh0MTggOGwxNjQgMTY0cTE4IDE4IDQzIDE4eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeDIwMDA7IiBob3Jpei1hZHYteD0iNjUwIiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4MjAwMTsiIGhvcml6LWFkdi14PSIxMzAwIiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4MjAwMjsiIGhvcml6LWFkdi14PSI2NTAiIC8+CjxnbHlwaCB1bmljb2RlPSImI3gyMDAzOyIgaG9yaXotYWR2LXg9IjEzMDAiIC8+CjxnbHlwaCB1bmljb2RlPSImI3gyMDA0OyIgaG9yaXotYWR2LXg9IjQzMyIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeDIwMDU7IiBob3Jpei1hZHYteD0iMzI1IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4MjAwNjsiIGhvcml6LWFkdi14PSIyMTYiIC8+CjxnbHlwaCB1bmljb2RlPSImI3gyMDA3OyIgaG9yaXotYWR2LXg9IjIxNiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeDIwMDg7IiBob3Jpei1hZHYteD0iMTYyIiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4MjAwOTsiIGhvcml6LWFkdi14PSIyNjAiIC8+CjxnbHlwaCB1bmljb2RlPSImI3gyMDBhOyIgaG9yaXotYWR2LXg9IjcyIiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4MjAyZjsiIGhvcml6LWFkdi14PSIyNjAiIC8+CjxnbHlwaCB1bmljb2RlPSImI3gyMDVmOyIgaG9yaXotYWR2LXg9IjMyNSIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeDIwYWM7IiBkPSJNNzQ0IDExOThxMjQyIDAgMzU0IC0xODlxNjAgLTEwNCA2NiAtMjA5aC0xODFxMCA0NSAtMTcuNSA4Mi41dC00My41IDYxLjV0LTU4IDQwLjV0LTYwLjUgMjR0LTUxLjUgNy41cS0xOSAwIC00MC41IC01LjV0LTQ5LjUgLTIwLjV0LTUzIC0zOHQtNDkgLTYyLjV0LTM5IC04OS41aDM3OWwtMTAwIC0xMDBoLTMwMHEtNiAtNTAgLTYgLTEwMGg0MDZsLTEwMCAtMTAwaC0zMDBxOSAtNzQgMzMgLTEzMnQ1Mi41IC05MXQ2MS41IC01NC41dDU5IC0yOSB0NDcgLTcuNXEyMiAwIDUwLjUgNy41dDYwLjUgMjQuNXQ1OCA0MXQ0My41IDYxdDE3LjUgODBoMTc0cS0zMCAtMTcxIC0xMjggLTI3OHEtMTA3IC0xMTcgLTI3NCAtMTE3cS0yMDYgMCAtMzI0IDE1OHEtMzYgNDggLTY5IDEzM3QtNDUgMjA0aC0yMTdsMTAwIDEwMGgxMTJxMSA0NyA2IDEwMGgtMjE4bDEwMCAxMDBoMTM0cTIwIDg3IDUxIDE1My41dDYyIDEwMy41cTExNyAxNDEgMjk3IDE0MXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3gyMGJkOyIgZD0iTTQyOCAxMjAwaDM1MHE2NyAwIDEyMCAtMTN0ODYgLTMxdDU3IC00OS41dDM1IC01Ni41dDE3IC02NC41dDYuNSAtNjAuNXQwLjUgLTU3di0xNi41di0xNi41cTAgLTM2IC0wLjUgLTU3dC02LjUgLTYxdC0xNyAtNjV0LTM1IC01N3QtNTcgLTUwLjV0LTg2IC0zMS41dC0xMjAgLTEzaC0xNzhsLTIgLTEwMGgyODhxMTAgMCAxMyAtNnQtMyAtMTRsLTEyMCAtMTYwcS02IC04IC0xOCAtMTR0LTIyIC02aC0xMzh2LTE3NXEwIC0xMSAtNS41IC0xOCB0LTE1LjUgLTdoLTE0OXEtMTAgMCAtMTcuNSA3LjV0LTcuNSAxNy41djE3NWgtMjY3cS0xMCAwIC0xMyA2dDMgMTRsMTIwIDE2MHE2IDggMTggMTR0MjIgNmgxMTd2MTAwaC0yNjdxLTEwIDAgLTEzIDZ0MyAxNGwxMjAgMTYwcTYgOCAxOCAxNHQyMiA2aDExN3Y0NzVxMCAxMCA3LjUgMTcuNXQxNy41IDcuNXpNNjAwIDEwMDB2LTMwMGgyMDNxNjQgMCA4Ni41IDMzdDIyLjUgMTE5cTAgODQgLTIyLjUgMTE2dC04Ni41IDMyaC0yMDN6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4MjIxMjsiIGQ9Ik0yNTAgNzAwaDgwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtMjAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC04MDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djIwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4MjMxYjsiIGQ9Ik0xMDAwIDEyMDB2LTE1MHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtNTB2LTEwMHEwIC05MSAtNDkuNSAtMTY1LjV0LTEzMC41IC0xMDkuNXE4MSAtMzUgMTMwLjUgLTEwOS41dDQ5LjUgLTE2NS41di0xNTBoNTBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTE1MGgtODAwdjE1MHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjVoNTB2MTUwcTAgOTEgNDkuNSAxNjUuNXQxMzAuNSAxMDkuNXEtODEgMzUgLTEzMC41IDEwOS41IHQtNDkuNSAxNjUuNXYxMDBoLTUwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXYxNTBoODAwek00MDAgMTAwMHYtMTAwcTAgLTYwIDMyLjUgLTEwOS41dDg3LjUgLTczLjVxMjggLTEyIDQ0IC0zN3QxNiAtNTV0LTE2IC01NXQtNDQgLTM3cS01NSAtMjQgLTg3LjUgLTczLjV0LTMyLjUgLTEwOS41di0xNTBoNDAwdjE1MHEwIDYwIC0zMi41IDEwOS41dC04Ny41IDczLjVxLTI4IDEyIC00NCAzN3QtMTYgNTV0MTYgNTV0NDQgMzcgcTU1IDI0IDg3LjUgNzMuNXQzMi41IDEwOS41djEwMGgtNDAweiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeDI1ZmM7IiBob3Jpei1hZHYteD0iNTAwIiBkPSJNMCAweiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeDI2MDE7IiBkPSJNNTAzIDEwODlxMTEwIDAgMjAwLjUgLTU5LjV0MTM0LjUgLTE1Ni41cTQ0IDE0IDkwIDE0cTEyMCAwIDIwNSAtODYuNXQ4NSAtMjA2LjVxMCAtMTIxIC04NSAtMjA3LjV0LTIwNSAtODYuNWgtNzUwcS03OSAwIC0xMzUuNSA1N3QtNTYuNSAxMzdxMCA2OSA0Mi41IDEyMi41dDEwOC41IDY3LjVxLTIgMTIgLTIgMzdxMCAxNTMgMTA4IDI2MC41dDI2MCAxMDcuNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3gyNmZhOyIgZD0iTTc3NCAxMTkzLjVxMTYgLTkuNSAyMC41IC0yN3QtNS41IC0zMy41bC0xMzYgLTE4N2w0NjcgLTc0NmgzMHEyMCAwIDM1IC0xOC41dDE1IC0zOS41di00MmgtMTIwMHY0MnEwIDIxIDE1IDM5LjV0MzUgMTguNWgzMGw0NjggNzQ2bC0xMzUgMTgzcS0xMCAxNiAtNS41IDM0dDIwLjUgMjh0MzQgNS41dDI4IC0yMC41bDExMSAtMTQ4bDExMiAxNTBxOSAxNiAyNyAyMC41dDM0IC01ek02MDAgMjAwaDM3N2wtMTgyIDExMmwtMTk1IDUzNHYtNjQ2eiAiIC8+CjxnbHlwaCB1bmljb2RlPSImI3gyNzA5OyIgZD0iTTI1IDExMDBoMTE1MHExMCAwIDEyLjUgLTV0LTUuNSAtMTNsLTU2NCAtNTY3cS04IC04IC0xOCAtOHQtMTggOGwtNTY0IDU2N3EtOCA4IC01LjUgMTN0MTIuNSA1ek0xOCA4ODJsMjY0IC0yNjRxOCAtOCA4IC0xOHQtOCAtMThsLTI2NCAtMjY0cS04IC04IC0xMyAtNS41dC01IDEyLjV2NTUwcTAgMTAgNSAxMi41dDEzIC01LjV6TTkxOCA2MThsMjY0IDI2NHE4IDggMTMgNS41dDUgLTEyLjV2LTU1MHEwIC0xMCAtNSAtMTIuNXQtMTMgNS41IGwtMjY0IDI2NHEtOCA4IC04IDE4dDggMTh6TTgxOCA0ODJsMzY0IC0zNjRxOCAtOCA1LjUgLTEzdC0xMi41IC01aC0xMTUwcS0xMCAwIC0xMi41IDV0NS41IDEzbDM2NCAzNjRxOCA4IDE4IDh0MTggLThsMTY0IC0xNjRxOCAtOCAxOCAtOHQxOCA4bDE2NCAxNjRxOCA4IDE4IDh0MTggLTh6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4MjcwZjsiIGQ9Ik0xMDExIDEyMTBxMTkgMCAzMyAtMTNsMTUzIC0xNTNxMTMgLTE0IDEzIC0zM3QtMTMgLTMzbC05OSAtOTJsLTIxNCAyMTRsOTUgOTZxMTMgMTQgMzIgMTR6TTEwMTMgODAwbC02MTUgLTYxNGwtMjE0IDIxNGw2MTQgNjE0ek0zMTcgOTZsLTMzMyAtMTEybDExMCAzMzV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTAwMTsiIGQ9Ik03MDAgNjUwdi01NTBoMjUwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di01MGgtODAwdjUwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNWgyNTB2NTUwbC01MDAgNTUwaDEyMDB6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTAwMjsiIGQ9Ik0zNjggMTAxN2w2NDUgMTYzcTM5IDE1IDYzIDB0MjQgLTQ5di04MzFxMCAtNTUgLTQxLjUgLTk1LjV0LTExMS41IC02My41cS03OSAtMjUgLTE0NyAtNC41dC04NiA3NXQyNS41IDExMS41dDEyMi41IDgycTcyIDI0IDEzOCA4djUyMWwtNjAwIC0xNTV2LTYwNnEwIC00MiAtNDQgLTkwdC0xMDkgLTY5cS03OSAtMjYgLTE0NyAtNS41dC04NiA3NS41dDI1LjUgMTExLjV0MTIyLjUgODIuNXE3MiAyNCAxMzggN3Y2MzlxMCAzOCAxNC41IDU5IHQ1My41IDM0eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUwMDM7IiBkPSJNNTAwIDExOTFxMTAwIDAgMTkxIC0zOXQxNTYuNSAtMTA0LjV0MTA0LjUgLTE1Ni41dDM5IC0xOTFsLTEgLTJsMSAtNXEwIC0xNDEgLTc4IC0yNjJsMjc1IC0yNzRxMjMgLTI2IDIyLjUgLTQ0LjV0LTIyLjUgLTQyLjVsLTU5IC01OHEtMjYgLTIwIC00Ni41IC0yMHQtMzkuNSAyMGwtMjc1IDI3NHEtMTE5IC03NyAtMjYxIC03N2wtNSAxbC0yIC0xcS0xMDAgMCAtMTkxIDM5dC0xNTYuNSAxMDQuNXQtMTA0LjUgMTU2LjV0LTM5IDE5MSB0MzkgMTkxdDEwNC41IDE1Ni41dDE1Ni41IDEwNC41dDE5MSAzOXpNNTAwIDEwMjJxLTg4IDAgLTE2MiAtNDN0LTExNyAtMTE3dC00MyAtMTYydDQzIC0xNjJ0MTE3IC0xMTd0MTYyIC00M3QxNjIgNDN0MTE3IDExN3Q0MyAxNjJ0LTQzIDE2MnQtMTE3IDExN3QtMTYyIDQzeiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUwMDU7IiBkPSJNNjQ5IDk0OXE0OCA2OCAxMDkuNSAxMDR0MTIxLjUgMzguNXQxMTguNSAtMjB0MTAyLjUgLTY0dDcxIC0xMDAuNXQyNyAtMTIzcTAgLTU3IC0zMy41IC0xMTcuNXQtOTQgLTEyNC41dC0xMjYuNSAtMTI3LjV0LTE1MCAtMTUyLjV0LTE0NiAtMTc0cS02MiA4NSAtMTQ1LjUgMTc0dC0xNTAgMTUyLjV0LTEyNi41IDEyNy41dC05My41IDEyNC41dC0zMy41IDExNy41cTAgNjQgMjggMTIzdDczIDEwMC41dDEwNCA2NHQxMTkgMjAgdDEyMC41IC0zOC41dDEwNC41IC0xMDR6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTAwNjsiIGQ9Ik00MDcgODAwbDEzMSAzNTNxNyAxOSAxNy41IDE5dDE3LjUgLTE5bDEyOSAtMzUzaDQyMXEyMSAwIDI0IC04LjV0LTE0IC0yMC41bC0zNDIgLTI0OWwxMzAgLTQwMXE3IC0yMCAtMC41IC0yNS41dC0yNC41IDYuNWwtMzQzIDI0NmwtMzQyIC0yNDdxLTE3IC0xMiAtMjQuNSAtNi41dC0wLjUgMjUuNWwxMzAgNDAwbC0zNDcgMjUxcS0xNyAxMiAtMTQgMjAuNXQyMyA4LjVoNDI5eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUwMDc7IiBkPSJNNDA3IDgwMGwxMzEgMzUzcTcgMTkgMTcuNSAxOXQxNy41IC0xOWwxMjkgLTM1M2g0MjFxMjEgMCAyNCAtOC41dC0xNCAtMjAuNWwtMzQyIC0yNDlsMTMwIC00MDFxNyAtMjAgLTAuNSAtMjUuNXQtMjQuNSA2LjVsLTM0MyAyNDZsLTM0MiAtMjQ3cS0xNyAtMTIgLTI0LjUgLTYuNXQtMC41IDI1LjVsMTMwIDQwMGwtMzQ3IDI1MXEtMTcgMTIgLTE0IDIwLjV0MjMgOC41aDQyOXpNNDc3IDcwMGgtMjQwbDE5NyAtMTQybC03NCAtMjI2IGwxOTMgMTM5bDE5NSAtMTQwbC03NCAyMjlsMTkyIDE0MGgtMjM0bC03OCAyMTF6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTAwODsiIGQ9Ik02MDAgMTIwMHExMjQgMCAyMTIgLTg4dDg4IC0yMTJ2LTI1MHEwIC00NiAtMzEgLTk4dC02OSAtNTJ2LTc1cTAgLTEwIDYgLTIxLjV0MTUgLTE3LjVsMzU4IC0yMzBxOSAtNSAxNSAtMTYuNXQ2IC0yMS41di05M3EwIC0xMCAtNy41IC0xNy41dC0xNy41IC03LjVoLTExNTBxLTEwIDAgLTE3LjUgNy41dC03LjUgMTcuNXY5M3EwIDEwIDYgMjEuNXQxNSAxNi41bDM1OCAyMzBxOSA2IDE1IDE3LjV0NiAyMS41djc1cS0zOCAwIC02OSA1MiB0LTMxIDk4djI1MHEwIDEyNCA4OCAyMTJ0MjEyIDg4eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUwMDk7IiBkPSJNMjUgMTEwMGgxMTUwcTEwIDAgMTcuNSAtNy41dDcuNSAtMTcuNXYtMTA1MHEwIC0xMCAtNy41IC0xNy41dC0xNy41IC03LjVoLTExNTBxLTEwIDAgLTE3LjUgNy41dC03LjUgMTcuNXYxMDUwcTAgMTAgNy41IDE3LjV0MTcuNSA3LjV6TTEwMCAxMDAwdi0xMDBoMTAwdjEwMGgtMTAwek04NzUgMTAwMGgtNTUwcS0xMCAwIC0xNy41IC03LjV0LTcuNSAtMTcuNXYtMzUwcTAgLTEwIDcuNSAtMTcuNXQxNy41IC03LjVoNTUwIHExMCAwIDE3LjUgNy41dDcuNSAxNy41djM1MHEwIDEwIC03LjUgMTcuNXQtMTcuNSA3LjV6TTEwMDAgMTAwMHYtMTAwaDEwMHYxMDBoLTEwMHpNMTAwIDgwMHYtMTAwaDEwMHYxMDBoLTEwMHpNMTAwMCA4MDB2LTEwMGgxMDB2MTAwaC0xMDB6TTEwMCA2MDB2LTEwMGgxMDB2MTAwaC0xMDB6TTEwMDAgNjAwdi0xMDBoMTAwdjEwMGgtMTAwek04NzUgNTAwaC01NTBxLTEwIDAgLTE3LjUgLTcuNXQtNy41IC0xNy41di0zNTBxMCAtMTAgNy41IC0xNy41IHQxNy41IC03LjVoNTUwcTEwIDAgMTcuNSA3LjV0Ny41IDE3LjV2MzUwcTAgMTAgLTcuNSAxNy41dC0xNy41IDcuNXpNMTAwIDQwMHYtMTAwaDEwMHYxMDBoLTEwMHpNMTAwMCA0MDB2LTEwMGgxMDB2MTAwaC0xMDB6TTEwMCAyMDB2LTEwMGgxMDB2MTAwaC0xMDB6TTEwMDAgMjAwdi0xMDBoMTAwdjEwMGgtMTAweiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUwMTA7IiBkPSJNNTAgMTEwMGg0MDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTQwMHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtNDAwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXY0MDBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41ek02NTAgMTEwMGg0MDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTQwMHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtNDAwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXY0MDAgcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXpNNTAgNTAwaDQwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtNDAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC00MDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djQwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6TTY1MCA1MDBoNDAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di00MDBxMCAtMjEgLTE0LjUgLTM1LjV0LTM1LjUgLTE0LjVoLTQwMCBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djQwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTAxMTsiIGQ9Ik01MCAxMTAwaDIwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtMjAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC0yMDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djIwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6TTQ1MCAxMTAwaDIwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtMjAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC0yMDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djIwMCBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41ek04NTAgMTEwMGgyMDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTIwMHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtMjAwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXYyMDBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41ek01MCA3MDBoMjAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di0yMDBxMCAtMjEgLTE0LjUgLTM1LjV0LTM1LjUgLTE0LjVoLTIwMCBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djIwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6TTQ1MCA3MDBoMjAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di0yMDBxMCAtMjEgLTE0LjUgLTM1LjV0LTM1LjUgLTE0LjVoLTIwMHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2MjAwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXpNODUwIDcwMGgyMDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTIwMCBxMCAtMjEgLTE0LjUgLTM1LjV0LTM1LjUgLTE0LjVoLTIwMHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2MjAwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXpNNTAgMzAwaDIwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtMjAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC0yMDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djIwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6TTQ1MCAzMDBoMjAwIHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtMjAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC0yMDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djIwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6TTg1MCAzMDBoMjAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di0yMDBxMCAtMjEgLTE0LjUgLTM1LjV0LTM1LjUgLTE0LjVoLTIwMHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2MjAwcTAgMjEgMTQuNSAzNS41IHQzNS41IDE0LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTAxMjsiIGQ9Ik01MCAxMTAwaDIwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtMjAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC0yMDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djIwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6TTQ1MCAxMTAwaDcwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtMjAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC03MDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djIwMCBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41ek01MCA3MDBoMjAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di0yMDBxMCAtMjEgLTE0LjUgLTM1LjV0LTM1LjUgLTE0LjVoLTIwMHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2MjAwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXpNNDUwIDcwMGg3MDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTIwMHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtNzAwIHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2MjAwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXpNNTAgMzAwaDIwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtMjAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC0yMDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djIwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6TTQ1MCAzMDBoNzAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di0yMDAgcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC03MDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djIwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTAxMzsiIGQ9Ik00NjUgNDc3bDU3MSA1NzFxOCA4IDE4IDh0MTcgLThsMTc3IC0xNzdxOCAtNyA4IC0xN3QtOCAtMThsLTc4MyAtNzg0cS03IC04IC0xNy41IC04dC0xNy41IDhsLTM4NCAzODRxLTggOCAtOCAxOHQ4IDE3bDE3NyAxNzdxNyA4IDE3IDh0MTggLThsMTcxIC0xNzFxNyAtNyAxOCAtN3QxOCA3eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUwMTQ7IiBkPSJNOTA0IDEwODNsMTc4IC0xNzlxOCAtOCA4IC0xOC41dC04IC0xNy41bC0yNjcgLTI2OGwyNjcgLTI2OHE4IC03IDggLTE3LjV0LTggLTE4LjVsLTE3OCAtMTc4cS04IC04IC0xOC41IC04dC0xNy41IDhsLTI2OCAyNjdsLTI2OCAtMjY3cS03IC04IC0xNy41IC04dC0xOC41IDhsLTE3OCAxNzhxLTggOCAtOCAxOC41dDggMTcuNWwyNjcgMjY4bC0yNjcgMjY4cS04IDcgLTggMTcuNXQ4IDE4LjVsMTc4IDE3OHE4IDggMTguNSA4dDE3LjUgLTggbDI2OCAtMjY3bDI2OCAyNjhxNyA3IDE3LjUgN3QxOC41IC03eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUwMTU7IiBkPSJNNTA3IDExNzdxOTggMCAxODcuNSAtMzguNXQxNTQuNSAtMTAzLjV0MTAzLjUgLTE1NC41dDM4LjUgLTE4Ny41cTAgLTE0MSAtNzggLTI2MmwzMDAgLTI5OXE4IC04IDggLTE4LjV0LTggLTE4LjVsLTEwOSAtMTA4cS03IC04IC0xNy41IC04dC0xOC41IDhsLTMwMCAyOTlxLTExOSAtNzcgLTI2MSAtNzdxLTk4IDAgLTE4OCAzOC41dC0xNTQuNSAxMDN0LTEwMyAxNTQuNXQtMzguNSAxODh0MzguNSAxODcuNXQxMDMgMTU0LjUgdDE1NC41IDEwMy41dDE4OCAzOC41ek01MDYuNSAxMDIzcS04OS41IDAgLTE2NS41IC00NHQtMTIwIC0xMjAuNXQtNDQgLTE2NnQ0NCAtMTY1LjV0MTIwIC0xMjB0MTY1LjUgLTQ0dDE2NiA0NHQxMjAuNSAxMjB0NDQgMTY1LjV0LTQ0IDE2NnQtMTIwLjUgMTIwLjV0LTE2NiA0NHpNNDI1IDkwMGgxNTBxMTAgMCAxNy41IC03LjV0Ny41IC0xNy41di03NWg3NXExMCAwIDE3LjUgLTcuNXQ3LjUgLTE3LjV2LTE1MHEwIC0xMCAtNy41IC0xNy41IHQtMTcuNSAtNy41aC03NXYtNzVxMCAtMTAgLTcuNSAtMTcuNXQtMTcuNSAtNy41aC0xNTBxLTEwIDAgLTE3LjUgNy41dC03LjUgMTcuNXY3NWgtNzVxLTEwIDAgLTE3LjUgNy41dC03LjUgMTcuNXYxNTBxMCAxMCA3LjUgMTcuNXQxNy41IDcuNWg3NXY3NXEwIDEwIDcuNSAxNy41dDE3LjUgNy41eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUwMTY7IiBkPSJNNTA3IDExNzdxOTggMCAxODcuNSAtMzguNXQxNTQuNSAtMTAzLjV0MTAzLjUgLTE1NC41dDM4LjUgLTE4Ny41cTAgLTE0MSAtNzggLTI2MmwzMDAgLTI5OXE4IC04IDggLTE4LjV0LTggLTE4LjVsLTEwOSAtMTA4cS03IC04IC0xNy41IC04dC0xOC41IDhsLTMwMCAyOTlxLTExOSAtNzcgLTI2MSAtNzdxLTk4IDAgLTE4OCAzOC41dC0xNTQuNSAxMDN0LTEwMyAxNTQuNXQtMzguNSAxODh0MzguNSAxODcuNXQxMDMgMTU0LjUgdDE1NC41IDEwMy41dDE4OCAzOC41ek01MDYuNSAxMDIzcS04OS41IDAgLTE2NS41IC00NHQtMTIwIC0xMjAuNXQtNDQgLTE2NnQ0NCAtMTY1LjV0MTIwIC0xMjB0MTY1LjUgLTQ0dDE2NiA0NHQxMjAuNSAxMjB0NDQgMTY1LjV0LTQ0IDE2NnQtMTIwLjUgMTIwLjV0LTE2NiA0NHpNMzI1IDgwMGgzNTBxMTAgMCAxNy41IC03LjV0Ny41IC0xNy41di0xNTBxMCAtMTAgLTcuNSAtMTcuNXQtMTcuNSAtNy41aC0zNTBxLTEwIDAgLTE3LjUgNy41IHQtNy41IDE3LjV2MTUwcTAgMTAgNy41IDE3LjV0MTcuNSA3LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTAxNzsiIGQ9Ik01NTAgMTIwMGgxMDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTQwMHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtMTAwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXY0MDBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41ek04MDAgOTc1djE2NnExNjcgLTYyIDI3MiAtMjA5LjV0MTA1IC0zMzEuNXEwIC0xMTcgLTQ1LjUgLTIyNHQtMTIzIC0xODQuNXQtMTg0LjUgLTEyM3QtMjI0IC00NS41dC0yMjQgNDUuNSB0LTE4NC41IDEyM3QtMTIzIDE4NC41dC00NS41IDIyNHEwIDE4NCAxMDUgMzMxLjV0MjcyIDIwOS41di0xNjZxLTEwMyAtNTUgLTE2NSAtMTU1dC02MiAtMjIwcTAgLTExNiA1NyAtMjE0LjV0MTU1LjUgLTE1NS41dDIxNC41IC01N3QyMTQuNSA1N3QxNTUuNSAxNTUuNXQ1NyAyMTQuNXEwIDEyMCAtNjIgMjIwdC0xNjUgMTU1eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUwMTg7IiBkPSJNMTAyNSAxMjAwaDE1MHExMCAwIDE3LjUgLTcuNXQ3LjUgLTE3LjV2LTExNTBxMCAtMTAgLTcuNSAtMTcuNXQtMTcuNSAtNy41aC0xNTBxLTEwIDAgLTE3LjUgNy41dC03LjUgMTcuNXYxMTUwcTAgMTAgNy41IDE3LjV0MTcuNSA3LjV6TTcyNSA4MDBoMTUwcTEwIDAgMTcuNSAtNy41dDcuNSAtMTcuNXYtNzUwcTAgLTEwIC03LjUgLTE3LjV0LTE3LjUgLTcuNWgtMTUwcS0xMCAwIC0xNy41IDcuNXQtNy41IDE3LjV2NzUwIHEwIDEwIDcuNSAxNy41dDE3LjUgNy41ek00MjUgNTAwaDE1MHExMCAwIDE3LjUgLTcuNXQ3LjUgLTE3LjV2LTQ1MHEwIC0xMCAtNy41IC0xNy41dC0xNy41IC03LjVoLTE1MHEtMTAgMCAtMTcuNSA3LjV0LTcuNSAxNy41djQ1MHEwIDEwIDcuNSAxNy41dDE3LjUgNy41ek0xMjUgMzAwaDE1MHExMCAwIDE3LjUgLTcuNXQ3LjUgLTE3LjV2LTI1MHEwIC0xMCAtNy41IC0xNy41dC0xNy41IC03LjVoLTE1MHEtMTAgMCAtMTcuNSA3LjV0LTcuNSAxNy41IHYyNTBxMCAxMCA3LjUgMTcuNXQxNy41IDcuNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDE5OyIgZD0iTTYwMCAxMTc0cTMzIDAgNzQgLTVsMzggLTE1Mmw1IC0xcTQ5IC0xNCA5NCAtMzlsNSAtMmwxMzQgODBxNjEgLTQ4IDEwNCAtMTA1bC04MCAtMTM0bDMgLTVxMjUgLTQ0IDM5IC05M2wxIC02bDE1MiAtMzhxNSAtNDMgNSAtNzNxMCAtMzQgLTUgLTc0bC0xNTIgLTM4bC0xIC02cS0xNSAtNDkgLTM5IC05M2wtMyAtNWw4MCAtMTM0cS00OCAtNjEgLTEwNCAtMTA1bC0xMzQgODFsLTUgLTNxLTQ0IC0yNSAtOTQgLTM5bC01IC0ybC0zOCAtMTUxIHEtNDMgLTUgLTc0IC01cS0zMyAwIC03NCA1bC0zOCAxNTFsLTUgMnEtNDkgMTQgLTk0IDM5bC01IDNsLTEzNCAtODFxLTYwIDQ4IC0xMDQgMTA1bDgwIDEzNGwtMyA1cS0yNSA0NSAtMzggOTNsLTIgNmwtMTUxIDM4cS02IDQyIC02IDc0cTAgMzMgNiA3M2wxNTEgMzhsMiA2cTEzIDQ4IDM4IDkzbDMgNWwtODAgMTM0cTQ3IDYxIDEwNSAxMDVsMTMzIC04MGw1IDJxNDUgMjUgOTQgMzlsNSAxbDM4IDE1MnE0MyA1IDc0IDV6TTYwMCA4MTUgcS04OSAwIC0xNTIgLTYzdC02MyAtMTUxLjV0NjMgLTE1MS41dDE1MiAtNjN0MTUyIDYzdDYzIDE1MS41dC02MyAxNTEuNXQtMTUyIDYzeiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUwMjA7IiBkPSJNNTAwIDEzMDBoMzAwcTQxIDAgNzAuNSAtMjkuNXQyOS41IC03MC41di0xMDBoMjc1cTEwIDAgMTcuNSAtNy41dDcuNSAtMTcuNXYtNzVoLTExMDB2NzVxMCAxMCA3LjUgMTcuNXQxNy41IDcuNWgyNzV2MTAwcTAgNDEgMjkuNSA3MC41dDcwLjUgMjkuNXpNNTAwIDEyMDB2LTEwMGgzMDB2MTAwaC0zMDB6TTExMDAgOTAwdi04MDBxMCAtNDEgLTI5LjUgLTcwLjV0LTcwLjUgLTI5LjVoLTcwMHEtNDEgMCAtNzAuNSAyOS41dC0yOS41IDcwLjUgdjgwMGg5MDB6TTMwMCA4MDB2LTcwMGgxMDB2NzAwaC0xMDB6TTUwMCA4MDB2LTcwMGgxMDB2NzAwaC0xMDB6TTcwMCA4MDB2LTcwMGgxMDB2NzAwaC0xMDB6TTkwMCA4MDB2LTcwMGgxMDB2NzAwaC0xMDB6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTAyMTsiIGQ9Ik0xOCA2MThsNjIwIDYwOHE4IDcgMTguNSA3dDE3LjUgLTdsNjA4IC02MDhxOCAtOCA1LjUgLTEzdC0xMi41IC01aC0xNzV2LTU3NXEwIC0xMCAtNy41IC0xNy41dC0xNy41IC03LjVoLTI1MHEtMTAgMCAtMTcuNSA3LjV0LTcuNSAxNy41djM3NWgtMzAwdi0zNzVxMCAtMTAgLTcuNSAtMTcuNXQtMTcuNSAtNy41aC0yNTBxLTEwIDAgLTE3LjUgNy41dC03LjUgMTcuNXY1NzVoLTE3NXEtMTAgMCAtMTIuNSA1dDUuNSAxM3oiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDIyOyIgZD0iTTYwMCAxMjAwdi00MDBxMCAtNDEgMjkuNSAtNzAuNXQ3MC41IC0yOS41aDMwMHYtNjUwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC04MDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djExMDBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41aDQ1MHpNMTAwMCA4MDBoLTI1MHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2MjUweiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUwMjM7IiBkPSJNNjAwIDExNzdxMTE3IDAgMjI0IC00NS41dDE4NC41IC0xMjN0MTIzIC0xODQuNXQ0NS41IC0yMjR0LTQ1LjUgLTIyNHQtMTIzIC0xODQuNXQtMTg0LjUgLTEyM3QtMjI0IC00NS41dC0yMjQgNDUuNXQtMTg0LjUgMTIzdC0xMjMgMTg0LjV0LTQ1LjUgMjI0dDQ1LjUgMjI0dDEyMyAxODQuNXQxODQuNSAxMjN0MjI0IDQ1LjV6TTYwMCAxMDI3cS0xMTYgMCAtMjE0LjUgLTU3dC0xNTUuNSAtMTU1LjV0LTU3IC0yMTQuNXQ1NyAtMjE0LjUgdDE1NS41IC0xNTUuNXQyMTQuNSAtNTd0MjE0LjUgNTd0MTU1LjUgMTU1LjV0NTcgMjE0LjV0LTU3IDIxNC41dC0xNTUuNSAxNTUuNXQtMjE0LjUgNTd6TTUyNSA5MDBoNTBxMTAgMCAxNy41IC03LjV0Ny41IC0xNy41di0yNzVoMTc1cTEwIDAgMTcuNSAtNy41dDcuNSAtMTcuNXYtNTBxMCAtMTAgLTcuNSAtMTcuNXQtMTcuNSAtNy41aC0yNTBxLTEwIDAgLTE3LjUgNy41dC03LjUgMTcuNXYzNTBxMCAxMCA3LjUgMTcuNXQxNy41IDcuNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDI0OyIgZD0iTTEzMDAgMGgtNTM4bC00MSA0MDBoLTI0MmwtNDEgLTQwMGgtNTM4bDQzMSAxMjAwaDIwOWwtMjEgLTMwMGgxNjJsLTIwIDMwMGgyMDh6TTUxNSA4MDBsLTI3IC0zMDBoMjI0bC0yNyAzMDBoLTE3MHoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDI1OyIgZD0iTTU1MCAxMjAwaDIwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtNDUwaDE5MXEyMCAwIDI1LjUgLTExLjV0LTcuNSAtMjcuNWwtMzI3IC00MDBxLTEzIC0xNiAtMzIgLTE2dC0zMiAxNmwtMzI3IDQwMHEtMTMgMTYgLTcuNSAyNy41dDI1LjUgMTEuNWgxOTF2NDUwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXpNMTEyNSA0MDBoNTBxMTAgMCAxNy41IC03LjV0Ny41IC0xNy41di0zNTBxMCAtMTAgLTcuNSAtMTcuNXQtMTcuNSAtNy41IGgtMTA1MHEtMTAgMCAtMTcuNSA3LjV0LTcuNSAxNy41djM1MHEwIDEwIDcuNSAxNy41dDE3LjUgNy41aDUwcTEwIDAgMTcuNSAtNy41dDcuNSAtMTcuNXYtMTc1aDkwMHYxNzVxMCAxMCA3LjUgMTcuNXQxNy41IDcuNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDI2OyIgZD0iTTYwMCAxMTc3cTExNyAwIDIyNCAtNDUuNXQxODQuNSAtMTIzdDEyMyAtMTg0LjV0NDUuNSAtMjI0dC00NS41IC0yMjR0LTEyMyAtMTg0LjV0LTE4NC41IC0xMjN0LTIyNCAtNDUuNXQtMjI0IDQ1LjV0LTE4NC41IDEyM3QtMTIzIDE4NC41dC00NS41IDIyNHQ0NS41IDIyNHQxMjMgMTg0LjV0MTg0LjUgMTIzdDIyNCA0NS41ek02MDAgMTAyN3EtMTE2IDAgLTIxNC41IC01N3QtMTU1LjUgLTE1NS41dC01NyAtMjE0LjV0NTcgLTIxNC41IHQxNTUuNSAtMTU1LjV0MjE0LjUgLTU3dDIxNC41IDU3dDE1NS41IDE1NS41dDU3IDIxNC41dC01NyAyMTQuNXQtMTU1LjUgMTU1LjV0LTIxNC41IDU3ek01MjUgOTAwaDE1MHExMCAwIDE3LjUgLTcuNXQ3LjUgLTE3LjV2LTI3NWgxMzdxMjEgMCAyNiAtMTEuNXQtOCAtMjcuNWwtMjIzIC0yNzVxLTEzIC0xNiAtMzIgLTE2dC0zMiAxNmwtMjIzIDI3NXEtMTMgMTYgLTggMjcuNXQyNiAxMS41aDEzN3YyNzVxMCAxMCA3LjUgMTcuNXQxNy41IDcuNXogIiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTAyNzsiIGQ9Ik02MDAgMTE3N3ExMTcgMCAyMjQgLTQ1LjV0MTg0LjUgLTEyM3QxMjMgLTE4NC41dDQ1LjUgLTIyNHQtNDUuNSAtMjI0dC0xMjMgLTE4NC41dC0xODQuNSAtMTIzdC0yMjQgLTQ1LjV0LTIyNCA0NS41dC0xODQuNSAxMjN0LTEyMyAxODQuNXQtNDUuNSAyMjR0NDUuNSAyMjR0MTIzIDE4NC41dDE4NC41IDEyM3QyMjQgNDUuNXpNNjAwIDEwMjdxLTExNiAwIC0yMTQuNSAtNTd0LTE1NS41IC0xNTUuNXQtNTcgLTIxNC41dDU3IC0yMTQuNSB0MTU1LjUgLTE1NS41dDIxNC41IC01N3QyMTQuNSA1N3QxNTUuNSAxNTUuNXQ1NyAyMTQuNXQtNTcgMjE0LjV0LTE1NS41IDE1NS41dC0yMTQuNSA1N3pNNjMyIDkxNGwyMjMgLTI3NXExMyAtMTYgOCAtMjcuNXQtMjYgLTExLjVoLTEzN3YtMjc1cTAgLTEwIC03LjUgLTE3LjV0LTE3LjUgLTcuNWgtMTUwcS0xMCAwIC0xNy41IDcuNXQtNy41IDE3LjV2Mjc1aC0xMzdxLTIxIDAgLTI2IDExLjV0OCAyNy41bDIyMyAyNzVxMTMgMTYgMzIgMTYgdDMyIC0xNnoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDI4OyIgZD0iTTIyNSAxMjAwaDc1MHExMCAwIDE5LjUgLTd0MTIuNSAtMTdsMTg2IC02NTJxNyAtMjQgNyAtNDl2LTQyNXEwIC0xMiAtNCAtMjd0LTkgLTE3cS0xMiAtNiAtMzcgLTZoLTExMDBxLTEyIDAgLTI3IDR0LTE3IDhxLTYgMTMgLTYgMzhsMSA0MjVxMCAyNSA3IDQ5bDE4NSA2NTJxMyAxMCAxMi41IDE3dDE5LjUgN3pNODc4IDEwMDBoLTU1NnEtMTAgMCAtMTkgLTd0LTExIC0xOGwtODcgLTQ1MHEtMiAtMTEgNCAtMTh0MTYgLTdoMTUwIHExMCAwIDE5LjUgLTd0MTEuNSAtMTdsMzggLTE1MnEyIC0xMCAxMS41IC0xN3QxOS41IC03aDI1MHExMCAwIDE5LjUgN3QxMS41IDE3bDM4IDE1MnEyIDEwIDExLjUgMTd0MTkuNSA3aDE1MHExMCAwIDE2IDd0NCAxOGwtODcgNDUwcS0yIDExIC0xMSAxOHQtMTkgN3oiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDI5OyIgZD0iTTYwMCAxMTc3cTExNyAwIDIyNCAtNDUuNXQxODQuNSAtMTIzdDEyMyAtMTg0LjV0NDUuNSAtMjI0dC00NS41IC0yMjR0LTEyMyAtMTg0LjV0LTE4NC41IC0xMjN0LTIyNCAtNDUuNXQtMjI0IDQ1LjV0LTE4NC41IDEyM3QtMTIzIDE4NC41dC00NS41IDIyNHQ0NS41IDIyNHQxMjMgMTg0LjV0MTg0LjUgMTIzdDIyNCA0NS41ek02MDAgMTAyN3EtMTE2IDAgLTIxNC41IC01N3QtMTU1LjUgLTE1NS41dC01NyAtMjE0LjV0NTcgLTIxNC41IHQxNTUuNSAtMTU1LjV0MjE0LjUgLTU3dDIxNC41IDU3dDE1NS41IDE1NS41dDU3IDIxNC41dC01NyAyMTQuNXQtMTU1LjUgMTU1LjV0LTIxNC41IDU3ek01NDAgODIwbDI1MyAtMTkwcTE3IC0xMiAxNyAtMzB0LTE3IC0zMGwtMjUzIC0xOTBxLTE2IC0xMiAtMjggLTYuNXQtMTIgMjYuNXY0MDBxMCAyMSAxMiAyNi41dDI4IC02LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTAzMDsiIGQ9Ik05NDcgMTA2MGwxMzUgMTM1cTcgNyAxMi41IDV0NS41IC0xM3YtMzYycTAgLTEwIC03LjUgLTE3LjV0LTE3LjUgLTcuNWgtMzYycS0xMSAwIC0xMyA1LjV0NSAxMi41bDEzMyAxMzNxLTEwOSA3NiAtMjM4IDc2cS0xMTYgMCAtMjE0LjUgLTU3dC0xNTUuNSAtMTU1LjV0LTU3IC0yMTQuNXQ1NyAtMjE0LjV0MTU1LjUgLTE1NS41dDIxNC41IC01N3QyMTQuNSA1N3QxNTUuNSAxNTUuNXQ1NyAyMTQuNWgxNTBxMCAtMTE3IC00NS41IC0yMjQgdC0xMjMgLTE4NC41dC0xODQuNSAtMTIzdC0yMjQgLTQ1LjV0LTIyNCA0NS41dC0xODQuNSAxMjN0LTEyMyAxODQuNXQtNDUuNSAyMjR0NDUuNSAyMjR0MTIzIDE4NC41dDE4NC41IDEyM3QyMjQgNDUuNXExOTIgMCAzNDcgLTExN3oiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDMxOyIgZD0iTTk0NyAxMDYwbDEzNSAxMzVxNyA3IDEyLjUgNXQ1LjUgLTEzdi0zNjFxMCAtMTEgLTcuNSAtMTguNXQtMTguNSAtNy41aC0zNjFxLTExIDAgLTEzIDUuNXQ1IDEyLjVsMTM0IDEzNHEtMTEwIDc1IC0yMzkgNzVxLTExNiAwIC0yMTQuNSAtNTd0LTE1NS41IC0xNTUuNXQtNTcgLTIxNC41aC0xNTBxMCAxMTcgNDUuNSAyMjR0MTIzIDE4NC41dDE4NC41IDEyM3QyMjQgNDUuNXExOTIgMCAzNDcgLTExN3pNMTAyNyA2MDBoMTUwIHEwIC0xMTcgLTQ1LjUgLTIyNHQtMTIzIC0xODQuNXQtMTg0LjUgLTEyM3QtMjI0IC00NS41cS0xOTIgMCAtMzQ4IDExOGwtMTM0IC0xMzRxLTcgLTggLTEyLjUgLTUuNXQtNS41IDEyLjV2MzYwcTAgMTEgNy41IDE4LjV0MTguNSA3LjVoMzYwcTEwIDAgMTIuNSAtNS41dC01LjUgLTEyLjVsLTEzMyAtMTMzcTExMCAtNzYgMjQwIC03NnExMTYgMCAyMTQuNSA1N3QxNTUuNSAxNTUuNXQ1NyAyMTQuNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDMyOyIgZD0iTTEyNSAxMjAwaDEwNTBxMTAgMCAxNy41IC03LjV0Ny41IC0xNy41di0xMTUwcTAgLTEwIC03LjUgLTE3LjV0LTE3LjUgLTcuNWgtMTA1MHEtMTAgMCAtMTcuNSA3LjV0LTcuNSAxNy41djExNTBxMCAxMCA3LjUgMTcuNXQxNy41IDcuNXpNMTA3NSAxMDAwaC04NTBxLTEwIDAgLTE3LjUgLTcuNXQtNy41IC0xNy41di04NTBxMCAtMTAgNy41IC0xNy41dDE3LjUgLTcuNWg4NTBxMTAgMCAxNy41IDcuNXQ3LjUgMTcuNXY4NTAgcTAgMTAgLTcuNSAxNy41dC0xNy41IDcuNXpNMzI1IDkwMGg1MHExMCAwIDE3LjUgLTcuNXQ3LjUgLTE3LjV2LTUwcTAgLTEwIC03LjUgLTE3LjV0LTE3LjUgLTcuNWgtNTBxLTEwIDAgLTE3LjUgNy41dC03LjUgMTcuNXY1MHEwIDEwIDcuNSAxNy41dDE3LjUgNy41ek01MjUgOTAwaDQ1MHExMCAwIDE3LjUgLTcuNXQ3LjUgLTE3LjV2LTUwcTAgLTEwIC03LjUgLTE3LjV0LTE3LjUgLTcuNWgtNDUwcS0xMCAwIC0xNy41IDcuNXQtNy41IDE3LjV2NTAgcTAgMTAgNy41IDE3LjV0MTcuNSA3LjV6TTMyNSA3MDBoNTBxMTAgMCAxNy41IC03LjV0Ny41IC0xNy41di01MHEwIC0xMCAtNy41IC0xNy41dC0xNy41IC03LjVoLTUwcS0xMCAwIC0xNy41IDcuNXQtNy41IDE3LjV2NTBxMCAxMCA3LjUgMTcuNXQxNy41IDcuNXpNNTI1IDcwMGg0NTBxMTAgMCAxNy41IC03LjV0Ny41IC0xNy41di01MHEwIC0xMCAtNy41IC0xNy41dC0xNy41IC03LjVoLTQ1MHEtMTAgMCAtMTcuNSA3LjV0LTcuNSAxNy41djUwIHEwIDEwIDcuNSAxNy41dDE3LjUgNy41ek0zMjUgNTAwaDUwcTEwIDAgMTcuNSAtNy41dDcuNSAtMTcuNXYtNTBxMCAtMTAgLTcuNSAtMTcuNXQtMTcuNSAtNy41aC01MHEtMTAgMCAtMTcuNSA3LjV0LTcuNSAxNy41djUwcTAgMTAgNy41IDE3LjV0MTcuNSA3LjV6TTUyNSA1MDBoNDUwcTEwIDAgMTcuNSAtNy41dDcuNSAtMTcuNXYtNTBxMCAtMTAgLTcuNSAtMTcuNXQtMTcuNSAtNy41aC00NTBxLTEwIDAgLTE3LjUgNy41dC03LjUgMTcuNXY1MCBxMCAxMCA3LjUgMTcuNXQxNy41IDcuNXpNMzI1IDMwMGg1MHExMCAwIDE3LjUgLTcuNXQ3LjUgLTE3LjV2LTUwcTAgLTEwIC03LjUgLTE3LjV0LTE3LjUgLTcuNWgtNTBxLTEwIDAgLTE3LjUgNy41dC03LjUgMTcuNXY1MHEwIDEwIDcuNSAxNy41dDE3LjUgNy41ek01MjUgMzAwaDQ1MHExMCAwIDE3LjUgLTcuNXQ3LjUgLTE3LjV2LTUwcTAgLTEwIC03LjUgLTE3LjV0LTE3LjUgLTcuNWgtNDUwcS0xMCAwIC0xNy41IDcuNXQtNy41IDE3LjV2NTAgcTAgMTAgNy41IDE3LjV0MTcuNSA3LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTAzMzsiIGQ9Ik05MDAgODAwdjIwMHEwIDgzIC01OC41IDE0MS41dC0xNDEuNSA1OC41aC0zMDBxLTgyIDAgLTE0MSAtNTl0LTU5IC0xNDF2LTIwMGgtMTAwcS00MSAwIC03MC41IC0yOS41dC0yOS41IC03MC41di02MDBxMCAtNDEgMjkuNSAtNzAuNXQ3MC41IC0yOS41aDkwMHE0MSAwIDcwLjUgMjkuNXQyOS41IDcwLjV2NjAwcTAgNDEgLTI5LjUgNzAuNXQtNzAuNSAyOS41aC0xMDB6TTQwMCA4MDB2MTUwcTAgMjEgMTUgMzUuNXQzNSAxNC41aDIwMCBxMjAgMCAzNSAtMTQuNXQxNSAtMzUuNXYtMTUwaC0zMDB6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTAzNDsiIGQ9Ik0xMjUgMTEwMGg1MHExMCAwIDE3LjUgLTcuNXQ3LjUgLTE3LjV2LTEwNzVoLTEwMHYxMDc1cTAgMTAgNy41IDE3LjV0MTcuNSA3LjV6TTEwNzUgMTA1MnE0IDAgOSAtMnExNiAtNiAxNiAtMjN2LTQyMXEwIC02IC0zIC0xMnEtMzMgLTU5IC02Ni41IC05OXQtNjUuNSAtNTh0LTU2LjUgLTI0LjV0LTUyLjUgLTYuNXEtMjYgMCAtNTcuNSA2LjV0LTUyLjUgMTMuNXQtNjAgMjFxLTQxIDE1IC02MyAyMi41dC01Ny41IDE1dC02NS41IDcuNSBxLTg1IDAgLTE2MCAtNTdxLTcgLTUgLTE1IC01cS02IDAgLTExIDNxLTE0IDcgLTE0IDIydjQzOHEyMiA1NSA4MiA5OC41dDExOSA0Ni41cTIzIDIgNDMgMC41dDQzIC03dDMyLjUgLTguNXQzOCAtMTN0MzIuNSAtMTFxNDEgLTE0IDYzLjUgLTIxdDU3IC0xNHQ2My41IC03cTEwMyAwIDE4MyA4N3E3IDggMTggOHoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDM1OyIgZD0iTTYwMCAxMTc1cTExNiAwIDIyNyAtNDkuNXQxOTIuNSAtMTMxdDEzMSAtMTkyLjV0NDkuNSAtMjI3di0zMDBxMCAtMTAgLTcuNSAtMTcuNXQtMTcuNSAtNy41aC01MHEtMTAgMCAtMTcuNSA3LjV0LTcuNSAxNy41djMwMHEwIDEyNyAtNzAuNSAyMzEuNXQtMTg0LjUgMTYxLjV0LTI0NSA1N3QtMjQ1IC01N3QtMTg0LjUgLTE2MS41dC03MC41IC0yMzEuNXYtMzAwcTAgLTEwIC03LjUgLTE3LjV0LTE3LjUgLTcuNWgtNTAgcS0xMCAwIC0xNy41IDcuNXQtNy41IDE3LjV2MzAwcTAgMTE2IDQ5LjUgMjI3dDEzMSAxOTIuNXQxOTIuNSAxMzF0MjI3IDQ5LjV6TTIyMCA1MDBoMTYwcTggMCAxNCAtNnQ2IC0xNHYtNDYwcTAgLTggLTYgLTE0dC0xNCAtNmgtMTYwcS04IDAgLTE0IDZ0LTYgMTR2NDYwcTAgOCA2IDE0dDE0IDZ6TTgyMCA1MDBoMTYwcTggMCAxNCAtNnQ2IC0xNHYtNDYwcTAgLTggLTYgLTE0dC0xNCAtNmgtMTYwcS04IDAgLTE0IDZ0LTYgMTR2NDYwIHEwIDggNiAxNHQxNCA2eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUwMzY7IiBkPSJNMzIxIDgxNGwyNTggMTcycTkgNiAxNSAyLjV0NiAtMTMuNXYtNzUwcTAgLTEwIC02IC0xMy41dC0xNSAyLjVsLTI1OCAxNzJxLTIxIDE0IC00NiAxNGgtMjUwcS0xMCAwIC0xNy41IDcuNXQtNy41IDE3LjV2MzUwcTAgMTAgNy41IDE3LjV0MTcuNSA3LjVoMjUwcTI1IDAgNDYgMTR6TTkwMCA2NjhsMTIwIDEyMHE3IDcgMTcgN3QxNyAtN2wzNCAtMzRxNyAtNyA3IC0xN3QtNyAtMTdsLTEyMCAtMTIwbDEyMCAtMTIwcTcgLTcgNyAtMTcgdC03IC0xN2wtMzQgLTM0cS03IC03IC0xNyAtN3QtMTcgN2wtMTIwIDExOWwtMTIwIC0xMTlxLTcgLTcgLTE3IC03dC0xNyA3bC0zNCAzNHEtNyA3IC03IDE3dDcgMTdsMTE5IDEyMGwtMTE5IDEyMHEtNyA3IC03IDE3dDcgMTdsMzQgMzRxNyA4IDE3IDh0MTcgLTh6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTAzNzsiIGQ9Ik0zMjEgODE0bDI1OCAxNzJxOSA2IDE1IDIuNXQ2IC0xMy41di03NTBxMCAtMTAgLTYgLTEzLjV0LTE1IDIuNWwtMjU4IDE3MnEtMjEgMTQgLTQ2IDE0aC0yNTBxLTEwIDAgLTE3LjUgNy41dC03LjUgMTcuNXYzNTBxMCAxMCA3LjUgMTcuNXQxNy41IDcuNWgyNTBxMjUgMCA0NiAxNHpNNzY2IDkwMGg0cTEwIC0xIDE2IC0xMHE5NiAtMTI5IDk2IC0yOTBxMCAtMTU0IC05MCAtMjgxcS02IC05IC0xNyAtMTBsLTMgLTFxLTkgMCAtMTYgNiBsLTI5IDIzcS03IDcgLTguNSAxNi41dDQuNSAxNy41cTcyIDEwMyA3MiAyMjlxMCAxMzIgLTc4IDIzOHEtNiA4IC00LjUgMTh0OS41IDE3bDI5IDIycTcgNSAxNSA1eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUwMzg7IiBkPSJNOTY3IDEwMDRoM3ExMSAtMSAxNyAtMTBxMTM1IC0xNzkgMTM1IC0zOTZxMCAtMTA1IC0zNCAtMjA2LjV0LTk4IC0xODUuNXEtNyAtOSAtMTcgLTEwaC0zcS05IDAgLTE2IDZsLTQyIDM0cS04IDYgLTkgMTZ0NSAxOHExMTEgMTUwIDExMSAzMjhxMCA5MCAtMjkuNSAxNzZ0LTg0LjUgMTU3cS02IDkgLTUgMTl0MTAgMTZsNDIgMzNxNyA1IDE1IDV6TTMyMSA4MTRsMjU4IDE3MnE5IDYgMTUgMi41dDYgLTEzLjV2LTc1MHEwIC0xMCAtNiAtMTMuNSB0LTE1IDIuNWwtMjU4IDE3MnEtMjEgMTQgLTQ2IDE0aC0yNTBxLTEwIDAgLTE3LjUgNy41dC03LjUgMTcuNXYzNTBxMCAxMCA3LjUgMTcuNXQxNy41IDcuNWgyNTBxMjUgMCA0NiAxNHpNNzY2IDkwMGg0cTEwIC0xIDE2IC0xMHE5NiAtMTI5IDk2IC0yOTBxMCAtMTU0IC05MCAtMjgxcS02IC05IC0xNyAtMTBsLTMgLTFxLTkgMCAtMTYgNmwtMjkgMjNxLTcgNyAtOC41IDE2LjV0NC41IDE3LjVxNzIgMTAzIDcyIDIyOXEwIDEzMiAtNzggMjM4IHEtNiA4IC00LjUgMTguNXQ5LjUgMTYuNWwyOSAyMnE3IDUgMTUgNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDM5OyIgZD0iTTUwMCA5MDBoMTAwdi0xMDBoLTEwMHYtMTAwaC00MDB2LTEwMGgtMTAwdjYwMGg1MDB2LTMwMHpNMTIwMCA3MDBoLTIwMHYtMTAwaDIwMHYtMjAwaC0zMDB2MzAwaC0yMDB2MzAwaC0xMDB2MjAwaDYwMHYtNTAwek0xMDAgMTEwMHYtMzAwaDMwMHYzMDBoLTMwMHpNODAwIDExMDB2LTMwMGgzMDB2MzAwaC0zMDB6TTMwMCA5MDBoLTEwMHYxMDBoMTAwdi0xMDB6TTEwMDAgOTAwaC0xMDB2MTAwaDEwMHYtMTAwek0zMDAgNTAwaDIwMHYtNTAwIGgtNTAwdjUwMGgyMDB2MTAwaDEwMHYtMTAwek04MDAgMzAwaDIwMHYtMTAwaC0xMDB2LTEwMGgtMjAwdjEwMGgtMTAwdjEwMGgxMDB2MjAwaC0yMDB2MTAwaDMwMHYtMzAwek0xMDAgNDAwdi0zMDBoMzAwdjMwMGgtMzAwek0zMDAgMjAwaC0xMDB2MTAwaDEwMHYtMTAwek0xMjAwIDIwMGgtMTAwdjEwMGgxMDB2LTEwMHpNNzAwIDBoLTEwMHYxMDBoMTAwdi0xMDB6TTEyMDAgMGgtMzAwdjEwMGgzMDB2LTEwMHoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDQwOyIgZD0iTTEwMCAyMDBoLTEwMHYxMDAwaDEwMHYtMTAwMHpNMzAwIDIwMGgtMTAwdjEwMDBoMTAwdi0xMDAwek03MDAgMjAwaC0yMDB2MTAwMGgyMDB2LTEwMDB6TTkwMCAyMDBoLTEwMHYxMDAwaDEwMHYtMTAwMHpNMTIwMCAyMDBoLTIwMHYxMDAwaDIwMHYtMTAwMHpNNDAwIDBoLTMwMHYxMDBoMzAwdi0xMDB6TTYwMCAwaC0xMDB2OTFoMTAwdi05MXpNODAwIDBoLTEwMHY5MWgxMDB2LTkxek0xMTAwIDBoLTIwMHY5MWgyMDB2LTkxeiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUwNDE7IiBkPSJNNTAwIDEyMDBsNjgyIC02ODJxOCAtOCA4IC0xOHQtOCAtMThsLTQ2NCAtNDY0cS04IC04IC0xOCAtOHQtMTggOGwtNjgyIDY4MmwxIDQ3NXEwIDEwIDcuNSAxNy41dDE3LjUgNy41aDQ3NHpNMzE5LjUgMTAyNC41cS0yOS41IDI5LjUgLTcxIDI5LjV0LTcxIC0yOS41dC0yOS41IC03MS41dDI5LjUgLTcxLjV0NzEgLTI5LjV0NzEgMjkuNXQyOS41IDcxLjV0LTI5LjUgNzEuNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDQyOyIgZD0iTTUwMCAxMjAwbDY4MiAtNjgycTggLTggOCAtMTh0LTggLTE4bC00NjQgLTQ2NHEtOCAtOCAtMTggLTh0LTE4IDhsLTY4MiA2ODJsMSA0NzVxMCAxMCA3LjUgMTcuNXQxNy41IDcuNWg0NzR6TTgwMCAxMjAwbDY4MiAtNjgycTggLTggOCAtMTh0LTggLTE4bC00NjQgLTQ2NHEtOCAtOCAtMTggLTh0LTE4IDhsLTU2IDU2bDQyNCA0MjZsLTcwMCA3MDBoMTUwek0zMTkuNSAxMDI0LjVxLTI5LjUgMjkuNSAtNzEgMjkuNXQtNzEgLTI5LjUgdC0yOS41IC03MS41dDI5LjUgLTcxLjV0NzEgLTI5LjV0NzEgMjkuNXQyOS41IDcxLjV0LTI5LjUgNzEuNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDQzOyIgZD0iTTMwMCAxMjAwaDgyNXE3NSAwIDc1IC03NXYtOTAwcTAgLTI1IC0xOCAtNDNsLTY0IC02NHEtOCAtOCAtMTMgLTUuNXQtNSAxMi41djk1MHEwIDEwIC03LjUgMTcuNXQtMTcuNSA3LjVoLTcwMHEtMjUgMCAtNDMgLTE4bC02NCAtNjRxLTggLTggLTUuNSAtMTN0MTIuNSAtNWg3MDBxMTAgMCAxNy41IC03LjV0Ny41IC0xNy41di05NTBxMCAtMTAgLTcuNSAtMTcuNXQtMTcuNSAtNy41aC04NTBxLTEwIDAgLTE3LjUgNy41dC03LjUgMTcuNXY5NzUgcTAgMjUgMTggNDNsMTM5IDEzOXExOCAxOCA0MyAxOHoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDQ0OyIgZD0iTTI1MCAxMjAwaDgwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtMTE1MGwtNDUwIDQ0NGwtNDUwIC00NDV2MTE1MXEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTA0NTsiIGQ9Ik04MjIgMTIwMGgtNDQ0cS0xMSAwIC0xOSAtNy41dC05IC0xNy41bC03OCAtMzAxcS03IC0yNCA3IC00NWw1NyAtMTA4cTYgLTkgMTcuNSAtMTV0MjEuNSAtNmg0NTBxMTAgMCAyMS41IDZ0MTcuNSAxNWw2MiAxMDhxMTQgMjEgNyA0NWwtODMgMzAxcS0xIDEwIC05IDE3LjV0LTE5IDcuNXpNMTE3NSA4MDBoLTE1MHEtMTAgMCAtMjEgLTYuNXQtMTUgLTE1LjVsLTc4IC0xNTZxLTQgLTkgLTE1IC0xNS41dC0yMSAtNi41aC01NTAgcS0xMCAwIC0yMSA2LjV0LTE1IDE1LjVsLTc4IDE1NnEtNCA5IC0xNSAxNS41dC0yMSA2LjVoLTE1MHEtMTAgMCAtMTcuNSAtNy41dC03LjUgLTE3LjV2LTY1MHEwIC0xMCA3LjUgLTE3LjV0MTcuNSAtNy41aDE1MHExMCAwIDE3LjUgNy41dDcuNSAxNy41djE1MHEwIDEwIDcuNSAxNy41dDE3LjUgNy41aDc1MHExMCAwIDE3LjUgLTcuNXQ3LjUgLTE3LjV2LTE1MHEwIC0xMCA3LjUgLTE3LjV0MTcuNSAtNy41aDE1MHExMCAwIDE3LjUgNy41IHQ3LjUgMTcuNXY2NTBxMCAxMCAtNy41IDE3LjV0LTE3LjUgNy41ek04NTAgMjAwaC01MDBxLTEwIDAgLTE5LjUgLTd0LTExLjUgLTE3bC0zOCAtMTUycS0yIC0xMCAzLjUgLTE3dDE1LjUgLTdoNjAwcTEwIDAgMTUuNSA3dDMuNSAxN2wtMzggMTUycS0yIDEwIC0xMS41IDE3dC0xOS41IDd6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTA0NjsiIGQ9Ik01MDAgMTEwMGgyMDBxNTYgMCAxMDIuNSAtMjAuNXQ3Mi41IC01MHQ0NCAtNTl0MjUgLTUwLjVsNiAtMjBoMTUwcTQxIDAgNzAuNSAtMjkuNXQyOS41IC03MC41di02MDBxMCAtNDEgLTI5LjUgLTcwLjV0LTcwLjUgLTI5LjVoLTEwMDBxLTQxIDAgLTcwLjUgMjkuNXQtMjkuNSA3MC41djYwMHEwIDQxIDI5LjUgNzAuNXQ3MC41IDI5LjVoMTUwcTIgOCA2LjUgMjEuNXQyNCA0OHQ0NSA2MXQ3MiA0OHQxMDIuNSAyMS41ek05MDAgODAwdi0xMDAgaDEwMHYxMDBoLTEwMHpNNjAwIDczMHEtOTUgMCAtMTYyLjUgLTY3LjV0LTY3LjUgLTE2Mi41dDY3LjUgLTE2Mi41dDE2Mi41IC02Ny41dDE2Mi41IDY3LjV0NjcuNSAxNjIuNXQtNjcuNSAxNjIuNXQtMTYyLjUgNjcuNXpNNjAwIDYwM3E0MyAwIDczIC0zMHQzMCAtNzN0LTMwIC03M3QtNzMgLTMwdC03MyAzMHQtMzAgNzN0MzAgNzN0NzMgMzB6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTA0NzsiIGQ9Ik02ODEgMTE5OWwzODUgLTk5OHEyMCAtNTAgNjAgLTkycTE4IC0xOSAzNi41IC0yOS41dDI3LjUgLTExLjVsMTAgLTJ2LTY2aC00MTd2NjZxNTMgMCA3NSA0My41dDUgODguNWwtODIgMjIyaC0zOTFxLTU4IC0xNDUgLTkyIC0yMzRxLTExIC0zNCAtNi41IC01N3QyNS41IC0zN3Q0NiAtMjB0NTUgLTZ2LTY2aC0zNjV2NjZxNTYgMjQgODQgNTJxMTIgMTIgMjUgMzAuNXQyMCAzMS41bDcgMTNsMzk5IDEwMDZoOTN6TTQxNiA1MjFoMzQwIGwtMTYyIDQ1N3oiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDQ4OyIgZD0iTTc1MyA2NDFxNSAtMSAxNC41IC00LjV0MzYgLTE1LjV0NTAuNSAtMjYuNXQ1My41IC00MHQ1MC41IC01NC41dDM1LjUgLTcwdDE0LjUgLTg3cTAgLTY3IC0yNy41IC0xMjUuNXQtNzEuNSAtOTcuNXQtOTguNSAtNjYuNXQtMTA4LjUgLTQwLjV0LTEwMiAtMTNoLTUwMHY4OXE0MSA3IDcwLjUgMzIuNXQyOS41IDY1LjV2ODI3cTAgMjQgLTAuNSAzNHQtMy41IDI0dC04LjUgMTkuNXQtMTcgMTMuNXQtMjggMTIuNXQtNDIuNSAxMS41djcxIGw0NzEgLTFxNTcgMCAxMTUuNSAtMjAuNXQxMDggLTU3dDgwLjUgLTk0dDMxIC0xMjQuNXEwIC01MSAtMTUuNSAtOTYuNXQtMzggLTc0LjV0LTQ1IC01MC41dC0zOC41IC0zMC41ek00MDAgNzAwaDEzOXE3OCAwIDEzMC41IDQ4LjV0NTIuNSAxMjIuNXEwIDQxIC04LjUgNzAuNXQtMjkuNSA1NS41dC02Mi41IDM5LjV0LTEwMy41IDEzLjVoLTExOHYtMzUwek00MDAgMjAwaDIxNnE4MCAwIDEyMSA1MC41dDQxIDEzMC41cTAgOTAgLTYyLjUgMTU0LjUgdC0xNTYuNSA2NC41aC0xNTl2LTQwMHoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDQ5OyIgZD0iTTg3NyAxMjAwbDIgLTU3cS04MyAtMTkgLTExNiAtNDUuNXQtNDAgLTY2LjVsLTEzMiAtODM5cS05IC00OSAxMyAtNjl0OTYgLTI2di05N2gtNTAwdjk3cTE4NiAxNiAyMDAgOThsMTczIDgzMnEzIDE3IDMgMzB0LTEuNSAyMi41dC05IDE3LjV0LTEzLjUgMTIuNXQtMjEuNSAxMHQtMjYgOC41dC0zMy41IDEwcS0xMyAzIC0xOSA1djU3aDQyNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDUwOyIgZD0iTTEzMDAgOTAwaC01MHEwIDIxIC00IDM3dC05LjUgMjYuNXQtMTggMTcuNXQtMjIgMTF0LTI4LjUgNS41dC0zMSAydC0zNyAwLjVoLTIwMHYtODUwcTAgLTIyIDI1IC0zNC41dDUwIC0xMy41bDI1IC0ydi0xMDBoLTQwMHYxMDBxNCAwIDExIDAuNXQyNCAzdDMwIDd0MjQgMTV0MTEgMjQuNXY4NTBoLTIwMHEtMjUgMCAtMzcgLTAuNXQtMzEgLTJ0LTI4LjUgLTUuNXQtMjIgLTExdC0xOCAtMTcuNXQtOS41IC0yNi41dC00IC0zN2gtNTB2MzAwIGgxMDAwdi0zMDB6TTE3NSAxMDAwaC03NXYtODAwaDc1bC0xMjUgLTE2N2wtMTI1IDE2N2g3NXY4MDBoLTc1bDEyNSAxNjd6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTA1MTsiIGQ9Ik0xMTAwIDkwMGgtNTBxMCAyMSAtNCAzN3QtOS41IDI2LjV0LTE4IDE3LjV0LTIyIDExdC0yOC41IDUuNXQtMzEgMnQtMzcgMC41aC0yMDB2LTY1MHEwIC0yMiAyNSAtMzQuNXQ1MCAtMTMuNWwyNSAtMnYtMTAwaC00MDB2MTAwcTQgMCAxMSAwLjV0MjQgM3QzMCA3dDI0IDE1dDExIDI0LjV2NjUwaC0yMDBxLTI1IDAgLTM3IC0wLjV0LTMxIC0ydC0yOC41IC01LjV0LTIyIC0xMXQtMTggLTE3LjV0LTkuNSAtMjYuNXQtNCAtMzdoLTUwdjMwMCBoMTAwMHYtMzAwek0xMTY3IDUwbC0xNjcgLTEyNXY3NWgtODAwdi03NWwtMTY3IDEyNWwxNjcgMTI1di03NWg4MDB2NzV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTA1MjsiIGQ9Ik01MCAxMTAwaDYwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtMTAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC02MDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djEwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6TTUwIDgwMGgxMDAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di0xMDBxMCAtMjEgLTE0LjUgLTM1LjV0LTM1LjUgLTE0LjVoLTEwMDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djEwMCBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41ek01MCA1MDBoODAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di0xMDBxMCAtMjEgLTE0LjUgLTM1LjV0LTM1LjUgLTE0LjVoLTgwMHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2MTAwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXpNNTAgMjAwaDExMDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTEwMHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtMTEwMCBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djEwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTA1MzsiIGQ9Ik0yNTAgMTEwMGg3MDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTEwMHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtNzAwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXYxMDBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41ek01MCA4MDBoMTEwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtMTAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC0xMTAwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXYxMDAgcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXpNMjUwIDUwMGg3MDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTEwMHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtNzAwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXYxMDBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41ek01MCAyMDBoMTEwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtMTAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC0xMTAwIHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2MTAwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDU0OyIgZD0iTTUwMCA5NTB2MTAwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNWg2MDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTEwMHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtNjAwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXpNMTAwIDY1MHYxMDBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41aDEwMDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTEwMHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtMTAwMCBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41ek0zMDAgMzUwdjEwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjVoODAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di0xMDBxMCAtMjEgLTE0LjUgLTM1LjV0LTM1LjUgLTE0LjVoLTgwMHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV6TTAgNTB2MTAwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNWgxMTAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di0xMDAgcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC0xMTAwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDU1OyIgZD0iTTUwIDExMDBoMTEwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtMTAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC0xMTAwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXYxMDBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41ek01MCA4MDBoMTEwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtMTAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC0xMTAwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXYxMDAgcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXpNNTAgNTAwaDExMDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTEwMHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtMTEwMHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2MTAwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXpNNTAgMjAwaDExMDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTEwMHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtMTEwMCBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djEwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTA1NjsiIGQ9Ik01MCAxMTAwaDEwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtMTAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC0xMDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djEwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6TTM1MCAxMTAwaDgwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtMTAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC04MDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djEwMCBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41ek01MCA4MDBoMTAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di0xMDBxMCAtMjEgLTE0LjUgLTM1LjV0LTM1LjUgLTE0LjVoLTEwMHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2MTAwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXpNMzUwIDgwMGg4MDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTEwMHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtODAwIHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2MTAwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXpNNTAgNTAwaDEwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtMTAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC0xMDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djEwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6TTM1MCA1MDBoODAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di0xMDAgcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC04MDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djEwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6TTUwIDIwMGgxMDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTEwMHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtMTAwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXYxMDBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41ek0zNTAgMjAwaDgwMCBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTEwMHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtODAwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXYxMDBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUwNTc7IiBkPSJNNDAwIDBoLTEwMHYxMTAwaDEwMHYtMTEwMHpNNTUwIDExMDBoMTAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di0xMDBxMCAtMjEgLTE0LjUgLTM1LjV0LTM1LjUgLTE0LjVoLTEwMHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2MTAwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXpNNTUwIDgwMGg1MDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTEwMHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtNTAwIHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2MTAwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXpNMjY3IDU1MGwtMTY3IC0xMjV2NzVoLTIwMHYxMDBoMjAwdjc1ek01NTAgNTAwaDMwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtMTAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC0zMDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djEwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6TTU1MCAyMDBoNjAwIHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtMTAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC02MDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djEwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTA1ODsiIGQ9Ik01MCAxMTAwaDEwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtMTAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC0xMDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djEwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6TTkwMCAwaC0xMDB2MTEwMGgxMDB2LTExMDB6TTUwIDgwMGg1MDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTEwMHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtNTAwIHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2MTAwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXpNMTEwMCA2MDBoMjAwdi0xMDBoLTIwMHYtNzVsLTE2NyAxMjVsMTY3IDEyNXYtNzV6TTUwIDUwMGgzMDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTEwMHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtMzAwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXYxMDBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41ek01MCAyMDBoNjAwIHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtMTAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC02MDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djEwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTA1OTsiIGQ9Ik03NSAxMDAwaDc1MHEzMSAwIDUzIC0yMnQyMiAtNTN2LTY1MHEwIC0zMSAtMjIgLTUzdC01MyAtMjJoLTc1MHEtMzEgMCAtNTMgMjJ0LTIyIDUzdjY1MHEwIDMxIDIyIDUzdDUzIDIyek0xMjAwIDMwMGwtMzAwIDMwMGwzMDAgMzAwdi02MDB6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTA2MDsiIGQ9Ik00NCAxMTAwaDExMTJxMTggMCAzMSAtMTN0MTMgLTMxdi0xMDEycTAgLTE4IC0xMyAtMzF0LTMxIC0xM2gtMTExMnEtMTggMCAtMzEgMTN0LTEzIDMxdjEwMTJxMCAxOCAxMyAzMXQzMSAxM3pNMTAwIDEwMDB2LTczN2wyNDcgMTgybDI5OCAtMTMxbC03NCAxNTZsMjkzIDMxOGwyMzYgLTI4OHY1MDBoLTEwMDB6TTM0MiA4ODRxNTYgMCA5NSAtMzl0MzkgLTk0LjV0LTM5IC05NXQtOTUgLTM5LjV0LTk1IDM5LjV0LTM5IDk1dDM5IDk0LjUgdDk1IDM5eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUwNjI7IiBkPSJNNjQ4IDExNjlxMTE3IDAgMjE2IC02MHQxNTYuNSAtMTYxdDU3LjUgLTIxOHEwIC0xMTUgLTcwIC0yNThxLTY5IC0xMDkgLTE1OCAtMjI1LjV0LTE0MyAtMTc5LjVsLTU0IC02MnEtOSA4IC0yNS41IDI0LjV0LTYzLjUgNjcuNXQtOTEgMTAzdC05OC41IDEyOHQtOTUuNSAxNDhxLTYwIDEzMiAtNjAgMjQ5cTAgODggMzQgMTY5LjV0OTEuNSAxNDJ0MTM3IDk2LjV0MTY2LjUgMzZ6TTY1Mi41IDk3NHEtOTEuNSAwIC0xNTYuNSAtNjUgdC02NSAtMTU3dDY1IC0xNTYuNXQxNTYuNSAtNjQuNXQxNTYuNSA2NC41dDY1IDE1Ni41dC02NSAxNTd0LTE1Ni41IDY1eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUwNjM7IiBkPSJNNjAwIDExNzdxMTE3IDAgMjI0IC00NS41dDE4NC41IC0xMjN0MTIzIC0xODQuNXQ0NS41IC0yMjR0LTQ1LjUgLTIyNHQtMTIzIC0xODQuNXQtMTg0LjUgLTEyM3QtMjI0IC00NS41dC0yMjQgNDUuNXQtMTg0LjUgMTIzdC0xMjMgMTg0LjV0LTQ1LjUgMjI0dDQ1LjUgMjI0dDEyMyAxODQuNXQxODQuNSAxMjN0MjI0IDQ1LjV6TTYwMCAxNzN2ODU0cS0xMTYgMCAtMjE0LjUgLTU3dC0xNTUuNSAtMTU1LjV0LTU3IC0yMTQuNXQ1NyAtMjE0LjUgdDE1NS41IC0xNTUuNXQyMTQuNSAtNTd6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTA2NDsiIGQ9Ik01NTQgMTI5NXEyMSAtNzIgNTcuNSAtMTQzLjV0NzYgLTEzMHQ4MyAtMTE4dDgyLjUgLTExN3Q3MCAtMTE2dDQ5LjUgLTEyNnQxOC41IC0xMzYuNXEwIC03MSAtMjUuNSAtMTM1dC02OC41IC0xMTF0LTk5IC04MnQtMTE4LjUgLTU0dC0xMjUuNSAtMjNxLTg0IDUgLTE2MS41IDM0dC0xMzkuNSA3OC41dC05OSAxMjV0LTM3IDE2NC41cTAgNjkgMTggMTM2LjV0NDkuNSAxMjYuNXQ2OS41IDExNi41dDgxLjUgMTE3LjV0ODMuNSAxMTkgdDc2LjUgMTMxdDU4LjUgMTQzek0zNDQgNzEwcS0yMyAtMzMgLTQzLjUgLTcwLjV0LTQwLjUgLTEwMi41dC0xNyAtMTIzcTEgLTM3IDE0LjUgLTY5LjV0MzAgLTUydDQxIC0zN3QzOC41IC0yNC41dDMzIC0xNXEyMSAtNyAzMiAtMXQxMyAyMmw2IDM0cTIgMTAgLTIuNSAyMnQtMTMuNSAxOXEtNSA0IC0xNCAxMnQtMjkuNSA0MC41dC0zMi41IDczLjVxLTI2IDg5IDYgMjcxcTIgMTEgLTYgMTFxLTggMSAtMTUgLTEweiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUwNjU7IiBkPSJNMTAwMCAxMDEzbDEwOCAxMTVxMiAxIDUgMnQxMyAydDIwLjUgLTF0MjUgLTkuNXQyOC41IC0yMS41cTIyIC0yMiAyNyAtNDN0MCAtMzJsLTYgLTEwbC0xMDggLTExNXpNMzUwIDExMDBoNDAwcTUwIDAgMTA1IC0xM2wtMTg3IC0xODdoLTM2OHEtNDEgMCAtNzAuNSAtMjkuNXQtMjkuNSAtNzAuNXYtNTAwcTAgLTQxIDI5LjUgLTcwLjV0NzAuNSAtMjkuNWg1MDBxNDEgMCA3MC41IDI5LjV0MjkuNSA3MC41djE4MmwyMDAgMjAwdi0zMzIgcTAgLTE2NSAtOTMuNSAtMjU3LjV0LTI1Ni41IC05Mi41aC00MDBxLTE2NSAwIC0yNTcuNSA5Mi41dC05Mi41IDI1Ny41djQwMHEwIDE2NSA5Mi41IDI1Ny41dDI1Ny41IDkyLjV6TTEwMDkgODAzbC0zNjIgLTM2MmwtMTYxIC01MGw1NSAxNzBsMzU1IDM1NXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDY2OyIgZD0iTTM1MCAxMTAwaDM2MXEtMTY0IC0xNDYgLTIxNiAtMjAwaC0xOTVxLTQxIDAgLTcwLjUgLTI5LjV0LTI5LjUgLTcwLjV2LTUwMHEwIC00MSAyOS41IC03MC41dDcwLjUgLTI5LjVoNTAwcTQxIDAgNzAuNSAyOS41dDI5LjUgNzAuNWwyMDAgMTUzdi0xMDNxMCAtMTY1IC05Mi41IC0yNTcuNXQtMjU3LjUgLTkyLjVoLTQwMHEtMTY1IDAgLTI1Ny41IDkyLjV0LTkyLjUgMjU3LjV2NDAwcTAgMTY1IDkyLjUgMjU3LjV0MjU3LjUgOTIuNXogTTgyNCAxMDczbDMzOSAtMzAxcTggLTcgOCAtMTcuNXQtOCAtMTcuNWwtMzQwIC0zMDZxLTcgLTYgLTEyLjUgLTR0LTYuNSAxMXYyMDNxLTI2IDEgLTU0LjUgMHQtNzguNSAtNy41dC05MiAtMTcuNXQtODYgLTM1dC03MCAtNTdxMTAgNTkgMzMgMTA4dDUxLjUgODEuNXQ2NSA1OC41dDY4LjUgNDAuNXQ2NyAyNC41dDU2IDEzLjV0NDAgNC41djIxMHExIDEwIDYuNSAxMi41dDEzLjUgLTQuNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDY3OyIgZD0iTTM1MCAxMTAwaDM1MHE2MCAwIDEyNyAtMjNsLTE3OCAtMTc3aC0zNDlxLTQxIDAgLTcwLjUgLTI5LjV0LTI5LjUgLTcwLjV2LTUwMHEwIC00MSAyOS41IC03MC41dDcwLjUgLTI5LjVoNTAwcTQxIDAgNzAuNSAyOS41dDI5LjUgNzAuNXY2OWwyMDAgMjAwdi0yMTlxMCAtMTY1IC05Mi41IC0yNTcuNXQtMjU3LjUgLTkyLjVoLTQwMHEtMTY1IDAgLTI1Ny41IDkyLjV0LTkyLjUgMjU3LjV2NDAwcTAgMTY1IDkyLjUgMjU3LjV0MjU3LjUgOTIuNXogTTY0MyA2MzlsMzk1IDM5NXE3IDcgMTcuNSA3dDE3LjUgLTdsMTAxIC0xMDFxNyAtNyA3IC0xNy41dC03IC0xNy41bC01MzEgLTUzMnEtNyAtNyAtMTcuNSAtN3QtMTcuNSA3bC0yNDggMjQ4cS03IDcgLTcgMTcuNXQ3IDE3LjVsMTAxIDEwMXE3IDcgMTcuNSA3dDE3LjUgLTdsMTExIC0xMTFxOCAtNyAxOCAtN3QxOCA3eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUwNjg7IiBkPSJNMzE4IDkxOGwyNjQgMjY0cTggOCAxOCA4dDE4IC04bDI2MCAtMjY0cTcgLTggNC41IC0xM3QtMTIuNSAtNWgtMTcwdi0yMDBoMjAwdjE3M3EwIDEwIDUgMTJ0MTMgLTVsMjY0IC0yNjBxOCAtNyA4IC0xNy41dC04IC0xNy41bC0yNjQgLTI2NXEtOCAtNyAtMTMgLTV0LTUgMTJ2MTczaC0yMDB2LTIwMGgxNzBxMTAgMCAxMi41IC01dC00LjUgLTEzbC0yNjAgLTI2NHEtOCAtOCAtMTggLTh0LTE4IDhsLTI2NCAyNjRxLTggOCAtNS41IDEzIHQxMi41IDVoMTc1djIwMGgtMjAwdi0xNzNxMCAtMTAgLTUgLTEydC0xMyA1bC0yNjQgMjY1cS04IDcgLTggMTcuNXQ4IDE3LjVsMjY0IDI2MHE4IDcgMTMgNXQ1IC0xMnYtMTczaDIwMHYyMDBoLTE3NXEtMTAgMCAtMTIuNSA1dDUuNSAxM3oiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDY5OyIgZD0iTTI1MCAxMTAwaDEwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtNDM4bDQ2NCA0NTNxMTUgMTQgMjUuNSAxMHQxMC41IC0yNXYtMTAwMHEwIC0yMSAtMTAuNSAtMjV0LTI1LjUgMTBsLTQ2NCA0NTN2LTQzOHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtMTAwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXYxMDAwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDcwOyIgZD0iTTUwIDExMDBoMTAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di00MzhsNDY0IDQ1M3ExNSAxNCAyNS41IDEwdDEwLjUgLTI1di00MzhsNDY0IDQ1M3ExNSAxNCAyNS41IDEwdDEwLjUgLTI1di0xMDAwcTAgLTIxIC0xMC41IC0yNXQtMjUuNSAxMGwtNDY0IDQ1M3YtNDM4cTAgLTIxIC0xMC41IC0yNXQtMjUuNSAxMGwtNDY0IDQ1M3YtNDM4cTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC0xMDBxLTIxIDAgLTM1LjUgMTQuNSB0LTE0LjUgMzUuNXYxMDAwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDcxOyIgZD0iTTEyMDAgMTA1MHYtMTAwMHEwIC0yMSAtMTAuNSAtMjV0LTI1LjUgMTBsLTQ2NCA0NTN2LTQzOHEwIC0yMSAtMTAuNSAtMjV0LTI1LjUgMTBsLTQ5MiA0ODBxLTE1IDE0IC0xNSAzNXQxNSAzNWw0OTIgNDgwcTE1IDE0IDI1LjUgMTB0MTAuNSAtMjV2LTQzOGw0NjQgNDUzcTE1IDE0IDI1LjUgMTB0MTAuNSAtMjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTA3MjsiIGQ9Ik0yNDMgMTA3NGw4MTQgLTQ5OHExOCAtMTEgMTggLTI2dC0xOCAtMjZsLTgxNCAtNDk4cS0xOCAtMTEgLTMwLjUgLTR0LTEyLjUgMjh2MTAwMHEwIDIxIDEyLjUgMjh0MzAuNSAtNHoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDczOyIgZD0iTTI1MCAxMDAwaDIwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtODAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC0yMDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djgwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6TTY1MCAxMDAwaDIwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtODAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC0yMDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djgwMCBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUwNzQ7IiBkPSJNMTEwMCA5NTB2LTgwMHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtODAwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXY4MDBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41aDgwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDc1OyIgZD0iTTUwMCA2MTJ2NDM4cTAgMjEgMTAuNSAyNXQyNS41IC0xMGw0OTIgLTQ4MHExNSAtMTQgMTUgLTM1dC0xNSAtMzVsLTQ5MiAtNDgwcS0xNSAtMTQgLTI1LjUgLTEwdC0xMC41IDI1djQzOGwtNDY0IC00NTNxLTE1IC0xNCAtMjUuNSAtMTB0LTEwLjUgMjV2MTAwMHEwIDIxIDEwLjUgMjV0MjUuNSAtMTB6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTA3NjsiIGQ9Ik0xMDQ4IDExMDJsMTAwIDFxMjAgMCAzNSAtMTQuNXQxNSAtMzUuNWw1IC0xMDAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41bC0xMDAgLTFxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41bC0yIDQzN2wtNDYzIC00NTRxLTE0IC0xNSAtMjQuNSAtMTAuNXQtMTAuNSAyNS41bC0yIDQzN2wtNDYyIC00NTVxLTE1IC0xNCAtMjUuNSAtOS41dC0xMC41IDI0LjVsLTUgMTAwMHEwIDIxIDEwLjUgMjUuNXQyNS41IC0xMC41bDQ2NiAtNDUwIGwtMiA0MzhxMCAyMCAxMC41IDI0LjV0MjUuNSAtOS41bDQ2NiAtNDUxbC0yIDQzOHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTA3NzsiIGQ9Ik04NTAgMTEwMGgxMDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTEwMDBxMCAtMjEgLTE0LjUgLTM1LjV0LTM1LjUgLTE0LjVoLTEwMHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2NDM4bC00NjQgLTQ1M3EtMTUgLTE0IC0yNS41IC0xMHQtMTAuNSAyNXYxMDAwcTAgMjEgMTAuNSAyNXQyNS41IC0xMGw0NjQgLTQ1M3Y0MzhxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUwNzg7IiBkPSJNNjg2IDEwODFsNTAxIC01NDBxMTUgLTE1IDEwLjUgLTI2dC0yNi41IC0xMWgtMTA0MnEtMjIgMCAtMjYuNSAxMXQxMC41IDI2bDUwMSA1NDBxMTUgMTUgMzYgMTV0MzYgLTE1ek0xNTAgNDAwaDEwMDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTEwMHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtMTAwMHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2MTAwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDc5OyIgZD0iTTg4NSA5MDBsLTM1MiAtMzUzbDM1MiAtMzUzbC0xOTcgLTE5OGwtNTUyIDU1Mmw1NTIgNTUweiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUwODA7IiBkPSJNMTA2NCA1NDdsLTU1MSAtNTUxbC0xOTggMTk4bDM1MyAzNTNsLTM1MyAzNTNsMTk4IDE5OHoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDgxOyIgZD0iTTYwMCAxMTc3cTExNyAwIDIyNCAtNDUuNXQxODQuNSAtMTIzdDEyMyAtMTg0LjV0NDUuNSAtMjI0dC00NS41IC0yMjR0LTEyMyAtMTg0LjV0LTE4NC41IC0xMjN0LTIyNCAtNDUuNXQtMjI0IDQ1LjV0LTE4NC41IDEyM3QtMTIzIDE4NC41dC00NS41IDIyNHQ0NS41IDIyNHQxMjMgMTg0LjV0MTg0LjUgMTIzdDIyNCA0NS41ek02NTAgOTAwaC0xMDBxLTIxIDAgLTM1LjUgLTE0LjV0LTE0LjUgLTM1LjV2LTE1MGgtMTUwIHEtMjEgMCAtMzUuNSAtMTQuNXQtMTQuNSAtMzUuNXYtMTAwcTAgLTIxIDE0LjUgLTM1LjV0MzUuNSAtMTQuNWgxNTB2LTE1MHEwIC0yMSAxNC41IC0zNS41dDM1LjUgLTE0LjVoMTAwcTIxIDAgMzUuNSAxNC41dDE0LjUgMzUuNXYxNTBoMTUwcTIxIDAgMzUuNSAxNC41dDE0LjUgMzUuNXYxMDBxMCAyMSAtMTQuNSAzNS41dC0zNS41IDE0LjVoLTE1MHYxNTBxMCAyMSAtMTQuNSAzNS41dC0zNS41IDE0LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTA4MjsiIGQ9Ik02MDAgMTE3N3ExMTcgMCAyMjQgLTQ1LjV0MTg0LjUgLTEyM3QxMjMgLTE4NC41dDQ1LjUgLTIyNHQtNDUuNSAtMjI0dC0xMjMgLTE4NC41dC0xODQuNSAtMTIzdC0yMjQgLTQ1LjV0LTIyNCA0NS41dC0xODQuNSAxMjN0LTEyMyAxODQuNXQtNDUuNSAyMjR0NDUuNSAyMjR0MTIzIDE4NC41dDE4NC41IDEyM3QyMjQgNDUuNXpNODUwIDcwMGgtNTAwcS0yMSAwIC0zNS41IC0xNC41dC0xNC41IC0zNS41di0xMDBxMCAtMjEgMTQuNSAtMzUuNSB0MzUuNSAtMTQuNWg1MDBxMjEgMCAzNS41IDE0LjV0MTQuNSAzNS41djEwMHEwIDIxIC0xNC41IDM1LjV0LTM1LjUgMTQuNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDgzOyIgZD0iTTYwMCAxMTc3cTExNyAwIDIyNCAtNDUuNXQxODQuNSAtMTIzdDEyMyAtMTg0LjV0NDUuNSAtMjI0dC00NS41IC0yMjR0LTEyMyAtMTg0LjV0LTE4NC41IC0xMjN0LTIyNCAtNDUuNXQtMjI0IDQ1LjV0LTE4NC41IDEyM3QtMTIzIDE4NC41dC00NS41IDIyNHQ0NS41IDIyNHQxMjMgMTg0LjV0MTg0LjUgMTIzdDIyNCA0NS41ek03NDEuNSA5MTNxLTEyLjUgMCAtMjEuNSAtOWwtMTIwIC0xMjBsLTEyMCAxMjBxLTkgOSAtMjEuNSA5IHQtMjEuNSAtOWwtMTQxIC0xNDFxLTkgLTkgLTkgLTIxLjV0OSAtMjEuNWwxMjAgLTEyMGwtMTIwIC0xMjBxLTkgLTkgLTkgLTIxLjV0OSAtMjEuNWwxNDEgLTE0MXE5IC05IDIxLjUgLTl0MjEuNSA5bDEyMCAxMjBsMTIwIC0xMjBxOSAtOSAyMS41IC05dDIxLjUgOWwxNDEgMTQxcTkgOSA5IDIxLjV0LTkgMjEuNWwtMTIwIDEyMGwxMjAgMTIwcTkgOSA5IDIxLjV0LTkgMjEuNWwtMTQxIDE0MXEtOSA5IC0yMS41IDl6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTA4NDsiIGQ9Ik02MDAgMTE3N3ExMTcgMCAyMjQgLTQ1LjV0MTg0LjUgLTEyM3QxMjMgLTE4NC41dDQ1LjUgLTIyNHQtNDUuNSAtMjI0dC0xMjMgLTE4NC41dC0xODQuNSAtMTIzdC0yMjQgLTQ1LjV0LTIyNCA0NS41dC0xODQuNSAxMjN0LTEyMyAxODQuNXQtNDUuNSAyMjR0NDUuNSAyMjR0MTIzIDE4NC41dDE4NC41IDEyM3QyMjQgNDUuNXpNNTQ2IDYyM2wtODQgODVxLTcgNyAtMTcuNSA3dC0xOC41IC03bC0xMzkgLTEzOXEtNyAtOCAtNyAtMTh0NyAtMTggbDI0MiAtMjQxcTcgLTggMTcuNSAtOHQxNy41IDhsMzc1IDM3NXE3IDcgNyAxNy41dC03IDE4LjVsLTEzOSAxMzlxLTcgNyAtMTcuNSA3dC0xNy41IC03eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUwODU7IiBkPSJNNjAwIDExNzdxMTE3IDAgMjI0IC00NS41dDE4NC41IC0xMjN0MTIzIC0xODQuNXQ0NS41IC0yMjR0LTQ1LjUgLTIyNHQtMTIzIC0xODQuNXQtMTg0LjUgLTEyM3QtMjI0IC00NS41dC0yMjQgNDUuNXQtMTg0LjUgMTIzdC0xMjMgMTg0LjV0LTQ1LjUgMjI0dDQ1LjUgMjI0dDEyMyAxODQuNXQxODQuNSAxMjN0MjI0IDQ1LjV6TTU4OCA5NDFxLTI5IDAgLTU5IC01LjV0LTYzIC0yMC41dC01OCAtMzguNXQtNDEuNSAtNjN0LTE2LjUgLTg5LjUgcTAgLTI1IDIwIC0yNWgxMzFxMzAgLTUgMzUgMTFxNiAyMCAyMC41IDI4dDQ1LjUgOHEyMCAwIDMxLjUgLTEwLjV0MTEuNSAtMjguNXEwIC0yMyAtNyAtMzR0LTI2IC0xOHEtMSAwIC0xMy41IC00dC0xOS41IC03LjV0LTIwIC0xMC41dC0yMiAtMTd0LTE4LjUgLTI0dC0xNS41IC0zNXQtOCAtNDZxLTEgLTggNS41IC0xNi41dDIwLjUgLTguNWgxNzNxNyAwIDIyIDh0MzUgMjh0MzcuNSA0OHQyOS41IDc0dDEyIDEwMHEwIDQ3IC0xNyA4MyB0LTQyLjUgNTd0LTU5LjUgMzQuNXQtNjQgMTh0LTU5IDQuNXpNNjc1IDQwMGgtMTUwcS0xMCAwIC0xNy41IC03LjV0LTcuNSAtMTcuNXYtMTUwcTAgLTEwIDcuNSAtMTcuNXQxNy41IC03LjVoMTUwcTEwIDAgMTcuNSA3LjV0Ny41IDE3LjV2MTUwcTAgMTAgLTcuNSAxNy41dC0xNy41IDcuNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDg2OyIgZD0iTTYwMCAxMTc3cTExNyAwIDIyNCAtNDUuNXQxODQuNSAtMTIzdDEyMyAtMTg0LjV0NDUuNSAtMjI0dC00NS41IC0yMjR0LTEyMyAtMTg0LjV0LTE4NC41IC0xMjN0LTIyNCAtNDUuNXQtMjI0IDQ1LjV0LTE4NC41IDEyM3QtMTIzIDE4NC41dC00NS41IDIyNHQ0NS41IDIyNHQxMjMgMTg0LjV0MTg0LjUgMTIzdDIyNCA0NS41ek02NzUgMTAwMGgtMTUwcS0xMCAwIC0xNy41IC03LjV0LTcuNSAtMTcuNXYtMTUwcTAgLTEwIDcuNSAtMTcuNSB0MTcuNSAtNy41aDE1MHExMCAwIDE3LjUgNy41dDcuNSAxNy41djE1MHEwIDEwIC03LjUgMTcuNXQtMTcuNSA3LjV6TTY3NSA3MDBoLTI1MHEtMTAgMCAtMTcuNSAtNy41dC03LjUgLTE3LjV2LTUwcTAgLTEwIDcuNSAtMTcuNXQxNy41IC03LjVoNzV2LTIwMGgtNzVxLTEwIDAgLTE3LjUgLTcuNXQtNy41IC0xNy41di01MHEwIC0xMCA3LjUgLTE3LjV0MTcuNSAtNy41aDM1MHExMCAwIDE3LjUgNy41dDcuNSAxNy41djUwcTAgMTAgLTcuNSAxNy41IHQtMTcuNSA3LjVoLTc1djI3NXEwIDEwIC03LjUgMTcuNXQtMTcuNSA3LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTA4NzsiIGQ9Ik01MjUgMTIwMGgxNTBxMTAgMCAxNy41IC03LjV0Ny41IC0xNy41di0xOTRxMTAzIC0yNyAxNzguNSAtMTAyLjV0MTAyLjUgLTE3OC41aDE5NHExMCAwIDE3LjUgLTcuNXQ3LjUgLTE3LjV2LTE1MHEwIC0xMCAtNy41IC0xNy41dC0xNy41IC03LjVoLTE5NHEtMjcgLTEwMyAtMTAyLjUgLTE3OC41dC0xNzguNSAtMTAyLjV2LTE5NHEwIC0xMCAtNy41IC0xNy41dC0xNy41IC03LjVoLTE1MHEtMTAgMCAtMTcuNSA3LjV0LTcuNSAxNy41djE5NCBxLTEwMyAyNyAtMTc4LjUgMTAyLjV0LTEwMi41IDE3OC41aC0xOTRxLTEwIDAgLTE3LjUgNy41dC03LjUgMTcuNXYxNTBxMCAxMCA3LjUgMTcuNXQxNy41IDcuNWgxOTRxMjcgMTAzIDEwMi41IDE3OC41dDE3OC41IDEwMi41djE5NHEwIDEwIDcuNSAxNy41dDE3LjUgNy41ek03MDAgODkzdi0xNjhxMCAtMTAgLTcuNSAtMTcuNXQtMTcuNSAtNy41aC0xNTBxLTEwIDAgLTE3LjUgNy41dC03LjUgMTcuNXYxNjhxLTY4IC0yMyAtMTE5IC03NCB0LTc0IC0xMTloMTY4cTEwIDAgMTcuNSAtNy41dDcuNSAtMTcuNXYtMTUwcTAgLTEwIC03LjUgLTE3LjV0LTE3LjUgLTcuNWgtMTY4cTIzIC02OCA3NCAtMTE5dDExOSAtNzR2MTY4cTAgMTAgNy41IDE3LjV0MTcuNSA3LjVoMTUwcTEwIDAgMTcuNSAtNy41dDcuNSAtMTcuNXYtMTY4cTY4IDIzIDExOSA3NHQ3NCAxMTloLTE2OHEtMTAgMCAtMTcuNSA3LjV0LTcuNSAxNy41djE1MHEwIDEwIDcuNSAxNy41dDE3LjUgNy41aDE2OCBxLTIzIDY4IC03NCAxMTl0LTExOSA3NHoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDg4OyIgZD0iTTYwMCAxMTc3cTExNyAwIDIyNCAtNDUuNXQxODQuNSAtMTIzdDEyMyAtMTg0LjV0NDUuNSAtMjI0dC00NS41IC0yMjR0LTEyMyAtMTg0LjV0LTE4NC41IC0xMjN0LTIyNCAtNDUuNXQtMjI0IDQ1LjV0LTE4NC41IDEyM3QtMTIzIDE4NC41dC00NS41IDIyNHQ0NS41IDIyNHQxMjMgMTg0LjV0MTg0LjUgMTIzdDIyNCA0NS41ek02MDAgMTAyN3EtMTE2IDAgLTIxNC41IC01N3QtMTU1LjUgLTE1NS41dC01NyAtMjE0LjV0NTcgLTIxNC41IHQxNTUuNSAtMTU1LjV0MjE0LjUgLTU3dDIxNC41IDU3dDE1NS41IDE1NS41dDU3IDIxNC41dC01NyAyMTQuNXQtMTU1LjUgMTU1LjV0LTIxNC41IDU3ek03NTkgODIzbDY0IC02NHE3IC03IDcgLTE3LjV0LTcgLTE3LjVsLTEyNCAtMTI0bDEyNCAtMTI0cTcgLTcgNyAtMTcuNXQtNyAtMTcuNWwtNjQgLTY0cS03IC03IC0xNy41IC03dC0xNy41IDdsLTEyNCAxMjRsLTEyNCAtMTI0cS03IC03IC0xNy41IC03dC0xNy41IDdsLTY0IDY0IHEtNyA3IC03IDE3LjV0NyAxNy41bDEyNCAxMjRsLTEyNCAxMjRxLTcgNyAtNyAxNy41dDcgMTcuNWw2NCA2NHE3IDcgMTcuNSA3dDE3LjUgLTdsMTI0IC0xMjRsMTI0IDEyNHE3IDcgMTcuNSA3dDE3LjUgLTd6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTA4OTsiIGQ9Ik02MDAgMTE3N3ExMTcgMCAyMjQgLTQ1LjV0MTg0LjUgLTEyM3QxMjMgLTE4NC41dDQ1LjUgLTIyNHQtNDUuNSAtMjI0dC0xMjMgLTE4NC41dC0xODQuNSAtMTIzdC0yMjQgLTQ1LjV0LTIyNCA0NS41dC0xODQuNSAxMjN0LTEyMyAxODQuNXQtNDUuNSAyMjR0NDUuNSAyMjR0MTIzIDE4NC41dDE4NC41IDEyM3QyMjQgNDUuNXpNNjAwIDEwMjdxLTExNiAwIC0yMTQuNSAtNTd0LTE1NS41IC0xNTUuNXQtNTcgLTIxNC41dDU3IC0yMTQuNSB0MTU1LjUgLTE1NS41dDIxNC41IC01N3QyMTQuNSA1N3QxNTUuNSAxNTUuNXQ1NyAyMTQuNXQtNTcgMjE0LjV0LTE1NS41IDE1NS41dC0yMTQuNSA1N3pNNzgyIDc4OGwxMDYgLTEwNnE3IC03IDcgLTE3LjV0LTcgLTE3LjVsLTMyMCAtMzIxcS04IC03IC0xOCAtN3QtMTggN2wtMjAyIDIwM3EtOCA3IC04IDE3LjV0OCAxNy41bDEwNiAxMDZxNyA4IDE3LjUgOHQxNy41IC04bDc5IC03OWwxOTcgMTk3cTcgNyAxNy41IDd0MTcuNSAtN3oiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDkwOyIgZD0iTTYwMCAxMTc3cTExNyAwIDIyNCAtNDUuNXQxODQuNSAtMTIzdDEyMyAtMTg0LjV0NDUuNSAtMjI0dC00NS41IC0yMjR0LTEyMyAtMTg0LjV0LTE4NC41IC0xMjN0LTIyNCAtNDUuNXQtMjI0IDQ1LjV0LTE4NC41IDEyM3QtMTIzIDE4NC41dC00NS41IDIyNHQ0NS41IDIyNHQxMjMgMTg0LjV0MTg0LjUgMTIzdDIyNCA0NS41ek02MDAgMTAyN3EtMTE2IDAgLTIxNC41IC01N3QtMTU1LjUgLTE1NS41dC01NyAtMjE0LjVxMCAtMTIwIDY1IC0yMjUgbDU4NyA1ODdxLTEwNSA2NSAtMjI1IDY1ek05NjUgODE5bC01ODQgLTU4NHExMDQgLTYyIDIxOSAtNjJxMTE2IDAgMjE0LjUgNTd0MTU1LjUgMTU1LjV0NTcgMjE0LjVxMCAxMTUgLTYyIDIxOXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDkxOyIgZD0iTTM5IDU4Mmw1MjIgNDI3cTE2IDEzIDI3LjUgOHQxMS41IC0yNnYtMjkxaDU1MHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtMjAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC01NTB2LTI5MXEwIC0yMSAtMTEuNSAtMjZ0LTI3LjUgOGwtNTIyIDQyN3EtMTYgMTMgLTE2IDMydDE2IDMyeiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUwOTI7IiBkPSJNNjM5IDEwMDlsNTIyIC00MjdxMTYgLTEzIDE2IC0zMnQtMTYgLTMybC01MjIgLTQyN3EtMTYgLTEzIC0yNy41IC04dC0xMS41IDI2djI5MWgtNTUwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXYyMDBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41aDU1MHYyOTFxMCAyMSAxMS41IDI2dDI3LjUgLTh6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTA5MzsiIGQ9Ik02ODIgMTE2MWw0MjcgLTUyMnExMyAtMTYgOCAtMjcuNXQtMjYgLTExLjVoLTI5MXYtNTUwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC0yMDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djU1MGgtMjkxcS0yMSAwIC0yNiAxMS41dDggMjcuNWw0MjcgNTIycTEzIDE2IDMyIDE2dDMyIC0xNnoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDk0OyIgZD0iTTU1MCAxMjAwaDIwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtNTUwaDI5MXEyMSAwIDI2IC0xMS41dC04IC0yNy41bC00MjcgLTUyMnEtMTMgLTE2IC0zMiAtMTZ0LTMyIDE2bC00MjcgNTIycS0xMyAxNiAtOCAyNy41dDI2IDExLjVoMjkxdjU1MHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTA5NTsiIGQ9Ik02MzkgMTEwOWw1MjIgLTQyN3ExNiAtMTMgMTYgLTMydC0xNiAtMzJsLTUyMiAtNDI3cS0xNiAtMTMgLTI3LjUgLTh0LTExLjUgMjZ2MjkxcS05NCAtMiAtMTgyIC0yMHQtMTcwLjUgLTUydC0xNDcgLTkyLjV0LTEwMC41IC0xMzUuNXE1IDEwNSAyNyAxOTMuNXQ2Ny41IDE2N3QxMTMgMTM1dDE2NyA5MS41dDIyNS41IDQydjI2MnEwIDIxIDExLjUgMjZ0MjcuNSAtOHoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDk2OyIgZD0iTTg1MCAxMjAwaDMwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtMzAwcTAgLTIxIC0xMC41IC0yNXQtMjQuNSAxMGwtOTQgOTRsLTI0OSAtMjQ5cS04IC03IC0xOCAtN3QtMTggN2wtMTA2IDEwNnEtNyA4IC03IDE4dDcgMThsMjQ5IDI0OWwtOTQgOTRxLTE0IDE0IC0xMCAyNC41dDI1IDEwLjV6TTM1MCAwaC0zMDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djMwMHEwIDIxIDEwLjUgMjV0MjQuNSAtMTBsOTQgLTk0bDI0OSAyNDkgcTggNyAxOCA3dDE4IC03bDEwNiAtMTA2cTcgLTggNyAtMTh0LTcgLTE4bC0yNDkgLTI0OWw5NCAtOTRxMTQgLTE0IDEwIC0yNC41dC0yNSAtMTAuNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMDk3OyIgZD0iTTEwMTQgMTEyMGwxMDYgLTEwNnE3IC04IDcgLTE4dC03IC0xOGwtMjQ5IC0yNDlsOTQgLTk0cTE0IC0xNCAxMCAtMjQuNXQtMjUgLTEwLjVoLTMwMHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2MzAwcTAgMjEgMTAuNSAyNXQyNC41IC0xMGw5NCAtOTRsMjQ5IDI0OXE4IDcgMTggN3QxOCAtN3pNMjUwIDYwMGgzMDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTMwMHEwIC0yMSAtMTAuNSAtMjV0LTI0LjUgMTBsLTk0IDk0IGwtMjQ5IC0yNDlxLTggLTcgLTE4IC03dC0xOCA3bC0xMDYgMTA2cS03IDggLTcgMTh0NyAxOGwyNDkgMjQ5bC05NCA5NHEtMTQgMTQgLTEwIDI0LjV0MjUgMTAuNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMTAxOyIgZD0iTTYwMCAxMTc3cTExNyAwIDIyNCAtNDUuNXQxODQuNSAtMTIzdDEyMyAtMTg0LjV0NDUuNSAtMjI0dC00NS41IC0yMjR0LTEyMyAtMTg0LjV0LTE4NC41IC0xMjN0LTIyNCAtNDUuNXQtMjI0IDQ1LjV0LTE4NC41IDEyM3QtMTIzIDE4NC41dC00NS41IDIyNHQ0NS41IDIyNHQxMjMgMTg0LjV0MTg0LjUgMTIzdDIyNCA0NS41ek03MDQgOTAwaC0yMDhxLTIwIDAgLTMyIC0xNC41dC04IC0zNC41bDU4IC0zMDJxNCAtMjAgMjEuNSAtMzQuNSB0MzcuNSAtMTQuNWg1NHEyMCAwIDM3LjUgMTQuNXQyMS41IDM0LjVsNTggMzAycTQgMjAgLTggMzQuNXQtMzIgMTQuNXpNNjc1IDQwMGgtMTUwcS0xMCAwIC0xNy41IC03LjV0LTcuNSAtMTcuNXYtMTUwcTAgLTEwIDcuNSAtMTcuNXQxNy41IC03LjVoMTUwcTEwIDAgMTcuNSA3LjV0Ny41IDE3LjV2MTUwcTAgMTAgLTcuNSAxNy41dC0xNy41IDcuNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMTAyOyIgZD0iTTI2MCAxMjAwcTkgMCAxOSAtMnQxNSAtNGw1IC0ycTIyIC0xMCA0NCAtMjNsMTk2IC0xMThxMjEgLTEzIDM2IC0yNHEyOSAtMjEgMzcgLTEycTExIDEzIDQ5IDM1bDE5NiAxMThxMjIgMTMgNDUgMjNxMTcgNyAzOCA3cTIzIDAgNDcgLTE2LjV0MzcgLTMzLjVsMTMgLTE2cTE0IC0yMSAxOCAtNDVsMjUgLTEyM2w4IC00NHExIC05IDguNSAtMTQuNXQxNy41IC01LjVoNjFxMTAgMCAxNy41IC03LjV0Ny41IC0xNy41di01MCBxMCAtMTAgLTcuNSAtMTcuNXQtMTcuNSAtNy41aC01MHEtMTAgMCAtMTcuNSAtNy41dC03LjUgLTE3LjV2LTE3NWgtNDAwdjMwMGgtMjAwdi0zMDBoLTQwMHYxNzVxMCAxMCAtNy41IDE3LjV0LTE3LjUgNy41aC01MHEtMTAgMCAtMTcuNSA3LjV0LTcuNSAxNy41djUwcTAgMTAgNy41IDE3LjV0MTcuNSA3LjVoNjFxMTEgMCAxOCAzdDcgOHEwIDQgOSA1MmwyNSAxMjhxNSAyNSAxOSA0NXEyIDMgNSA3dDEzLjUgMTV0MjEuNSAxOS41dDI2LjUgMTUuNSB0MjkuNSA3ek05MTUgMTA3OWwtMTY2IC0xNjJxLTcgLTcgLTUgLTEydDEyIC01aDIxOXExMCAwIDE1IDd0MiAxN2wtNTEgMTQ5cS0zIDEwIC0xMSAxMnQtMTUgLTZ6TTQ2MyA5MTdsLTE3NyAxNTdxLTggNyAtMTYgNXQtMTEgLTEybC01MSAtMTQzcS0zIC0xMCAyIC0xN3QxNSAtN2gyMzFxMTEgMCAxMi41IDV0LTUuNSAxMnpNNTAwIDBoLTM3NXEtMTAgMCAtMTcuNSA3LjV0LTcuNSAxNy41djM3NWg0MDB2LTQwMHpNMTEwMCA0MDB2LTM3NSBxMCAtMTAgLTcuNSAtMTcuNXQtMTcuNSAtNy41aC0zNzV2NDAwaDQwMHoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMTAzOyIgZD0iTTExNjUgMTE5MHE4IDMgMjEgLTYuNXQxMyAtMTcuNXEtMiAtMTc4IC0yNC41IC0zMjMuNXQtNTUuNSAtMjQ1LjV0LTg3IC0xNzQuNXQtMTAyLjUgLTExOC41dC0xMTggLTY4LjV0LTExOC41IC0zM3QtMTIwIC00LjV0LTEwNSA5LjV0LTkwIDE2LjVxLTYxIDEyIC03OCAxMXEtNCAxIC0xMi41IDB0LTM0IC0xNC41dC01Mi41IC00MC41bC0xNTMgLTE1M3EtMjYgLTI0IC0zNyAtMTQuNXQtMTEgNDMuNXEwIDY0IDQyIDEwMnE4IDggNTAuNSA0NSB0NjYuNSA1OHExOSAxNyAzNSA0N3QxMyA2MXEtOSA1NSAtMTAgMTAyLjV0NyAxMTF0MzcgMTMwdDc4IDEyOS41cTM5IDUxIDgwIDg4dDg5LjUgNjMuNXQ5NC41IDQ1dDExMy41IDM2dDEyOSAzMXQxNTcuNSAzN3QxODIgNDcuNXpNMTExNiAxMDk4cS04IDkgLTIyLjUgLTN0LTQ1LjUgLTUwcS0zOCAtNDcgLTExOSAtMTAzLjV0LTE0MiAtODkuNWwtNjIgLTMzcS01NiAtMzAgLTEwMiAtNTd0LTEwNCAtNjh0LTEwMi41IC04MC41dC04NS41IC05MSB0LTY0IC0xMDQuNXEtMjQgLTU2IC0zMSAtODZ0MiAtMzJ0MzEuNSAxNy41dDU1LjUgNTkuNXEyNSAzMCA5NCA3NS41dDEyNS41IDc3LjV0MTQ3LjUgODFxNzAgMzcgMTE4LjUgNjl0MTAyIDc5LjV0OTkgMTExdDg2LjUgMTQ4LjVxMjIgNTAgMjQgNjB0LTYgMTl6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTEwNDsiIGQ9Ik02NTMgMTIzMXEtMzkgLTY3IC01NC41IC0xMzF0LTEwLjUgLTExNC41dDI0LjUgLTk2LjV0NDcuNSAtODB0NjMuNSAtNjIuNXQ2OC41IC00Ni41dDY1IC0zMHEtNCA3IC0xNy41IDM1dC0xOC41IDM5LjV0LTE3IDM5LjV0LTE3IDQzdC0xMyA0MnQtOS41IDQ0LjV0LTIgNDJ0NCA0M3QxMy41IDM5dDIzIDM4LjVxOTYgLTQyIDE2NSAtMTA3LjV0MTA1IC0xMzh0NTIgLTE1NnQxMyAtMTU5dC0xOSAtMTQ5LjVxLTEzIC01NSAtNDQgLTEwNi41IHQtNjggLTg3dC03OC41IC02NC41dC03Mi41IC00NXQtNTMgLTIycS03MiAtMjIgLTEyNyAtMTFxLTMxIDYgLTEzIDE5cTYgMyAxNyA3cTEzIDUgMzIuNSAyMXQ0MSA0NHQzOC41IDYzLjV0MjEuNSA4MS41dC02LjUgOTQuNXQtNTAgMTA3dC0xMDQgMTE1LjVxMTAgLTEwNCAtMC41IC0xODl0LTM3IC0xNDAuNXQtNjUgLTkzdC04NCAtNTJ0LTkzLjUgLTExdC05NSAyNC41cS04MCAzNiAtMTMxLjUgMTE0dC01My41IDE3MXEtMiAyMyAwIDQ5LjUgdDQuNSA1Mi41dDEzLjUgNTZ0MjcuNSA2MHQ0NiA2NC41dDY5LjUgNjguNXEtOCAtNTMgLTUgLTEwMi41dDE3LjUgLTkwdDM0IC02OC41dDQ0LjUgLTM5dDQ5IC0ycTMxIDEzIDM4LjUgMzZ0LTQuNSA1NXQtMjkgNjQuNXQtMzYgNzV0LTI2IDc1LjVxLTE1IDg1IDIgMTYxLjV0NTMuNSAxMjguNXQ4NS41IDkyLjV0OTMuNSA2MXQ4MS41IDI1LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTEwNTsiIGQ9Ik02MDAgMTA5NHE4MiAwIDE2MC41IC0yMi41dDE0MCAtNTl0MTE2LjUgLTgyLjV0OTQuNSAtOTV0NjggLTk1dDQyLjUgLTgyLjV0MTQgLTU3LjV0LTE0IC01Ny41dC00MyAtODIuNXQtNjguNSAtOTV0LTk0LjUgLTk1dC0xMTYuNSAtODIuNXQtMTQwIC01OXQtMTU5LjUgLTIyLjV0LTE1OS41IDIyLjV0LTE0MCA1OXQtMTE2LjUgODIuNXQtOTQuNSA5NXQtNjguNSA5NXQtNDMgODIuNXQtMTQgNTcuNXQxNCA1Ny41dDQyLjUgODIuNXQ2OCA5NSB0OTQuNSA5NXQxMTYuNSA4Mi41dDE0MCA1OXQxNjAuNSAyMi41ek04ODggODI5cS0xNSAxNSAtMTggMTJ0NSAtMjJxMjUgLTU3IDI1IC0xMTlxMCAtMTI0IC04OCAtMjEydC0yMTIgLTg4dC0yMTIgODh0LTg4IDIxMnEwIDU5IDIzIDExNHE4IDE5IDQuNSAyMnQtMTcuNSAtMTJxLTcwIC02OSAtMTYwIC0xODRxLTEzIC0xNiAtMTUgLTQwLjV0OSAtNDIuNXEyMiAtMzYgNDcgLTcxdDcwIC04MnQ5Mi41IC04MXQxMTMgLTU4LjV0MTMzLjUgLTI0LjUgdDEzMy41IDI0dDExMyA1OC41dDkyLjUgODEuNXQ3MCA4MS41dDQ3IDcwLjVxMTEgMTggOSA0Mi41dC0xNCA0MS41cS05MCAxMTcgLTE2MyAxODl6TTQ0OCA3MjdsLTM1IC0zNnEtMTUgLTE1IC0xOS41IC0zOC41dDQuNSAtNDEuNXEzNyAtNjggOTMgLTExNnExNiAtMTMgMzguNSAtMTF0MzYuNSAxN2wzNSAzNHExNCAxNSAxMi41IDMzLjV0LTE2LjUgMzMuNXEtNDQgNDQgLTg5IDExN3EtMTEgMTggLTI4IDIwdC0zMiAtMTJ6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTEwNjsiIGQ9Ik01OTIgMGgtMTQ4bDMxIDEyMHEtOTEgMjAgLTE3NS41IDY4LjV0LTE0My41IDEwNi41dC0xMDMuNSAxMTl0LTY2LjUgMTEwdC0yMiA3NnEwIDIxIDE0IDU3LjV0NDIuNSA4Mi41dDY4IDk1dDk0LjUgOTV0MTE2LjUgODIuNXQxNDAgNTl0MTYwLjUgMjIuNXE2MSAwIDEyNiAtMTVsMzIgMTIxaDE0OHpNOTQ0IDc3MGw0NyAxODFxMTA4IC04NSAxNzYuNSAtMTkydDY4LjUgLTE1OXEwIC0yNiAtMTkuNSAtNzF0LTU5LjUgLTEwMnQtOTMgLTExMiB0LTEyOSAtMTA0LjV0LTE1OCAtNzUuNWw0NiAxNzNxNzcgNDkgMTM2IDExN3Q5NyAxMzFxMTEgMTggOSA0Mi41dC0xNCA0MS41cS01NCA3MCAtMTA3IDEzMHpNMzEwIDgyNHEtNzAgLTY5IC0xNjAgLTE4NHEtMTMgLTE2IC0xNSAtNDAuNXQ5IC00Mi41cTE4IC0zMCAzOSAtNjB0NTcgLTcwLjV0NzQgLTczdDkwIC02MXQxMDUgLTQxLjVsNDEgMTU0cS0xMDcgMTggLTE3OC41IDEwMS41dC03MS41IDE5My41cTAgNTkgMjMgMTE0cTggMTkgNC41IDIyIHQtMTcuNSAtMTJ6TTQ0OCA3MjdsLTM1IC0zNnEtMTUgLTE1IC0xOS41IC0zOC41dDQuNSAtNDEuNXEzNyAtNjggOTMgLTExNnExNiAtMTMgMzguNSAtMTF0MzYuNSAxN2wxMiAxMWwyMiA4NmwtMyA0cS00NCA0NCAtODkgMTE3cS0xMSAxOCAtMjggMjB0LTMyIC0xMnoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMTA3OyIgZD0iTS05MCAxMDBsNjQyIDEwNjZxMjAgMzEgNDggMjguNXQ0OCAtMzUuNWw2NDIgLTEwNTZxMjEgLTMyIDcuNSAtNjcuNXQtNTAuNSAtMzUuNWgtMTI5NHEtMzcgMCAtNTAuNSAzNHQ3LjUgNjZ6TTE1NSAyMDBoMzQ1djc1cTAgMTAgNy41IDE3LjV0MTcuNSA3LjVoMTUwcTEwIDAgMTcuNSAtNy41dDcuNSAtMTcuNXYtNzVoMzQ1bC00NDUgNzIzek00OTYgNzAwaDIwOHEyMCAwIDMyIC0xNC41dDggLTM0LjVsLTU4IC0yNTIgcS00IC0yMCAtMjEuNSAtMzQuNXQtMzcuNSAtMTQuNWgtNTRxLTIwIDAgLTM3LjUgMTQuNXQtMjEuNSAzNC41bC01OCAyNTJxLTQgMjAgOCAzNC41dDMyIDE0LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTEwODsiIGQ9Ik02NTAgMTIwMHE2MiAwIDEwNiAtNDR0NDQgLTEwNnYtMzM5bDM2MyAtMzI1cTE1IC0xNCAyNiAtMzguNXQxMSAtNDQuNXYtNDFxMCAtMjAgLTEyIC0yNi41dC0yOSA1LjVsLTM1OSAyNDl2LTI2M3ExMDAgLTkzIDEwMCAtMTEzdi02NHEwIC0yMSAtMTMgLTI5dC0zMiAxbC0yMDUgMTI4bC0yMDUgLTEyOHEtMTkgLTkgLTMyIC0xdC0xMyAyOXY2NHEwIDIwIDEwMCAxMTN2MjYzbC0zNTkgLTI0OXEtMTcgLTEyIC0yOSAtNS41dC0xMiAyNi41djQxIHEwIDIwIDExIDQ0LjV0MjYgMzguNWwzNjMgMzI1djMzOXEwIDYyIDQ0IDEwNnQxMDYgNDR6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTEwOTsiIGQ9Ik04NTAgMTIwMGgxMDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTUwaDUwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di0xNTBoLTExMDB2MTUwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNWg1MHY1MHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjVoMTAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di01MGg1MDB2NTBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41ek0xMTAwIDgwMHYtNzUwcTAgLTIxIC0xNC41IC0zNS41IHQtMzUuNSAtMTQuNWgtMTAwMHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2NzUwaDExMDB6TTEwMCA2MDB2LTEwMGgxMDB2MTAwaC0xMDB6TTMwMCA2MDB2LTEwMGgxMDB2MTAwaC0xMDB6TTUwMCA2MDB2LTEwMGgxMDB2MTAwaC0xMDB6TTcwMCA2MDB2LTEwMGgxMDB2MTAwaC0xMDB6TTkwMCA2MDB2LTEwMGgxMDB2MTAwaC0xMDB6TTEwMCA0MDB2LTEwMGgxMDB2MTAwaC0xMDB6TTMwMCA0MDB2LTEwMGgxMDB2MTAwaC0xMDB6TTUwMCA0MDAgdi0xMDBoMTAwdjEwMGgtMTAwek03MDAgNDAwdi0xMDBoMTAwdjEwMGgtMTAwek05MDAgNDAwdi0xMDBoMTAwdjEwMGgtMTAwek0xMDAgMjAwdi0xMDBoMTAwdjEwMGgtMTAwek0zMDAgMjAwdi0xMDBoMTAwdjEwMGgtMTAwek01MDAgMjAwdi0xMDBoMTAwdjEwMGgtMTAwek03MDAgMjAwdi0xMDBoMTAwdjEwMGgtMTAwek05MDAgMjAwdi0xMDBoMTAwdjEwMGgtMTAweiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxMTA7IiBkPSJNMTEzNSAxMTY1bDI0OSAtMjMwcTE1IC0xNCAxNSAtMzV0LTE1IC0zNWwtMjQ5IC0yMzBxLTE0IC0xNCAtMjQuNSAtMTB0LTEwLjUgMjV2MTUwaC0xNTlsLTYwMCAtNjAwaC0yOTFxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djEwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjVoMjA5bDYwMCA2MDBoMjQxdjE1MHEwIDIxIDEwLjUgMjV0MjQuNSAtMTB6TTUyMiA4MTlsLTE0MSAtMTQxbC0xMjIgMTIyaC0yMDlxLTIxIDAgLTM1LjUgMTQuNSB0LTE0LjUgMzUuNXYxMDBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41aDI5MXpNMTEzNSA1NjVsMjQ5IC0yMzBxMTUgLTE0IDE1IC0zNXQtMTUgLTM1bC0yNDkgLTIzMHEtMTQgLTE0IC0yNC41IC0xMHQtMTAuNSAyNXYxNTBoLTI0MWwtMTgxIDE4MWwxNDEgMTQxbDEyMiAtMTIyaDE1OXYxNTBxMCAyMSAxMC41IDI1dDI0LjUgLTEweiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxMTE7IiBkPSJNMTAwIDExMDBoMTAwMHE0MSAwIDcwLjUgLTI5LjV0MjkuNSAtNzAuNXYtNjAwcTAgLTQxIC0yOS41IC03MC41dC03MC41IC0yOS41aC01OTZsLTMwNCAtMzAwdjMwMGgtMTAwcS00MSAwIC03MC41IDI5LjV0LTI5LjUgNzAuNXY2MDBxMCA0MSAyOS41IDcwLjV0NzAuNSAyOS41eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxMTI7IiBkPSJNMTUwIDEyMDBoMjAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di0yNTBoLTMwMHYyNTBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41ek04NTAgMTIwMGgyMDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTI1MGgtMzAwdjI1MHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6TTExMDAgODAwdi0zMDBxMCAtNDEgLTMgLTc3LjV0LTE1IC04OS41dC0zMiAtOTZ0LTU4IC04OXQtODkgLTc3dC0xMjkgLTUxdC0xNzQgLTIwdC0xNzQgMjAgdC0xMjkgNTF0LTg5IDc3dC01OCA4OXQtMzIgOTZ0LTE1IDg5LjV0LTMgNzcuNXYzMDBoMzAwdi0yNTB2LTI3di00Mi41dDEuNSAtNDF0NSAtMzh0MTAgLTM1dDE2LjUgLTMwdDI1LjUgLTI0LjV0MzUgLTE5dDQ2LjUgLTEydDYwIC00dDYwIDQuNXQ0Ni41IDEyLjV0MzUgMTkuNXQyNSAyNS41dDE3IDMwLjV0MTAgMzV0NSAzOHQyIDQwLjV0LTAuNSA0MnYyNXYyNTBoMzAweiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxMTM7IiBkPSJNMTEwMCA0MTFsLTE5OCAtMTk5bC0zNTMgMzUzbC0zNTMgLTM1M2wtMTk3IDE5OWw1NTEgNTUxeiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxMTQ7IiBkPSJNMTEwMSA3ODlsLTU1MCAtNTUxbC01NTEgNTUxbDE5OCAxOTlsMzUzIC0zNTNsMzUzIDM1M3oiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMTE1OyIgZD0iTTQwNCAxMDAwaDc0NnEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtNTUxaDE1MHEyMSAwIDI1IC0xMC41dC0xMCAtMjQuNWwtMjMwIC0yNDlxLTE0IC0xNSAtMzUgLTE1dC0zNSAxNWwtMjMwIDI0OXEtMTQgMTQgLTEwIDI0LjV0MjUgMTAuNWgxNTB2NDAxaC0zODF6TTEzNSA5ODRsMjMwIC0yNDlxMTQgLTE0IDEwIC0yNC41dC0yNSAtMTAuNWgtMTUwdi00MDBoMzg1bDIxNSAtMjAwaC03NTBxLTIxIDAgLTM1LjUgMTQuNSB0LTE0LjUgMzUuNXY1NTBoLTE1MHEtMjEgMCAtMjUgMTAuNXQxMCAyNC41bDIzMCAyNDlxMTQgMTUgMzUgMTV0MzUgLTE1eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxMTY7IiBkPSJNNTYgMTIwMGg5NHExNyAwIDMxIC0xMXQxOCAtMjdsMzggLTE2Mmg4OTZxMjQgMCAzOSAtMTguNXQxMCAtNDIuNWwtMTAwIC00NzVxLTUgLTIxIC0yNyAtNDIuNXQtNTUgLTIxLjVoLTYzM2w0OCAtMjAwaDUzNXEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXQtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtNTB2LTUwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41dC0zNS41IDE0LjV0LTE0LjUgMzUuNXY1MGgtMzAwdi01MCBxMCAtMjEgLTE0LjUgLTM1LjV0LTM1LjUgLTE0LjV0LTM1LjUgMTQuNXQtMTQuNSAzNS41djUwaC0zMXEtMTggMCAtMzIuNSAxMHQtMjAuNSAxOWwtNSAxMGwtMjAxIDk2MWgtNTRxLTIwIDAgLTM1IDE0LjV0LTE1IDM1LjV0MTUgMzUuNXQzNSAxNC41eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxMTc7IiBkPSJNMTIwMCAxMDAwdi0xMDBoLTEyMDB2MTAwaDIwMHEwIDQxIDI5LjUgNzAuNXQ3MC41IDI5LjVoMzAwcTQxIDAgNzAuNSAtMjkuNXQyOS41IC03MC41aDUwMHpNMCA4MDBoMTIwMHYtODAwaC0xMjAwdjgwMHoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMTE4OyIgZD0iTTIwMCA4MDBsLTIwMCAtNDAwdjYwMGgyMDBxMCA0MSAyOS41IDcwLjV0NzAuNSAyOS41aDMwMHE0MiAwIDcxIC0yOS41dDI5IC03MC41aDUwMHYtMjAwaC0xMDAwek0xNTAwIDcwMGwtMzAwIC03MDBoLTEyMDBsMzAwIDcwMGgxMjAweiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxMTk7IiBkPSJNNjM1IDExODRsMjMwIC0yNDlxMTQgLTE0IDEwIC0yNC41dC0yNSAtMTAuNWgtMTUwdi02MDFoMTUwcTIxIDAgMjUgLTEwLjV0LTEwIC0yNC41bC0yMzAgLTI0OXEtMTQgLTE1IC0zNSAtMTV0LTM1IDE1bC0yMzAgMjQ5cS0xNCAxNCAtMTAgMjQuNXQyNSAxMC41aDE1MHY2MDFoLTE1MHEtMjEgMCAtMjUgMTAuNXQxMCAyNC41bDIzMCAyNDlxMTQgMTUgMzUgMTV0MzUgLTE1eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxMjA7IiBkPSJNOTM2IDg2NGwyNDkgLTIyOXExNCAtMTUgMTQgLTM1LjV0LTE0IC0zNS41bC0yNDkgLTIyOXEtMTUgLTE1IC0yNS41IC0xMC41dC0xMC41IDI0LjV2MTUxaC02MDB2LTE1MXEwIC0yMCAtMTAuNSAtMjQuNXQtMjUuNSAxMC41bC0yNDkgMjI5cS0xNCAxNSAtMTQgMzUuNXQxNCAzNS41bDI0OSAyMjlxMTUgMTUgMjUuNSAxMC41dDEwLjUgLTI1LjV2LTE0OWg2MDB2MTQ5cTAgMjEgMTAuNSAyNS41dDI1LjUgLTEwLjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTEyMTsiIGQ9Ik0xMTY5IDQwMGwtMTcyIDczMnEtNSAyMyAtMjMgNDUuNXQtMzggMjIuNWgtNjcycS0yMCAwIC0zOCAtMjB0LTIzIC00MWwtMTcyIC03MzloMTEzOHpNMTEwMCAzMDBoLTEwMDBxLTQxIDAgLTcwLjUgLTI5LjV0LTI5LjUgLTcwLjV2LTEwMHEwIC00MSAyOS41IC03MC41dDcwLjUgLTI5LjVoMTAwMHE0MSAwIDcwLjUgMjkuNXQyOS41IDcwLjV2MTAwcTAgNDEgLTI5LjUgNzAuNXQtNzAuNSAyOS41ek04MDAgMTAwdjEwMGgxMDB2LTEwMGgtMTAwIHpNMTAwMCAxMDB2MTAwaDEwMHYtMTAwaC0xMDB6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTEyMjsiIGQ9Ik0xMTUwIDExMDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTg1MHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNXQtMzUuNSAxNC41dC0xNC41IDM1LjV2ODUwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXpNMTAwMCAyMDBsLTY3NSAyMDBoLTM4bDQ3IC0yNzZxMyAtMTYgLTUuNSAtMjB0LTI5LjUgLTRoLTdoLTg0cS0yMCAwIC0zNC41IDE0dC0xOC41IDM1cS01NSAzMzcgLTU1IDM1MXYyNTB2NnEwIDE2IDEgMjMuNXQ2LjUgMTQgdDE3LjUgNi41aDIwMGw2NzUgMjUwdi04NTB6TTAgNzUwdi0yNTBxLTQgMCAtMTEgMC41dC0yNCA2dC0zMCAxNXQtMjQgMzB0LTExIDQ4LjV2NTBxMCAyNiAxMC41IDQ2dDI1IDMwdDI5IDE2dDI1LjUgN3oiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMTIzOyIgZD0iTTU1MyAxMjAwaDk0cTIwIDAgMjkgLTEwLjV0MyAtMjkuNWwtMTggLTM3cTgzIC0xOSAxNDQgLTgyLjV0NzYgLTE0MC41bDYzIC0zMjdsMTE4IC0xNzNoMTdxMTkgMCAzMyAtMTQuNXQxNCAtMzV0LTEzIC00MC41dC0zMSAtMjdxLTggLTQgLTIzIC05LjV0LTY1IC0xOS41dC0xMDMgLTI1dC0xMzIuNSAtMjB0LTE1OC41IC05cS01NyAwIC0xMTUgNXQtMTA0IDEydC04OC41IDE1LjV0LTczLjUgMTcuNXQtNTQuNSAxNnQtMzUuNSAxMmwtMTEgNCBxLTE4IDggLTMxIDI4dC0xMyA0MC41dDE0IDM1dDMzIDE0LjVoMTdsMTE4IDE3M2w2MyAzMjdxMTUgNzcgNzYgMTQwdDE0NCA4M2wtMTggMzJxLTYgMTkgMy41IDMydDI4LjUgMTN6TTQ5OCAxMTBxNTAgLTYgMTAyIC02cTUzIDAgMTAyIDZxLTEyIC00OSAtMzkuNSAtNzkuNXQtNjIuNSAtMzAuNXQtNjMgMzAuNXQtMzkgNzkuNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMTI0OyIgZD0iTTgwMCA5NDZsMjI0IDc4bC03OCAtMjI0bDIzNCAtNDVsLTE4MCAtMTU1bDE4MCAtMTU1bC0yMzQgLTQ1bDc4IC0yMjRsLTIyNCA3OGwtNDUgLTIzNGwtMTU1IDE4MGwtMTU1IC0xODBsLTQ1IDIzNGwtMjI0IC03OGw3OCAyMjRsLTIzNCA0NWwxODAgMTU1bC0xODAgMTU1bDIzNCA0NWwtNzggMjI0bDIyNCAtNzhsNDUgMjM0bDE1NSAtMTgwbDE1NSAxODB6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTEyNTsiIGQ9Ik02NTAgMTIwMGg1MHE0MCAwIDcwIC00MC41dDMwIC04NC41di0xNTBsLTI4IC0xMjVoMzI4cTQwIDAgNzAgLTQwLjV0MzAgLTg0LjV2LTEwMHEwIC00NSAtMjkgLTc0bC0yMzggLTM0NHEtMTYgLTI0IC0zOCAtNDAuNXQtNDUgLTE2LjVoLTI1MHEtNyAwIC00MiAyNXQtNjYgNTBsLTMxIDI1aC02MXEtNDUgMCAtNzIuNSAxOHQtMjcuNSA1N3Y0MDBxMCAzNiAyMCA2M2wxNDUgMTk2bDk2IDE5OHExMyAyOCAzNy41IDQ4dDUxLjUgMjB6IE02NTAgMTEwMGwtMTAwIC0yMTJsLTE1MCAtMjEzdi0zNzVoMTAwbDEzNiAtMTAwaDIxNGwyNTAgMzc1djEyNWgtNDUwbDUwIDIyNXYxNzVoLTUwek01MCA4MDBoMTAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di01MDBxMCAtMjEgLTE0LjUgLTM1LjV0LTM1LjUgLTE0LjVoLTEwMHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2NTAwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMTI2OyIgZD0iTTYwMCAxMTAwaDI1MHEyMyAwIDQ1IC0xNi41dDM4IC00MC41bDIzOCAtMzQ0cTI5IC0yOSAyOSAtNzR2LTEwMHEwIC00NCAtMzAgLTg0LjV0LTcwIC00MC41aC0zMjhxMjggLTExOCAyOCAtMTI1di0xNTBxMCAtNDQgLTMwIC04NC41dC03MCAtNDAuNWgtNTBxLTI3IDAgLTUxLjUgMjB0LTM3LjUgNDhsLTk2IDE5OGwtMTQ1IDE5NnEtMjAgMjcgLTIwIDYzdjQwMHEwIDM5IDI3LjUgNTd0NzIuNSAxOGg2MXExMjQgMTAwIDEzOSAxMDB6IE01MCAxMDAwaDEwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtNTAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC0xMDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djUwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6TTYzNiAxMDAwbC0xMzYgLTEwMGgtMTAwdi0zNzVsMTUwIC0yMTNsMTAwIC0yMTJoNTB2MTc1bC01MCAyMjVoNDUwdjEyNWwtMjUwIDM3NWgtMjE0eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxMjc7IiBkPSJNMzU2IDg3M2wzNjMgMjMwcTMxIDE2IDUzIC02bDExMCAtMTEycTEzIC0xMyAxMy41IC0zMnQtMTEuNSAtMzRsLTg0IC0xMjFoMzAycTg0IDAgMTM4IC0zOHQ1NCAtMTEwdC01NSAtMTExdC0xMzkgLTM5aC0xMDZsLTEzMSAtMzM5cS02IC0yMSAtMTkuNSAtNDF0LTI4LjUgLTIwaC0zNDJxLTcgMCAtOTAgODF0LTgzIDk0djUyNXEwIDE3IDE0IDM1LjV0MjggMjguNXpNNDAwIDc5MnYtNTAzbDEwMCAtODloMjkzbDEzMSAzMzkgcTYgMjEgMTkuNSA0MXQyOC41IDIwaDIwM3EyMSAwIDMwLjUgMjV0MC41IDUwdC0zMSAyNWgtNDU2aC03aC02aC01LjV0LTYgMC41dC01IDEuNXQtNSAydC00IDIuNXQtNCA0dC0yLjUgNC41cS0xMiAyNSA1IDQ3bDE0NiAxODNsLTg2IDgzek01MCA4MDBoMTAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di01MDBxMCAtMjEgLTE0LjUgLTM1LjV0LTM1LjUgLTE0LjVoLTEwMHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2NTAwIHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTEyODsiIGQ9Ik00NzUgMTEwM2wzNjYgLTIzMHEyIC0xIDYgLTMuNXQxNCAtMTAuNXQxOCAtMTYuNXQxNC41IC0yMHQ2LjUgLTIyLjV2LTUyNXEwIC0xMyAtODYgLTk0dC05MyAtODFoLTM0MnEtMTUgMCAtMjguNSAyMHQtMTkuNSA0MWwtMTMxIDMzOWgtMTA2cS04NSAwIC0xMzkuNSAzOXQtNTQuNSAxMTF0NTQgMTEwdDEzOCAzOGgzMDJsLTg1IDEyMXEtMTEgMTUgLTEwLjUgMzR0MTMuNSAzMmwxMTAgMTEycTIyIDIyIDUzIDZ6TTM3MCA5NDVsMTQ2IC0xODMgcTE3IC0yMiA1IC00N3EtMiAtMiAtMy41IC00LjV0LTQgLTR0LTQgLTIuNXQtNSAtMnQtNSAtMS41dC02IC0wLjVoLTZoLTYuNWgtNmgtNDc1di0xMDBoMjIxcTE1IDAgMjkgLTIwdDIwIC00MWwxMzAgLTMzOWgyOTRsMTA2IDg5djUwM2wtMzQyIDIzNnpNMTA1MCA4MDBoMTAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di01MDBxMCAtMjEgLTE0LjUgLTM1LjV0LTM1LjUgLTE0LjVoLTEwMHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjUgdjUwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTEyOTsiIGQ9Ik01NTAgMTI5NHE3MiAwIDExMSAtNTV0MzkgLTEzOXYtMTA2bDMzOSAtMTMxcTIxIC02IDQxIC0xOS41dDIwIC0yOC41di0zNDJxMCAtNyAtODEgLTkwdC05NCAtODNoLTUyNXEtMTcgMCAtMzUuNSAxNHQtMjguNSAyOGwtOSAxNGwtMjMwIDM2M3EtMTYgMzEgNiA1M2wxMTIgMTEwcTEzIDEzIDMyIDEzLjV0MzQgLTExLjVsMTIxIC04NHYzMDJxMCA4NCAzOCAxMzh0MTEwIDU0ek02MDAgOTcydjIwM3EwIDIxIC0yNSAzMC41dC01MCAwLjUgdC0yNSAtMzF2LTQ1NnYtN3YtNnYtNS41dC0wLjUgLTZ0LTEuNSAtNXQtMiAtNXQtMi41IC00dC00IC00dC00LjUgLTIuNXEtMjUgLTEyIC00NyA1bC0xODMgMTQ2bC04MyAtODZsMjM2IC0zMzloNTAzbDg5IDEwMHYyOTNsLTMzOSAxMzFxLTIxIDYgLTQxIDE5LjV0LTIwIDI4LjV6TTQ1MCAyMDBoNTAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di0xMDBxMCAtMjEgLTE0LjUgLTM1LjV0LTM1LjUgLTE0LjVoLTUwMCBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djEwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTEzMDsiIGQ9Ik0zNTAgMTEwMGg1MDBxMjEgMCAzNS41IDE0LjV0MTQuNSAzNS41djEwMHEwIDIxIC0xNC41IDM1LjV0LTM1LjUgMTQuNWgtNTAwcS0yMSAwIC0zNS41IC0xNC41dC0xNC41IC0zNS41di0xMDBxMCAtMjEgMTQuNSAtMzUuNXQzNS41IC0xNC41ek02MDAgMzA2di0xMDZxMCAtODQgLTM5IC0xMzl0LTExMSAtNTV0LTExMCA1NHQtMzggMTM4djMwMmwtMTIxIC04NHEtMTUgLTEyIC0zNCAtMTEuNXQtMzIgMTMuNWwtMTEyIDExMCBxLTIyIDIyIC02IDUzbDIzMCAzNjNxMSAyIDMuNSA2dDEwLjUgMTMuNXQxNi41IDE3dDIwIDEzLjV0MjIuNSA2aDUyNXExMyAwIDk0IC04M3Q4MSAtOTB2LTM0MnEwIC0xNSAtMjAgLTI4LjV0LTQxIC0xOS41ek0zMDggOTAwbC0yMzYgLTMzOWw4MyAtODZsMTgzIDE0NnEyMiAxNyA0NyA1cTIgLTEgNC41IC0yLjV0NCAtNHQyLjUgLTR0MiAtNXQxLjUgLTV0MC41IC02di01LjV2LTZ2LTd2LTQ1NnEwIC0yMiAyNSAtMzF0NTAgMC41dDI1IDMwLjUgdjIwM3EwIDE1IDIwIDI4LjV0NDEgMTkuNWwzMzkgMTMxdjI5M2wtODkgMTAwaC01MDN6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTEzMTsiIGQ9Ik02MDAgMTE3OHExMTggMCAyMjUgLTQ1LjV0MTg0LjUgLTEyM3QxMjMgLTE4NC41dDQ1LjUgLTIyNXQtNDUuNSAtMjI1dC0xMjMgLTE4NC41dC0xODQuNSAtMTIzdC0yMjUgLTQ1LjV0LTIyNSA0NS41dC0xODQuNSAxMjN0LTEyMyAxODQuNXQtNDUuNSAyMjV0NDUuNSAyMjV0MTIzIDE4NC41dDE4NC41IDEyM3QyMjUgNDUuNXpNOTE0IDYzMmwtMjc1IDIyM3EtMTYgMTMgLTI3LjUgOHQtMTEuNSAtMjZ2LTEzN2gtMjc1IHEtMTAgMCAtMTcuNSAtNy41dC03LjUgLTE3LjV2LTE1MHEwIC0xMCA3LjUgLTE3LjV0MTcuNSAtNy41aDI3NXYtMTM3cTAgLTIxIDExLjUgLTI2dDI3LjUgOGwyNzUgMjIzcTE2IDEzIDE2IDMydC0xNiAzMnoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMTMyOyIgZD0iTTYwMCAxMTc4cTExOCAwIDIyNSAtNDUuNXQxODQuNSAtMTIzdDEyMyAtMTg0LjV0NDUuNSAtMjI1dC00NS41IC0yMjV0LTEyMyAtMTg0LjV0LTE4NC41IC0xMjN0LTIyNSAtNDUuNXQtMjI1IDQ1LjV0LTE4NC41IDEyM3QtMTIzIDE4NC41dC00NS41IDIyNXQ0NS41IDIyNXQxMjMgMTg0LjV0MTg0LjUgMTIzdDIyNSA0NS41ek01NjEgODU1bC0yNzUgLTIyM3EtMTYgLTEzIC0xNiAtMzJ0MTYgLTMybDI3NSAtMjIzcTE2IC0xMyAyNy41IC04IHQxMS41IDI2djEzN2gyNzVxMTAgMCAxNy41IDcuNXQ3LjUgMTcuNXYxNTBxMCAxMCAtNy41IDE3LjV0LTE3LjUgNy41aC0yNzV2MTM3cTAgMjEgLTExLjUgMjZ0LTI3LjUgLTh6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTEzMzsiIGQ9Ik02MDAgMTE3OHExMTggMCAyMjUgLTQ1LjV0MTg0LjUgLTEyM3QxMjMgLTE4NC41dDQ1LjUgLTIyNXQtNDUuNSAtMjI1dC0xMjMgLTE4NC41dC0xODQuNSAtMTIzdC0yMjUgLTQ1LjV0LTIyNSA0NS41dC0xODQuNSAxMjN0LTEyMyAxODQuNXQtNDUuNSAyMjV0NDUuNSAyMjV0MTIzIDE4NC41dDE4NC41IDEyM3QyMjUgNDUuNXpNODU1IDYzOWwtMjIzIDI3NXEtMTMgMTYgLTMyIDE2dC0zMiAtMTZsLTIyMyAtMjc1cS0xMyAtMTYgLTggLTI3LjUgdDI2IC0xMS41aDEzN3YtMjc1cTAgLTEwIDcuNSAtMTcuNXQxNy41IC03LjVoMTUwcTEwIDAgMTcuNSA3LjV0Ny41IDE3LjV2Mjc1aDEzN3EyMSAwIDI2IDExLjV0LTggMjcuNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMTM0OyIgZD0iTTYwMCAxMTc4cTExOCAwIDIyNSAtNDUuNXQxODQuNSAtMTIzdDEyMyAtMTg0LjV0NDUuNSAtMjI1dC00NS41IC0yMjV0LTEyMyAtMTg0LjV0LTE4NC41IC0xMjN0LTIyNSAtNDUuNXQtMjI1IDQ1LjV0LTE4NC41IDEyM3QtMTIzIDE4NC41dC00NS41IDIyNXQ0NS41IDIyNXQxMjMgMTg0LjV0MTg0LjUgMTIzdDIyNSA0NS41ek02NzUgOTAwaC0xNTBxLTEwIDAgLTE3LjUgLTcuNXQtNy41IC0xNy41di0yNzVoLTEzN3EtMjEgMCAtMjYgLTExLjUgdDggLTI3LjVsMjIzIC0yNzVxMTMgLTE2IDMyIC0xNnQzMiAxNmwyMjMgMjc1cTEzIDE2IDggMjcuNXQtMjYgMTEuNWgtMTM3djI3NXEwIDEwIC03LjUgMTcuNXQtMTcuNSA3LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTEzNTsiIGQ9Ik02MDAgMTE3NnExMTYgMCAyMjIuNSAtNDZ0MTg0IC0xMjMuNXQxMjMuNSAtMTg0dDQ2IC0yMjIuNXQtNDYgLTIyMi41dC0xMjMuNSAtMTg0dC0xODQgLTEyMy41dC0yMjIuNSAtNDZ0LTIyMi41IDQ2dC0xODQgMTIzLjV0LTEyMy41IDE4NHQtNDYgMjIyLjV0NDYgMjIyLjV0MTIzLjUgMTg0dDE4NCAxMjMuNXQyMjIuNSA0NnpNNjI3IDExMDFxLTE1IC0xMiAtMzYuNSAtMjAuNXQtMzUuNSAtMTJ0LTQzIC04dC0zOSAtNi41IHEtMTUgLTMgLTQ1LjUgMHQtNDUuNSAtMnEtMjAgLTcgLTUxLjUgLTI2LjV0LTM0LjUgLTM0LjVxLTMgLTExIDYuNSAtMjIuNXQ4LjUgLTE4LjVxLTMgLTM0IC0yNy41IC05MXQtMjkuNSAtNzlxLTkgLTM0IDUgLTkzdDggLTg3cTAgLTkgMTcgLTQ0LjV0MTYgLTU5LjVxMTIgMCAyMyAtNXQyMy41IC0xNXQxOS41IC0xNHExNiAtOCAzMyAtMTV0NDAuNSAtMTV0MzQuNSAtMTJxMjEgLTkgNTIuNSAtMzJ0NjAgLTM4dDU3LjUgLTExIHE3IC0xNSAtMyAtMzR0LTIyLjUgLTQwdC05LjUgLTM4cTEzIC0yMSAyMyAtMzQuNXQyNy41IC0yNy41dDM2LjUgLTE4cTAgLTcgLTMuNSAtMTZ0LTMuNSAtMTR0NSAtMTdxMTA0IC0yIDIyMSAxMTJxMzAgMjkgNDYuNSA0N3QzNC41IDQ5dDIxIDYzcS0xMyA4IC0zNyA4LjV0LTM2IDcuNXEtMTUgNyAtNDkuNSAxNXQtNTEuNSAxOXEtMTggMCAtNDEgLTAuNXQtNDMgLTEuNXQtNDIgLTYuNXQtMzggLTE2LjVxLTUxIC0zNSAtNjYgLTEyIHEtNCAxIC0zLjUgMjUuNXQwLjUgMjUuNXEtNiAxMyAtMjYuNSAxNy41dC0yNC41IDYuNXExIDE1IC0wLjUgMzAuNXQtNyAyOHQtMTguNSAxMS41dC0zMSAtMjFxLTIzIC0yNSAtNDIgNHEtMTkgMjggLTggNThxNiAxNiAyMiAyMnE2IC0xIDI2IC0xLjV0MzMuNSAtNHQxOS41IC0xMy41cTcgLTEyIDE4IC0yNHQyMS41IC0yMC41dDIwIC0xNXQxNS41IC0xMC41bDUgLTNxMiAxMiA3LjUgMzAuNXQ4IDM0LjV0LTAuNSAzMnEtMyAxOCAzLjUgMjkgdDE4IDIyLjV0MTUuNSAyNC41cTYgMTQgMTAuNSAzNXQ4IDMxdDE1LjUgMjIuNXQzNCAyMi41cS02IDE4IDEwIDM2cTggMCAyNCAtMS41dDI0LjUgLTEuNXQyMCA0LjV0MjAuNSAxNS41cS0xMCAyMyAtMzEgNDIuNXQtMzcuNSAyOS41dC00OSAyN3QtNDMuNSAyM3EwIDEgMiA4dDMgMTEuNXQxLjUgMTAuNXQtMSA5LjV0LTQuNSA0LjVxMzEgLTEzIDU4LjUgLTE0LjV0MzguNSAyLjVsMTIgNXE1IDI4IC05LjUgNDZ0LTM2LjUgMjR0LTUwIDE1IHQtNDEgMjBxLTE4IC00IC0zNyAwek02MTMgOTk0cTAgLTE3IDggLTQydDE3IC00NXQ5IC0yM3EtOCAxIC0zOS41IDUuNXQtNTIuNSAxMHQtMzcgMTYuNXEzIDExIDE2IDI5LjV0MTYgMjUuNXExMCAtMTAgMTkgLTEwdDE0IDZ0MTMuNSAxNC41dDE2LjUgMTIuNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMTM2OyIgZD0iTTc1NiAxMTU3cTE2NCA5MiAzMDYgLTlsLTI1OSAtMTM4bDE0NSAtMjMybDI1MSAxMjZxNiAtODkgLTM0IC0xNTYuNXQtMTE3IC0xMTAuNXEtNjAgLTM0IC0xMjcgLTM5LjV0LTEyNiAxNi41bC01OTYgLTU5NnEtMTUgLTE2IC0zNi41IC0xNnQtMzYuNSAxNmwtMTExIDExMHEtMTUgMTUgLTE1IDM2LjV0MTUgMzcuNWw2MDAgNTk5cS0zNCAxMDEgNS41IDIwMS41dDEzNS41IDE1NC41eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxMzc7IiBob3Jpei1hZHYteD0iMTIyMCIgZD0iTTEwMCAxMTk2aDEwMDBxNDEgMCA3MC41IC0yOS41dDI5LjUgLTcwLjV2LTEwMHEwIC00MSAtMjkuNSAtNzAuNXQtNzAuNSAtMjkuNWgtMTAwMHEtNDEgMCAtNzAuNSAyOS41dC0yOS41IDcwLjV2MTAwcTAgNDEgMjkuNSA3MC41dDcwLjUgMjkuNXpNMTEwMCAxMDk2aC0yMDB2LTEwMGgyMDB2MTAwek0xMDAgNzk2aDEwMDBxNDEgMCA3MC41IC0yOS41dDI5LjUgLTcwLjV2LTEwMHEwIC00MSAtMjkuNSAtNzAuNXQtNzAuNSAtMjkuNWgtMTAwMCBxLTQxIDAgLTcwLjUgMjkuNXQtMjkuNSA3MC41djEwMHEwIDQxIDI5LjUgNzAuNXQ3MC41IDI5LjV6TTExMDAgNjk2aC01MDB2LTEwMGg1MDB2MTAwek0xMDAgMzk2aDEwMDBxNDEgMCA3MC41IC0yOS41dDI5LjUgLTcwLjV2LTEwMHEwIC00MSAtMjkuNSAtNzAuNXQtNzAuNSAtMjkuNWgtMTAwMHEtNDEgMCAtNzAuNSAyOS41dC0yOS41IDcwLjV2MTAwcTAgNDEgMjkuNSA3MC41dDcwLjUgMjkuNXpNMTEwMCAyOTZoLTMwMHYtMTAwaDMwMHYxMDB6ICIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxMzg7IiBkPSJNMTUwIDEyMDBoOTAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41dC0xNC41IC0zNS41dC0zNS41IC0xNC41aC05MDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41dDE0LjUgMzUuNXQzNS41IDE0LjV6TTcwMCA1MDB2LTMwMGwtMjAwIC0yMDB2NTAwbC0zNTAgNTAwaDkwMHoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMTM5OyIgZD0iTTUwMCAxMjAwaDIwMHE0MSAwIDcwLjUgLTI5LjV0MjkuNSAtNzAuNXYtMTAwaDMwMHE0MSAwIDcwLjUgLTI5LjV0MjkuNSAtNzAuNXYtNDAwaC01MDB2MTAwaC0yMDB2LTEwMGgtNTAwdjQwMHEwIDQxIDI5LjUgNzAuNXQ3MC41IDI5LjVoMzAwdjEwMHEwIDQxIDI5LjUgNzAuNXQ3MC41IDI5LjV6TTUwMCAxMTAwdi0xMDBoMjAwdjEwMGgtMjAwek0xMjAwIDQwMHYtMjAwcTAgLTQxIC0yOS41IC03MC41dC03MC41IC0yOS41aC0xMDAwIHEtNDEgMCAtNzAuNSAyOS41dC0yOS41IDcwLjV2MjAwaDEyMDB6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTE0MDsiIGQ9Ik01MCAxMjAwaDMwMHEyMSAwIDI1IC0xMC41dC0xMCAtMjQuNWwtOTQgLTk0bDE5OSAtMTk5cTcgLTggNyAtMTh0LTcgLTE4bC0xMDYgLTEwNnEtOCAtNyAtMTggLTd0LTE4IDdsLTE5OSAxOTlsLTk0IC05NHEtMTQgLTE0IC0yNC41IC0xMHQtMTAuNSAyNXYzMDBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41ek04NTAgMTIwMGgzMDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTMwMHEwIC0yMSAtMTAuNSAtMjV0LTI0LjUgMTBsLTk0IDk0IGwtMTk5IC0xOTlxLTggLTcgLTE4IC03dC0xOCA3bC0xMDYgMTA2cS03IDggLTcgMTh0NyAxOGwxOTkgMTk5bC05NCA5NHEtMTQgMTQgLTEwIDI0LjV0MjUgMTAuNXpNMzY0IDQ3MGwxMDYgLTEwNnE3IC04IDcgLTE4dC03IC0xOGwtMTk5IC0xOTlsOTQgLTk0cTE0IC0xNCAxMCAtMjQuNXQtMjUgLTEwLjVoLTMwMHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2MzAwcTAgMjEgMTAuNSAyNXQyNC41IC0xMGw5NCAtOTRsMTk5IDE5OSBxOCA3IDE4IDd0MTggLTd6TTEwNzEgMjcxbDk0IDk0cTE0IDE0IDI0LjUgMTB0MTAuNSAtMjV2LTMwMHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtMzAwcS0yMSAwIC0yNSAxMC41dDEwIDI0LjVsOTQgOTRsLTE5OSAxOTlxLTcgOCAtNyAxOHQ3IDE4bDEwNiAxMDZxOCA3IDE4IDd0MTggLTd6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTE0MTsiIGQ9Ik01OTYgMTE5MnExMjEgMCAyMzEuNSAtNDcuNXQxOTAgLTEyN3QxMjcgLTE5MHQ0Ny41IC0yMzEuNXQtNDcuNSAtMjMxLjV0LTEyNyAtMTkwLjV0LTE5MCAtMTI3dC0yMzEuNSAtNDd0LTIzMS41IDQ3dC0xOTAuNSAxMjd0LTEyNyAxOTAuNXQtNDcgMjMxLjV0NDcgMjMxLjV0MTI3IDE5MHQxOTAuNSAxMjd0MjMxLjUgNDcuNXpNNTk2IDEwMTBxLTExMiAwIC0yMDcuNSAtNTUuNXQtMTUxIC0xNTF0LTU1LjUgLTIwNy41dDU1LjUgLTIwNy41IHQxNTEgLTE1MXQyMDcuNSAtNTUuNXQyMDcuNSA1NS41dDE1MSAxNTF0NTUuNSAyMDcuNXQtNTUuNSAyMDcuNXQtMTUxIDE1MXQtMjA3LjUgNTUuNXpNNDU0LjUgOTA1cTIyLjUgMCAzOC41IC0xNnQxNiAtMzguNXQtMTYgLTM5dC0zOC41IC0xNi41dC0zOC41IDE2LjV0LTE2IDM5dDE2IDM4LjV0MzguNSAxNnpNNzU0LjUgOTA1cTIyLjUgMCAzOC41IC0xNnQxNiAtMzguNXQtMTYgLTM5dC0zOCAtMTYuNXEtMTQgMCAtMjkgMTBsLTU1IC0xNDUgcTE3IC0yMyAxNyAtNTFxMCAtMzYgLTI1LjUgLTYxLjV0LTYxLjUgLTI1LjV0LTYxLjUgMjUuNXQtMjUuNSA2MS41cTAgMzIgMjAuNSA1Ni41dDUxLjUgMjkuNWwxMjIgMTI2bDEgMXEtOSAxNCAtOSAyOHEwIDIzIDE2IDM5dDM4LjUgMTZ6TTM0NS41IDcwOXEyMi41IDAgMzguNSAtMTZ0MTYgLTM4LjV0LTE2IC0zOC41dC0zOC41IC0xNnQtMzguNSAxNnQtMTYgMzguNXQxNiAzOC41dDM4LjUgMTZ6TTg1NC41IDcwOXEyMi41IDAgMzguNSAtMTYgdDE2IC0zOC41dC0xNiAtMzguNXQtMzguNSAtMTZ0LTM4LjUgMTZ0LTE2IDM4LjV0MTYgMzguNXQzOC41IDE2eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxNDI7IiBkPSJNNTQ2IDE3M2w0NjkgNDcwcTkxIDkxIDk5IDE5MnE3IDk4IC01MiAxNzUuNXQtMTU0IDk0LjVxLTIyIDQgLTQ3IDRxLTM0IDAgLTY2LjUgLTEwdC01Ni41IC0yM3QtNTUuNSAtMzh0LTQ4IC00MS41dC00OC41IC00Ny41cS0zNzYgLTM3NSAtMzkxIC0zOTBxLTMwIC0yNyAtNDUgLTQxLjV0LTM3LjUgLTQxdC0zMiAtNDYuNXQtMTYgLTQ3LjV0LTEuNSAtNTYuNXE5IC02MiA1My41IC05NXQ5OS41IC0zM3E3NCAwIDEyNSA1MWw1NDggNTQ4IHEzNiAzNiAyMCA3NXEtNyAxNiAtMjEuNSAyNnQtMzIuNSAxMHEtMjYgMCAtNTAgLTIzcS0xMyAtMTIgLTM5IC0zOGwtMzQxIC0zMzhxLTE1IC0xNSAtMzUuNSAtMTUuNXQtMzQuNSAxMy41dC0xNCAzNC41dDE0IDM0LjVxMzI3IDMzMyAzNjEgMzY3cTM1IDM1IDY3LjUgNTEuNXQ3OC41IDE2LjVxMTQgMCAyOSAtMXE0NCAtOCA3NC41IC0zNS41dDQzLjUgLTY4LjVxMTQgLTQ3IDIgLTk2LjV0LTQ3IC04NC41cS0xMiAtMTEgLTMyIC0zMiB0LTc5LjUgLTgxdC0xMTQuNSAtMTE1dC0xMjQuNSAtMTIzLjV0LTEyMyAtMTE5LjV0LTk2LjUgLTg5dC01NyAtNDVxLTU2IC0yNyAtMTIwIC0yN3EtNzAgMCAtMTI5IDMydC05MyA4OXEtNDggNzggLTM1IDE3M3Q4MSAxNjNsNTExIDUxMXE3MSA3MiAxMTEgOTZxOTEgNTUgMTk4IDU1cTgwIDAgMTUyIC0zM3E3OCAtMzYgMTI5LjUgLTEwM3Q2Ni41IC0xNTRxMTcgLTkzIC0xMSAtMTgzLjV0LTk0IC0xNTYuNWwtNDgyIC00NzYgcS0xNSAtMTUgLTM2IC0xNnQtMzcgMTR0LTE3LjUgMzR0MTQuNSAzNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMTQzOyIgZD0iTTY0OSA5NDlxNDggNjggMTA5LjUgMTA0dDEyMS41IDM4LjV0MTE4LjUgLTIwdDEwMi41IC02NHQ3MSAtMTAwLjV0MjcgLTEyM3EwIC01NyAtMzMuNSAtMTE3LjV0LTk0IC0xMjQuNXQtMTI2LjUgLTEyNy41dC0xNTAgLTE1Mi41dC0xNDYgLTE3NHEtNjIgODUgLTE0NS41IDE3NHQtMTUwIDE1Mi41dC0xMjYuNSAxMjcuNXQtOTMuNSAxMjQuNXQtMzMuNSAxMTcuNXEwIDY0IDI4IDEyM3Q3MyAxMDAuNXQxMDQgNjR0MTE5IDIwIHQxMjAuNSAtMzguNXQxMDQuNSAtMTA0ek04OTYgOTcycS0zMyAwIC02NC41IC0xOXQtNTYuNSAtNDZ0LTQ3LjUgLTUzLjV0LTQzLjUgLTQ1LjV0LTM3LjUgLTE5dC0zNiAxOXQtNDAgNDUuNXQtNDMgNTMuNXQtNTQgNDZ0LTY1LjUgMTlxLTY3IDAgLTEyMi41IC01NS41dC01NS41IC0xMzIuNXEwIC0yMyAxMy41IC01MXQ0NiAtNjV0NTcuNSAtNjN0NzYgLTc1bDIyIC0yMnExNSAtMTQgNDQgLTQ0dDUwLjUgLTUxdDQ2IC00NHQ0MSAtMzV0MjMgLTEyIHQyMy41IDEydDQyLjUgMzZ0NDYgNDR0NTIuNSA1MnQ0NCA0M3E0IDQgMTIgMTNxNDMgNDEgNjMuNSA2MnQ1MiA1NXQ0NiA1NXQyNiA0NnQxMS41IDQ0cTAgNzkgLTUzIDEzMy41dC0xMjAgNTQuNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMTQ0OyIgZD0iTTc3Ni41IDEyMTRxOTMuNSAwIDE1OS41IC02NmwxNDEgLTE0MXE2NiAtNjYgNjYgLTE2MHEwIC00MiAtMjggLTk1LjV0LTYyIC04Ny41bC0yOSAtMjlxLTMxIDUzIC03NyA5OWwtMTggMThsOTUgOTVsLTI0NyAyNDhsLTM4OSAtMzg5bDIxMiAtMjEybC0xMDUgLTEwNmwtMTkgMThsLTE0MSAxNDFxLTY2IDY2IC02NiAxNTl0NjYgMTU5bDI4MyAyODNxNjUgNjYgMTU4LjUgNjZ6TTYwMCA3MDZsMTA1IDEwNXExMCAtOCAxOSAtMTdsMTQxIC0xNDEgcTY2IC02NiA2NiAtMTU5dC02NiAtMTU5bC0yODMgLTI4M3EtNjYgLTY2IC0xNTkgLTY2dC0xNTkgNjZsLTE0MSAxNDFxLTY2IDY2IC02NiAxNTkuNXQ2NiAxNTkuNWw1NSA1NXEyOSAtNTUgNzUgLTEwMmwxOCAtMTdsLTk1IC05NWwyNDcgLTI0OGwzODkgMzg5eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxNDU7IiBkPSJNNjAzIDEyMDBxODUgMCAxNjIgLTE1dDEyNyAtMzh0NzkgLTQ4dDI5IC00NnYtOTUzcTAgLTQxIC0yOS41IC03MC41dC03MC41IC0yOS41aC02MDBxLTQxIDAgLTcwLjUgMjkuNXQtMjkuNSA3MC41djk1M3EwIDIxIDMwIDQ2LjV0ODEgNDh0MTI5IDM3LjV0MTYzIDE1ek0zMDAgMTAwMHYtNzAwaDYwMHY3MDBoLTYwMHpNNjAwIDI1NHEtNDMgMCAtNzMuNSAtMzAuNXQtMzAuNSAtNzMuNXQzMC41IC03My41dDczLjUgLTMwLjV0NzMuNSAzMC41IHQzMC41IDczLjV0LTMwLjUgNzMuNXQtNzMuNSAzMC41eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxNDY7IiBkPSJNOTAyIDExODVsMjgzIC0yODJxMTUgLTE1IDE1IC0zNnQtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNXQtMzUgMTVsLTM2IDM1bC0yNzkgLTI2N3YtMzAwbC0yMTIgMjEwbC0zMDggLTMwN2wtMjgwIC0yMDNsMjAzIDI4MGwzMDcgMzA4bC0yMTAgMjEyaDMwMGwyNjcgMjc5bC0zNSAzNnEtMTUgMTQgLTE1IDM1dDE0LjUgMzUuNXQzNS41IDE0LjV0MzUgLTE1eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxNDg7IiBkPSJNNzAwIDEyNDh2LTc4cTM4IC01IDcyLjUgLTE0LjV0NzUuNSAtMzEuNXQ3MSAtNTMuNXQ1MiAtODR0MjQgLTExOC41aC0xNTlxLTQgMzYgLTEwLjUgNTl0LTIxIDQ1dC00MCAzNS41dC02NC41IDIwLjV2LTMwN2w2NCAtMTNxMzQgLTcgNjQgLTE2LjV0NzAgLTMydDY3LjUgLTUyLjV0NDcuNSAtODB0MjAgLTExMnEwIC0xMzkgLTg5IC0yMjR0LTI0NCAtOTd2LTc3aC0xMDB2NzlxLTE1MCAxNiAtMjM3IDEwM3EtNDAgNDAgLTUyLjUgOTMuNSB0LTE1LjUgMTM5LjVoMTM5cTUgLTc3IDQ4LjUgLTEyNnQxMTcuNSAtNjV2MzM1bC0yNyA4cS00NiAxNCAtNzkgMjYuNXQtNzIgMzZ0LTYzIDUydC00MCA3Mi41dC0xNiA5OHEwIDcwIDI1IDEyNnQ2Ny41IDkydDk0LjUgNTd0MTEwIDI3djc3aDEwMHpNNjAwIDc1NHYyNzRxLTI5IC00IC01MCAtMTF0LTQyIC0yMS41dC0zMS41IC00MS41dC0xMC41IC02NXEwIC0yOSA3IC01MC41dDE2LjUgLTM0dDI4LjUgLTIyLjV0MzEuNSAtMTR0MzcuNSAtMTAgcTkgLTMgMTMgLTR6TTcwMCA1NDd2LTMxMHEyMiAyIDQyLjUgNi41dDQ1IDE1LjV0NDEuNSAyN3QyOSA0MnQxMiA1OS41dC0xMi41IDU5LjV0LTM4IDQ0LjV0LTUzIDMxdC02Ni41IDI0LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTE0OTsiIGQ9Ik01NjEgMTE5N3E4NCAwIDE2MC41IC00MHQxMjMuNSAtMTA5LjV0NDcgLTE0Ny41aC0xNTNxMCA0MCAtMTkuNSA3MS41dC00OS41IDQ4LjV0LTU5LjUgMjZ0LTU1LjUgOXEtMzcgMCAtNzkgLTE0LjV0LTYyIC0zNS41cS00MSAtNDQgLTQxIC0xMDFxMCAtMjYgMTMuNSAtNjN0MjYuNSAtNjF0MzcgLTY2cTYgLTkgOSAtMTRoMjQxdi0xMDBoLTE5N3E4IC01MCAtMi41IC0xMTV0LTMxLjUgLTk1cS00NSAtNjIgLTk5IC0xMTIgcTM0IDEwIDgzIDE3LjV0NzEgNy41cTMyIDEgMTAyIC0xNnQxMDQgLTE3cTgzIDAgMTM2IDMwbDUwIC0xNDdxLTMxIC0xOSAtNTggLTMwLjV0LTU1IC0xNS41dC00MiAtNC41dC00NiAtMC41cS0yMyAwIC03NiAxN3QtMTExIDMyLjV0LTk2IDExLjVxLTM5IC0zIC04MiAtMTZ0LTY3IC0yNWwtMjMgLTExbC01NSAxNDVxNCAzIDE2IDExdDE1LjUgMTAuNXQxMyA5dDE1LjUgMTJ0MTQuNSAxNHQxNy41IDE4LjVxNDggNTUgNTQgMTI2LjUgdC0zMCAxNDIuNWgtMjIxdjEwMGgxNjZxLTIzIDQ3IC00NCAxMDRxLTcgMjAgLTEyIDQxLjV0LTYgNTUuNXQ2IDY2LjV0MjkuNSA3MC41dDU4LjUgNzFxOTcgODggMjYzIDg4eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxNTA7IiBkPSJNNDAwIDMwMGgxNTBxMjEgMCAyNSAtMTF0LTEwIC0yNWwtMjMwIC0yNTBxLTE0IC0xNSAtMzUgLTE1dC0zNSAxNWwtMjMwIDI1MHEtMTQgMTQgLTEwIDI1dDI1IDExaDE1MHY5MDBoMjAwdi05MDB6TTkzNSAxMTg0bDIzMCAtMjQ5cTE0IC0xNCAxMCAtMjQuNXQtMjUgLTEwLjVoLTE1MHYtOTAwaC0yMDB2OTAwaC0xNTBxLTIxIDAgLTI1IDEwLjV0MTAgMjQuNWwyMzAgMjQ5cTE0IDE1IDM1IDE1dDM1IC0xNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMTUxOyIgZD0iTTEwMDAgNzAwaC0xMDB2MTAwaC0xMDB2LTEwMGgtMTAwdjUwMGgzMDB2LTUwMHpNNDAwIDMwMGgxNTBxMjEgMCAyNSAtMTF0LTEwIC0yNWwtMjMwIC0yNTBxLTE0IC0xNSAtMzUgLTE1dC0zNSAxNWwtMjMwIDI1MHEtMTQgMTQgLTEwIDI1dDI1IDExaDE1MHY5MDBoMjAwdi05MDB6TTgwMSAxMTAwdi0yMDBoMTAwdjIwMGgtMTAwek0xMDAwIDM1MGwtMjAwIC0yNTBoMjAwdi0xMDBoLTMwMHYxNTBsMjAwIDI1MGgtMjAwdjEwMGgzMDB2LTE1MHogIiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTE1MjsiIGQ9Ik00MDAgMzAwaDE1MHEyMSAwIDI1IC0xMXQtMTAgLTI1bC0yMzAgLTI1MHEtMTQgLTE1IC0zNSAtMTV0LTM1IDE1bC0yMzAgMjUwcS0xNCAxNCAtMTAgMjV0MjUgMTFoMTUwdjkwMGgyMDB2LTkwMHpNMTAwMCAxMDUwbC0yMDAgLTI1MGgyMDB2LTEwMGgtMzAwdjE1MGwyMDAgMjUwaC0yMDB2MTAwaDMwMHYtMTUwek0xMDAwIDBoLTEwMHYxMDBoLTEwMHYtMTAwaC0xMDB2NTAwaDMwMHYtNTAwek04MDEgNDAwdi0yMDBoMTAwdjIwMGgtMTAweiAiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMTUzOyIgZD0iTTQwMCAzMDBoMTUwcTIxIDAgMjUgLTExdC0xMCAtMjVsLTIzMCAtMjUwcS0xNCAtMTUgLTM1IC0xNXQtMzUgMTVsLTIzMCAyNTBxLTE0IDE0IC0xMCAyNXQyNSAxMWgxNTB2OTAwaDIwMHYtOTAwek0xMDAwIDcwMGgtMTAwdjQwMGgtMTAwdjEwMGgyMDB2LTUwMHpNMTEwMCAwaC0xMDB2MTAwaC0yMDB2NDAwaDMwMHYtNTAwek05MDEgNDAwdi0yMDBoMTAwdjIwMGgtMTAweiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxNTQ7IiBkPSJNNDAwIDMwMGgxNTBxMjEgMCAyNSAtMTF0LTEwIC0yNWwtMjMwIC0yNTBxLTE0IC0xNSAtMzUgLTE1dC0zNSAxNWwtMjMwIDI1MHEtMTQgMTQgLTEwIDI1dDI1IDExaDE1MHY5MDBoMjAwdi05MDB6TTExMDAgNzAwaC0xMDB2MTAwaC0yMDB2NDAwaDMwMHYtNTAwek05MDEgMTEwMHYtMjAwaDEwMHYyMDBoLTEwMHpNMTAwMCAwaC0xMDB2NDAwaC0xMDB2MTAwaDIwMHYtNTAweiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxNTU7IiBkPSJNNDAwIDMwMGgxNTBxMjEgMCAyNSAtMTF0LTEwIC0yNWwtMjMwIC0yNTBxLTE0IC0xNSAtMzUgLTE1dC0zNSAxNWwtMjMwIDI1MHEtMTQgMTQgLTEwIDI1dDI1IDExaDE1MHY5MDBoMjAwdi05MDB6TTkwMCAxMDAwaC0yMDB2MjAwaDIwMHYtMjAwek0xMDAwIDcwMGgtMzAwdjIwMGgzMDB2LTIwMHpNMTEwMCA0MDBoLTQwMHYyMDBoNDAwdi0yMDB6TTEyMDAgMTAwaC01MDB2MjAwaDUwMHYtMjAweiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxNTY7IiBkPSJNNDAwIDMwMGgxNTBxMjEgMCAyNSAtMTF0LTEwIC0yNWwtMjMwIC0yNTBxLTE0IC0xNSAtMzUgLTE1dC0zNSAxNWwtMjMwIDI1MHEtMTQgMTQgLTEwIDI1dDI1IDExaDE1MHY5MDBoMjAwdi05MDB6TTEyMDAgMTAwMGgtNTAwdjIwMGg1MDB2LTIwMHpNMTEwMCA3MDBoLTQwMHYyMDBoNDAwdi0yMDB6TTEwMDAgNDAwaC0zMDB2MjAwaDMwMHYtMjAwek05MDAgMTAwaC0yMDB2MjAwaDIwMHYtMjAweiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxNTc7IiBkPSJNMzUwIDExMDBoNDAwcTE2MiAwIDI1NiAtOTMuNXQ5NCAtMjU2LjV2LTQwMHEwIC0xNjUgLTkzLjUgLTI1Ny41dC0yNTYuNSAtOTIuNWgtNDAwcS0xNjUgMCAtMjU3LjUgOTIuNXQtOTIuNSAyNTcuNXY0MDBxMCAxNjUgOTIuNSAyNTcuNXQyNTcuNSA5Mi41ek04MDAgOTAwaC01MDBxLTQxIDAgLTcwLjUgLTI5LjV0LTI5LjUgLTcwLjV2LTUwMHEwIC00MSAyOS41IC03MC41dDcwLjUgLTI5LjVoNTAwcTQxIDAgNzAuNSAyOS41dDI5LjUgNzAuNSB2NTAwcTAgNDEgLTI5LjUgNzAuNXQtNzAuNSAyOS41eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxNTg7IiBkPSJNMzUwIDExMDBoNDAwcTE2NSAwIDI1Ny41IC05Mi41dDkyLjUgLTI1Ny41di00MDBxMCAtMTY1IC05Mi41IC0yNTcuNXQtMjU3LjUgLTkyLjVoLTQwMHEtMTYzIDAgLTI1Ni41IDkyLjV0LTkzLjUgMjU3LjV2NDAwcTAgMTYzIDk0IDI1Ni41dDI1NiA5My41ek04MDAgOTAwaC01MDBxLTQxIDAgLTcwLjUgLTI5LjV0LTI5LjUgLTcwLjV2LTUwMHEwIC00MSAyOS41IC03MC41dDcwLjUgLTI5LjVoNTAwcTQxIDAgNzAuNSAyOS41dDI5LjUgNzAuNSB2NTAwcTAgNDEgLTI5LjUgNzAuNXQtNzAuNSAyOS41ek00NDAgNzcwbDI1MyAtMTkwcTE3IC0xMiAxNyAtMzB0LTE3IC0zMGwtMjUzIC0xOTBxLTE2IC0xMiAtMjggLTYuNXQtMTIgMjYuNXY0MDBxMCAyMSAxMiAyNi41dDI4IC02LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTE1OTsiIGQ9Ik0zNTAgMTEwMGg0MDBxMTYzIDAgMjU2LjUgLTk0dDkzLjUgLTI1NnYtNDAwcTAgLTE2NSAtOTIuNSAtMjU3LjV0LTI1Ny41IC05Mi41aC00MDBxLTE2NSAwIC0yNTcuNSA5Mi41dC05Mi41IDI1Ny41djQwMHEwIDE2MyA5Mi41IDI1Ni41dDI1Ny41IDkzLjV6TTgwMCA5MDBoLTUwMHEtNDEgMCAtNzAuNSAtMjkuNXQtMjkuNSAtNzAuNXYtNTAwcTAgLTQxIDI5LjUgLTcwLjV0NzAuNSAtMjkuNWg1MDBxNDEgMCA3MC41IDI5LjV0MjkuNSA3MC41IHY1MDBxMCA0MSAtMjkuNSA3MC41dC03MC41IDI5LjV6TTM1MCA3MDBoNDAwcTIxIDAgMjYuNSAtMTJ0LTYuNSAtMjhsLTE5MCAtMjUzcS0xMiAtMTcgLTMwIC0xN3QtMzAgMTdsLTE5MCAyNTNxLTEyIDE2IC02LjUgMjh0MjYuNSAxMnoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMTYwOyIgZD0iTTM1MCAxMTAwaDQwMHExNjUgMCAyNTcuNSAtOTIuNXQ5Mi41IC0yNTcuNXYtNDAwcTAgLTE2MyAtOTIuNSAtMjU2LjV0LTI1Ny41IC05My41aC00MDBxLTE2MyAwIC0yNTYuNSA5NHQtOTMuNSAyNTZ2NDAwcTAgMTY1IDkyLjUgMjU3LjV0MjU3LjUgOTIuNXpNODAwIDkwMGgtNTAwcS00MSAwIC03MC41IC0yOS41dC0yOS41IC03MC41di01MDBxMCAtNDEgMjkuNSAtNzAuNXQ3MC41IC0yOS41aDUwMHE0MSAwIDcwLjUgMjkuNXQyOS41IDcwLjUgdjUwMHEwIDQxIC0yOS41IDcwLjV0LTcwLjUgMjkuNXpNNTgwIDY5M2wxOTAgLTI1M3ExMiAtMTYgNi41IC0yOHQtMjYuNSAtMTJoLTQwMHEtMjEgMCAtMjYuNSAxMnQ2LjUgMjhsMTkwIDI1M3ExMiAxNyAzMCAxN3QzMCAtMTd6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTE2MTsiIGQ9Ik01NTAgMTEwMGg0MDBxMTY1IDAgMjU3LjUgLTkyLjV0OTIuNSAtMjU3LjV2LTQwMHEwIC0xNjUgLTkyLjUgLTI1Ny41dC0yNTcuNSAtOTIuNWgtNDAwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXYxMDBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41aDQ1MHE0MSAwIDcwLjUgMjkuNXQyOS41IDcwLjV2NTAwcTAgNDEgLTI5LjUgNzAuNXQtNzAuNSAyOS41aC00NTBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djEwMCBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41ek0zMzggODY3bDMyNCAtMjg0cTE2IC0xNCAxNiAtMzN0LTE2IC0zM2wtMzI0IC0yODRxLTE2IC0xNCAtMjcgLTl0LTExIDI2djE1MGgtMjUwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXYyMDBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41aDI1MHYxNTBxMCAyMSAxMSAyNnQyNyAtOXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMTYyOyIgZD0iTTc5MyAxMTgybDkgLTlxOCAtMTAgNSAtMjdxLTMgLTExIC03OSAtMjI1LjV0LTc4IC0yMjEuNWwzMDAgMXEyNCAwIDMyLjUgLTE3LjV0LTUuNSAtMzUuNXEtMSAwIC0xMzMuNSAtMTU1dC0yNjcgLTMxMi41dC0xMzguNSAtMTYyLjVxLTEyIC0xNSAtMjYgLTE1aC05bC05IDhxLTkgMTEgLTQgMzJxMiA5IDQyIDEyMy41dDc5IDIyNC41bDM5IDExMGgtMzAycS0yMyAwIC0zMSAxOXEtMTAgMjEgNiA0MXE3NSA4NiAyMDkuNSAyMzcuNSB0MjI4IDI1N3Q5OC41IDExMS41cTkgMTYgMjUgMTZoOXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMTYzOyIgZD0iTTM1MCAxMTAwaDQwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtMTAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC00NTBxLTQxIDAgLTcwLjUgLTI5LjV0LTI5LjUgLTcwLjV2LTUwMHEwIC00MSAyOS41IC03MC41dDcwLjUgLTI5LjVoNDUwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di0xMDBxMCAtMjEgLTE0LjUgLTM1LjV0LTM1LjUgLTE0LjVoLTQwMHEtMTY1IDAgLTI1Ny41IDkyLjV0LTkyLjUgMjU3LjV2NDAwIHEwIDE2NSA5Mi41IDI1Ny41dDI1Ny41IDkyLjV6TTkzOCA4NjdsMzI0IC0yODRxMTYgLTE0IDE2IC0zM3QtMTYgLTMzbC0zMjQgLTI4NHEtMTYgLTE0IC0yNyAtOXQtMTEgMjZ2MTUwaC0yNTBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djIwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjVoMjUwdjE1MHEwIDIxIDExIDI2dDI3IC05eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxNjQ7IiBkPSJNNzUwIDEyMDBoNDAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di00MDBxMCAtMjEgLTEwLjUgLTI1dC0yNC41IDEwbC0xMDkgMTA5bC0zMTIgLTMxMnEtMTUgLTE1IC0zNS41IC0xNXQtMzUuNSAxNWwtMTQxIDE0MXEtMTUgMTUgLTE1IDM1LjV0MTUgMzUuNWwzMTIgMzEybC0xMDkgMTA5cS0xNCAxNCAtMTAgMjQuNXQyNSAxMC41ek00NTYgOTAwaC0xNTZxLTQxIDAgLTcwLjUgLTI5LjV0LTI5LjUgLTcwLjV2LTUwMCBxMCAtNDEgMjkuNSAtNzAuNXQ3MC41IC0yOS41aDUwMHE0MSAwIDcwLjUgMjkuNXQyOS41IDcwLjV2MTQ4bDIwMCAyMDB2LTI5OHEwIC0xNjUgLTkzLjUgLTI1Ny41dC0yNTYuNSAtOTIuNWgtNDAwcS0xNjUgMCAtMjU3LjUgOTIuNXQtOTIuNSAyNTcuNXY0MDBxMCAxNjUgOTIuNSAyNTcuNXQyNTcuNSA5Mi41aDMwMHoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMTY1OyIgZD0iTTYwMCAxMTg2cTExOSAwIDIyNy41IC00Ni41dDE4NyAtMTI1dDEyNSAtMTg3dDQ2LjUgLTIyNy41dC00Ni41IC0yMjcuNXQtMTI1IC0xODd0LTE4NyAtMTI1dC0yMjcuNSAtNDYuNXQtMjI3LjUgNDYuNXQtMTg3IDEyNXQtMTI1IDE4N3QtNDYuNSAyMjcuNXQ0Ni41IDIyNy41dDEyNSAxODd0MTg3IDEyNXQyMjcuNSA0Ni41ek02MDAgMTAyMnEtMTE1IDAgLTIxMiAtNTYuNXQtMTUzLjUgLTE1My41dC01Ni41IC0yMTJ0NTYuNSAtMjEyIHQxNTMuNSAtMTUzLjV0MjEyIC01Ni41dDIxMiA1Ni41dDE1My41IDE1My41dDU2LjUgMjEydC01Ni41IDIxMnQtMTUzLjUgMTUzLjV0LTIxMiA1Ni41ek02MDAgNzk0cTgwIDAgMTM3IC01N3Q1NyAtMTM3dC01NyAtMTM3dC0xMzcgLTU3dC0xMzcgNTd0LTU3IDEzN3Q1NyAxMzd0MTM3IDU3eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxNjY7IiBkPSJNNDUwIDEyMDBoMjAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di0zNTBoMjQ1cTIwIDAgMjUgLTExdC05IC0yNmwtMzgzIC00MjZxLTE0IC0xNSAtMzMuNSAtMTV0LTMyLjUgMTVsLTM3OSA0MjZxLTEzIDE1IC04LjUgMjZ0MjUuNSAxMWgyNTB2MzUwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXpNNTAgMzAwaDEwMDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTI1MGgtMTEwMHYyNTBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41eiBNOTAwIDIwMHYtNTBoMTAwdjUwaC0xMDB6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTE2NzsiIGQ9Ik01ODMgMTE4MmwzNzggLTQzNXExNCAtMTUgOSAtMzF0LTI2IC0xNmgtMjQ0di0yNTBxMCAtMjAgLTE3IC0zNXQtMzkgLTE1aC0yMDBxLTIwIDAgLTMyIDE0LjV0LTEyIDM1LjV2MjUwaC0yNTBxLTIwIDAgLTI1LjUgMTYuNXQ4LjUgMzEuNWwzODMgNDMxcTE0IDE2IDMzLjUgMTd0MzMuNSAtMTR6TTUwIDMwMGgxMDAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di0yNTBoLTExMDB2MjUwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXogTTkwMCAyMDB2LTUwaDEwMHY1MGgtMTAweiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxNjg7IiBkPSJNMzk2IDcyM2wzNjkgMzY5cTcgNyAxNy41IDd0MTcuNSAtN2wxMzkgLTEzOXE3IC04IDcgLTE4LjV0LTcgLTE3LjVsLTUyNSAtNTI1cS03IC04IC0xNy41IC04dC0xNy41IDhsLTI5MiAyOTFxLTcgOCAtNyAxOHQ3IDE4bDEzOSAxMzlxOCA3IDE4LjUgN3QxNy41IC03ek01MCAzMDBoMTAwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtMjUwaC0xMTAwdjI1MHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6TTkwMCAyMDB2LTUwaDEwMHY1MCBoLTEwMHoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMTY5OyIgZD0iTTEzNSAxMDIzbDE0MiAxNDJxMTQgMTQgMzUgMTR0MzUgLTE0bDc3IC03N2wtMjEyIC0yMTJsLTc3IDc2cS0xNCAxNSAtMTQgMzZ0MTQgMzV6TTY1NSA4NTVsMjEwIDIxMHExNCAxNCAyNC41IDEwdDEwLjUgLTI1bC0yIC01OTlxLTEgLTIwIC0xNS41IC0zNXQtMzUuNSAtMTVsLTU5NyAtMXEtMjEgMCAtMjUgMTAuNXQxMCAyNC41bDIwOCAyMDhsLTE1NCAxNTVsMjEyIDIxMnpNNTAgMzAwaDEwMDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjUgdi0yNTBoLTExMDB2MjUwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXpNOTAwIDIwMHYtNTBoMTAwdjUwaC0xMDB6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTE3MDsiIGQ9Ik0zNTAgMTIwMGw1OTkgLTJxMjAgLTEgMzUgLTE1LjV0MTUgLTM1LjVsMSAtNTk3cTAgLTIxIC0xMC41IC0yNXQtMjQuNSAxMGwtMjA4IDIwOGwtMTU1IC0xNTRsLTIxMiAyMTJsMTU1IDE1NGwtMjEwIDIxMHEtMTQgMTQgLTEwIDI0LjV0MjUgMTAuNXpNNTI0IDUxMmwtNzYgLTc3cS0xNSAtMTQgLTM2IC0xNHQtMzUgMTRsLTE0MiAxNDJxLTE0IDE0IC0xNCAzNXQxNCAzNWw3NyA3N3pNNTAgMzAwaDEwMDBxMjEgMCAzNS41IC0xNC41IHQxNC41IC0zNS41di0yNTBoLTExMDB2MjUwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXpNOTAwIDIwMHYtNTBoMTAwdjUwaC0xMDB6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTE3MTsiIGQ9Ik0xMjAwIDEwM2wtNDgzIDI3NmwtMzE0IC0zOTl2NDIzaC0zOTlsMTE5NiA3OTZ2LTEwOTZ6TTQ4MyA0MjR2LTIzMGw2ODMgOTUzeiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxNzI7IiBkPSJNMTEwMCAxMDAwdi04NTBxMCAtMjEgLTE0LjUgLTM1LjV0LTM1LjUgLTE0LjVoLTE1MHY0MDBoLTcwMHYtNDAwaC0xNTBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djEwMDBxMCAyMCAxNC41IDM1dDM1LjUgMTVoMjUwdi0zMDBoNTAwdjMwMGgxMDB6TTcwMCAxMDAwaC0xMDB2MjAwaDEwMHYtMjAweiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxNzM7IiBkPSJNMTEwMCAxMDAwbC0yIC0xNDlsLTI5OSAtMjk5bC05NSA5NXEtOSA5IC0yMS41IDl0LTIxLjUgLTlsLTE0OSAtMTQ3aC0zMTJ2LTQwMGgtMTUwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXYxMDAwcTAgMjAgMTQuNSAzNXQzNS41IDE1aDI1MHYtMzAwaDUwMHYzMDBoMTAwek03MDAgMTAwMGgtMTAwdjIwMGgxMDB2LTIwMHpNMTEzMiA2MzhsMTA2IC0xMDZxNyAtNyA3IC0xNy41dC03IC0xNy41bC00MjAgLTQyMXEtOCAtNyAtMTggLTcgdC0xOCA3bC0yMDIgMjAzcS04IDcgLTggMTcuNXQ4IDE3LjVsMTA2IDEwNnE3IDggMTcuNSA4dDE3LjUgLThsNzkgLTc5bDI5NyAyOTdxNyA3IDE3LjUgN3QxNy41IC03eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxNzQ7IiBkPSJNMTEwMCAxMDAwdi0yNjlsLTEwMyAtMTAzbC0xMzQgMTM0cS0xNSAxNSAtMzMuNSAxNi41dC0zNC41IC0xMi41bC0yNjYgLTI2NmgtMzI5di00MDBoLTE1MHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2MTAwMHEwIDIwIDE0LjUgMzV0MzUuNSAxNWgyNTB2LTMwMGg1MDB2MzAwaDEwMHpNNzAwIDEwMDBoLTEwMHYyMDBoMTAwdi0yMDB6TTEyMDIgNTcybDcwIC03MHExNSAtMTUgMTUgLTM1LjV0LTE1IC0zNS41bC0xMzEgLTEzMSBsMTMxIC0xMzFxMTUgLTE1IDE1IC0zNS41dC0xNSAtMzUuNWwtNzAgLTcwcS0xNSAtMTUgLTM1LjUgLTE1dC0zNS41IDE1bC0xMzEgMTMxbC0xMzEgLTEzMXEtMTUgLTE1IC0zNS41IC0xNXQtMzUuNSAxNWwtNzAgNzBxLTE1IDE1IC0xNSAzNS41dDE1IDM1LjVsMTMxIDEzMWwtMTMxIDEzMXEtMTUgMTUgLTE1IDM1LjV0MTUgMzUuNWw3MCA3MHExNSAxNSAzNS41IDE1dDM1LjUgLTE1bDEzMSAtMTMxbDEzMSAxMzFxMTUgMTUgMzUuNSAxNSB0MzUuNSAtMTV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTE3NTsiIGQ9Ik0xMTAwIDEwMDB2LTMwMGgtMzUwcS0yMSAwIC0zNS41IC0xNC41dC0xNC41IC0zNS41di0xNTBoLTUwMHYtNDAwaC0xNTBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djEwMDBxMCAyMCAxNC41IDM1dDM1LjUgMTVoMjUwdi0zMDBoNTAwdjMwMGgxMDB6TTcwMCAxMDAwaC0xMDB2MjAwaDEwMHYtMjAwek04NTAgNjAwaDEwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtMjUwaDE1MHEyMSAwIDI1IC0xMC41dC0xMCAtMjQuNSBsLTIzMCAtMjMwcS0xNCAtMTQgLTM1IC0xNHQtMzUgMTRsLTIzMCAyMzBxLTE0IDE0IC0xMCAyNC41dDI1IDEwLjVoMTUwdjI1MHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTE3NjsiIGQ9Ik0xMTAwIDEwMDB2LTQwMGwtMTY1IDE2NXEtMTQgMTUgLTM1IDE1dC0zNSAtMTVsLTI2MyAtMjY1aC00MDJ2LTQwMGgtMTUwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXYxMDAwcTAgMjAgMTQuNSAzNXQzNS41IDE1aDI1MHYtMzAwaDUwMHYzMDBoMTAwek03MDAgMTAwMGgtMTAwdjIwMGgxMDB2LTIwMHpNOTM1IDU2NWwyMzAgLTIyOXExNCAtMTUgMTAgLTI1LjV0LTI1IC0xMC41aC0xNTB2LTI1MHEwIC0yMCAtMTQuNSAtMzUgdC0zNS41IC0xNWgtMTAwcS0yMSAwIC0zNS41IDE1dC0xNC41IDM1djI1MGgtMTUwcS0yMSAwIC0yNSAxMC41dDEwIDI1LjVsMjMwIDIyOXExNCAxNSAzNSAxNXQzNSAtMTV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTE3NzsiIGQ9Ik01MCAxMTAwaDExMDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTE1MGgtMTIwMHYxNTBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41ek0xMjAwIDgwMHYtNTUwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC0xMTAwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXY1NTBoMTIwMHpNMTAwIDUwMHYtMjAwaDQwMHYyMDBoLTQwMHoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMTc4OyIgZD0iTTkzNSAxMTY1bDI0OCAtMjMwcTE0IC0xNCAxNCAtMzV0LTE0IC0zNWwtMjQ4IC0yMzBxLTE0IC0xNCAtMjQuNSAtMTB0LTEwLjUgMjV2MTUwaC00MDB2MjAwaDQwMHYxNTBxMCAyMSAxMC41IDI1dDI0LjUgLTEwek0yMDAgODAwaC01MHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2MTAwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNWg1MHYtMjAwek00MDAgODAwaC0xMDB2MjAwaDEwMHYtMjAwek0xOCA0MzVsMjQ3IDIzMCBxMTQgMTQgMjQuNSAxMHQxMC41IC0yNXYtMTUwaDQwMHYtMjAwaC00MDB2LTE1MHEwIC0yMSAtMTAuNSAtMjV0LTI0LjUgMTBsLTI0NyAyMzBxLTE1IDE0IC0xNSAzNXQxNSAzNXpNOTAwIDMwMGgtMTAwdjIwMGgxMDB2LTIwMHpNMTAwMCA1MDBoNTFxMjAgMCAzNC41IC0xNC41dDE0LjUgLTM1LjV2LTEwMHEwIC0yMSAtMTQuNSAtMzUuNXQtMzQuNSAtMTQuNWgtNTF2MjAweiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxNzk7IiBkPSJNODYyIDEwNzNsMjc2IDExNnEyNSAxOCA0My41IDh0MTguNSAtNDF2LTExMDZxMCAtMjEgLTE0LjUgLTM1LjV0LTM1LjUgLTE0LjVoLTIwMHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2Mzk3cS00IDEgLTExIDV0LTI0IDE3LjV0LTMwIDI5dC0yNCA0MnQtMTEgNTYuNXYzNTlxMCAzMSAxOC41IDY1dDQzLjUgNTJ6TTU1MCAxMjAwcTIyIDAgMzQuNSAtMTIuNXQxNC41IC0yNC41bDEgLTEzdi00NTBxMCAtMjggLTEwLjUgLTU5LjUgdC0yNSAtNTZ0LTI5IC00NXQtMjUuNSAtMzEuNWwtMTAgLTExdi00NDdxMCAtMjEgLTE0LjUgLTM1LjV0LTM1LjUgLTE0LjVoLTIwMHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2NDQ3cS00IDQgLTExIDExLjV0LTI0IDMwLjV0LTMwIDQ2dC0yNCA1NXQtMTEgNjB2NDUwcTAgMiAwLjUgNS41dDQgMTJ0OC41IDE1dDE0LjUgMTJ0MjIuNSA1LjVxMjAgMCAzMi41IC0xMi41dDE0LjUgLTI0LjVsMyAtMTN2LTM1MGgxMDB2MzUwdjUuNXQyLjUgMTIgdDcgMTV0MTUgMTJ0MjUuNSA1LjVxMjMgMCAzNS41IC0xMi41dDEzLjUgLTI0LjVsMSAtMTN2LTM1MGgxMDB2MzUwcTAgMiAwLjUgNS41dDMgMTJ0NyAxNXQxNSAxMnQyNC41IDUuNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMTgwOyIgZD0iTTEyMDAgMTEwMHYtNTZxLTQgMCAtMTEgLTAuNXQtMjQgLTN0LTMwIC03LjV0LTI0IC0xNXQtMTEgLTI0di04ODhxMCAtMjIgMjUgLTM0LjV0NTAgLTEzLjVsMjUgLTJ2LTU2aC00MDB2NTZxNzUgMCA4Ny41IDYuNXQxMi41IDQzLjV2Mzk0aC01MDB2LTM5NHEwIC0zNyAxMi41IC00My41dDg3LjUgLTYuNXYtNTZoLTQwMHY1NnE0IDAgMTEgMC41dDI0IDN0MzAgNy41dDI0IDE1dDExIDI0djg4OHEwIDIyIC0yNSAzNC41dC01MCAxMy41IGwtMjUgMnY1Nmg0MDB2LTU2cS03NSAwIC04Ny41IC02LjV0LTEyLjUgLTQzLjV2LTM5NGg1MDB2Mzk0cTAgMzcgLTEyLjUgNDMuNXQtODcuNSA2LjV2NTZoNDAweiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxODE7IiBkPSJNNjc1IDEwMDBoMzc1cTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di0xNTBoLTEwNWwtMjk1IC05OHY5OGwtMjAwIDIwMGgtNDAwbDEwMCAxMDBoMzc1ek0xMDAgOTAwaDMwMHE0MSAwIDcwLjUgLTI5LjV0MjkuNSAtNzAuNXYtNTAwcTAgLTQxIC0yOS41IC03MC41dC03MC41IC0yOS41aC0zMDBxLTQxIDAgLTcwLjUgMjkuNXQtMjkuNSA3MC41djUwMHEwIDQxIDI5LjUgNzAuNXQ3MC41IDI5LjV6TTEwMCA4MDB2LTIwMGgzMDB2MjAwIGgtMzAwek0xMTAwIDUzNWwtNDAwIC0xMzN2MTYzbDQwMCAxMzN2LTE2M3pNMTAwIDUwMHYtMjAwaDMwMHYyMDBoLTMwMHpNMTEwMCAzOTh2LTI0OHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtMzc1bC0xMDAgLTEwMGgtMzc1bC0xMDAgMTAwaDQwMGwyMDAgMjAwaDEwNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMTgyOyIgZD0iTTE3IDEwMDdsMTYyIDE2MnExNyAxNyA0MCAxNHQzNyAtMjJsMTM5IC0xOTRxMTQgLTIwIDExIC00NC41dC0yMCAtNDEuNWwtMTE5IC0xMThxMTAyIC0xNDIgMjI4IC0yNjh0MjY3IC0yMjdsMTE5IDExOHExNyAxNyA0Mi41IDE5dDQ0LjUgLTEybDE5MiAtMTM2cTE5IC0xNCAyMi41IC0zNy41dC0xMy41IC00MC41bC0xNjMgLTE2MnEtMyAtMSAtOS41IC0xdC0yOS41IDJ0LTQ3LjUgNnQtNjIuNSAxNC41dC03Ny41IDI2LjV0LTkwIDQyLjUgdC0xMDEuNSA2MHQtMTExIDgzdC0xMTkgMTA4LjVxLTc0IDc0IC0xMzMuNSAxNTAuNXQtOTQuNSAxMzguNXQtNjAgMTE5LjV0LTM0LjUgMTAwdC0xNSA3NC41dC00LjUgNDh6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTE4MzsiIGQ9Ik02MDAgMTEwMHE5MiAwIDE3NSAtMTAuNXQxNDEuNSAtMjd0MTA4LjUgLTM2LjV0ODEuNSAtNDB0NTMuNSAtMzd0MzEgLTI3bDkgLTEwdi0yMDBxMCAtMjEgLTE0LjUgLTMzdC0zNC41IC05bC0yMDIgMzRxLTIwIDMgLTM0LjUgMjB0LTE0LjUgMzh2MTQ2cS0xNDEgMjQgLTMwMCAyNHQtMzAwIC0yNHYtMTQ2cTAgLTIxIC0xNC41IC0zOHQtMzQuNSAtMjBsLTIwMiAtMzRxLTIwIC0zIC0zNC41IDl0LTE0LjUgMzN2MjAwcTMgNCA5LjUgMTAuNSB0MzEgMjZ0NTQgMzcuNXQ4MC41IDM5LjV0MTA5IDM3LjV0MTQxIDI2LjV0MTc1IDEwLjV6TTYwMCA3OTVxNTYgMCA5NyAtOS41dDYwIC0yMy41dDMwIC0yOHQxMiAtMjRsMSAtMTB2LTUwbDM2NSAtMzAzcTE0IC0xNSAyNC41IC00MHQxMC41IC00NXYtMjEycTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC0xMTAwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXYyMTJxMCAyMCAxMC41IDQ1dDI0LjUgNDBsMzY1IDMwM3Y1MCBxMCA0IDEgMTAuNXQxMiAyM3QzMCAyOXQ2MCAyMi41dDk3IDEweiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxODQ7IiBkPSJNMTEwMCA3MDBsLTIwMCAtMjAwaC02MDBsLTIwMCAyMDB2NTAwaDIwMHYtMjAwaDIwMHYyMDBoMjAwdi0yMDBoMjAwdjIwMGgyMDB2LTUwMHpNMjUwIDQwMGg3MDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV0LTE0LjUgLTM1LjV0LTM1LjUgLTE0LjVoLTEybDEzNyAtMTAwaC05NTBsMTM3IDEwMGgtMTJxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41dDE0LjUgMzUuNXQzNS41IDE0LjV6TTUwIDEwMGgxMTAwcTIxIDAgMzUuNSAtMTQuNSB0MTQuNSAtMzUuNXYtNTBoLTEyMDB2NTBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxODU7IiBkPSJNNzAwIDExMDBoLTEwMHEtNDEgMCAtNzAuNSAtMjkuNXQtMjkuNSAtNzAuNXYtMTAwMGgzMDB2MTAwMHEwIDQxIC0yOS41IDcwLjV0LTcwLjUgMjkuNXpNMTEwMCA4MDBoLTEwMHEtNDEgMCAtNzAuNSAtMjkuNXQtMjkuNSAtNzAuNXYtNzAwaDMwMHY3MDBxMCA0MSAtMjkuNSA3MC41dC03MC41IDI5LjV6TTQwMCAwaC0zMDB2NDAwcTAgNDEgMjkuNSA3MC41dDcwLjUgMjkuNWgxMDBxNDEgMCA3MC41IC0yOS41dDI5LjUgLTcwLjV2LTQwMHogIiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTE4NjsiIGQ9Ik0yMDAgMTEwMGg3MDBxMTI0IDAgMjEyIC04OHQ4OCAtMjEydi01MDBxMCAtMTI0IC04OCAtMjEydC0yMTIgLTg4aC03MDBxLTEyNCAwIC0yMTIgODh0LTg4IDIxMnY1MDBxMCAxMjQgODggMjEydDIxMiA4OHpNMTAwIDkwMHYtNzAwaDkwMHY3MDBoLTkwMHpNNTAwIDcwMGgtMjAwdi0xMDBoMjAwdi0zMDBoLTMwMHYxMDBoMjAwdjEwMGgtMjAwdjMwMGgzMDB2LTEwMHpNOTAwIDcwMHYtMzAwbC0xMDAgLTEwMGgtMjAwdjUwMGgyMDB6IE03MDAgNzAwdi0zMDBoMTAwdjMwMGgtMTAweiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxODc7IiBkPSJNMjAwIDExMDBoNzAwcTEyNCAwIDIxMiAtODh0ODggLTIxMnYtNTAwcTAgLTEyNCAtODggLTIxMnQtMjEyIC04OGgtNzAwcS0xMjQgMCAtMjEyIDg4dC04OCAyMTJ2NTAwcTAgMTI0IDg4IDIxMnQyMTIgODh6TTEwMCA5MDB2LTcwMGg5MDB2NzAwaC05MDB6TTUwMCAzMDBoLTEwMHYyMDBoLTEwMHYtMjAwaC0xMDB2NTAwaDEwMHYtMjAwaDEwMHYyMDBoMTAwdi01MDB6TTkwMCA3MDB2LTMwMGwtMTAwIC0xMDBoLTIwMHY1MDBoMjAweiBNNzAwIDcwMHYtMzAwaDEwMHYzMDBoLTEwMHoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMTg4OyIgZD0iTTIwMCAxMTAwaDcwMHExMjQgMCAyMTIgLTg4dDg4IC0yMTJ2LTUwMHEwIC0xMjQgLTg4IC0yMTJ0LTIxMiAtODhoLTcwMHEtMTI0IDAgLTIxMiA4OHQtODggMjEydjUwMHEwIDEyNCA4OCAyMTJ0MjEyIDg4ek0xMDAgOTAwdi03MDBoOTAwdjcwMGgtOTAwek01MDAgNzAwaC0yMDB2LTMwMGgyMDB2LTEwMGgtMzAwdjUwMGgzMDB2LTEwMHpNOTAwIDcwMGgtMjAwdi0zMDBoMjAwdi0xMDBoLTMwMHY1MDBoMzAwdi0xMDB6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTE4OTsiIGQ9Ik0yMDAgMTEwMGg3MDBxMTI0IDAgMjEyIC04OHQ4OCAtMjEydi01MDBxMCAtMTI0IC04OCAtMjEydC0yMTIgLTg4aC03MDBxLTEyNCAwIC0yMTIgODh0LTg4IDIxMnY1MDBxMCAxMjQgODggMjEydDIxMiA4OHpNMTAwIDkwMHYtNzAwaDkwMHY3MDBoLTkwMHpNNTAwIDQwMGwtMzAwIDE1MGwzMDAgMTUwdi0zMDB6TTkwMCA1NTBsLTMwMCAtMTUwdjMwMHoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMTkwOyIgZD0iTTIwMCAxMTAwaDcwMHExMjQgMCAyMTIgLTg4dDg4IC0yMTJ2LTUwMHEwIC0xMjQgLTg4IC0yMTJ0LTIxMiAtODhoLTcwMHEtMTI0IDAgLTIxMiA4OHQtODggMjEydjUwMHEwIDEyNCA4OCAyMTJ0MjEyIDg4ek0xMDAgOTAwdi03MDBoOTAwdjcwMGgtOTAwek05MDAgMzAwaC03MDB2NTAwaDcwMHYtNTAwek04MDAgNzAwaC0xMzBxLTM4IDAgLTY2LjUgLTQzdC0yOC41IC0xMDh0MjcgLTEwN3Q2OCAtNDJoMTMwdjMwMHpNMzAwIDcwMHYtMzAwIGgxMzBxNDEgMCA2OCA0MnQyNyAxMDd0LTI4LjUgMTA4dC02Ni41IDQzaC0xMzB6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTE5MTsiIGQ9Ik0yMDAgMTEwMGg3MDBxMTI0IDAgMjEyIC04OHQ4OCAtMjEydi01MDBxMCAtMTI0IC04OCAtMjEydC0yMTIgLTg4aC03MDBxLTEyNCAwIC0yMTIgODh0LTg4IDIxMnY1MDBxMCAxMjQgODggMjEydDIxMiA4OHpNMTAwIDkwMHYtNzAwaDkwMHY3MDBoLTkwMHpNNTAwIDcwMGgtMjAwdi0xMDBoMjAwdi0zMDBoLTMwMHYxMDBoMjAwdjEwMGgtMjAwdjMwMGgzMDB2LTEwMHpNOTAwIDMwMGgtMTAwdjQwMGgtMTAwdjEwMGgyMDB2LTUwMHogTTcwMCAzMDBoLTEwMHYxMDBoMTAwdi0xMDB6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTE5MjsiIGQ9Ik0yMDAgMTEwMGg3MDBxMTI0IDAgMjEyIC04OHQ4OCAtMjEydi01MDBxMCAtMTI0IC04OCAtMjEydC0yMTIgLTg4aC03MDBxLTEyNCAwIC0yMTIgODh0LTg4IDIxMnY1MDBxMCAxMjQgODggMjEydDIxMiA4OHpNMTAwIDkwMHYtNzAwaDkwMHY3MDBoLTkwMHpNMzAwIDcwMGgyMDB2LTQwMGgtMzAwdjUwMGgxMDB2LTEwMHpNOTAwIDMwMGgtMTAwdjQwMGgtMTAwdjEwMGgyMDB2LTUwMHpNMzAwIDYwMHYtMjAwaDEwMHYyMDBoLTEwMHogTTcwMCAzMDBoLTEwMHYxMDBoMTAwdi0xMDB6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTE5MzsiIGQ9Ik0yMDAgMTEwMGg3MDBxMTI0IDAgMjEyIC04OHQ4OCAtMjEydi01MDBxMCAtMTI0IC04OCAtMjEydC0yMTIgLTg4aC03MDBxLTEyNCAwIC0yMTIgODh0LTg4IDIxMnY1MDBxMCAxMjQgODggMjEydDIxMiA4OHpNMTAwIDkwMHYtNzAwaDkwMHY3MDBoLTkwMHpNNTAwIDUwMGwtMTk5IC0yMDBoLTEwMHY1MGwxOTkgMjAwdjE1MGgtMjAwdjEwMGgzMDB2LTMwMHpNOTAwIDMwMGgtMTAwdjQwMGgtMTAwdjEwMGgyMDB2LTUwMHpNNzAxIDMwMGgtMTAwIHYxMDBoMTAwdi0xMDB6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTE5NDsiIGQ9Ik02MDAgMTE5MXExMjAgMCAyMjkuNSAtNDd0MTg4LjUgLTEyNnQxMjYgLTE4OC41dDQ3IC0yMjkuNXQtNDcgLTIyOS41dC0xMjYgLTE4OC41dC0xODguNSAtMTI2dC0yMjkuNSAtNDd0LTIyOS41IDQ3dC0xODguNSAxMjZ0LTEyNiAxODguNXQtNDcgMjI5LjV0NDcgMjI5LjV0MTI2IDE4OC41dDE4OC41IDEyNnQyMjkuNSA0N3pNNjAwIDEwMjFxLTExNCAwIC0yMTEgLTU2LjV0LTE1My41IC0xNTMuNXQtNTYuNSAtMjExdDU2LjUgLTIxMSB0MTUzLjUgLTE1My41dDIxMSAtNTYuNXQyMTEgNTYuNXQxNTMuNSAxNTMuNXQ1Ni41IDIxMXQtNTYuNSAyMTF0LTE1My41IDE1My41dC0yMTEgNTYuNXpNODAwIDcwMGgtMzAwdi0yMDBoMzAwdi0xMDBoLTMwMGwtMTAwIDEwMHYyMDBsMTAwIDEwMGgzMDB2LTEwMHoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMTk1OyIgZD0iTTYwMCAxMTkxcTEyMCAwIDIyOS41IC00N3QxODguNSAtMTI2dDEyNiAtMTg4LjV0NDcgLTIyOS41dC00NyAtMjI5LjV0LTEyNiAtMTg4LjV0LTE4OC41IC0xMjZ0LTIyOS41IC00N3QtMjI5LjUgNDd0LTE4OC41IDEyNnQtMTI2IDE4OC41dC00NyAyMjkuNXQ0NyAyMjkuNXQxMjYgMTg4LjV0MTg4LjUgMTI2dDIyOS41IDQ3ek02MDAgMTAyMXEtMTE0IDAgLTIxMSAtNTYuNXQtMTUzLjUgLTE1My41dC01Ni41IC0yMTF0NTYuNSAtMjExIHQxNTMuNSAtMTUzLjV0MjExIC01Ni41dDIxMSA1Ni41dDE1My41IDE1My41dDU2LjUgMjExdC01Ni41IDIxMXQtMTUzLjUgMTUzLjV0LTIxMSA1Ni41ek04MDAgNzAwdi0xMDBsLTUwIC01MGwxMDAgLTEwMHYtNTBoLTEwMGwtMTAwIDEwMGgtMTUwdi0xMDBoLTEwMHY0MDBoMzAwek01MDAgNzAwdi0xMDBoMjAwdjEwMGgtMjAweiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxOTc7IiBkPSJNNTAzIDEwODlxMTEwIDAgMjAwLjUgLTU5LjV0MTM0LjUgLTE1Ni41cTQ0IDE0IDkwIDE0cTEyMCAwIDIwNSAtODYuNXQ4NSAtMjA3dC04NSAtMjA3dC0yMDUgLTg2LjVoLTEyOHYyNTBxMCAyMSAtMTQuNSAzNS41dC0zNS41IDE0LjVoLTMwMHEtMjEgMCAtMzUuNSAtMTQuNXQtMTQuNSAtMzUuNXYtMjUwaC0yMjJxLTgwIDAgLTEzNiA1Ny41dC01NiAxMzYuNXEwIDY5IDQzIDEyMi41dDEwOCA2Ny41cS0yIDE5IC0yIDM3cTAgMTAwIDQ5IDE4NSB0MTM0IDEzNHQxODUgNDl6TTUyNSA1MDBoMTUwcTEwIDAgMTcuNSAtNy41dDcuNSAtMTcuNXYtMjc1aDEzN3EyMSAwIDI2IC0xMS41dC04IC0yNy41bC0yMjMgLTI0NHEtMTMgLTE2IC0zMiAtMTZ0LTMyIDE2bC0yMjMgMjQ0cS0xMyAxNiAtOCAyNy41dDI2IDExLjVoMTM3djI3NXEwIDEwIDcuNSAxNy41dDE3LjUgNy41eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUxOTg7IiBkPSJNNTAyIDEwODlxMTEwIDAgMjAxIC01OS41dDEzNSAtMTU2LjVxNDMgMTUgODkgMTVxMTIxIDAgMjA2IC04Ni41dDg2IC0yMDYuNXEwIC05OSAtNjAgLTE4MXQtMTUwIC0xMTBsLTM3OCAzNjBxLTEzIDE2IC0zMS41IDE2dC0zMS41IC0xNmwtMzgxIC0zNjVoLTlxLTc5IDAgLTEzNS41IDU3LjV0LTU2LjUgMTM2LjVxMCA2OSA0MyAxMjIuNXQxMDggNjcuNXEtMiAxOSAtMiAzOHEwIDEwMCA0OSAxODQuNXQxMzMuNSAxMzR0MTg0LjUgNDkuNXogTTYzMiA0NjdsMjIzIC0yMjhxMTMgLTE2IDggLTI3LjV0LTI2IC0xMS41aC0xMzd2LTI3NXEwIC0xMCAtNy41IC0xNy41dC0xNy41IC03LjVoLTE1MHEtMTAgMCAtMTcuNSA3LjV0LTcuNSAxNy41djI3NWgtMTM3cS0yMSAwIC0yNiAxMS41dDggMjcuNXExOTkgMjA0IDIyMyAyMjhxMTkgMTkgMzEuNSAxOXQzMi41IC0xOXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMTk5OyIgZD0iTTcwMCAxMDB2MTAwaDQwMGwtMjcwIDMwMGgxNzBsLTI3MCAzMDBoMTcwbC0zMDAgMzMzbC0zMDAgLTMzM2gxNzBsLTI3MCAtMzAwaDE3MGwtMjcwIC0zMDBoNDAwdi0xMDBoLTUwcS0yMSAwIC0zNS41IC0xNC41dC0xNC41IC0zNS41di01MGg0MDB2NTBxMCAyMSAtMTQuNSAzNS41dC0zNS41IDE0LjVoLTUweiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUyMDA7IiBkPSJNNjAwIDExNzlxOTQgMCAxNjcuNSAtNTYuNXQ5OS41IC0xNDUuNXE4OSAtNiAxNTAuNSAtNzEuNXQ2MS41IC0xNTUuNXEwIC02MSAtMjkuNSAtMTEyLjV0LTc5LjUgLTgyLjVxOSAtMjkgOSAtNTVxMCAtNzQgLTUyLjUgLTEyNi41dC0xMjYuNSAtNTIuNXEtNTUgMCAtMTAwIDMwdi0yNTFxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTUwaC0zMDB2NTBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41djI1MXEtNDUgLTMwIC0xMDAgLTMwIHEtNzQgMCAtMTI2LjUgNTIuNXQtNTIuNSAxMjYuNXEwIDE4IDQgMzhxLTQ3IDIxIC03NS41IDY1dC0yOC41IDk3cTAgNzQgNTIuNSAxMjYuNXQxMjYuNSA1Mi41cTUgMCAyMyAtMnEwIDIgLTEgMTB0LTEgMTNxMCAxMTYgODEuNSAxOTcuNXQxOTcuNSA4MS41eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUyMDE7IiBkPSJNMTAxMCAxMDEwcTExMSAtMTExIDE1MC41IC0yNjAuNXQwIC0yOTl0LTE1MC41IC0yNjAuNXEtODMgLTgzIC0xOTEuNSAtMTI2LjV0LTIxOC41IC00My41dC0yMTguNSA0My41dC0xOTEuNSAxMjYuNXEtMTExIDExMSAtMTUwLjUgMjYwLjV0MCAyOTl0MTUwLjUgMjYwLjVxODMgODMgMTkxLjUgMTI2LjV0MjE4LjUgNDMuNXQyMTguNSAtNDMuNXQxOTEuNSAtMTI2LjV6TTQ3NiAxMDY1cS00IDAgLTggLTFxLTEyMSAtMzQgLTIwOS41IC0xMjIuNSB0LTEyMi41IC0yMDkuNXEtNCAtMTIgMi41IC0yM3QxOC41IC0xNGwzNiAtOXEzIC0xIDcgLTFxMjMgMCAyOSAyMnEyNyA5NiA5OCAxNjZxNzAgNzEgMTY2IDk4cTExIDMgMTcuNSAxMy41dDMuNSAyMi41bC05IDM1cS0zIDEzIC0xNCAxOXEtNyA0IC0xNSA0ek01MTIgOTIwcS00IDAgLTkgLTJxLTgwIC0yNCAtMTM4LjUgLTgyLjV0LTgyLjUgLTEzOC41cS00IC0xMyAyIC0yNHQxOSAtMTRsMzQgLTlxNCAtMSA4IC0xcTIyIDAgMjggMjEgcTE4IDU4IDU4LjUgOTguNXQ5Ny41IDU4LjVxMTIgMyAxOCAxMy41dDMgMjEuNWwtOSAzNXEtMyAxMiAtMTQgMTlxLTcgNCAtMTUgNHpNNzE5LjUgNzE5LjVxLTQ5LjUgNDkuNSAtMTE5LjUgNDkuNXQtMTE5LjUgLTQ5LjV0LTQ5LjUgLTExOS41dDQ5LjUgLTExOS41dDExOS41IC00OS41dDExOS41IDQ5LjV0NDkuNSAxMTkuNXQtNDkuNSAxMTkuNXpNODU1IDU1MXEtMjIgMCAtMjggLTIxcS0xOCAtNTggLTU4LjUgLTk4LjV0LTk4LjUgLTU3LjUgcS0xMSAtNCAtMTcgLTE0LjV0LTMgLTIxLjVsOSAtMzVxMyAtMTIgMTQgLTE5cTcgLTQgMTUgLTRxNCAwIDkgMnE4MCAyNCAxMzguNSA4Mi41dDgyLjUgMTM4LjVxNCAxMyAtMi41IDI0dC0xOC41IDE0bC0zNCA5cS00IDEgLTggMXpNMTAwMCA1MTVxLTIzIDAgLTI5IC0yMnEtMjcgLTk2IC05OCAtMTY2cS03MCAtNzEgLTE2NiAtOThxLTExIC0zIC0xNy41IC0xMy41dC0zLjUgLTIyLjVsOSAtMzVxMyAtMTMgMTQgLTE5cTcgLTQgMTUgLTQgcTQgMCA4IDFxMTIxIDM0IDIwOS41IDEyMi41dDEyMi41IDIwOS41cTQgMTIgLTIuNSAyM3QtMTguNSAxNGwtMzYgOXEtMyAxIC03IDF6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTIwMjsiIGQ9Ik03MDAgODAwaDMwMHYtMzgwaC0xODB2MjAwaC0zNDB2LTIwMGgtMzgwdjc1NXEwIDEwIDcuNSAxNy41dDE3LjUgNy41aDU3NXYtNDAwek0xMDAwIDkwMGgtMjAwdjIwMHpNNzAwIDMwMGgxNjJsLTIxMiAtMjEybC0yMTIgMjEyaDE2MnYyMDBoMTAwdi0yMDB6TTUyMCAwaC0zOTVxLTEwIDAgLTE3LjUgNy41dC03LjUgMTcuNXYzOTV6TTEwMDAgMjIwdi0xOTVxMCAtMTAgLTcuNSAtMTcuNXQtMTcuNSAtNy41aC0xOTV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTIwMzsiIGQ9Ik03MDAgODAwaDMwMHYtNTIwbC0zNTAgMzUwbC01NTAgLTU1MHYxMDk1cTAgMTAgNy41IDE3LjV0MTcuNSA3LjVoNTc1di00MDB6TTEwMDAgOTAwaC0yMDB2MjAwek04NjIgMjAwaC0xNjJ2LTIwMGgtMTAwdjIwMGgtMTYybDIxMiAyMTJ6TTQ4MCAwaC0zNTVxLTEwIDAgLTE3LjUgNy41dC03LjUgMTcuNXY1NWgzODB2LTgwek0xMDAwIDgwdi01NXEwIC0xMCAtNy41IC0xNy41dC0xNy41IC03LjVoLTE1NXY4MGgxODB6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTIwNDsiIGQ9Ik0xMTYyIDgwMGgtMTYydi0yMDBoMTAwbDEwMCAtMTAwaC0zMDB2MzAwaC0xNjJsMjEyIDIxMnpNMjAwIDgwMGgyMDBxMjcgMCA0MCAtMnQyOS41IC0xMC41dDIzLjUgLTMwdDcgLTU3LjVoMzAwdi0xMDBoLTYwMGwtMjAwIC0zNTB2NDUwaDEwMHEwIDM2IDcgNTcuNXQyMy41IDMwdDI5LjUgMTAuNXQ0MCAyek04MDAgNDAwaDI0MGwtMjQwIC00MDBoLTgwMGwzMDAgNTAwaDUwMHYtMTAweiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUyMDU7IiBkPSJNNjUwIDExMDBoMTAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di01MGg1MHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtMTAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC0zMDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djEwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjVoNTB2NTBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41ek0xMDAwIDg1MHYxNTBxNDEgMCA3MC41IC0yOS41dDI5LjUgLTcwLjV2LTgwMCBxMCAtNDEgLTI5LjUgLTcwLjV0LTcwLjUgLTI5LjVoLTYwMHEtMSAwIC0yMCA0bDI0NiAyNDZsLTMyNiAzMjZ2MzI0cTAgNDEgMjkuNSA3MC41dDcwLjUgMjkuNXYtMTUwcTAgLTYyIDQ0IC0xMDZ0MTA2IC00NGgzMDBxNjIgMCAxMDYgNDR0NDQgMTA2ek00MTIgMjUwbC0yMTIgLTIxMnYxNjJoLTIwMHYxMDBoMjAwdjE2MnoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMjA2OyIgZD0iTTQ1MCAxMTAwaDEwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtNTBoNTBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTEwMHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtMzAwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXYxMDBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41aDUwdjUwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXpNODAwIDg1MHYxNTBxNDEgMCA3MC41IC0yOS41dDI5LjUgLTcwLjV2LTUwMCBoLTIwMHYtMzAwaDIwMHEwIC0zNiAtNyAtNTcuNXQtMjMuNSAtMzB0LTI5LjUgLTEwLjV0LTQwIC0yaC02MDBxLTQxIDAgLTcwLjUgMjkuNXQtMjkuNSA3MC41djgwMHEwIDQxIDI5LjUgNzAuNXQ3MC41IDI5LjV2LTE1MHEwIC02MiA0NCAtMTA2dDEwNiAtNDRoMzAwcTYyIDAgMTA2IDQ0dDQ0IDEwNnpNMTIxMiAyNTBsLTIxMiAtMjEydjE2MmgtMjAwdjEwMGgyMDB2MTYyeiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUyMDk7IiBkPSJNNjU4IDExOTdsNjM3IC0xMTA0cTIzIC0zOCA3IC02NS41dC02MCAtMjcuNWgtMTI3NnEtNDQgMCAtNjAgMjcuNXQ3IDY1LjVsNjM3IDExMDRxMjIgMzkgNTQgMzl0NTQgLTM5ek03MDQgODAwaC0yMDhxLTIwIDAgLTMyIC0xNC41dC04IC0zNC41bDU4IC0zMDJxNCAtMjAgMjEuNSAtMzQuNXQzNy41IC0xNC41aDU0cTIwIDAgMzcuNSAxNC41dDIxLjUgMzQuNWw1OCAzMDJxNCAyMCAtOCAzNC41dC0zMiAxNC41ek01MDAgMzAwdi0xMDBoMjAwIHYxMDBoLTIwMHoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMjEwOyIgZD0iTTQyNSAxMTAwaDI1MHExMCAwIDE3LjUgLTcuNXQ3LjUgLTE3LjV2LTE1MHEwIC0xMCAtNy41IC0xNy41dC0xNy41IC03LjVoLTI1MHEtMTAgMCAtMTcuNSA3LjV0LTcuNSAxNy41djE1MHEwIDEwIDcuNSAxNy41dDE3LjUgNy41ek00MjUgODAwaDI1MHExMCAwIDE3LjUgLTcuNXQ3LjUgLTE3LjV2LTE1MHEwIC0xMCAtNy41IC0xNy41dC0xNy41IC03LjVoLTI1MHEtMTAgMCAtMTcuNSA3LjV0LTcuNSAxNy41djE1MHEwIDEwIDcuNSAxNy41IHQxNy41IDcuNXpNODI1IDgwMGgyNTBxMTAgMCAxNy41IC03LjV0Ny41IC0xNy41di0xNTBxMCAtMTAgLTcuNSAtMTcuNXQtMTcuNSAtNy41aC0yNTBxLTEwIDAgLTE3LjUgNy41dC03LjUgMTcuNXYxNTBxMCAxMCA3LjUgMTcuNXQxNy41IDcuNXpNMjUgNTAwaDI1MHExMCAwIDE3LjUgLTcuNXQ3LjUgLTE3LjV2LTE1MHEwIC0xMCAtNy41IC0xNy41dC0xNy41IC03LjVoLTI1MHEtMTAgMCAtMTcuNSA3LjV0LTcuNSAxNy41djE1MCBxMCAxMCA3LjUgMTcuNXQxNy41IDcuNXpNNDI1IDUwMGgyNTBxMTAgMCAxNy41IC03LjV0Ny41IC0xNy41di0xNTBxMCAtMTAgLTcuNSAtMTcuNXQtMTcuNSAtNy41aC0yNTBxLTEwIDAgLTE3LjUgNy41dC03LjUgMTcuNXYxNTBxMCAxMCA3LjUgMTcuNXQxNy41IDcuNXpNODI1IDUwMGgyNTBxMTAgMCAxNy41IC03LjV0Ny41IC0xNy41di0xNTBxMCAtMTAgLTcuNSAtMTcuNXQtMTcuNSAtNy41aC0yNTBxLTEwIDAgLTE3LjUgNy41dC03LjUgMTcuNSB2MTUwcTAgMTAgNy41IDE3LjV0MTcuNSA3LjV6TTI1IDIwMGgyNTBxMTAgMCAxNy41IC03LjV0Ny41IC0xNy41di0xNTBxMCAtMTAgLTcuNSAtMTcuNXQtMTcuNSAtNy41aC0yNTBxLTEwIDAgLTE3LjUgNy41dC03LjUgMTcuNXYxNTBxMCAxMCA3LjUgMTcuNXQxNy41IDcuNXpNNDI1IDIwMGgyNTBxMTAgMCAxNy41IC03LjV0Ny41IC0xNy41di0xNTBxMCAtMTAgLTcuNSAtMTcuNXQtMTcuNSAtNy41aC0yNTBxLTEwIDAgLTE3LjUgNy41IHQtNy41IDE3LjV2MTUwcTAgMTAgNy41IDE3LjV0MTcuNSA3LjV6TTgyNSAyMDBoMjUwcTEwIDAgMTcuNSAtNy41dDcuNSAtMTcuNXYtMTUwcTAgLTEwIC03LjUgLTE3LjV0LTE3LjUgLTcuNWgtMjUwcS0xMCAwIC0xNy41IDcuNXQtNy41IDE3LjV2MTUwcTAgMTAgNy41IDE3LjV0MTcuNSA3LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTIxMTsiIGQ9Ik03MDAgMTIwMGgxMDB2LTIwMGgtMTAwdi0xMDBoMzUwcTYyIDAgODYuNSAtMzkuNXQtMy41IC05NC41bC02NiAtMTMycS00MSAtODMgLTgxIC0xMzRoLTc3MnEtNDAgNTEgLTgxIDEzNGwtNjYgMTMycS0yOCA1NSAtMy41IDk0LjV0ODYuNSAzOS41aDM1MHYxMDBoLTEwMHYyMDBoMTAwdjEwMGgyMDB2LTEwMHpNMjUwIDQwMGg3MDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV0LTE0LjUgLTM1LjV0LTM1LjUgLTE0LjVoLTEybDEzNyAtMTAwIGgtOTUwbDEzOCAxMDBoLTEzcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXQxNC41IDM1LjV0MzUuNSAxNC41ek01MCAxMDBoMTEwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtNTBoLTEyMDB2NTBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUyMTI7IiBkPSJNNjAwIDEzMDBxNDAgMCA2OC41IC0yOS41dDI4LjUgLTcwLjVoLTE5NHEwIDQxIDI4LjUgNzAuNXQ2OC41IDI5LjV6TTQ0MyAxMTAwaDMxNHExOCAtMzcgMTggLTc1cTAgLTggLTMgLTI1aDMyOHE0MSAwIDQ0LjUgLTE2LjV0LTMwLjUgLTM4LjVsLTE3NSAtMTQ1aC02NzhsLTE3OCAxNDVxLTM0IDIyIC0yOSAzOC41dDQ2IDE2LjVoMzI4cS0zIDE3IC0zIDI1cTAgMzggMTggNzV6TTI1MCA3MDBoNzAwcTIxIDAgMzUuNSAtMTQuNSB0MTQuNSAtMzUuNXQtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtMTUwdi0yMDBsMjc1IC0yMDBoLTk1MGwyNzUgMjAwdjIwMGgtMTUwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXQxNC41IDM1LjV0MzUuNSAxNC41ek01MCAxMDBoMTEwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtNTBoLTEyMDB2NTBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUyMTM7IiBkPSJNNjAwIDExODFxNzUgMCAxMjggLTUzdDUzIC0xMjh0LTUzIC0xMjh0LTEyOCAtNTN0LTEyOCA1M3QtNTMgMTI4dDUzIDEyOHQxMjggNTN6TTYwMiA3OThoNDZxMzQgMCA1NS41IC0yOC41dDIxLjUgLTg2LjVxMCAtNzYgMzkgLTE4M2gtMzI0cTM5IDEwNyAzOSAxODNxMCA1OCAyMS41IDg2LjV0NTYuNSAyOC41aDQ1ek0yNTAgNDAwaDcwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXQtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtMTMgbDEzOCAtMTAwaC05NTBsMTM3IDEwMGgtMTJxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41dDE0LjUgMzUuNXQzNS41IDE0LjV6TTUwIDEwMGgxMTAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di01MGgtMTIwMHY1MHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTIxNDsiIGQ9Ik02MDAgMTMwMHE0NyAwIDkyLjUgLTUzLjV0NzEgLTEyM3QyNS41IC0xMjMuNXEwIC03OCAtNTUuNSAtMTMzLjV0LTEzMy41IC01NS41dC0xMzMuNSA1NS41dC01NS41IDEzMy41cTAgNjIgMzQgMTQzbDE0NCAtMTQzbDExMSAxMTFsLTE2MyAxNjNxMzQgMjYgNjMgMjZ6TTYwMiA3OThoNDZxMzQgMCA1NS41IC0yOC41dDIxLjUgLTg2LjVxMCAtNzYgMzkgLTE4M2gtMzI0cTM5IDEwNyAzOSAxODNxMCA1OCAyMS41IDg2LjV0NTYuNSAyOC41aDQ1IHpNMjUwIDQwMGg3MDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV0LTE0LjUgLTM1LjV0LTM1LjUgLTE0LjVoLTEzbDEzOCAtMTAwaC05NTBsMTM3IDEwMGgtMTJxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41dDE0LjUgMzUuNXQzNS41IDE0LjV6TTUwIDEwMGgxMTAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di01MGgtMTIwMHY1MHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTIxNTsiIGQ9Ik02MDAgMTIwMGwzMDAgLTE2MXYtMTM5aC0zMDBxMCAtNTcgMTguNSAtMTA4dDUwIC05MS41dDYzIC03MnQ3MCAtNjcuNXQ1Ny41IC02MWgtNTMwcS02MCA4MyAtOTAuNSAxNzcuNXQtMzAuNSAxNzguNXQzMyAxNjQuNXQ4Ny41IDEzOS41dDEyNiA5Ni41dDE0NS41IDQxLjV2LTk4ek0yNTAgNDAwaDcwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXQtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtMTNsMTM4IC0xMDBoLTk1MGwxMzcgMTAwIGgtMTJxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41dDE0LjUgMzUuNXQzNS41IDE0LjV6TTUwIDEwMGgxMTAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di01MGgtMTIwMHY1MHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTIxNjsiIGQ9Ik02MDAgMTMwMHE0MSAwIDcwLjUgLTI5LjV0MjkuNSAtNzAuNXYtNzhxNDYgLTI2IDczIC03MnQyNyAtMTAwdi01MGgtNDAwdjUwcTAgNTQgMjcgMTAwdDczIDcydjc4cTAgNDEgMjkuNSA3MC41dDcwLjUgMjkuNXpNNDAwIDgwMGg0MDBxNTQgMCAxMDAgLTI3dDcyIC03M2gtMTcydi0xMDBoMjAwdi0xMDBoLTIwMHYtMTAwaDIwMHYtMTAwaC0yMDB2LTEwMGgyMDBxMCAtODMgLTU4LjUgLTE0MS41dC0xNDEuNSAtNTguNWgtNDAwIHEtODMgMCAtMTQxLjUgNTguNXQtNTguNSAxNDEuNXY0MDBxMCA4MyA1OC41IDE0MS41dDE0MS41IDU4LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTIxODsiIGQ9Ik0xNTAgMTEwMGg5MDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTUwMHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtOTAwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXY1MDBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41ek0xMjUgNDAwaDk1MHExMCAwIDE3LjUgLTcuNXQ3LjUgLTE3LjV2LTUwcTAgLTEwIC03LjUgLTE3LjV0LTE3LjUgLTcuNWgtMjgzbDIyNCAtMjI0cTEzIC0xMyAxMyAtMzEuNXQtMTMgLTMyIHQtMzEuNSAtMTMuNXQtMzEuNSAxM2wtODggODhoLTUyNGwtODcgLTg4cS0xMyAtMTMgLTMyIC0xM3QtMzIgMTMuNXQtMTMgMzJ0MTMgMzEuNWwyMjQgMjI0aC0yODlxLTEwIDAgLTE3LjUgNy41dC03LjUgMTcuNXY1MHEwIDEwIDcuNSAxNy41dDE3LjUgNy41ek01NDEgMzAwbC0xMDAgLTEwMGgzMjRsLTEwMCAxMDBoLTEyNHoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMjE5OyIgZD0iTTIwMCAxMTAwaDgwMHE4MyAwIDE0MS41IC01OC41dDU4LjUgLTE0MS41di0yMDBoLTEwMHEwIDQxIC0yOS41IDcwLjV0LTcwLjUgMjkuNWgtMjUwcS00MSAwIC03MC41IC0yOS41dC0yOS41IC03MC41aC0xMDBxMCA0MSAtMjkuNSA3MC41dC03MC41IDI5LjVoLTI1MHEtNDEgMCAtNzAuNSAtMjkuNXQtMjkuNSAtNzAuNWgtMTAwdjIwMHEwIDgzIDU4LjUgMTQxLjV0MTQxLjUgNTguNXpNMTAwIDYwMGgxMDAwcTQxIDAgNzAuNSAtMjkuNSB0MjkuNSAtNzAuNXYtMzAwaC0xMjAwdjMwMHEwIDQxIDI5LjUgNzAuNXQ3MC41IDI5LjV6TTMwMCAxMDB2LTUwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC0xMDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djUwaDIwMHpNMTEwMCAxMDB2LTUwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC0xMDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djUwaDIwMHoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMjIxOyIgZD0iTTQ4MCAxMTY1bDY4MiAtNjgzcTMxIC0zMSAzMSAtNzUuNXQtMzEgLTc1LjVsLTEzMSAtMTMxaC00ODFsLTUxNyA1MThxLTMyIDMxIC0zMiA3NS41dDMyIDc1LjVsMjk1IDI5NnEzMSAzMSA3NS41IDMxdDc2LjUgLTMxek0xMDggNzk0bDM0MiAtMzQybDMwMyAzMDRsLTM0MSAzNDF6TTI1MCAxMDBoODAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di01MGgtOTAwdjUwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMjIzOyIgZD0iTTEwNTcgNjQ3bC0xODkgNTA2cS04IDE5IC0yNy41IDMzdC00MC41IDE0aC00MDBxLTIxIDAgLTQwLjUgLTE0dC0yNy41IC0zM2wtMTg5IC01MDZxLTggLTE5IDEuNSAtMzN0MzAuNSAtMTRoNjI1di0xNTBxMCAtMjEgMTQuNSAtMzUuNXQzNS41IC0xNC41dDM1LjUgMTQuNXQxNC41IDM1LjV2MTUwaDEyNXEyMSAwIDMwLjUgMTR0MS41IDMzek04OTcgMGgtNTk1djUwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNWg1MHY1MCBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41aDQ4djMwMGgyMDB2LTMwMGg0N3EyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtNTBoNTBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTUweiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUyMjQ7IiBkPSJNOTAwIDgwMGgzMDB2LTU3NXEwIC0xMCAtNy41IC0xNy41dC0xNy41IC03LjVoLTM3NXY1OTFsLTMwMCAzMDB2ODRxMCAxMCA3LjUgMTcuNXQxNy41IDcuNWgzNzV2LTQwMHpNMTIwMCA5MDBoLTIwMHYyMDB6TTQwMCA2MDBoMzAwdi01NzVxMCAtMTAgLTcuNSAtMTcuNXQtMTcuNSAtNy41aC02NTBxLTEwIDAgLTE3LjUgNy41dC03LjUgMTcuNXY5NTBxMCAxMCA3LjUgMTcuNXQxNy41IDcuNWgzNzV2LTQwMHpNNzAwIDcwMGgtMjAwdjIwMHogIiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTIyNTsiIGQ9Ik00ODQgMTA5NWgxOTVxNzUgMCAxNDYgLTMyLjV0MTI0IC04NnQ4OS41IC0xMjIuNXQ0OC41IC0xNDJxMTggLTE0IDM1IC0yMHEzMSAtMTAgNjQuNSA2LjV0NDMuNSA0OC41cTEwIDM0IC0xNSA3MXEtMTkgMjcgLTkgNDNxNSA4IDEyLjUgMTF0MTkgLTF0MjMuNSAtMTZxNDEgLTQ0IDM5IC0xMDVxLTMgLTYzIC00NiAtMTA2LjV0LTEwNCAtNDMuNWgtNjJxLTcgLTU1IC0zNSAtMTE3dC01NiAtMTAwbC0zOSAtMjM0cS0zIC0yMCAtMjAgLTM0LjUgdC0zOCAtMTQuNWgtMTAwcS0yMSAwIC0zMyAxNC41dC05IDM0LjVsMTIgNzBxLTQ5IC0xNCAtOTEgLTE0aC0xOTVxLTI0IDAgLTY1IDhsLTExIC02NHEtMyAtMjAgLTIwIC0zNC41dC0zOCAtMTQuNWgtMTAwcS0yMSAwIC0zMyAxNC41dC05IDM0LjVsMjYgMTU3cS04NCA3NCAtMTI4IDE3NWwtMTU5IDUzcS0xOSA3IC0zMyAyNnQtMTQgNDB2NTBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41aDEyNHExMSA4NyA1NiAxNjZsLTExMSA5NSBxLTE2IDE0IC0xMi41IDIzLjV0MjQuNSA5LjVoMjAzcTExNiAxMDEgMjUwIDEwMXpNNjc1IDEwMDBoLTI1MHEtMTAgMCAtMTcuNSAtNy41dC03LjUgLTE3LjV2LTUwcTAgLTEwIDcuNSAtMTcuNXQxNy41IC03LjVoMjUwcTEwIDAgMTcuNSA3LjV0Ny41IDE3LjV2NTBxMCAxMCAtNy41IDE3LjV0LTE3LjUgNy41eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUyMjY7IiBkPSJNNjQxIDkwMGw0MjMgMjQ3cTE5IDggNDIgMi41dDM3IC0yMS41bDMyIC0zOHExNCAtMTUgMTIuNSAtMzZ0LTE3LjUgLTM0bC0xMzkgLTEyMGgtMzkwek01MCAxMTAwaDEwNnE2NyAwIDEwMyAtMTd0NjYgLTcxbDEwMiAtMjEyaDgyM3EyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtNTBxMCAtMjEgLTE0IC00MHQtMzMgLTI2bC03MzcgLTEzMnEtMjMgLTQgLTQwIDZ0LTI2IDI1cS00MiA2NyAtMTAwIDY3aC0zMDBxLTYyIDAgLTEwNiA0NCB0LTQ0IDEwNnYyMDBxMCA2MiA0NCAxMDZ0MTA2IDQ0ek0xNzMgOTI4aC04MHEtMTkgMCAtMjggLTE0dC05IC0zNXYtNTZxMCAtNTEgNDIgLTUxaDEzNHExNiAwIDIxLjUgOHQ1LjUgMjRxMCAxMSAtMTYgNDV0LTI3IDUxcS0xOCAyOCAtNDMgMjh6TTU1MCA3MjdxLTMyIDAgLTU0LjUgLTIyLjV0LTIyLjUgLTU0LjV0MjIuNSAtNTQuNXQ1NC41IC0yMi41dDU0LjUgMjIuNXQyMi41IDU0LjV0LTIyLjUgNTQuNXQtNTQuNSAyMi41ek0xMzAgMzg5IGwxNTIgMTMwcTE4IDE5IDM0IDI0dDMxIC0zLjV0MjQuNSAtMTcuNXQyNS41IC0yOHEyOCAtMzUgNTAuNSAtNTF0NDguNSAtMTNsNjMgNWw0OCAtMTc5cTEzIC02MSAtMy41IC05Ny41dC02Ny41IC03OS41bC04MCAtNjlxLTQ3IC00MCAtMTA5IC0zNS41dC0xMDMgNTEuNWwtMTMwIDE1MXEtNDAgNDcgLTM1LjUgMTA5LjV0NTEuNSAxMDIuNXpNMzgwIDM3N2wtMTAyIC04OHEtMzEgLTI3IDIgLTY1bDM3IC00M3ExMyAtMTUgMjcuNSAtMTkuNSB0MzEuNSA2LjVsNjEgNTNxMTkgMTYgMTQgNDlxLTIgMjAgLTEyIDU2dC0xNyA0NXEtMTEgMTIgLTE5IDE0dC0yMyAtOHoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMjI3OyIgZD0iTTYyNSAxMjAwaDE1MHExMCAwIDE3LjUgLTcuNXQ3LjUgLTE3LjV2LTEwOXE3OSAtMzMgMTMxIC04Ny41dDUzIC0xMjguNXExIC00NiAtMTUgLTg0LjV0LTM5IC02MXQtNDYgLTM4dC0zOSAtMjEuNWwtMTcgLTZxNiAwIDE1IC0xLjV0MzUgLTl0NTAgLTE3LjV0NTMgLTMwdDUwIC00NXQzNS41IC02NHQxNC41IC04NHEwIC01OSAtMTEuNSAtMTA1LjV0LTI4LjUgLTc2LjV0LTQ0IC01MXQtNDkuNSAtMzEuNXQtNTQuNSAtMTZ0LTQ5LjUgLTYuNSB0LTQzLjUgLTF2LTc1cTAgLTEwIC03LjUgLTE3LjV0LTE3LjUgLTcuNWgtMTUwcS0xMCAwIC0xNy41IDcuNXQtNy41IDE3LjV2NzVoLTEwMHYtNzVxMCAtMTAgLTcuNSAtMTcuNXQtMTcuNSAtNy41aC0xNTBxLTEwIDAgLTE3LjUgNy41dC03LjUgMTcuNXY3NWgtMTc1cS0xMCAwIC0xNy41IDcuNXQtNy41IDE3LjV2MTUwcTAgMTAgNy41IDE3LjV0MTcuNSA3LjVoNzV2NjAwaC03NXEtMTAgMCAtMTcuNSA3LjV0LTcuNSAxNy41djE1MCBxMCAxMCA3LjUgMTcuNXQxNy41IDcuNWgxNzV2NzVxMCAxMCA3LjUgMTcuNXQxNy41IDcuNWgxNTBxMTAgMCAxNy41IC03LjV0Ny41IC0xNy41di03NWgxMDB2NzVxMCAxMCA3LjUgMTcuNXQxNy41IDcuNXpNNDAwIDkwMHYtMjAwaDI2M3EyOCAwIDQ4LjUgMTAuNXQzMCAyNXQxNSAyOXQ1LjUgMjUuNWwxIDEwcTAgNCAtMC41IDExdC02IDI0dC0xNSAzMHQtMzAgMjR0LTQ4LjUgMTFoLTI2M3pNNDAwIDUwMHYtMjAwaDM2M3EyOCAwIDQ4LjUgMTAuNSB0MzAgMjV0MTUgMjl0NS41IDI1LjVsMSAxMHEwIDQgLTAuNSAxMXQtNiAyNHQtMTUgMzB0LTMwIDI0dC00OC41IDExaC0zNjN6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTIzMDsiIGQ9Ik0yMTIgMTE5OGg3ODBxODYgMCAxNDcgLTYxdDYxIC0xNDd2LTQxNnEwIC01MSAtMTggLTE0Mi41dC0zNiAtMTU3LjVsLTE4IC02NnEtMjkgLTg3IC05My41IC0xNDYuNXQtMTQ2LjUgLTU5LjVoLTU3MnEtODIgMCAtMTQ3IDU5dC05MyAxNDdxLTggMjggLTIwIDczdC0zMiAxNDMuNXQtMjAgMTQ5LjV2NDE2cTAgODYgNjEgMTQ3dDE0NyA2MXpNNjAwIDEwNDVxLTcwIDAgLTEzMi41IC0xMS41dC0xMDUuNSAtMzAuNXQtNzguNSAtNDEuNSB0LTU3IC00NXQtMzYgLTQxdC0yMC41IC0zMC41bC02IC0xMmwxNTYgLTI0M2g1NjBsMTU2IDI0M3EtMiA1IC02IDEyLjV0LTIwIDI5LjV0LTM2LjUgNDJ0LTU3IDQ0LjV0LTc5IDQydC0xMDUgMjkuNXQtMTMyLjUgMTJ6TTc2MiA3MDNoLTE1N2wxOTUgMjYxeiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUyMzE7IiBkPSJNNDc1IDEzMDBoMTUwcTEwMyAwIDE4OSAtODZ0ODYgLTE4OXYtNTAwcTAgLTQxIC00MiAtODN0LTgzIC00MmgtNDUwcS00MSAwIC04MyA0MnQtNDIgODN2NTAwcTAgMTAzIDg2IDE4OXQxODkgODZ6TTcwMCAzMDB2LTIyNXEwIC0yMSAtMjcgLTQ4dC00OCAtMjdoLTE1MHEtMjEgMCAtNDggMjd0LTI3IDQ4djIyNWgzMDB6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTIzMjsiIGQ9Ik00NzUgMTMwMGg5NnEwIC0xNTAgODkuNSAtMjM5LjV0MjM5LjUgLTg5LjV2LTQ0NnEwIC00MSAtNDIgLTgzdC04MyAtNDJoLTQ1MHEtNDEgMCAtODMgNDJ0LTQyIDgzdjUwMHEwIDEwMyA4NiAxODl0MTg5IDg2ek03MDAgMzAwdi0yMjVxMCAtMjEgLTI3IC00OHQtNDggLTI3aC0xNTBxLTIxIDAgLTQ4IDI3dC0yNyA0OHYyMjVoMzAweiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUyMzM7IiBkPSJNMTI5NCA3NjdsLTYzOCAtMjgzbC0zNzggMTcwbC03OCAtNjB2LTIyNGwxMDAgLTE1MHYtMTk5bC0xNTAgMTQ4bC0xNTAgLTE0OXYyMDBsMTAwIDE1MHYyNTBxMCA0IC0wLjUgMTAuNXQwIDkuNXQxIDh0MyA4dDYuNSA2bDQ3IDQwbC0xNDcgNjVsNjQyIDI4M3pNMTAwMCAzODBsLTM1MCAtMTY2bC0zNTAgMTY2djE0N2wzNTAgLTE2NWwzNTAgMTY1di0xNDd6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTIzNDsiIGQ9Ik0yNTAgODAwcTYyIDAgMTA2IC00NHQ0NCAtMTA2dC00NCAtMTA2dC0xMDYgLTQ0dC0xMDYgNDR0LTQ0IDEwNnQ0NCAxMDZ0MTA2IDQ0ek02NTAgODAwcTYyIDAgMTA2IC00NHQ0NCAtMTA2dC00NCAtMTA2dC0xMDYgLTQ0dC0xMDYgNDR0LTQ0IDEwNnQ0NCAxMDZ0MTA2IDQ0ek0xMDUwIDgwMHE2MiAwIDEwNiAtNDR0NDQgLTEwNnQtNDQgLTEwNnQtMTA2IC00NHQtMTA2IDQ0dC00NCAxMDZ0NDQgMTA2dDEwNiA0NHoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMjM1OyIgZD0iTTU1MCAxMTAwcTYyIDAgMTA2IC00NHQ0NCAtMTA2dC00NCAtMTA2dC0xMDYgLTQ0dC0xMDYgNDR0LTQ0IDEwNnQ0NCAxMDZ0MTA2IDQ0ek01NTAgNzAwcTYyIDAgMTA2IC00NHQ0NCAtMTA2dC00NCAtMTA2dC0xMDYgLTQ0dC0xMDYgNDR0LTQ0IDEwNnQ0NCAxMDZ0MTA2IDQ0ek01NTAgMzAwcTYyIDAgMTA2IC00NHQ0NCAtMTA2dC00NCAtMTA2dC0xMDYgLTQ0dC0xMDYgNDR0LTQ0IDEwNnQ0NCAxMDZ0MTA2IDQ0eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUyMzY7IiBkPSJNMTI1IDExMDBoOTUwcTEwIDAgMTcuNSAtNy41dDcuNSAtMTcuNXYtMTUwcTAgLTEwIC03LjUgLTE3LjV0LTE3LjUgLTcuNWgtOTUwcS0xMCAwIC0xNy41IDcuNXQtNy41IDE3LjV2MTUwcTAgMTAgNy41IDE3LjV0MTcuNSA3LjV6TTEyNSA3MDBoOTUwcTEwIDAgMTcuNSAtNy41dDcuNSAtMTcuNXYtMTUwcTAgLTEwIC03LjUgLTE3LjV0LTE3LjUgLTcuNWgtOTUwcS0xMCAwIC0xNy41IDcuNXQtNy41IDE3LjV2MTUwcTAgMTAgNy41IDE3LjUgdDE3LjUgNy41ek0xMjUgMzAwaDk1MHExMCAwIDE3LjUgLTcuNXQ3LjUgLTE3LjV2LTE1MHEwIC0xMCAtNy41IC0xNy41dC0xNy41IC03LjVoLTk1MHEtMTAgMCAtMTcuNSA3LjV0LTcuNSAxNy41djE1MHEwIDEwIDcuNSAxNy41dDE3LjUgNy41eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUyMzc7IiBkPSJNMzUwIDEyMDBoNTAwcTE2MiAwIDI1NiAtOTMuNXQ5NCAtMjU2LjV2LTUwMHEwIC0xNjUgLTkzLjUgLTI1Ny41dC0yNTYuNSAtOTIuNWgtNTAwcS0xNjUgMCAtMjU3LjUgOTIuNXQtOTIuNSAyNTcuNXY1MDBxMCAxNjUgOTIuNSAyNTcuNXQyNTcuNSA5Mi41ek05MDAgMTAwMGgtNjAwcS00MSAwIC03MC41IC0yOS41dC0yOS41IC03MC41di02MDBxMCAtNDEgMjkuNSAtNzAuNXQ3MC41IC0yOS41aDYwMHE0MSAwIDcwLjUgMjkuNSB0MjkuNSA3MC41djYwMHEwIDQxIC0yOS41IDcwLjV0LTcwLjUgMjkuNXpNMzUwIDkwMGg1MDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTMwMHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtNTAwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXYzMDBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41ek00MDAgODAwdi0yMDBoNDAwdjIwMGgtNDAweiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUyMzg7IiBkPSJNMTUwIDExMDBoMTAwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXQtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtNTB2LTIwMGg1MHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXQtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtNTB2LTIwMGg1MHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXQtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtNTB2LTIwMGg1MHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXQtMTQuNSAtMzUuNSB0LTM1LjUgLTE0LjVoLTEwMDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41dDE0LjUgMzUuNXQzNS41IDE0LjVoNTB2MjAwaC01MHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV0MTQuNSAzNS41dDM1LjUgMTQuNWg1MHYyMDBoLTUwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXQxNC41IDM1LjV0MzUuNSAxNC41aDUwdjIwMGgtNTBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41dDE0LjUgMzUuNXQzNS41IDE0LjV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTIzOTsiIGQ9Ik02NTAgMTE4N3E4NyAtNjcgMTE4LjUgLTE1NnQwIC0xNzh0LTExOC41IC0xNTVxLTg3IDY2IC0xMTguNSAxNTV0MCAxNzh0MTE4LjUgMTU2ek0zMDAgODAwcTEyNCAwIDIxMiAtODh0ODggLTIxMnEtMTI0IDAgLTIxMiA4OHQtODggMjEyek0xMDAwIDgwMHEwIC0xMjQgLTg4IC0yMTJ0LTIxMiAtODhxMCAxMjQgODggMjEydDIxMiA4OHpNMzAwIDUwMHExMjQgMCAyMTIgLTg4dDg4IC0yMTJxLTEyNCAwIC0yMTIgODh0LTg4IDIxMnogTTEwMDAgNTAwcTAgLTEyNCAtODggLTIxMnQtMjEyIC04OHEwIDEyNCA4OCAyMTJ0MjEyIDg4ek03MDAgMTk5di0xNDRxMCAtMjEgLTE0LjUgLTM1LjV0LTM1LjUgLTE0LjV0LTM1LjUgMTQuNXQtMTQuNSAzNS41djE0MnE0MCAtNCA0MyAtNHExNyAwIDU3IDZ6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTI0MDsiIGQ9Ik03NDUgODc4bDY5IDE5cTI1IDYgNDUgLTEybDI5OCAtMjk1cTExIC0xMSAxNSAtMjYuNXQtMiAtMzAuNXEtNSAtMTQgLTE4IC0yMy41dC0yOCAtOS41aC04cTEgMCAxIC0xM3EwIC0yOSAtMiAtNTZ0LTguNSAtNjJ0LTIwIC02M3QtMzMgLTUzdC01MSAtMzl0LTcyLjUgLTE0aC0xNDZxLTE4NCAwIC0xODQgMjg4cTAgMjQgMTAgNDdxLTIwIDQgLTYyIDR0LTYzIC00cTExIC0yNCAxMSAtNDdxMCAtMjg4IC0xODQgLTI4OGgtMTQyIHEtNDggMCAtODQuNSAyMXQtNTYgNTF0LTMyIDcxLjV0LTE2IDc1dC0zLjUgNjguNXEwIDEzIDIgMTNoLTdxLTE1IDAgLTI3LjUgOS41dC0xOC41IDIzLjVxLTYgMTUgLTIgMzAuNXQxNSAyNS41bDI5OCAyOTZxMjAgMTggNDYgMTFsNzYgLTE5cTIwIC01IDMwLjUgLTIyLjV0NS41IC0zNy41dC0yMi41IC0zMXQtMzcuNSAtNWwtNTEgMTJsLTE4MiAtMTkzaDg5MWwtMTgyIDE5M2wtNDQgLTEycS0yMCAtNSAtMzcuNSA2dC0yMi41IDMxdDYgMzcuNSB0MzEgMjIuNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMjQxOyIgZD0iTTEyMDAgOTAwaC01MHEwIDIxIC00IDM3dC05LjUgMjYuNXQtMTggMTcuNXQtMjIgMTF0LTI4LjUgNS41dC0zMSAydC0zNyAwLjVoLTIwMHYtODUwcTAgLTIyIDI1IC0zNC41dDUwIC0xMy41bDI1IC0ydi0xMDBoLTQwMHYxMDBxNCAwIDExIDAuNXQyNCAzdDMwIDd0MjQgMTV0MTEgMjQuNXY4NTBoLTIwMHEtMjUgMCAtMzcgLTAuNXQtMzEgLTJ0LTI4LjUgLTUuNXQtMjIgLTExdC0xOCAtMTcuNXQtOS41IC0yNi41dC00IC0zN2gtNTB2MzAwIGgxMDAwdi0zMDB6TTUwMCA0NTBoLTI1cTAgMTUgLTQgMjQuNXQtOSAxNC41dC0xNyA3LjV0LTIwIDN0LTI1IDAuNWgtMTAwdi00MjVxMCAtMTEgMTIuNSAtMTcuNXQyNS41IC03LjVoMTJ2LTUwaC0yMDB2NTBxNTAgMCA1MCAyNXY0MjVoLTEwMHEtMTcgMCAtMjUgLTAuNXQtMjAgLTN0LTE3IC03LjV0LTkgLTE0LjV0LTQgLTI0LjVoLTI1djE1MGg1MDB2LTE1MHoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMjQyOyIgZD0iTTEwMDAgMzAwdjUwcS0yNSAwIC01NSAzMnEtMTQgMTQgLTI1IDMxdC0xNiAyN2wtNCAxMWwtMjg5IDc0N2gtNjlsLTMwMCAtNzU0cS0xOCAtMzUgLTM5IC01NnEtOSAtOSAtMjQuNSAtMTguNXQtMjYuNSAtMTQuNWwtMTEgLTV2LTUwaDI3M3Y1MHEtNDkgMCAtNzguNSAyMS41dC0xMS41IDY3LjVsNjkgMTc2aDI5M2w2MSAtMTY2cTEzIC0zNCAtMy41IC02Ni41dC01NS41IC0zMi41di01MGgzMTJ6TTQxMiA2OTFsMTM0IDM0MmwxMjEgLTM0MiBoLTI1NXpNMTEwMCAxNTB2LTEwMHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtMTAwMHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2MTAwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNWgxMDAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUyNDM7IiBkPSJNNTAgMTIwMGgxMTAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di0xMTAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC0xMTAwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXYxMTAwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXpNNjExIDExMThoLTcwcS0xMyAwIC0xOCAtMTJsLTI5OSAtNzUzcS0xNyAtMzIgLTM1IC01MXEtMTggLTE4IC01NiAtMzRxLTEyIC01IC0xMiAtMTh2LTUwcTAgLTggNS41IC0xNHQxNC41IC02IGgyNzNxOCAwIDE0IDZ0NiAxNHY1MHEwIDggLTYgMTR0LTE0IDZxLTU1IDAgLTcxIDIzcS0xMCAxNCAwIDM5bDYzIDE2M2gyNjZsNTcgLTE1M3ExMSAtMzEgLTYgLTU1cS0xMiAtMTcgLTM2IC0xN3EtOCAwIC0xNCAtNnQtNiAtMTR2LTUwcTAgLTggNiAtMTR0MTQgLTZoMzEzcTggMCAxNCA2dDYgMTR2NTBxMCA3IC01LjUgMTN0LTEzLjUgN3EtMTcgMCAtNDIgMjVxLTI1IDI3IC00MCA2M2gtMWwtMjg4IDc0OHEtNSAxMiAtMTkgMTJ6TTYzOSA2MTEgaC0xOTdsMTAzIDI2NHoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMjQ0OyIgZD0iTTEyMDAgMTEwMGgtMTIwMHYxMDBoMTIwMHYtMTAwek01MCAxMDAwaDQwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtOTAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC00MDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djkwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6TTY1MCAxMDAwaDQwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtNDAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC00MDAgcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXY0MDBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41ek03MDAgOTAwdi0zMDBoMzAwdjMwMGgtMzAweiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUyNDU7IiBkPSJNNTAgMTIwMGg0MDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTkwMHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtNDAwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXY5MDBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41ek02NTAgNzAwaDQwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtNDAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC00MDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djQwMCBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41ek03MDAgNjAwdi0zMDBoMzAwdjMwMGgtMzAwek0xMjAwIDBoLTEyMDB2MTAwaDEyMDB2LTEwMHoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMjQ2OyIgZD0iTTUwIDEwMDBoNDAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di0zNTBoMTAwdjE1MHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjVoNDAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di0xNTBoMTAwdi0xMDBoLTEwMHYtMTUwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC00MDBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djE1MGgtMTAwdi0zNTBxMCAtMjEgLTE0LjUgLTM1LjV0LTM1LjUgLTE0LjVoLTQwMCBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djgwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6TTcwMCA3MDB2LTMwMGgzMDB2MzAwaC0zMDB6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTI0NzsiIGQ9Ik0xMDAgMGgtMTAwdjEyMDBoMTAwdi0xMjAwek0yNTAgMTEwMGg0MDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTQwMHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtNDAwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXY0MDBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41ek0zMDAgMTAwMHYtMzAwaDMwMHYzMDBoLTMwMHpNMjUwIDUwMGg5MDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTQwMCBxMCAtMjEgLTE0LjUgLTM1LjV0LTM1LjUgLTE0LjVoLTkwMHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2NDAwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMjQ4OyIgZD0iTTYwMCAxMTAwaDE1MHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtNDAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC0xNTB2LTEwMGg0NTBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTQwMHEwIC0yMSAtMTQuNSAtMzUuNXQtMzUuNSAtMTQuNWgtOTAwcS0yMSAwIC0zNS41IDE0LjV0LTE0LjUgMzUuNXY0MDBxMCAyMSAxNC41IDM1LjV0MzUuNSAxNC41aDM1MHYxMDBoLTE1MHEtMjEgMCAtMzUuNSAxNC41IHQtMTQuNSAzNS41djQwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjVoMTUwdjEwMGgxMDB2LTEwMHpNNDAwIDEwMDB2LTMwMGgzMDB2MzAwaC0zMDB6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTI0OTsiIGQ9Ik0xMjAwIDBoLTEwMHYxMjAwaDEwMHYtMTIwMHpNNTUwIDExMDBoNDAwcTIxIDAgMzUuNSAtMTQuNXQxNC41IC0zNS41di00MDBxMCAtMjEgLTE0LjUgLTM1LjV0LTM1LjUgLTE0LjVoLTQwMHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2NDAwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXpNNjAwIDEwMDB2LTMwMGgzMDB2MzAwaC0zMDB6TTUwIDUwMGg5MDBxMjEgMCAzNS41IC0xNC41dDE0LjUgLTM1LjV2LTQwMCBxMCAtMjEgLTE0LjUgLTM1LjV0LTM1LjUgLTE0LjVoLTkwMHEtMjEgMCAtMzUuNSAxNC41dC0xNC41IDM1LjV2NDAwcTAgMjEgMTQuNSAzNS41dDM1LjUgMTQuNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMjUwOyIgZD0iTTg2NSA1NjVsLTQ5NCAtNDk0cS0yMyAtMjMgLTQxIC0yM3EtMTQgMCAtMjIgMTMuNXQtOCAzOC41djEwMDBxMCAyNSA4IDM4LjV0MjIgMTMuNXExOCAwIDQxIC0yM2w0OTQgLTQ5NHExNCAtMTQgMTQgLTM1dC0xNCAtMzV6IiAvPgo8Z2x5cGggdW5pY29kZT0iJiN4ZTI1MTsiIGQ9Ik0zMzUgNjM1bDQ5NCA0OTRxMjkgMjkgNTAgMjAuNXQyMSAtNDkuNXYtMTAwMHEwIC00MSAtMjEgLTQ5LjV0LTUwIDIwLjVsLTQ5NCA0OTRxLTE0IDE0IC0xNCAzNXQxNCAzNXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMjUyOyIgZD0iTTEwMCA5MDBoMTAwMHE0MSAwIDQ5LjUgLTIxdC0yMC41IC01MGwtNDk0IC00OTRxLTE0IC0xNCAtMzUgLTE0dC0zNSAxNGwtNDk0IDQ5NHEtMjkgMjkgLTIwLjUgNTB0NDkuNSAyMXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMjUzOyIgZD0iTTYzNSA4NjVsNDk0IC00OTRxMjkgLTI5IDIwLjUgLTUwdC00OS41IC0yMWgtMTAwMHEtNDEgMCAtNDkuNSAyMXQyMC41IDUwbDQ5NCA0OTRxMTQgMTQgMzUgMTR0MzUgLTE0eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUyNTQ7IiBkPSJNNzAwIDc0MXYtMTgybC02OTIgLTMyM3YyMjFsNDEzIDE5M2wtNDEzIDE5M3YyMjF6TTEyMDAgMGgtODAwdjIwMGg4MDB2LTIwMHoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMjU1OyIgZD0iTTEyMDAgOTAwaC0yMDB2LTEwMGgyMDB2LTEwMGgtMzAwdjMwMGgyMDB2MTAwaC0yMDB2MTAwaDMwMHYtMzAwek0wIDcwMGg1MHEwIDIxIDQgMzd0OS41IDI2LjV0MTggMTcuNXQyMiAxMXQyOC41IDUuNXQzMSAydDM3IDAuNWgxMDB2LTU1MHEwIC0yMiAtMjUgLTM0LjV0LTUwIC0xMy41bC0yNSAtMnYtMTAwaDQwMHYxMDBxLTQgMCAtMTEgMC41dC0yNCAzdC0zMCA3dC0yNCAxNXQtMTEgMjQuNXY1NTBoMTAwcTI1IDAgMzcgLTAuNXQzMSAtMiB0MjguNSAtNS41dDIyIC0xMXQxOCAtMTcuNXQ5LjUgLTI2LjV0NCAtMzdoNTB2MzAwaC04MDB2LTMwMHoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMjU2OyIgZD0iTTgwMCA3MDBoLTUwcTAgMjEgLTQgMzd0LTkuNSAyNi41dC0xOCAxNy41dC0yMiAxMXQtMjguNSA1LjV0LTMxIDJ0LTM3IDAuNWgtMTAwdi01NTBxMCAtMjIgMjUgLTM0LjV0NTAgLTE0LjVsMjUgLTF2LTEwMGgtNDAwdjEwMHE0IDAgMTEgMC41dDI0IDN0MzAgN3QyNCAxNXQxMSAyNC41djU1MGgtMTAwcS0yNSAwIC0zNyAtMC41dC0zMSAtMnQtMjguNSAtNS41dC0yMiAtMTF0LTE4IC0xNy41dC05LjUgLTI2LjV0LTQgLTM3aC01MHYzMDAgaDgwMHYtMzAwek0xMTAwIDIwMGgtMjAwdi0xMDBoMjAwdi0xMDBoLTMwMHYzMDBoMjAwdjEwMGgtMjAwdjEwMGgzMDB2LTMwMHoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMjU3OyIgZD0iTTcwMSAxMDk4aDE2MHExNiAwIDIxIC0xMXQtNyAtMjNsLTQ2NCAtNDY0bDQ2NCAtNDY0cTEyIC0xMiA3IC0yM3QtMjEgLTExaC0xNjBxLTEzIDAgLTIzIDlsLTQ3MSA0NzFxLTcgOCAtNyAxOHQ3IDE4bDQ3MSA0NzFxMTAgOSAyMyA5eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGUyNTg7IiBkPSJNMzM5IDEwOThoMTYwcTEzIDAgMjMgLTlsNDcxIC00NzFxNyAtOCA3IC0xOHQtNyAtMThsLTQ3MSAtNDcxcS0xMCAtOSAtMjMgLTloLTE2MHEtMTYgMCAtMjEgMTF0NyAyM2w0NjQgNDY0bC00NjQgNDY0cS0xMiAxMiAtNyAyM3QyMSAxMXoiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMjU5OyIgZD0iTTEwODcgODgycTExIC01IDExIC0yMXYtMTYwcTAgLTEzIC05IC0yM2wtNDcxIC00NzFxLTggLTcgLTE4IC03dC0xOCA3bC00NzEgNDcxcS05IDEwIC05IDIzdjE2MHEwIDE2IDExIDIxdDIzIC03bDQ2NCAtNDY0bDQ2NCA0NjRxMTIgMTIgMjMgN3oiIC8+CjxnbHlwaCB1bmljb2RlPSImI3hlMjYwOyIgZD0iTTYxOCA5OTNsNDcxIC00NzFxOSAtMTAgOSAtMjN2LTE2MHEwIC0xNiAtMTEgLTIxdC0yMyA3bC00NjQgNDY0bC00NjQgLTQ2NHEtMTIgLTEyIC0yMyAtN3QtMTEgMjF2MTYwcTAgMTMgOSAyM2w0NzEgNDcxcTggNyAxOCA3dDE4IC03eiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeGY4ZmY7IiBkPSJNMTAwMCAxMjAwcTAgLTEyNCAtODggLTIxMnQtMjEyIC04OHEwIDEyNCA4OCAyMTJ0MjEyIDg4ek00NTAgMTAwMGgxMDBxMjEgMCA0MCAtMTR0MjYgLTMzbDc5IC0xOTRxNSAxIDE2IDNxMzQgNiA1NCA5LjV0NjAgN3Q2NS41IDF0NjEgLTEwdDU2LjUgLTIzdDQyLjUgLTQydDI5IC02NHQ1IC05MnQtMTkuNSAtMTIxLjVxLTEgLTcgLTMgLTE5LjV0LTExIC01MHQtMjAuNSAtNzN0LTMyLjUgLTgxLjV0LTQ2LjUgLTgzdC02NCAtNzAgdC04Mi41IC01MHEtMTMgLTUgLTQyIC01dC02NS41IDIuNXQtNDcuNSAyLjVxLTE0IDAgLTQ5LjUgLTMuNXQtNjMgLTMuNXQtNDMuNSA3cS01NyAyNSAtMTA0LjUgNzguNXQtNzUgMTExLjV0LTQ2LjUgMTEydC0yNiA5MGwtNyAzNXEtMTUgNjMgLTE4IDExNXQ0LjUgODguNXQyNiA2NHQzOS41IDQzLjV0NTIgMjUuNXQ1OC41IDEzdDYyLjUgMnQ1OS41IC00LjV0NTUuNSAtOGwtMTQ3IDE5MnEtMTIgMTggLTUuNSAzMHQyNy41IDEyeiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeDFmNTExOyIgZD0iTTI1MCAxMjAwaDYwMHEyMSAwIDM1LjUgLTE0LjV0MTQuNSAtMzUuNXYtNDAwcTAgLTIxIC0xNC41IC0zNS41dC0zNS41IC0xNC41aC0xNTB2LTUwMGwtMjU1IC0xNzhxLTE5IC05IC0zMiAtMXQtMTMgMjl2NjUwaC0xNTBxLTIxIDAgLTM1LjUgMTQuNXQtMTQuNSAzNS41djQwMHEwIDIxIDE0LjUgMzUuNXQzNS41IDE0LjV6TTQwMCAxMTAwdi0xMDBoMzAwdjEwMGgtMzAweiIgLz4KPGdseXBoIHVuaWNvZGU9IiYjeDFmNmFhOyIgZD0iTTI1MCAxMjAwaDc1MHEzOSAwIDY5LjUgLTQwLjV0MzAuNSAtODQuNXYtOTMzbC03MDAgLTExN3Y5NTBsNjAwIDEyNWgtNzAwdi0xMDAwaC0xMDB2MTAyNXEwIDIzIDE1LjUgNDl0MzQuNSAyNnpNNTAwIDUyNXYtMTAwbDEwMCAyMHYxMDB6IiAvPgo8L2ZvbnQ+CjwvZGVmcz48L3N2Zz4g) format('svg')}.glyphicon{position:relative;top:1px;display:inline-block;font-family:'Glyphicons Halflings';font-style:normal;font-weight:normal;line-height:1;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.glyphicon-asterisk:before{content:"\002a"}.glyphicon-plus:before{content:"\002b"}.glyphicon-euro:before,.glyphicon-eur:before{content:"\20ac"}.glyphicon-minus:before{content:"\2212"}.glyphicon-cloud:before{content:"\2601"}.glyphicon-envelope:before{content:"\2709"}.glyphicon-pencil:before{content:"\270f"}.glyphicon-glass:before{content:"\e001"}.glyphicon-music:before{content:"\e002"}.glyphicon-search:before{content:"\e003"}.glyphicon-heart:before{content:"\e005"}.glyphicon-star:before{content:"\e006"}.glyphicon-star-empty:before{content:"\e007"}.glyphicon-user:before{content:"\e008"}.glyphicon-film:before{content:"\e009"}.glyphicon-th-large:before{content:"\e010"}.glyphicon-th:before{content:"\e011"}.glyphicon-th-list:before{content:"\e012"}.glyphicon-ok:before{content:"\e013"}.glyphicon-remove:before{content:"\e014"}.glyphicon-zoom-in:before{content:"\e015"}.glyphicon-zoom-out:before{content:"\e016"}.glyphicon-off:before{content:"\e017"}.glyphicon-signal:before{content:"\e018"}.glyphicon-cog:before{content:"\e019"}.glyphicon-trash:before{content:"\e020"}.glyphicon-home:before{content:"\e021"}.glyphicon-file:before{content:"\e022"}.glyphicon-time:before{content:"\e023"}.glyphicon-road:before{content:"\e024"}.glyphicon-download-alt:before{content:"\e025"}.glyphicon-download:before{content:"\e026"}.glyphicon-upload:before{content:"\e027"}.glyphicon-inbox:before{content:"\e028"}.glyphicon-play-circle:before{content:"\e029"}.glyphicon-repeat:before{content:"\e030"}.glyphicon-refresh:before{content:"\e031"}.glyphicon-list-alt:before{content:"\e032"}.glyphicon-lock:before{content:"\e033"}.glyphicon-flag:before{content:"\e034"}.glyphicon-headphones:before{content:"\e035"}.glyphicon-volume-off:before{content:"\e036"}.glyphicon-volume-down:before{content:"\e037"}.glyphicon-volume-up:before{content:"\e038"}.glyphicon-qrcode:before{content:"\e039"}.glyphicon-barcode:before{content:"\e040"}.glyphicon-tag:before{content:"\e041"}.glyphicon-tags:before{content:"\e042"}.glyphicon-book:before{content:"\e043"}.glyphicon-bookmark:before{content:"\e044"}.glyphicon-print:before{content:"\e045"}.glyphicon-camera:before{content:"\e046"}.glyphicon-font:before{content:"\e047"}.glyphicon-bold:before{content:"\e048"}.glyphicon-italic:before{content:"\e049"}.glyphicon-text-height:before{content:"\e050"}.glyphicon-text-width:before{content:"\e051"}.glyphicon-align-left:before{content:"\e052"}.glyphicon-align-center:before{content:"\e053"}.glyphicon-align-right:before{content:"\e054"}.glyphicon-align-justify:before{content:"\e055"}.glyphicon-list:before{content:"\e056"}.glyphicon-indent-left:before{content:"\e057"}.glyphicon-indent-right:before{content:"\e058"}.glyphicon-facetime-video:before{content:"\e059"}.glyphicon-picture:before{content:"\e060"}.glyphicon-map-marker:before{content:"\e062"}.glyphicon-adjust:before{content:"\e063"}.glyphicon-tint:before{content:"\e064"}.glyphicon-edit:before{content:"\e065"}.glyphicon-share:before{content:"\e066"}.glyphicon-check:before{content:"\e067"}.glyphicon-move:before{content:"\e068"}.glyphicon-step-backward:before{content:"\e069"}.glyphicon-fast-backward:before{content:"\e070"}.glyphicon-backward:before{content:"\e071"}.glyphicon-play:before{content:"\e072"}.glyphicon-pause:before{content:"\e073"}.glyphicon-stop:before{content:"\e074"}.glyphicon-forward:before{content:"\e075"}.glyphicon-fast-forward:before{content:"\e076"}.glyphicon-step-forward:before{content:"\e077"}.glyphicon-eject:before{content:"\e078"}.glyphicon-chevron-left:before{content:"\e079"}.glyphicon-chevron-right:before{content:"\e080"}.glyphicon-plus-sign:before{content:"\e081"}.glyphicon-minus-sign:before{content:"\e082"}.glyphicon-remove-sign:before{content:"\e083"}.glyphicon-ok-sign:before{content:"\e084"}.glyphicon-question-sign:before{content:"\e085"}.glyphicon-info-sign:before{content:"\e086"}.glyphicon-screenshot:before{content:"\e087"}.glyphicon-remove-circle:before{content:"\e088"}.glyphicon-ok-circle:before{content:"\e089"}.glyphicon-ban-circle:before{content:"\e090"}.glyphicon-arrow-left:before{content:"\e091"}.glyphicon-arrow-right:before{content:"\e092"}.glyphicon-arrow-up:before{content:"\e093"}.glyphicon-arrow-down:before{content:"\e094"}.glyphicon-share-alt:before{content:"\e095"}.glyphicon-resize-full:before{content:"\e096"}.glyphicon-resize-small:before{content:"\e097"}.glyphicon-exclamation-sign:before{content:"\e101"}.glyphicon-gift:before{content:"\e102"}.glyphicon-leaf:before{content:"\e103"}.glyphicon-fire:before{content:"\e104"}.glyphicon-eye-open:before{content:"\e105"}.glyphicon-eye-close:before{content:"\e106"}.glyphicon-warning-sign:before{content:"\e107"}.glyphicon-plane:before{content:"\e108"}.glyphicon-calendar:before{content:"\e109"}.glyphicon-random:before{content:"\e110"}.glyphicon-comment:before{content:"\e111"}.glyphicon-magnet:before{content:"\e112"}.glyphicon-chevron-up:before{content:"\e113"}.glyphicon-chevron-down:before{content:"\e114"}.glyphicon-retweet:before{content:"\e115"}.glyphicon-shopping-cart:before{content:"\e116"}.glyphicon-folder-close:before{content:"\e117"}.glyphicon-folder-open:before{content:"\e118"}.glyphicon-resize-vertical:before{content:"\e119"}.glyphicon-resize-horizontal:before{content:"\e120"}.glyphicon-hdd:before{content:"\e121"}.glyphicon-bullhorn:before{content:"\e122"}.glyphicon-bell:before{content:"\e123"}.glyphicon-certificate:before{content:"\e124"}.glyphicon-thumbs-up:before{content:"\e125"}.glyphicon-thumbs-down:before{content:"\e126"}.glyphicon-hand-right:before{content:"\e127"}.glyphicon-hand-left:before{content:"\e128"}.glyphicon-hand-up:before{content:"\e129"}.glyphicon-hand-down:before{content:"\e130"}.glyphicon-circle-arrow-right:before{content:"\e131"}.glyphicon-circle-arrow-left:before{content:"\e132"}.glyphicon-circle-arrow-up:before{content:"\e133"}.glyphicon-circle-arrow-down:before{content:"\e134"}.glyphicon-globe:before{content:"\e135"}.glyphicon-wrench:before{content:"\e136"}.glyphicon-tasks:before{content:"\e137"}.glyphicon-filter:before{content:"\e138"}.glyphicon-briefcase:before{content:"\e139"}.glyphicon-fullscreen:before{content:"\e140"}.glyphicon-dashboard:before{content:"\e141"}.glyphicon-paperclip:before{content:"\e142"}.glyphicon-heart-empty:before{content:"\e143"}.glyphicon-link:before{content:"\e144"}.glyphicon-phone:before{content:"\e145"}.glyphicon-pushpin:before{content:"\e146"}.glyphicon-usd:before{content:"\e148"}.glyphicon-gbp:before{content:"\e149"}.glyphicon-sort:before{content:"\e150"}.glyphicon-sort-by-alphabet:before{content:"\e151"}.glyphicon-sort-by-alphabet-alt:before{content:"\e152"}.glyphicon-sort-by-order:before{content:"\e153"}.glyphicon-sort-by-order-alt:before{content:"\e154"}.glyphicon-sort-by-attributes:before{content:"\e155"}.glyphicon-sort-by-attributes-alt:before{content:"\e156"}.glyphicon-unchecked:before{content:"\e157"}.glyphicon-expand:before{content:"\e158"}.glyphicon-collapse-down:before{content:"\e159"}.glyphicon-collapse-up:before{content:"\e160"}.glyphicon-log-in:before{content:"\e161"}.glyphicon-flash:before{content:"\e162"}.glyphicon-log-out:before{content:"\e163"}.glyphicon-new-window:before{content:"\e164"}.glyphicon-record:before{content:"\e165"}.glyphicon-save:before{content:"\e166"}.glyphicon-open:before{content:"\e167"}.glyphicon-saved:before{content:"\e168"}.glyphicon-import:before{content:"\e169"}.glyphicon-export:before{content:"\e170"}.glyphicon-send:before{content:"\e171"}.glyphicon-floppy-disk:before{content:"\e172"}.glyphicon-floppy-saved:before{content:"\e173"}.glyphicon-floppy-remove:before{content:"\e174"}.glyphicon-floppy-save:before{content:"\e175"}.glyphicon-floppy-open:before{content:"\e176"}.glyphicon-credit-card:before{content:"\e177"}.glyphicon-transfer:before{content:"\e178"}.glyphicon-cutlery:before{content:"\e179"}.glyphicon-header:before{content:"\e180"}.glyphicon-compressed:before{content:"\e181"}.glyphicon-earphone:before{content:"\e182"}.glyphicon-phone-alt:before{content:"\e183"}.glyphicon-tower:before{content:"\e184"}.glyphicon-stats:before{content:"\e185"}.glyphicon-sd-video:before{content:"\e186"}.glyphicon-hd-video:before{content:"\e187"}.glyphicon-subtitles:before{content:"\e188"}.glyphicon-sound-stereo:before{content:"\e189"}.glyphicon-sound-dolby:before{content:"\e190"}.glyphicon-sound-5-1:before{content:"\e191"}.glyphicon-sound-6-1:before{content:"\e192"}.glyphicon-sound-7-1:before{content:"\e193"}.glyphicon-copyright-mark:before{content:"\e194"}.glyphicon-registration-mark:before{content:"\e195"}.glyphicon-cloud-download:before{content:"\e197"}.glyphicon-cloud-upload:before{content:"\e198"}.glyphicon-tree-conifer:before{content:"\e199"}.glyphicon-tree-deciduous:before{content:"\e200"}.glyphicon-cd:before{content:"\e201"}.glyphicon-save-file:before{content:"\e202"}.glyphicon-open-file:before{content:"\e203"}.glyphicon-level-up:before{content:"\e204"}.glyphicon-copy:before{content:"\e205"}.glyphicon-paste:before{content:"\e206"}.glyphicon-alert:before{content:"\e209"}.glyphicon-equalizer:before{content:"\e210"}.glyphicon-king:before{content:"\e211"}.glyphicon-queen:before{content:"\e212"}.glyphicon-pawn:before{content:"\e213"}.glyphicon-bishop:before{content:"\e214"}.glyphicon-knight:before{content:"\e215"}.glyphicon-baby-formula:before{content:"\e216"}.glyphicon-tent:before{content:"\26fa"}.glyphicon-blackboard:before{content:"\e218"}.glyphicon-bed:before{content:"\e219"}.glyphicon-apple:before{content:"\f8ff"}.glyphicon-erase:before{content:"\e221"}.glyphicon-hourglass:before{content:"\231b"}.glyphicon-lamp:before{content:"\e223"}.glyphicon-duplicate:before{content:"\e224"}.glyphicon-piggy-bank:before{content:"\e225"}.glyphicon-scissors:before{content:"\e226"}.glyphicon-bitcoin:before{content:"\e227"}.glyphicon-btc:before{content:"\e227"}.glyphicon-xbt:before{content:"\e227"}.glyphicon-yen:before{content:"\00a5"}.glyphicon-jpy:before{content:"\00a5"}.glyphicon-ruble:before{content:"\20bd"}.glyphicon-rub:before{content:"\20bd"}.glyphicon-scale:before{content:"\e230"}.glyphicon-ice-lolly:before{content:"\e231"}.glyphicon-ice-lolly-tasted:before{content:"\e232"}.glyphicon-education:before{content:"\e233"}.glyphicon-option-horizontal:before{content:"\e234"}.glyphicon-option-vertical:before{content:"\e235"}.glyphicon-menu-hamburger:before{content:"\e236"}.glyphicon-modal-window:before{content:"\e237"}.glyphicon-oil:before{content:"\e238"}.glyphicon-grain:before{content:"\e239"}.glyphicon-sunglasses:before{content:"\e240"}.glyphicon-text-size:before{content:"\e241"}.glyphicon-text-color:before{content:"\e242"}.glyphicon-text-background:before{content:"\e243"}.glyphicon-object-align-top:before{content:"\e244"}.glyphicon-object-align-bottom:before{content:"\e245"}.glyphicon-object-align-horizontal:before{content:"\e246"}.glyphicon-object-align-left:before{content:"\e247"}.glyphicon-object-align-vertical:before{content:"\e248"}.glyphicon-object-align-right:before{content:"\e249"}.glyphicon-triangle-right:before{content:"\e250"}.glyphicon-triangle-left:before{content:"\e251"}.glyphicon-triangle-bottom:before{content:"\e252"}.glyphicon-triangle-top:before{content:"\e253"}.glyphicon-console:before{content:"\e254"}.glyphicon-superscript:before{content:"\e255"}.glyphicon-subscript:before{content:"\e256"}.glyphicon-menu-left:before{content:"\e257"}.glyphicon-menu-right:before{content:"\e258"}.glyphicon-menu-down:before{content:"\e259"}.glyphicon-menu-up:before{content:"\e260"}*{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}*:before,*:after{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}html{font-size:10px;-webkit-tap-highlight-color:rgba(0,0,0,0)}body{font-family:"Source Sans Pro",Calibri,Candara,Arial,sans-serif;font-size:15px;line-height:1.42857143;color:#333333;background-color:#ffffff}input,button,select,textarea{font-family:inherit;font-size:inherit;line-height:inherit}a{color:#2780e3;text-decoration:none}a:hover,a:focus{color:#165ba8;text-decoration:underline}a:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}figure{margin:0}img{vertical-align:middle}.img-responsive,.thumbnail>img,.thumbnail a>img,.carousel-inner>.item>img,.carousel-inner>.item>a>img{display:block;max-width:100%;height:auto}.img-rounded{border-radius:0}.img-thumbnail{padding:4px;line-height:1.42857143;background-color:#ffffff;border:1px solid #dddddd;border-radius:0;-webkit-transition:all .2s ease-in-out;-o-transition:all .2s ease-in-out;transition:all .2s ease-in-out;display:inline-block;max-width:100%;height:auto}.img-circle{border-radius:50%}hr{margin-top:21px;margin-bottom:21px;border:0;border-top:1px solid #e6e6e6}.sr-only{position:absolute;width:1px;height:1px;margin:-1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);border:0}.sr-only-focusable:active,.sr-only-focusable:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}[role="button"]{cursor:pointer}h1,h2,h3,h4,h5,h6,.h1,.h2,.h3,.h4,.h5,.h6{font-family:"Source Sans Pro",Calibri,Candara,Arial,sans-serif;font-weight:300;line-height:1.1;color:inherit}h1 small,h2 small,h3 small,h4 small,h5 small,h6 small,.h1 small,.h2 small,.h3 small,.h4 small,.h5 small,.h6 small,h1 .small,h2 .small,h3 .small,h4 .small,h5 .small,h6 .small,.h1 .small,.h2 .small,.h3 .small,.h4 .small,.h5 .small,.h6 .small{font-weight:normal;line-height:1;color:#999999}h1,.h1,h2,.h2,h3,.h3{margin-top:21px;margin-bottom:10.5px}h1 small,.h1 small,h2 small,.h2 small,h3 small,.h3 small,h1 .small,.h1 .small,h2 .small,.h2 .small,h3 .small,.h3 .small{font-size:65%}h4,.h4,h5,.h5,h6,.h6{margin-top:10.5px;margin-bottom:10.5px}h4 small,.h4 small,h5 small,.h5 small,h6 small,.h6 small,h4 .small,.h4 .small,h5 .small,.h5 .small,h6 .small,.h6 .small{font-size:75%}h1,.h1{font-size:39px}h2,.h2{font-size:32px}h3,.h3{font-size:26px}h4,.h4{font-size:19px}h5,.h5{font-size:15px}h6,.h6{font-size:13px}p{margin:0 0 10.5px}.lead{margin-bottom:21px;font-size:17px;font-weight:300;line-height:1.4}@media (min-width:768px){.lead{font-size:22.5px}}small,.small{font-size:86%}mark,.mark{background-color:#ff7518;padding:.2em}.text-left{text-align:left}.text-right{text-align:right}.text-center{text-align:center}.text-justify{text-align:justify}.text-nowrap{white-space:nowrap}.text-lowercase{text-transform:lowercase}.text-uppercase{text-transform:uppercase}.text-capitalize{text-transform:capitalize}.text-muted{color:#999999}.text-primary{color:#2780e3}a.text-primary:hover,a.text-primary:focus{color:#1967be}.text-success{color:#ffffff}a.text-success:hover,a.text-success:focus{color:#e6e6e6}.text-info{color:#ffffff}a.text-info:hover,a.text-info:focus{color:#e6e6e6}.text-warning{color:#ffffff}a.text-warning:hover,a.text-warning:focus{color:#e6e6e6}.text-danger{color:#ffffff}a.text-danger:hover,a.text-danger:focus{color:#e6e6e6}.bg-primary{color:#fff;background-color:#2780e3}a.bg-primary:hover,a.bg-primary:focus{background-color:#1967be}.bg-success{background-color:#3fb618}a.bg-success:hover,a.bg-success:focus{background-color:#2f8912}.bg-info{background-color:#9954bb}a.bg-info:hover,a.bg-info:focus{background-color:#7e3f9d}.bg-warning{background-color:#ff7518}a.bg-warning:hover,a.bg-warning:focus{background-color:#e45c00}.bg-danger{background-color:#ff0039}a.bg-danger:hover,a.bg-danger:focus{background-color:#cc002e}.page-header{padding-bottom:9.5px;margin:42px 0 21px;border-bottom:1px solid #e6e6e6}ul,ol{margin-top:0;margin-bottom:10.5px}ul ul,ol ul,ul ol,ol ol{margin-bottom:0}.list-unstyled{padding-left:0;list-style:none}.list-inline{padding-left:0;list-style:none;margin-left:-5px}.list-inline>li{display:inline-block;padding-left:5px;padding-right:5px}dl{margin-top:0;margin-bottom:21px}dt,dd{line-height:1.42857143}dt{font-weight:bold}dd{margin-left:0}@media (min-width:768px){.dl-horizontal dt{float:left;width:160px;clear:left;text-align:right;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.dl-horizontal dd{margin-left:180px}}abbr[title],abbr[data-original-title]{cursor:help;border-bottom:1px dotted #999999}.initialism{font-size:90%;text-transform:uppercase}blockquote{padding:10.5px 21px;margin:0 0 21px;font-size:18.75px;border-left:5px solid #e6e6e6}blockquote p:last-child,blockquote ul:last-child,blockquote ol:last-child{margin-bottom:0}blockquote footer,blockquote small,blockquote .small{display:block;font-size:80%;line-height:1.42857143;color:#999999}blockquote footer:before,blockquote small:before,blockquote .small:before{content:'\2014 \00A0'}.blockquote-reverse,blockquote.pull-right{padding-right:15px;padding-left:0;border-right:5px solid #e6e6e6;border-left:0;text-align:right}.blockquote-reverse footer:before,blockquote.pull-right footer:before,.blockquote-reverse small:before,blockquote.pull-right small:before,.blockquote-reverse .small:before,blockquote.pull-right .small:before{content:''}.blockquote-reverse footer:after,blockquote.pull-right footer:after,.blockquote-reverse small:after,blockquote.pull-right small:after,.blockquote-reverse .small:after,blockquote.pull-right .small:after{content:'\00A0 \2014'}address{margin-bottom:21px;font-style:normal;line-height:1.42857143}code,kbd,pre,samp{font-family:monospace}code{padding:2px 4px;font-size:90%;color:#c7254e;background-color:#f9f2f4;border-radius:0}kbd{padding:2px 4px;font-size:90%;color:#ffffff;background-color:#333333;border-radius:0;-webkit-box-shadow:inset 0 -1px 0 rgba(0,0,0,0.25);box-shadow:inset 0 -1px 0 rgba(0,0,0,0.25)}kbd kbd{padding:0;font-size:100%;font-weight:bold;-webkit-box-shadow:none;box-shadow:none}pre{display:block;padding:10px;margin:0 0 10.5px;font-size:14px;line-height:1.42857143;word-break:break-all;word-wrap:break-word;color:#333333;background-color:#f5f5f5;border:1px solid #cccccc;border-radius:0}pre code{padding:0;font-size:inherit;color:inherit;white-space:pre-wrap;background-color:transparent;border-radius:0}.pre-scrollable{max-height:340px;overflow-y:scroll}.container{margin-right:auto;margin-left:auto;padding-left:15px;padding-right:15px}@media (min-width:768px){.container{width:750px}}@media (min-width:992px){.container{width:970px}}@media (min-width:1200px){.container{width:1170px}}.container-fluid{margin-right:auto;margin-left:auto;padding-left:15px;padding-right:15px}.row{margin-left:-15px;margin-right:-15px}.col-xs-1,.col-sm-1,.col-md-1,.col-lg-1,.col-xs-2,.col-sm-2,.col-md-2,.col-lg-2,.col-xs-3,.col-sm-3,.col-md-3,.col-lg-3,.col-xs-4,.col-sm-4,.col-md-4,.col-lg-4,.col-xs-5,.col-sm-5,.col-md-5,.col-lg-5,.col-xs-6,.col-sm-6,.col-md-6,.col-lg-6,.col-xs-7,.col-sm-7,.col-md-7,.col-lg-7,.col-xs-8,.col-sm-8,.col-md-8,.col-lg-8,.col-xs-9,.col-sm-9,.col-md-9,.col-lg-9,.col-xs-10,.col-sm-10,.col-md-10,.col-lg-10,.col-xs-11,.col-sm-11,.col-md-11,.col-lg-11,.col-xs-12,.col-sm-12,.col-md-12,.col-lg-12{position:relative;min-height:1px;padding-left:15px;padding-right:15px}.col-xs-1,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9,.col-xs-10,.col-xs-11,.col-xs-12{float:left}.col-xs-12{width:100%}.col-xs-11{width:91.66666667%}.col-xs-10{width:83.33333333%}.col-xs-9{width:75%}.col-xs-8{width:66.66666667%}.col-xs-7{width:58.33333333%}.col-xs-6{width:50%}.col-xs-5{width:41.66666667%}.col-xs-4{width:33.33333333%}.col-xs-3{width:25%}.col-xs-2{width:16.66666667%}.col-xs-1{width:8.33333333%}.col-xs-pull-12{right:100%}.col-xs-pull-11{right:91.66666667%}.col-xs-pull-10{right:83.33333333%}.col-xs-pull-9{right:75%}.col-xs-pull-8{right:66.66666667%}.col-xs-pull-7{right:58.33333333%}.col-xs-pull-6{right:50%}.col-xs-pull-5{right:41.66666667%}.col-xs-pull-4{right:33.33333333%}.col-xs-pull-3{right:25%}.col-xs-pull-2{right:16.66666667%}.col-xs-pull-1{right:8.33333333%}.col-xs-pull-0{right:auto}.col-xs-push-12{left:100%}.col-xs-push-11{left:91.66666667%}.col-xs-push-10{left:83.33333333%}.col-xs-push-9{left:75%}.col-xs-push-8{left:66.66666667%}.col-xs-push-7{left:58.33333333%}.col-xs-push-6{left:50%}.col-xs-push-5{left:41.66666667%}.col-xs-push-4{left:33.33333333%}.col-xs-push-3{left:25%}.col-xs-push-2{left:16.66666667%}.col-xs-push-1{left:8.33333333%}.col-xs-push-0{left:auto}.col-xs-offset-12{margin-left:100%}.col-xs-offset-11{margin-left:91.66666667%}.col-xs-offset-10{margin-left:83.33333333%}.col-xs-offset-9{margin-left:75%}.col-xs-offset-8{margin-left:66.66666667%}.col-xs-offset-7{margin-left:58.33333333%}.col-xs-offset-6{margin-left:50%}.col-xs-offset-5{margin-left:41.66666667%}.col-xs-offset-4{margin-left:33.33333333%}.col-xs-offset-3{margin-left:25%}.col-xs-offset-2{margin-left:16.66666667%}.col-xs-offset-1{margin-left:8.33333333%}.col-xs-offset-0{margin-left:0%}@media (min-width:768px){.col-sm-1,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9,.col-sm-10,.col-sm-11,.col-sm-12{float:left}.col-sm-12{width:100%}.col-sm-11{width:91.66666667%}.col-sm-10{width:83.33333333%}.col-sm-9{width:75%}.col-sm-8{width:66.66666667%}.col-sm-7{width:58.33333333%}.col-sm-6{width:50%}.col-sm-5{width:41.66666667%}.col-sm-4{width:33.33333333%}.col-sm-3{width:25%}.col-sm-2{width:16.66666667%}.col-sm-1{width:8.33333333%}.col-sm-pull-12{right:100%}.col-sm-pull-11{right:91.66666667%}.col-sm-pull-10{right:83.33333333%}.col-sm-pull-9{right:75%}.col-sm-pull-8{right:66.66666667%}.col-sm-pull-7{right:58.33333333%}.col-sm-pull-6{right:50%}.col-sm-pull-5{right:41.66666667%}.col-sm-pull-4{right:33.33333333%}.col-sm-pull-3{right:25%}.col-sm-pull-2{right:16.66666667%}.col-sm-pull-1{right:8.33333333%}.col-sm-pull-0{right:auto}.col-sm-push-12{left:100%}.col-sm-push-11{left:91.66666667%}.col-sm-push-10{left:83.33333333%}.col-sm-push-9{left:75%}.col-sm-push-8{left:66.66666667%}.col-sm-push-7{left:58.33333333%}.col-sm-push-6{left:50%}.col-sm-push-5{left:41.66666667%}.col-sm-push-4{left:33.33333333%}.col-sm-push-3{left:25%}.col-sm-push-2{left:16.66666667%}.col-sm-push-1{left:8.33333333%}.col-sm-push-0{left:auto}.col-sm-offset-12{margin-left:100%}.col-sm-offset-11{margin-left:91.66666667%}.col-sm-offset-10{margin-left:83.33333333%}.col-sm-offset-9{margin-left:75%}.col-sm-offset-8{margin-left:66.66666667%}.col-sm-offset-7{margin-left:58.33333333%}.col-sm-offset-6{margin-left:50%}.col-sm-offset-5{margin-left:41.66666667%}.col-sm-offset-4{margin-left:33.33333333%}.col-sm-offset-3{margin-left:25%}.col-sm-offset-2{margin-left:16.66666667%}.col-sm-offset-1{margin-left:8.33333333%}.col-sm-offset-0{margin-left:0%}}@media (min-width:992px){.col-md-1,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9,.col-md-10,.col-md-11,.col-md-12{float:left}.col-md-12{width:100%}.col-md-11{width:91.66666667%}.col-md-10{width:83.33333333%}.col-md-9{width:75%}.col-md-8{width:66.66666667%}.col-md-7{width:58.33333333%}.col-md-6{width:50%}.col-md-5{width:41.66666667%}.col-md-4{width:33.33333333%}.col-md-3{width:25%}.col-md-2{width:16.66666667%}.col-md-1{width:8.33333333%}.col-md-pull-12{right:100%}.col-md-pull-11{right:91.66666667%}.col-md-pull-10{right:83.33333333%}.col-md-pull-9{right:75%}.col-md-pull-8{right:66.66666667%}.col-md-pull-7{right:58.33333333%}.col-md-pull-6{right:50%}.col-md-pull-5{right:41.66666667%}.col-md-pull-4{right:33.33333333%}.col-md-pull-3{right:25%}.col-md-pull-2{right:16.66666667%}.col-md-pull-1{right:8.33333333%}.col-md-pull-0{right:auto}.col-md-push-12{left:100%}.col-md-push-11{left:91.66666667%}.col-md-push-10{left:83.33333333%}.col-md-push-9{left:75%}.col-md-push-8{left:66.66666667%}.col-md-push-7{left:58.33333333%}.col-md-push-6{left:50%}.col-md-push-5{left:41.66666667%}.col-md-push-4{left:33.33333333%}.col-md-push-3{left:25%}.col-md-push-2{left:16.66666667%}.col-md-push-1{left:8.33333333%}.col-md-push-0{left:auto}.col-md-offset-12{margin-left:100%}.col-md-offset-11{margin-left:91.66666667%}.col-md-offset-10{margin-left:83.33333333%}.col-md-offset-9{margin-left:75%}.col-md-offset-8{margin-left:66.66666667%}.col-md-offset-7{margin-left:58.33333333%}.col-md-offset-6{margin-left:50%}.col-md-offset-5{margin-left:41.66666667%}.col-md-offset-4{margin-left:33.33333333%}.col-md-offset-3{margin-left:25%}.col-md-offset-2{margin-left:16.66666667%}.col-md-offset-1{margin-left:8.33333333%}.col-md-offset-0{margin-left:0%}}@media (min-width:1200px){.col-lg-1,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9,.col-lg-10,.col-lg-11,.col-lg-12{float:left}.col-lg-12{width:100%}.col-lg-11{width:91.66666667%}.col-lg-10{width:83.33333333%}.col-lg-9{width:75%}.col-lg-8{width:66.66666667%}.col-lg-7{width:58.33333333%}.col-lg-6{width:50%}.col-lg-5{width:41.66666667%}.col-lg-4{width:33.33333333%}.col-lg-3{width:25%}.col-lg-2{width:16.66666667%}.col-lg-1{width:8.33333333%}.col-lg-pull-12{right:100%}.col-lg-pull-11{right:91.66666667%}.col-lg-pull-10{right:83.33333333%}.col-lg-pull-9{right:75%}.col-lg-pull-8{right:66.66666667%}.col-lg-pull-7{right:58.33333333%}.col-lg-pull-6{right:50%}.col-lg-pull-5{right:41.66666667%}.col-lg-pull-4{right:33.33333333%}.col-lg-pull-3{right:25%}.col-lg-pull-2{right:16.66666667%}.col-lg-pull-1{right:8.33333333%}.col-lg-pull-0{right:auto}.col-lg-push-12{left:100%}.col-lg-push-11{left:91.66666667%}.col-lg-push-10{left:83.33333333%}.col-lg-push-9{left:75%}.col-lg-push-8{left:66.66666667%}.col-lg-push-7{left:58.33333333%}.col-lg-push-6{left:50%}.col-lg-push-5{left:41.66666667%}.col-lg-push-4{left:33.33333333%}.col-lg-push-3{left:25%}.col-lg-push-2{left:16.66666667%}.col-lg-push-1{left:8.33333333%}.col-lg-push-0{left:auto}.col-lg-offset-12{margin-left:100%}.col-lg-offset-11{margin-left:91.66666667%}.col-lg-offset-10{margin-left:83.33333333%}.col-lg-offset-9{margin-left:75%}.col-lg-offset-8{margin-left:66.66666667%}.col-lg-offset-7{margin-left:58.33333333%}.col-lg-offset-6{margin-left:50%}.col-lg-offset-5{margin-left:41.66666667%}.col-lg-offset-4{margin-left:33.33333333%}.col-lg-offset-3{margin-left:25%}.col-lg-offset-2{margin-left:16.66666667%}.col-lg-offset-1{margin-left:8.33333333%}.col-lg-offset-0{margin-left:0%}}table{background-color:transparent}caption{padding-top:8px;padding-bottom:8px;color:#999999;text-align:left}th{}.table{width:100%;max-width:100%;margin-bottom:21px}.table>thead>tr>th,.table>tbody>tr>th,.table>tfoot>tr>th,.table>thead>tr>td,.table>tbody>tr>td,.table>tfoot>tr>td{padding:8px;line-height:1.42857143;vertical-align:top;border-top:1px solid #dddddd}.table>thead>tr>th{vertical-align:bottom;border-bottom:2px solid #dddddd}.table>caption+thead>tr:first-child>th,.table>colgroup+thead>tr:first-child>th,.table>thead:first-child>tr:first-child>th,.table>caption+thead>tr:first-child>td,.table>colgroup+thead>tr:first-child>td,.table>thead:first-child>tr:first-child>td{border-top:0}.table>tbody+tbody{border-top:2px solid #dddddd}.table .table{background-color:#ffffff}.table-condensed>thead>tr>th,.table-condensed>tbody>tr>th,.table-condensed>tfoot>tr>th,.table-condensed>thead>tr>td,.table-condensed>tbody>tr>td,.table-condensed>tfoot>tr>td{padding:5px}.table-bordered{border:1px solid #dddddd}.table-bordered>thead>tr>th,.table-bordered>tbody>tr>th,.table-bordered>tfoot>tr>th,.table-bordered>thead>tr>td,.table-bordered>tbody>tr>td,.table-bordered>tfoot>tr>td{border:1px solid #dddddd}.table-bordered>thead>tr>th,.table-bordered>thead>tr>td{border-bottom-width:2px}.table-striped>tbody>tr:nth-of-type(odd){background-color:#f9f9f9}.table-hover>tbody>tr:hover{background-color:#f5f5f5}table col[class*="col-"]{position:static;float:none;display:table-column}table td[class*="col-"],table th[class*="col-"]{position:static;float:none;display:table-cell}.table>thead>tr>td.active,.table>tbody>tr>td.active,.table>tfoot>tr>td.active,.table>thead>tr>th.active,.table>tbody>tr>th.active,.table>tfoot>tr>th.active,.table>thead>tr.active>td,.table>tbody>tr.active>td,.table>tfoot>tr.active>td,.table>thead>tr.active>th,.table>tbody>tr.active>th,.table>tfoot>tr.active>th{background-color:#f5f5f5}.table-hover>tbody>tr>td.active:hover,.table-hover>tbody>tr>th.active:hover,.table-hover>tbody>tr.active:hover>td,.table-hover>tbody>tr:hover>.active,.table-hover>tbody>tr.active:hover>th{background-color:#e8e8e8}.table>thead>tr>td.success,.table>tbody>tr>td.success,.table>tfoot>tr>td.success,.table>thead>tr>th.success,.table>tbody>tr>th.success,.table>tfoot>tr>th.success,.table>thead>tr.success>td,.table>tbody>tr.success>td,.table>tfoot>tr.success>td,.table>thead>tr.success>th,.table>tbody>tr.success>th,.table>tfoot>tr.success>th{background-color:#3fb618}.table-hover>tbody>tr>td.success:hover,.table-hover>tbody>tr>th.success:hover,.table-hover>tbody>tr.success:hover>td,.table-hover>tbody>tr:hover>.success,.table-hover>tbody>tr.success:hover>th{background-color:#379f15}.table>thead>tr>td.info,.table>tbody>tr>td.info,.table>tfoot>tr>td.info,.table>thead>tr>th.info,.table>tbody>tr>th.info,.table>tfoot>tr>th.info,.table>thead>tr.info>td,.table>tbody>tr.info>td,.table>tfoot>tr.info>td,.table>thead>tr.info>th,.table>tbody>tr.info>th,.table>tfoot>tr.info>th{background-color:#9954bb}.table-hover>tbody>tr>td.info:hover,.table-hover>tbody>tr>th.info:hover,.table-hover>tbody>tr.info:hover>td,.table-hover>tbody>tr:hover>.info,.table-hover>tbody>tr.info:hover>th{background-color:#8d46b0}.table>thead>tr>td.warning,.table>tbody>tr>td.warning,.table>tfoot>tr>td.warning,.table>thead>tr>th.warning,.table>tbody>tr>th.warning,.table>tfoot>tr>th.warning,.table>thead>tr.warning>td,.table>tbody>tr.warning>td,.table>tfoot>tr.warning>td,.table>thead>tr.warning>th,.table>tbody>tr.warning>th,.table>tfoot>tr.warning>th{background-color:#ff7518}.table-hover>tbody>tr>td.warning:hover,.table-hover>tbody>tr>th.warning:hover,.table-hover>tbody>tr.warning:hover>td,.table-hover>tbody>tr:hover>.warning,.table-hover>tbody>tr.warning:hover>th{background-color:#fe6600}.table>thead>tr>td.danger,.table>tbody>tr>td.danger,.table>tfoot>tr>td.danger,.table>thead>tr>th.danger,.table>tbody>tr>th.danger,.table>tfoot>tr>th.danger,.table>thead>tr.danger>td,.table>tbody>tr.danger>td,.table>tfoot>tr.danger>td,.table>thead>tr.danger>th,.table>tbody>tr.danger>th,.table>tfoot>tr.danger>th{background-color:#ff0039}.table-hover>tbody>tr>td.danger:hover,.table-hover>tbody>tr>th.danger:hover,.table-hover>tbody>tr.danger:hover>td,.table-hover>tbody>tr:hover>.danger,.table-hover>tbody>tr.danger:hover>th{background-color:#e60033}.table-responsive{overflow-x:auto;min-height:0.01%}@media screen and (max-width:767px){.table-responsive{width:100%;margin-bottom:15.75px;overflow-y:hidden;-ms-overflow-style:-ms-autohiding-scrollbar;border:1px solid #dddddd}.table-responsive>.table{margin-bottom:0}.table-responsive>.table>thead>tr>th,.table-responsive>.table>tbody>tr>th,.table-responsive>.table>tfoot>tr>th,.table-responsive>.table>thead>tr>td,.table-responsive>.table>tbody>tr>td,.table-responsive>.table>tfoot>tr>td{white-space:nowrap}.table-responsive>.table-bordered{border:0}.table-responsive>.table-bordered>thead>tr>th:first-child,.table-responsive>.table-bordered>tbody>tr>th:first-child,.table-responsive>.table-bordered>tfoot>tr>th:first-child,.table-responsive>.table-bordered>thead>tr>td:first-child,.table-responsive>.table-bordered>tbody>tr>td:first-child,.table-responsive>.table-bordered>tfoot>tr>td:first-child{border-left:0}.table-responsive>.table-bordered>thead>tr>th:last-child,.table-responsive>.table-bordered>tbody>tr>th:last-child,.table-responsive>.table-bordered>tfoot>tr>th:last-child,.table-responsive>.table-bordered>thead>tr>td:last-child,.table-responsive>.table-bordered>tbody>tr>td:last-child,.table-responsive>.table-bordered>tfoot>tr>td:last-child{border-right:0}.table-responsive>.table-bordered>tbody>tr:last-child>th,.table-responsive>.table-bordered>tfoot>tr:last-child>th,.table-responsive>.table-bordered>tbody>tr:last-child>td,.table-responsive>.table-bordered>tfoot>tr:last-child>td{border-bottom:0}}fieldset{padding:0;margin:0;border:0;min-width:0}legend{display:block;width:100%;padding:0;margin-bottom:21px;font-size:22.5px;line-height:inherit;color:#333333;border:0;border-bottom:1px solid #e5e5e5}label{display:inline-block;max-width:100%;margin-bottom:5px;font-weight:bold}input[type="search"]{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}input[type="radio"],input[type="checkbox"]{margin:4px 0 0;margin-top:1px \9;line-height:normal}input[type="file"]{display:block}input[type="range"]{display:block;width:100%}select[multiple],select[size]{height:auto}input[type="file"]:focus,input[type="radio"]:focus,input[type="checkbox"]:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}output{display:block;padding-top:11px;font-size:15px;line-height:1.42857143;color:#333333}.form-control{display:block;width:100%;height:43px;padding:10px 18px;font-size:15px;line-height:1.42857143;color:#333333;background-color:#ffffff;background-image:none;border:1px solid #cccccc;border-radius:0;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);-webkit-transition:border-color ease-in-out .15s,-webkit-box-shadow ease-in-out .15s;-o-transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s;transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s}.form-control:focus{border-color:#66afe9;outline:0;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 8px rgba(102,175,233,0.6);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 8px rgba(102,175,233,0.6)}.form-control::-moz-placeholder{color:#999999;opacity:1}.form-control:-ms-input-placeholder{color:#999999}.form-control::-webkit-input-placeholder{color:#999999}.form-control::-ms-expand{border:0;background-color:transparent}.form-control[disabled],.form-control[readonly],fieldset[disabled] .form-control{background-color:#e6e6e6;opacity:1}.form-control[disabled],fieldset[disabled] .form-control{cursor:not-allowed}textarea.form-control{height:auto}input[type="search"]{-webkit-appearance:none}@media screen and (-webkit-min-device-pixel-ratio:0){input[type="date"].form-control,input[type="time"].form-control,input[type="datetime-local"].form-control,input[type="month"].form-control{line-height:43px}input[type="date"].input-sm,input[type="time"].input-sm,input[type="datetime-local"].input-sm,input[type="month"].input-sm,.input-group-sm input[type="date"],.input-group-sm input[type="time"],.input-group-sm input[type="datetime-local"],.input-group-sm input[type="month"]{line-height:31px}input[type="date"].input-lg,input[type="time"].input-lg,input[type="datetime-local"].input-lg,input[type="month"].input-lg,.input-group-lg input[type="date"],.input-group-lg input[type="time"],.input-group-lg input[type="datetime-local"],.input-group-lg input[type="month"]{line-height:64px}}.form-group{margin-bottom:15px}.radio,.checkbox{position:relative;display:block;margin-top:10px;margin-bottom:10px}.radio label,.checkbox label{min-height:21px;padding-left:20px;margin-bottom:0;font-weight:normal;cursor:pointer}.radio input[type="radio"],.radio-inline input[type="radio"],.checkbox input[type="checkbox"],.checkbox-inline input[type="checkbox"]{position:absolute;margin-left:-20px;margin-top:4px \9}.radio+.radio,.checkbox+.checkbox{margin-top:-5px}.radio-inline,.checkbox-inline{position:relative;display:inline-block;padding-left:20px;margin-bottom:0;vertical-align:middle;font-weight:normal;cursor:pointer}.radio-inline+.radio-inline,.checkbox-inline+.checkbox-inline{margin-top:0;margin-left:10px}input[type="radio"][disabled],input[type="checkbox"][disabled],input[type="radio"].disabled,input[type="checkbox"].disabled,fieldset[disabled] input[type="radio"],fieldset[disabled] input[type="checkbox"]{cursor:not-allowed}.radio-inline.disabled,.checkbox-inline.disabled,fieldset[disabled] .radio-inline,fieldset[disabled] .checkbox-inline{cursor:not-allowed}.radio.disabled label,.checkbox.disabled label,fieldset[disabled] .radio label,fieldset[disabled] .checkbox label{cursor:not-allowed}.form-control-static{padding-top:11px;padding-bottom:11px;margin-bottom:0;min-height:36px}.form-control-static.input-lg,.form-control-static.input-sm{padding-left:0;padding-right:0}.input-sm{height:31px;padding:5px 10px;font-size:13px;line-height:1.5;border-radius:0}select.input-sm{height:31px;line-height:31px}textarea.input-sm,select[multiple].input-sm{height:auto}.form-group-sm .form-control{height:31px;padding:5px 10px;font-size:13px;line-height:1.5;border-radius:0}.form-group-sm select.form-control{height:31px;line-height:31px}.form-group-sm textarea.form-control,.form-group-sm select[multiple].form-control{height:auto}.form-group-sm .form-control-static{height:31px;min-height:34px;padding:6px 10px;font-size:13px;line-height:1.5}.input-lg{height:64px;padding:18px 30px;font-size:19px;line-height:1.3333333;border-radius:0}select.input-lg{height:64px;line-height:64px}textarea.input-lg,select[multiple].input-lg{height:auto}.form-group-lg .form-control{height:64px;padding:18px 30px;font-size:19px;line-height:1.3333333;border-radius:0}.form-group-lg select.form-control{height:64px;line-height:64px}.form-group-lg textarea.form-control,.form-group-lg select[multiple].form-control{height:auto}.form-group-lg .form-control-static{height:64px;min-height:40px;padding:19px 30px;font-size:19px;line-height:1.3333333}.has-feedback{position:relative}.has-feedback .form-control{padding-right:53.75px}.form-control-feedback{position:absolute;top:0;right:0;z-index:2;display:block;width:43px;height:43px;line-height:43px;text-align:center;pointer-events:none}.input-lg+.form-control-feedback,.input-group-lg+.form-control-feedback,.form-group-lg .form-control+.form-control-feedback{width:64px;height:64px;line-height:64px}.input-sm+.form-control-feedback,.input-group-sm+.form-control-feedback,.form-group-sm .form-control+.form-control-feedback{width:31px;height:31px;line-height:31px}.has-success .help-block,.has-success .control-label,.has-success .radio,.has-success .checkbox,.has-success .radio-inline,.has-success .checkbox-inline,.has-success.radio label,.has-success.checkbox label,.has-success.radio-inline label,.has-success.checkbox-inline label{color:#ffffff}.has-success .form-control{border-color:#ffffff;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075)}.has-success .form-control:focus{border-color:#e6e6e6;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #fff;box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #fff}.has-success .input-group-addon{color:#ffffff;border-color:#ffffff;background-color:#3fb618}.has-success .form-control-feedback{color:#ffffff}.has-warning .help-block,.has-warning .control-label,.has-warning .radio,.has-warning .checkbox,.has-warning .radio-inline,.has-warning .checkbox-inline,.has-warning.radio label,.has-warning.checkbox label,.has-warning.radio-inline label,.has-warning.checkbox-inline label{color:#ffffff}.has-warning .form-control{border-color:#ffffff;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075)}.has-warning .form-control:focus{border-color:#e6e6e6;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #fff;box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #fff}.has-warning .input-group-addon{color:#ffffff;border-color:#ffffff;background-color:#ff7518}.has-warning .form-control-feedback{color:#ffffff}.has-error .help-block,.has-error .control-label,.has-error .radio,.has-error .checkbox,.has-error .radio-inline,.has-error .checkbox-inline,.has-error.radio label,.has-error.checkbox label,.has-error.radio-inline label,.has-error.checkbox-inline label{color:#ffffff}.has-error .form-control{border-color:#ffffff;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075);box-shadow:inset 0 1px 1px rgba(0,0,0,0.075)}.has-error .form-control:focus{border-color:#e6e6e6;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #fff;box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 6px #fff}.has-error .input-group-addon{color:#ffffff;border-color:#ffffff;background-color:#ff0039}.has-error .form-control-feedback{color:#ffffff}.has-feedback label~.form-control-feedback{top:26px}.has-feedback label.sr-only~.form-control-feedback{top:0}.help-block{display:block;margin-top:5px;margin-bottom:10px;color:#737373}@media (min-width:768px){.form-inline .form-group{display:inline-block;margin-bottom:0;vertical-align:middle}.form-inline .form-control{display:inline-block;width:auto;vertical-align:middle}.form-inline .form-control-static{display:inline-block}.form-inline .input-group{display:inline-table;vertical-align:middle}.form-inline .input-group .input-group-addon,.form-inline .input-group .input-group-btn,.form-inline .input-group .form-control{width:auto}.form-inline .input-group>.form-control{width:100%}.form-inline .control-label{margin-bottom:0;vertical-align:middle}.form-inline .radio,.form-inline .checkbox{display:inline-block;margin-top:0;margin-bottom:0;vertical-align:middle}.form-inline .radio label,.form-inline .checkbox label{padding-left:0}.form-inline .radio input[type="radio"],.form-inline .checkbox input[type="checkbox"]{position:relative;margin-left:0}.form-inline .has-feedback .form-control-feedback{top:0}}.form-horizontal .radio,.form-horizontal .checkbox,.form-horizontal .radio-inline,.form-horizontal .checkbox-inline{margin-top:0;margin-bottom:0;padding-top:11px}.form-horizontal .radio,.form-horizontal .checkbox{min-height:32px}.form-horizontal .form-group{margin-left:-15px;margin-right:-15px}@media (min-width:768px){.form-horizontal .control-label{text-align:right;margin-bottom:0;padding-top:11px}}.form-horizontal .has-feedback .form-control-feedback{right:15px}@media (min-width:768px){.form-horizontal .form-group-lg .control-label{padding-top:19px;font-size:19px}}@media (min-width:768px){.form-horizontal .form-group-sm .control-label{padding-top:6px;font-size:13px}}.btn{display:inline-block;margin-bottom:0;font-weight:normal;text-align:center;vertical-align:middle;-ms-touch-action:manipulation;touch-action:manipulation;cursor:pointer;background-image:none;border:1px solid transparent;white-space:nowrap;padding:10px 18px;font-size:15px;line-height:1.42857143;border-radius:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.btn:focus,.btn:active:focus,.btn.active:focus,.btn.focus,.btn:active.focus,.btn.active.focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.btn:hover,.btn:focus,.btn.focus{color:#ffffff;text-decoration:none}.btn:active,.btn.active{outline:0;background-image:none;-webkit-box-shadow:inset 0 3px 5px rgba(0,0,0,0.125);box-shadow:inset 0 3px 5px rgba(0,0,0,0.125)}.btn.disabled,.btn[disabled],fieldset[disabled] .btn{cursor:not-allowed;opacity:0.65;filter:alpha(opacity=65);-webkit-box-shadow:none;box-shadow:none}a.btn.disabled,fieldset[disabled] a.btn{pointer-events:none}.btn-default{color:#ffffff;background-color:#222222;border-color:#222222}.btn-default:focus,.btn-default.focus{color:#ffffff;background-color:#090909;border-color:#000000}.btn-default:hover{color:#ffffff;background-color:#090909;border-color:#040404}.btn-default:active,.btn-default.active,.open>.dropdown-toggle.btn-default{color:#ffffff;background-color:#090909;border-color:#040404}.btn-default:active:hover,.btn-default.active:hover,.open>.dropdown-toggle.btn-default:hover,.btn-default:active:focus,.btn-default.active:focus,.open>.dropdown-toggle.btn-default:focus,.btn-default:active.focus,.btn-default.active.focus,.open>.dropdown-toggle.btn-default.focus{color:#ffffff;background-color:#000000;border-color:#000000}.btn-default:active,.btn-default.active,.open>.dropdown-toggle.btn-default{background-image:none}.btn-default.disabled:hover,.btn-default[disabled]:hover,fieldset[disabled] .btn-default:hover,.btn-default.disabled:focus,.btn-default[disabled]:focus,fieldset[disabled] .btn-default:focus,.btn-default.disabled.focus,.btn-default[disabled].focus,fieldset[disabled] .btn-default.focus{background-color:#222222;border-color:#222222}.btn-default .badge{color:#222222;background-color:#ffffff}.btn-primary{color:#ffffff;background-color:#2780e3;border-color:#2780e3}.btn-primary:focus,.btn-primary.focus{color:#ffffff;background-color:#1967be;border-color:#10427b}.btn-primary:hover{color:#ffffff;background-color:#1967be;border-color:#1862b5}.btn-primary:active,.btn-primary.active,.open>.dropdown-toggle.btn-primary{color:#ffffff;background-color:#1967be;border-color:#1862b5}.btn-primary:active:hover,.btn-primary.active:hover,.open>.dropdown-toggle.btn-primary:hover,.btn-primary:active:focus,.btn-primary.active:focus,.open>.dropdown-toggle.btn-primary:focus,.btn-primary:active.focus,.btn-primary.active.focus,.open>.dropdown-toggle.btn-primary.focus{color:#ffffff;background-color:#15569f;border-color:#10427b}.btn-primary:active,.btn-primary.active,.open>.dropdown-toggle.btn-primary{background-image:none}.btn-primary.disabled:hover,.btn-primary[disabled]:hover,fieldset[disabled] .btn-primary:hover,.btn-primary.disabled:focus,.btn-primary[disabled]:focus,fieldset[disabled] .btn-primary:focus,.btn-primary.disabled.focus,.btn-primary[disabled].focus,fieldset[disabled] .btn-primary.focus{background-color:#2780e3;border-color:#2780e3}.btn-primary .badge{color:#2780e3;background-color:#ffffff}.btn-success{color:#ffffff;background-color:#3fb618;border-color:#3fb618}.btn-success:focus,.btn-success.focus{color:#ffffff;background-color:#2f8912;border-color:#184509}.btn-success:hover{color:#ffffff;background-color:#2f8912;border-color:#2c8011}.btn-success:active,.btn-success.active,.open>.dropdown-toggle.btn-success{color:#ffffff;background-color:#2f8912;border-color:#2c8011}.btn-success:active:hover,.btn-success.active:hover,.open>.dropdown-toggle.btn-success:hover,.btn-success:active:focus,.btn-success.active:focus,.open>.dropdown-toggle.btn-success:focus,.btn-success:active.focus,.btn-success.active.focus,.open>.dropdown-toggle.btn-success.focus{color:#ffffff;background-color:#24690e;border-color:#184509}.btn-success:active,.btn-success.active,.open>.dropdown-toggle.btn-success{background-image:none}.btn-success.disabled:hover,.btn-success[disabled]:hover,fieldset[disabled] .btn-success:hover,.btn-success.disabled:focus,.btn-success[disabled]:focus,fieldset[disabled] .btn-success:focus,.btn-success.disabled.focus,.btn-success[disabled].focus,fieldset[disabled] .btn-success.focus{background-color:#3fb618;border-color:#3fb618}.btn-success .badge{color:#3fb618;background-color:#ffffff}.btn-info{color:#ffffff;background-color:#9954bb;border-color:#9954bb}.btn-info:focus,.btn-info.focus{color:#ffffff;background-color:#7e3f9d;border-color:#522967}.btn-info:hover{color:#ffffff;background-color:#7e3f9d;border-color:#783c96}.btn-info:active,.btn-info.active,.open>.dropdown-toggle.btn-info{color:#ffffff;background-color:#7e3f9d;border-color:#783c96}.btn-info:active:hover,.btn-info.active:hover,.open>.dropdown-toggle.btn-info:hover,.btn-info:active:focus,.btn-info.active:focus,.open>.dropdown-toggle.btn-info:focus,.btn-info:active.focus,.btn-info.active.focus,.open>.dropdown-toggle.btn-info.focus{color:#ffffff;background-color:#6a3484;border-color:#522967}.btn-info:active,.btn-info.active,.open>.dropdown-toggle.btn-info{background-image:none}.btn-info.disabled:hover,.btn-info[disabled]:hover,fieldset[disabled] .btn-info:hover,.btn-info.disabled:focus,.btn-info[disabled]:focus,fieldset[disabled] .btn-info:focus,.btn-info.disabled.focus,.btn-info[disabled].focus,fieldset[disabled] .btn-info.focus{background-color:#9954bb;border-color:#9954bb}.btn-info .badge{color:#9954bb;background-color:#ffffff}.btn-warning{color:#ffffff;background-color:#ff7518;border-color:#ff7518}.btn-warning:focus,.btn-warning.focus{color:#ffffff;background-color:#e45c00;border-color:#983d00}.btn-warning:hover{color:#ffffff;background-color:#e45c00;border-color:#da5800}.btn-warning:active,.btn-warning.active,.open>.dropdown-toggle.btn-warning{color:#ffffff;background-color:#e45c00;border-color:#da5800}.btn-warning:active:hover,.btn-warning.active:hover,.open>.dropdown-toggle.btn-warning:hover,.btn-warning:active:focus,.btn-warning.active:focus,.open>.dropdown-toggle.btn-warning:focus,.btn-warning:active.focus,.btn-warning.active.focus,.open>.dropdown-toggle.btn-warning.focus{color:#ffffff;background-color:#c04d00;border-color:#983d00}.btn-warning:active,.btn-warning.active,.open>.dropdown-toggle.btn-warning{background-image:none}.btn-warning.disabled:hover,.btn-warning[disabled]:hover,fieldset[disabled] .btn-warning:hover,.btn-warning.disabled:focus,.btn-warning[disabled]:focus,fieldset[disabled] .btn-warning:focus,.btn-warning.disabled.focus,.btn-warning[disabled].focus,fieldset[disabled] .btn-warning.focus{background-color:#ff7518;border-color:#ff7518}.btn-warning .badge{color:#ff7518;background-color:#ffffff}.btn-danger{color:#ffffff;background-color:#ff0039;border-color:#ff0039}.btn-danger:focus,.btn-danger.focus{color:#ffffff;background-color:#cc002e;border-color:#80001c}.btn-danger:hover{color:#ffffff;background-color:#cc002e;border-color:#c2002b}.btn-danger:active,.btn-danger.active,.open>.dropdown-toggle.btn-danger{color:#ffffff;background-color:#cc002e;border-color:#c2002b}.btn-danger:active:hover,.btn-danger.active:hover,.open>.dropdown-toggle.btn-danger:hover,.btn-danger:active:focus,.btn-danger.active:focus,.open>.dropdown-toggle.btn-danger:focus,.btn-danger:active.focus,.btn-danger.active.focus,.open>.dropdown-toggle.btn-danger.focus{color:#ffffff;background-color:#a80026;border-color:#80001c}.btn-danger:active,.btn-danger.active,.open>.dropdown-toggle.btn-danger{background-image:none}.btn-danger.disabled:hover,.btn-danger[disabled]:hover,fieldset[disabled] .btn-danger:hover,.btn-danger.disabled:focus,.btn-danger[disabled]:focus,fieldset[disabled] .btn-danger:focus,.btn-danger.disabled.focus,.btn-danger[disabled].focus,fieldset[disabled] .btn-danger.focus{background-color:#ff0039;border-color:#ff0039}.btn-danger .badge{color:#ff0039;background-color:#ffffff}.btn-link{color:#2780e3;font-weight:normal;border-radius:0}.btn-link,.btn-link:active,.btn-link.active,.btn-link[disabled],fieldset[disabled] .btn-link{background-color:transparent;-webkit-box-shadow:none;box-shadow:none}.btn-link,.btn-link:hover,.btn-link:focus,.btn-link:active{border-color:transparent}.btn-link:hover,.btn-link:focus{color:#165ba8;text-decoration:underline;background-color:transparent}.btn-link[disabled]:hover,fieldset[disabled] .btn-link:hover,.btn-link[disabled]:focus,fieldset[disabled] .btn-link:focus{color:#999999;text-decoration:none}.btn-lg,.btn-group-lg>.btn{padding:18px 30px;font-size:19px;line-height:1.3333333;border-radius:0}.btn-sm,.btn-group-sm>.btn{padding:5px 10px;font-size:13px;line-height:1.5;border-radius:0}.btn-xs,.btn-group-xs>.btn{padding:1px 5px;font-size:13px;line-height:1.5;border-radius:0}.btn-block{display:block;width:100%}.btn-block+.btn-block{margin-top:5px}input[type="submit"].btn-block,input[type="reset"].btn-block,input[type="button"].btn-block{width:100%}.fade{opacity:0;-webkit-transition:opacity 0.15s linear;-o-transition:opacity 0.15s linear;transition:opacity 0.15s linear}.fade.in{opacity:1}.collapse{display:none}.collapse.in{display:block}tr.collapse.in{display:table-row}tbody.collapse.in{display:table-row-group}.collapsing{position:relative;height:0;overflow:hidden;-webkit-transition-property:height, visibility;-o-transition-property:height, visibility;transition-property:height, visibility;-webkit-transition-duration:0.35s;-o-transition-duration:0.35s;transition-duration:0.35s;-webkit-transition-timing-function:ease;-o-transition-timing-function:ease;transition-timing-function:ease}.caret{display:inline-block;width:0;height:0;margin-left:2px;vertical-align:middle;border-top:4px dashed;border-top:4px solid \9;border-right:4px solid transparent;border-left:4px solid transparent}.dropup,.dropdown{position:relative}.dropdown-toggle:focus{outline:0}.dropdown-menu{position:absolute;top:100%;left:0;z-index:1000;display:none;float:left;min-width:160px;padding:5px 0;margin:2px 0 0;list-style:none;font-size:15px;text-align:left;background-color:#ffffff;border:1px solid #cccccc;border:1px solid rgba(0,0,0,0.15);border-radius:0;-webkit-box-shadow:0 6px 12px rgba(0,0,0,0.175);box-shadow:0 6px 12px rgba(0,0,0,0.175);-webkit-background-clip:padding-box;background-clip:padding-box}.dropdown-menu.pull-right{right:0;left:auto}.dropdown-menu .divider{height:1px;margin:9.5px 0;overflow:hidden;background-color:#e5e5e5}.dropdown-menu>li>a{display:block;padding:3px 20px;clear:both;font-weight:normal;line-height:1.42857143;color:#333333;white-space:nowrap}.dropdown-menu>li>a:hover,.dropdown-menu>li>a:focus{text-decoration:none;color:#ffffff;background-color:#2780e3}.dropdown-menu>.active>a,.dropdown-menu>.active>a:hover,.dropdown-menu>.active>a:focus{color:#ffffff;text-decoration:none;outline:0;background-color:#2780e3}.dropdown-menu>.disabled>a,.dropdown-menu>.disabled>a:hover,.dropdown-menu>.disabled>a:focus{color:#999999}.dropdown-menu>.disabled>a:hover,.dropdown-menu>.disabled>a:focus{text-decoration:none;background-color:transparent;background-image:none;filter:progid:DXImageTransform.Microsoft.gradient(enabled=false);cursor:not-allowed}.open>.dropdown-menu{display:block}.open>a{outline:0}.dropdown-menu-right{left:auto;right:0}.dropdown-menu-left{left:0;right:auto}.dropdown-header{display:block;padding:3px 20px;font-size:13px;line-height:1.42857143;color:#999999;white-space:nowrap}.dropdown-backdrop{position:fixed;left:0;right:0;bottom:0;top:0;z-index:990}.pull-right>.dropdown-menu{right:0;left:auto}.dropup .caret,.navbar-fixed-bottom .dropdown .caret{border-top:0;border-bottom:4px dashed;border-bottom:4px solid \9;content:""}.dropup .dropdown-menu,.navbar-fixed-bottom .dropdown .dropdown-menu{top:auto;bottom:100%;margin-bottom:2px}@media (min-width:768px){.navbar-right .dropdown-menu{left:auto;right:0}.navbar-right .dropdown-menu-left{left:0;right:auto}}.btn-group,.btn-group-vertical{position:relative;display:inline-block;vertical-align:middle}.btn-group>.btn,.btn-group-vertical>.btn{position:relative;float:left}.btn-group>.btn:hover,.btn-group-vertical>.btn:hover,.btn-group>.btn:focus,.btn-group-vertical>.btn:focus,.btn-group>.btn:active,.btn-group-vertical>.btn:active,.btn-group>.btn.active,.btn-group-vertical>.btn.active{z-index:2}.btn-group .btn+.btn,.btn-group .btn+.btn-group,.btn-group .btn-group+.btn,.btn-group .btn-group+.btn-group{margin-left:-1px}.btn-toolbar{margin-left:-5px}.btn-toolbar .btn,.btn-toolbar .btn-group,.btn-toolbar .input-group{float:left}.btn-toolbar>.btn,.btn-toolbar>.btn-group,.btn-toolbar>.input-group{margin-left:5px}.btn-group>.btn:not(:first-child):not(:last-child):not(.dropdown-toggle){border-radius:0}.btn-group>.btn:first-child{margin-left:0}.btn-group>.btn:first-child:not(:last-child):not(.dropdown-toggle){border-bottom-right-radius:0;border-top-right-radius:0}.btn-group>.btn:last-child:not(:first-child),.btn-group>.dropdown-toggle:not(:first-child){border-bottom-left-radius:0;border-top-left-radius:0}.btn-group>.btn-group{float:left}.btn-group>.btn-group:not(:first-child):not(:last-child)>.btn{border-radius:0}.btn-group>.btn-group:first-child:not(:last-child)>.btn:last-child,.btn-group>.btn-group:first-child:not(:last-child)>.dropdown-toggle{border-bottom-right-radius:0;border-top-right-radius:0}.btn-group>.btn-group:last-child:not(:first-child)>.btn:first-child{border-bottom-left-radius:0;border-top-left-radius:0}.btn-group .dropdown-toggle:active,.btn-group.open .dropdown-toggle{outline:0}.btn-group>.btn+.dropdown-toggle{padding-left:8px;padding-right:8px}.btn-group>.btn-lg+.dropdown-toggle{padding-left:12px;padding-right:12px}.btn-group.open .dropdown-toggle{-webkit-box-shadow:inset 0 3px 5px rgba(0,0,0,0.125);box-shadow:inset 0 3px 5px rgba(0,0,0,0.125)}.btn-group.open .dropdown-toggle.btn-link{-webkit-box-shadow:none;box-shadow:none}.btn .caret{margin-left:0}.btn-lg .caret{border-width:5px 5px 0;border-bottom-width:0}.dropup .btn-lg .caret{border-width:0 5px 5px}.btn-group-vertical>.btn,.btn-group-vertical>.btn-group,.btn-group-vertical>.btn-group>.btn{display:block;float:none;width:100%;max-width:100%}.btn-group-vertical>.btn-group>.btn{float:none}.btn-group-vertical>.btn+.btn,.btn-group-vertical>.btn+.btn-group,.btn-group-vertical>.btn-group+.btn,.btn-group-vertical>.btn-group+.btn-group{margin-top:-1px;margin-left:0}.btn-group-vertical>.btn:not(:first-child):not(:last-child){border-radius:0}.btn-group-vertical>.btn:first-child:not(:last-child){border-top-right-radius:0;border-top-left-radius:0;border-bottom-right-radius:0;border-bottom-left-radius:0}.btn-group-vertical>.btn:last-child:not(:first-child){border-top-right-radius:0;border-top-left-radius:0;border-bottom-right-radius:0;border-bottom-left-radius:0}.btn-group-vertical>.btn-group:not(:first-child):not(:last-child)>.btn{border-radius:0}.btn-group-vertical>.btn-group:first-child:not(:last-child)>.btn:last-child,.btn-group-vertical>.btn-group:first-child:not(:last-child)>.dropdown-toggle{border-bottom-right-radius:0;border-bottom-left-radius:0}.btn-group-vertical>.btn-group:last-child:not(:first-child)>.btn:first-child{border-top-right-radius:0;border-top-left-radius:0}.btn-group-justified{display:table;width:100%;table-layout:fixed;border-collapse:separate}.btn-group-justified>.btn,.btn-group-justified>.btn-group{float:none;display:table-cell;width:1%}.btn-group-justified>.btn-group .btn{width:100%}.btn-group-justified>.btn-group .dropdown-menu{left:auto}[data-toggle="buttons"]>.btn input[type="radio"],[data-toggle="buttons"]>.btn-group>.btn input[type="radio"],[data-toggle="buttons"]>.btn input[type="checkbox"],[data-toggle="buttons"]>.btn-group>.btn input[type="checkbox"]{position:absolute;clip:rect(0, 0, 0, 0);pointer-events:none}.input-group{position:relative;display:table;border-collapse:separate}.input-group[class*="col-"]{float:none;padding-left:0;padding-right:0}.input-group .form-control{position:relative;z-index:2;float:left;width:100%;margin-bottom:0}.input-group .form-control:focus{z-index:3}.input-group-lg>.form-control,.input-group-lg>.input-group-addon,.input-group-lg>.input-group-btn>.btn{height:64px;padding:18px 30px;font-size:19px;line-height:1.3333333;border-radius:0}select.input-group-lg>.form-control,select.input-group-lg>.input-group-addon,select.input-group-lg>.input-group-btn>.btn{height:64px;line-height:64px}textarea.input-group-lg>.form-control,textarea.input-group-lg>.input-group-addon,textarea.input-group-lg>.input-group-btn>.btn,select[multiple].input-group-lg>.form-control,select[multiple].input-group-lg>.input-group-addon,select[multiple].input-group-lg>.input-group-btn>.btn{height:auto}.input-group-sm>.form-control,.input-group-sm>.input-group-addon,.input-group-sm>.input-group-btn>.btn{height:31px;padding:5px 10px;font-size:13px;line-height:1.5;border-radius:0}select.input-group-sm>.form-control,select.input-group-sm>.input-group-addon,select.input-group-sm>.input-group-btn>.btn{height:31px;line-height:31px}textarea.input-group-sm>.form-control,textarea.input-group-sm>.input-group-addon,textarea.input-group-sm>.input-group-btn>.btn,select[multiple].input-group-sm>.form-control,select[multiple].input-group-sm>.input-group-addon,select[multiple].input-group-sm>.input-group-btn>.btn{height:auto}.input-group-addon,.input-group-btn,.input-group .form-control{display:table-cell}.input-group-addon:not(:first-child):not(:last-child),.input-group-btn:not(:first-child):not(:last-child),.input-group .form-control:not(:first-child):not(:last-child){border-radius:0}.input-group-addon,.input-group-btn{width:1%;white-space:nowrap;vertical-align:middle}.input-group-addon{padding:10px 18px;font-size:15px;font-weight:normal;line-height:1;color:#333333;text-align:center;background-color:#e6e6e6;border:1px solid #cccccc;border-radius:0}.input-group-addon.input-sm{padding:5px 10px;font-size:13px;border-radius:0}.input-group-addon.input-lg{padding:18px 30px;font-size:19px;border-radius:0}.input-group-addon input[type="radio"],.input-group-addon input[type="checkbox"]{margin-top:0}.input-group .form-control:first-child,.input-group-addon:first-child,.input-group-btn:first-child>.btn,.input-group-btn:first-child>.btn-group>.btn,.input-group-btn:first-child>.dropdown-toggle,.input-group-btn:last-child>.btn:not(:last-child):not(.dropdown-toggle),.input-group-btn:last-child>.btn-group:not(:last-child)>.btn{border-bottom-right-radius:0;border-top-right-radius:0}.input-group-addon:first-child{border-right:0}.input-group .form-control:last-child,.input-group-addon:last-child,.input-group-btn:last-child>.btn,.input-group-btn:last-child>.btn-group>.btn,.input-group-btn:last-child>.dropdown-toggle,.input-group-btn:first-child>.btn:not(:first-child),.input-group-btn:first-child>.btn-group:not(:first-child)>.btn{border-bottom-left-radius:0;border-top-left-radius:0}.input-group-addon:last-child{border-left:0}.input-group-btn{position:relative;font-size:0;white-space:nowrap}.input-group-btn>.btn{position:relative}.input-group-btn>.btn+.btn{margin-left:-1px}.input-group-btn>.btn:hover,.input-group-btn>.btn:focus,.input-group-btn>.btn:active{z-index:2}.input-group-btn:first-child>.btn,.input-group-btn:first-child>.btn-group{margin-right:-1px}.input-group-btn:last-child>.btn,.input-group-btn:last-child>.btn-group{z-index:2;margin-left:-1px}.nav{margin-bottom:0;padding-left:0;list-style:none}.nav>li{position:relative;display:block}.nav>li>a{position:relative;display:block;padding:10px 15px}.nav>li>a:hover,.nav>li>a:focus{text-decoration:none;background-color:#e6e6e6}.nav>li.disabled>a{color:#999999}.nav>li.disabled>a:hover,.nav>li.disabled>a:focus{color:#999999;text-decoration:none;background-color:transparent;cursor:not-allowed}.nav .open>a,.nav .open>a:hover,.nav .open>a:focus{background-color:#e6e6e6;border-color:#2780e3}.nav .nav-divider{height:1px;margin:9.5px 0;overflow:hidden;background-color:#e5e5e5}.nav>li>a>img{max-width:none}.nav-tabs{border-bottom:1px solid #dddddd}.nav-tabs>li{float:left;margin-bottom:-1px}.nav-tabs>li>a{margin-right:2px;line-height:1.42857143;border:1px solid transparent;border-radius:0 0 0 0}.nav-tabs>li>a:hover{border-color:#e6e6e6 #e6e6e6 #dddddd}.nav-tabs>li.active>a,.nav-tabs>li.active>a:hover,.nav-tabs>li.active>a:focus{color:#555555;background-color:#ffffff;border:1px solid #dddddd;border-bottom-color:transparent;cursor:default}.nav-tabs.nav-justified{width:100%;border-bottom:0}.nav-tabs.nav-justified>li{float:none}.nav-tabs.nav-justified>li>a{text-align:center;margin-bottom:5px}.nav-tabs.nav-justified>.dropdown .dropdown-menu{top:auto;left:auto}@media (min-width:768px){.nav-tabs.nav-justified>li{display:table-cell;width:1%}.nav-tabs.nav-justified>li>a{margin-bottom:0}}.nav-tabs.nav-justified>li>a{margin-right:0;border-radius:0}.nav-tabs.nav-justified>.active>a,.nav-tabs.nav-justified>.active>a:hover,.nav-tabs.nav-justified>.active>a:focus{border:1px solid #dddddd}@media (min-width:768px){.nav-tabs.nav-justified>li>a{border-bottom:1px solid #dddddd;border-radius:0 0 0 0}.nav-tabs.nav-justified>.active>a,.nav-tabs.nav-justified>.active>a:hover,.nav-tabs.nav-justified>.active>a:focus{border-bottom-color:#ffffff}}.nav-pills>li{float:left}.nav-pills>li>a{border-radius:0}.nav-pills>li+li{margin-left:2px}.nav-pills>li.active>a,.nav-pills>li.active>a:hover,.nav-pills>li.active>a:focus{color:#ffffff;background-color:#2780e3}.nav-stacked>li{float:none}.nav-stacked>li+li{margin-top:2px;margin-left:0}.nav-justified{width:100%}.nav-justified>li{float:none}.nav-justified>li>a{text-align:center;margin-bottom:5px}.nav-justified>.dropdown .dropdown-menu{top:auto;left:auto}@media (min-width:768px){.nav-justified>li{display:table-cell;width:1%}.nav-justified>li>a{margin-bottom:0}}.nav-tabs-justified{border-bottom:0}.nav-tabs-justified>li>a{margin-right:0;border-radius:0}.nav-tabs-justified>.active>a,.nav-tabs-justified>.active>a:hover,.nav-tabs-justified>.active>a:focus{border:1px solid #dddddd}@media (min-width:768px){.nav-tabs-justified>li>a{border-bottom:1px solid #dddddd;border-radius:0 0 0 0}.nav-tabs-justified>.active>a,.nav-tabs-justified>.active>a:hover,.nav-tabs-justified>.active>a:focus{border-bottom-color:#ffffff}}.tab-content>.tab-pane{display:none}.tab-content>.active{display:block}.nav-tabs .dropdown-menu{margin-top:-1px;border-top-right-radius:0;border-top-left-radius:0}.navbar{position:relative;min-height:50px;margin-bottom:21px;border:1px solid transparent}@media (min-width:768px){.navbar{border-radius:0}}@media (min-width:768px){.navbar-header{float:left}}.navbar-collapse{overflow-x:visible;padding-right:15px;padding-left:15px;border-top:1px solid transparent;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,0.1);box-shadow:inset 0 1px 0 rgba(255,255,255,0.1);-webkit-overflow-scrolling:touch}.navbar-collapse.in{overflow-y:auto}@media (min-width:768px){.navbar-collapse{width:auto;border-top:0;-webkit-box-shadow:none;box-shadow:none}.navbar-collapse.collapse{display:block !important;height:auto !important;padding-bottom:0;overflow:visible !important}.navbar-collapse.in{overflow-y:visible}.navbar-fixed-top .navbar-collapse,.navbar-static-top .navbar-collapse,.navbar-fixed-bottom .navbar-collapse{padding-left:0;padding-right:0}}.navbar-fixed-top .navbar-collapse,.navbar-fixed-bottom .navbar-collapse{max-height:340px}@media (max-device-width:480px) and (orientation:landscape){.navbar-fixed-top .navbar-collapse,.navbar-fixed-bottom .navbar-collapse{max-height:200px}}.container>.navbar-header,.container-fluid>.navbar-header,.container>.navbar-collapse,.container-fluid>.navbar-collapse{margin-right:-15px;margin-left:-15px}@media (min-width:768px){.container>.navbar-header,.container-fluid>.navbar-header,.container>.navbar-collapse,.container-fluid>.navbar-collapse{margin-right:0;margin-left:0}}.navbar-static-top{z-index:1000;border-width:0 0 1px}@media (min-width:768px){.navbar-static-top{border-radius:0}}.navbar-fixed-top,.navbar-fixed-bottom{position:fixed;right:0;left:0;z-index:1030}@media (min-width:768px){.navbar-fixed-top,.navbar-fixed-bottom{border-radius:0}}.navbar-fixed-top{top:0;border-width:0 0 1px}.navbar-fixed-bottom{bottom:0;margin-bottom:0;border-width:1px 0 0}.navbar-brand{float:left;padding:14.5px 15px;font-size:19px;line-height:21px;height:50px}.navbar-brand:hover,.navbar-brand:focus{text-decoration:none}.navbar-brand>img{display:block}@media (min-width:768px){.navbar>.container .navbar-brand,.navbar>.container-fluid .navbar-brand{margin-left:-15px}}.navbar-toggle{position:relative;float:right;margin-right:15px;padding:9px 10px;margin-top:8px;margin-bottom:8px;background-color:transparent;background-image:none;border:1px solid transparent;border-radius:0}.navbar-toggle:focus{outline:0}.navbar-toggle .icon-bar{display:block;width:22px;height:2px;border-radius:1px}.navbar-toggle .icon-bar+.icon-bar{margin-top:4px}@media (min-width:768px){.navbar-toggle{display:none}}.navbar-nav{margin:7.25px -15px}.navbar-nav>li>a{padding-top:10px;padding-bottom:10px;line-height:21px}@media (max-width:767px){.navbar-nav .open .dropdown-menu{position:static;float:none;width:auto;margin-top:0;background-color:transparent;border:0;-webkit-box-shadow:none;box-shadow:none}.navbar-nav .open .dropdown-menu>li>a,.navbar-nav .open .dropdown-menu .dropdown-header{padding:5px 15px 5px 25px}.navbar-nav .open .dropdown-menu>li>a{line-height:21px}.navbar-nav .open .dropdown-menu>li>a:hover,.navbar-nav .open .dropdown-menu>li>a:focus{background-image:none}}@media (min-width:768px){.navbar-nav{float:left;margin:0}.navbar-nav>li{float:left}.navbar-nav>li>a{padding-top:14.5px;padding-bottom:14.5px}}.navbar-form{margin-left:-15px;margin-right:-15px;padding:10px 15px;border-top:1px solid transparent;border-bottom:1px solid transparent;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.1);box-shadow:inset 0 1px 0 rgba(255,255,255,0.1),0 1px 0 rgba(255,255,255,0.1);margin-top:3.5px;margin-bottom:3.5px}@media (min-width:768px){.navbar-form .form-group{display:inline-block;margin-bottom:0;vertical-align:middle}.navbar-form .form-control{display:inline-block;width:auto;vertical-align:middle}.navbar-form .form-control-static{display:inline-block}.navbar-form .input-group{display:inline-table;vertical-align:middle}.navbar-form .input-group .input-group-addon,.navbar-form .input-group .input-group-btn,.navbar-form .input-group .form-control{width:auto}.navbar-form .input-group>.form-control{width:100%}.navbar-form .control-label{margin-bottom:0;vertical-align:middle}.navbar-form .radio,.navbar-form .checkbox{display:inline-block;margin-top:0;margin-bottom:0;vertical-align:middle}.navbar-form .radio label,.navbar-form .checkbox label{padding-left:0}.navbar-form .radio input[type="radio"],.navbar-form .checkbox input[type="checkbox"]{position:relative;margin-left:0}.navbar-form .has-feedback .form-control-feedback{top:0}}@media (max-width:767px){.navbar-form .form-group{margin-bottom:5px}.navbar-form .form-group:last-child{margin-bottom:0}}@media (min-width:768px){.navbar-form{width:auto;border:0;margin-left:0;margin-right:0;padding-top:0;padding-bottom:0;-webkit-box-shadow:none;box-shadow:none}}.navbar-nav>li>.dropdown-menu{margin-top:0;border-top-right-radius:0;border-top-left-radius:0}.navbar-fixed-bottom .navbar-nav>li>.dropdown-menu{margin-bottom:0;border-top-right-radius:0;border-top-left-radius:0;border-bottom-right-radius:0;border-bottom-left-radius:0}.navbar-btn{margin-top:3.5px;margin-bottom:3.5px}.navbar-btn.btn-sm{margin-top:9.5px;margin-bottom:9.5px}.navbar-btn.btn-xs{margin-top:14px;margin-bottom:14px}.navbar-text{margin-top:14.5px;margin-bottom:14.5px}@media (min-width:768px){.navbar-text{float:left;margin-left:15px;margin-right:15px}}@media (min-width:768px){.navbar-left{float:left !important}.navbar-right{float:right !important;margin-right:-15px}.navbar-right~.navbar-right{margin-right:0}}.navbar-default{background-color:#222222;border-color:#121212}.navbar-default .navbar-brand{color:#ffffff}.navbar-default .navbar-brand:hover,.navbar-default .navbar-brand:focus{color:#ffffff;background-color:none}.navbar-default .navbar-text{color:#ffffff}.navbar-default .navbar-nav>li>a{color:#ffffff}.navbar-default .navbar-nav>li>a:hover,.navbar-default .navbar-nav>li>a:focus{color:#ffffff;background-color:#090909}.navbar-default .navbar-nav>.active>a,.navbar-default .navbar-nav>.active>a:hover,.navbar-default .navbar-nav>.active>a:focus{color:#ffffff;background-color:#090909}.navbar-default .navbar-nav>.disabled>a,.navbar-default .navbar-nav>.disabled>a:hover,.navbar-default .navbar-nav>.disabled>a:focus{color:#cccccc;background-color:transparent}.navbar-default .navbar-toggle{border-color:transparent}.navbar-default .navbar-toggle:hover,.navbar-default .navbar-toggle:focus{background-color:#090909}.navbar-default .navbar-toggle .icon-bar{background-color:#ffffff}.navbar-default .navbar-collapse,.navbar-default .navbar-form{border-color:#121212}.navbar-default .navbar-nav>.open>a,.navbar-default .navbar-nav>.open>a:hover,.navbar-default .navbar-nav>.open>a:focus{background-color:#090909;color:#ffffff}@media (max-width:767px){.navbar-default .navbar-nav .open .dropdown-menu>li>a{color:#ffffff}.navbar-default .navbar-nav .open .dropdown-menu>li>a:hover,.navbar-default .navbar-nav .open .dropdown-menu>li>a:focus{color:#ffffff;background-color:#090909}.navbar-default .navbar-nav .open .dropdown-menu>.active>a,.navbar-default .navbar-nav .open .dropdown-menu>.active>a:hover,.navbar-default .navbar-nav .open .dropdown-menu>.active>a:focus{color:#ffffff;background-color:#090909}.navbar-default .navbar-nav .open .dropdown-menu>.disabled>a,.navbar-default .navbar-nav .open .dropdown-menu>.disabled>a:hover,.navbar-default .navbar-nav .open .dropdown-menu>.disabled>a:focus{color:#cccccc;background-color:transparent}}.navbar-default .navbar-link{color:#ffffff}.navbar-default .navbar-link:hover{color:#ffffff}.navbar-default .btn-link{color:#ffffff}.navbar-default .btn-link:hover,.navbar-default .btn-link:focus{color:#ffffff}.navbar-default .btn-link[disabled]:hover,fieldset[disabled] .navbar-default .btn-link:hover,.navbar-default .btn-link[disabled]:focus,fieldset[disabled] .navbar-default .btn-link:focus{color:#cccccc}.navbar-inverse{background-color:#2780e3;border-color:#1967be}.navbar-inverse .navbar-brand{color:#ffffff}.navbar-inverse .navbar-brand:hover,.navbar-inverse .navbar-brand:focus{color:#ffffff;background-color:none}.navbar-inverse .navbar-text{color:#ffffff}.navbar-inverse .navbar-nav>li>a{color:#ffffff}.navbar-inverse .navbar-nav>li>a:hover,.navbar-inverse .navbar-nav>li>a:focus{color:#ffffff;background-color:#1967be}.navbar-inverse .navbar-nav>.active>a,.navbar-inverse .navbar-nav>.active>a:hover,.navbar-inverse .navbar-nav>.active>a:focus{color:#ffffff;background-color:#1967be}.navbar-inverse .navbar-nav>.disabled>a,.navbar-inverse .navbar-nav>.disabled>a:hover,.navbar-inverse .navbar-nav>.disabled>a:focus{color:#ffffff;background-color:transparent}.navbar-inverse .navbar-toggle{border-color:transparent}.navbar-inverse .navbar-toggle:hover,.navbar-inverse .navbar-toggle:focus{background-color:#1967be}.navbar-inverse .navbar-toggle .icon-bar{background-color:#ffffff}.navbar-inverse .navbar-collapse,.navbar-inverse .navbar-form{border-color:#1a6ecc}.navbar-inverse .navbar-nav>.open>a,.navbar-inverse .navbar-nav>.open>a:hover,.navbar-inverse .navbar-nav>.open>a:focus{background-color:#1967be;color:#ffffff}@media (max-width:767px){.navbar-inverse .navbar-nav .open .dropdown-menu>.dropdown-header{border-color:#1967be}.navbar-inverse .navbar-nav .open .dropdown-menu .divider{background-color:#1967be}.navbar-inverse .navbar-nav .open .dropdown-menu>li>a{color:#ffffff}.navbar-inverse .navbar-nav .open .dropdown-menu>li>a:hover,.navbar-inverse .navbar-nav .open .dropdown-menu>li>a:focus{color:#ffffff;background-color:#1967be}.navbar-inverse .navbar-nav .open .dropdown-menu>.active>a,.navbar-inverse .navbar-nav .open .dropdown-menu>.active>a:hover,.navbar-inverse .navbar-nav .open .dropdown-menu>.active>a:focus{color:#ffffff;background-color:#1967be}.navbar-inverse .navbar-nav .open .dropdown-menu>.disabled>a,.navbar-inverse .navbar-nav .open .dropdown-menu>.disabled>a:hover,.navbar-inverse .navbar-nav .open .dropdown-menu>.disabled>a:focus{color:#ffffff;background-color:transparent}}.navbar-inverse .navbar-link{color:#ffffff}.navbar-inverse .navbar-link:hover{color:#ffffff}.navbar-inverse .btn-link{color:#ffffff}.navbar-inverse .btn-link:hover,.navbar-inverse .btn-link:focus{color:#ffffff}.navbar-inverse .btn-link[disabled]:hover,fieldset[disabled] .navbar-inverse .btn-link:hover,.navbar-inverse .btn-link[disabled]:focus,fieldset[disabled] .navbar-inverse .btn-link:focus{color:#ffffff}.breadcrumb{padding:8px 15px;margin-bottom:21px;list-style:none;background-color:#f5f5f5;border-radius:0}.breadcrumb>li{display:inline-block}.breadcrumb>li+li:before{content:"/\00a0";padding:0 5px;color:#cccccc}.breadcrumb>.active{color:#999999}.pagination{display:inline-block;padding-left:0;margin:21px 0;border-radius:0}.pagination>li{display:inline}.pagination>li>a,.pagination>li>span{position:relative;float:left;padding:10px 18px;line-height:1.42857143;text-decoration:none;color:#2780e3;background-color:#ffffff;border:1px solid #dddddd;margin-left:-1px}.pagination>li:first-child>a,.pagination>li:first-child>span{margin-left:0;border-bottom-left-radius:0;border-top-left-radius:0}.pagination>li:last-child>a,.pagination>li:last-child>span{border-bottom-right-radius:0;border-top-right-radius:0}.pagination>li>a:hover,.pagination>li>span:hover,.pagination>li>a:focus,.pagination>li>span:focus{z-index:2;color:#165ba8;background-color:#e6e6e6;border-color:#dddddd}.pagination>.active>a,.pagination>.active>span,.pagination>.active>a:hover,.pagination>.active>span:hover,.pagination>.active>a:focus,.pagination>.active>span:focus{z-index:3;color:#999999;background-color:#f5f5f5;border-color:#dddddd;cursor:default}.pagination>.disabled>span,.pagination>.disabled>span:hover,.pagination>.disabled>span:focus,.pagination>.disabled>a,.pagination>.disabled>a:hover,.pagination>.disabled>a:focus{color:#999999;background-color:#ffffff;border-color:#dddddd;cursor:not-allowed}.pagination-lg>li>a,.pagination-lg>li>span{padding:18px 30px;font-size:19px;line-height:1.3333333}.pagination-lg>li:first-child>a,.pagination-lg>li:first-child>span{border-bottom-left-radius:0;border-top-left-radius:0}.pagination-lg>li:last-child>a,.pagination-lg>li:last-child>span{border-bottom-right-radius:0;border-top-right-radius:0}.pagination-sm>li>a,.pagination-sm>li>span{padding:5px 10px;font-size:13px;line-height:1.5}.pagination-sm>li:first-child>a,.pagination-sm>li:first-child>span{border-bottom-left-radius:0;border-top-left-radius:0}.pagination-sm>li:last-child>a,.pagination-sm>li:last-child>span{border-bottom-right-radius:0;border-top-right-radius:0}.pager{padding-left:0;margin:21px 0;list-style:none;text-align:center}.pager li{display:inline}.pager li>a,.pager li>span{display:inline-block;padding:5px 14px;background-color:#ffffff;border:1px solid #dddddd;border-radius:0}.pager li>a:hover,.pager li>a:focus{text-decoration:none;background-color:#e6e6e6}.pager .next>a,.pager .next>span{float:right}.pager .previous>a,.pager .previous>span{float:left}.pager .disabled>a,.pager .disabled>a:hover,.pager .disabled>a:focus,.pager .disabled>span{color:#999999;background-color:#ffffff;cursor:not-allowed}.label{display:inline;padding:.2em .6em .3em;font-size:75%;font-weight:bold;line-height:1;color:#ffffff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:.25em}a.label:hover,a.label:focus{color:#ffffff;text-decoration:none;cursor:pointer}.label:empty{display:none}.btn .label{position:relative;top:-1px}.label-default{background-color:#222222}.label-default[href]:hover,.label-default[href]:focus{background-color:#090909}.label-primary{background-color:#2780e3}.label-primary[href]:hover,.label-primary[href]:focus{background-color:#1967be}.label-success{background-color:#3fb618}.label-success[href]:hover,.label-success[href]:focus{background-color:#2f8912}.label-info{background-color:#9954bb}.label-info[href]:hover,.label-info[href]:focus{background-color:#7e3f9d}.label-warning{background-color:#ff7518}.label-warning[href]:hover,.label-warning[href]:focus{background-color:#e45c00}.label-danger{background-color:#ff0039}.label-danger[href]:hover,.label-danger[href]:focus{background-color:#cc002e}.badge{display:inline-block;min-width:10px;padding:3px 7px;font-size:13px;font-weight:bold;color:#ffffff;line-height:1;vertical-align:middle;white-space:nowrap;text-align:center;background-color:#2780e3;border-radius:10px}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.btn-xs .badge,.btn-group-xs>.btn .badge{top:0;padding:1px 5px}a.badge:hover,a.badge:focus{color:#ffffff;text-decoration:none;cursor:pointer}.list-group-item.active>.badge,.nav-pills>.active>a>.badge{color:#2780e3;background-color:#ffffff}.list-group-item>.badge{float:right}.list-group-item>.badge+.badge{margin-right:5px}.nav-pills>li>a>.badge{margin-left:3px}.jumbotron{padding-top:30px;padding-bottom:30px;margin-bottom:30px;color:inherit;background-color:#e6e6e6}.jumbotron h1,.jumbotron .h1{color:inherit}.jumbotron p{margin-bottom:15px;font-size:23px;font-weight:200}.jumbotron>hr{border-top-color:#cccccc}.container .jumbotron,.container-fluid .jumbotron{border-radius:0;padding-left:15px;padding-right:15px}.jumbotron .container{max-width:100%}@media screen and (min-width:768px){.jumbotron{padding-top:48px;padding-bottom:48px}.container .jumbotron,.container-fluid .jumbotron{padding-left:60px;padding-right:60px}.jumbotron h1,.jumbotron .h1{font-size:68px}}.thumbnail{display:block;padding:4px;margin-bottom:21px;line-height:1.42857143;background-color:#ffffff;border:1px solid #dddddd;border-radius:0;-webkit-transition:border .2s ease-in-out;-o-transition:border .2s ease-in-out;transition:border .2s ease-in-out}.thumbnail>img,.thumbnail a>img{margin-left:auto;margin-right:auto}a.thumbnail:hover,a.thumbnail:focus,a.thumbnail.active{border-color:#2780e3}.thumbnail .caption{padding:9px;color:#333333}.alert{padding:15px;margin-bottom:21px;border:1px solid transparent;border-radius:0}.alert h4{margin-top:0;color:inherit}.alert .alert-link{font-weight:bold}.alert>p,.alert>ul{margin-bottom:0}.alert>p+p{margin-top:5px}.alert-dismissable,.alert-dismissible{padding-right:35px}.alert-dismissable .close,.alert-dismissible .close{position:relative;top:-2px;right:-21px;color:inherit}.alert-success{background-color:#3fb618;border-color:#4e9f15;color:#ffffff}.alert-success hr{border-top-color:#438912}.alert-success .alert-link{color:#e6e6e6}.alert-info{background-color:#9954bb;border-color:#7643a8;color:#ffffff}.alert-info hr{border-top-color:#693c96}.alert-info .alert-link{color:#e6e6e6}.alert-warning{background-color:#ff7518;border-color:#ff4309;color:#ffffff}.alert-warning hr{border-top-color:#ee3800}.alert-warning .alert-link{color:#e6e6e6}.alert-danger{background-color:#ff0039;border-color:#f0005e;color:#ffffff}.alert-danger hr{border-top-color:#d60054}.alert-danger .alert-link{color:#e6e6e6}@-webkit-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@-o-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}.progress{overflow:hidden;height:21px;margin-bottom:21px;background-color:#cccccc;border-radius:0;-webkit-box-shadow:inset 0 1px 2px rgba(0,0,0,0.1);box-shadow:inset 0 1px 2px rgba(0,0,0,0.1)}.progress-bar{float:left;width:0%;height:100%;font-size:13px;line-height:21px;color:#ffffff;text-align:center;background-color:#2780e3;-webkit-box-shadow:inset 0 -1px 0 rgba(0,0,0,0.15);box-shadow:inset 0 -1px 0 rgba(0,0,0,0.15);-webkit-transition:width 0.6s ease;-o-transition:width 0.6s ease;transition:width 0.6s ease}.progress-striped .progress-bar,.progress-bar-striped{background-image:-webkit-linear-gradient(45deg, rgba(255,255,255,0.15) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.15) 50%, rgba(255,255,255,0.15) 75%, transparent 75%, transparent);background-image:-o-linear-gradient(45deg, rgba(255,255,255,0.15) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.15) 50%, rgba(255,255,255,0.15) 75%, transparent 75%, transparent);background-image:linear-gradient(45deg, rgba(255,255,255,0.15) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.15) 50%, rgba(255,255,255,0.15) 75%, transparent 75%, transparent);-webkit-background-size:40px 40px;background-size:40px 40px}.progress.active .progress-bar,.progress-bar.active{-webkit-animation:progress-bar-stripes 2s linear infinite;-o-animation:progress-bar-stripes 2s linear infinite;animation:progress-bar-stripes 2s linear infinite}.progress-bar-success{background-color:#3fb618}.progress-striped .progress-bar-success{background-image:-webkit-linear-gradient(45deg, rgba(255,255,255,0.15) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.15) 50%, rgba(255,255,255,0.15) 75%, transparent 75%, transparent);background-image:-o-linear-gradient(45deg, rgba(255,255,255,0.15) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.15) 50%, rgba(255,255,255,0.15) 75%, transparent 75%, transparent);background-image:linear-gradient(45deg, rgba(255,255,255,0.15) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.15) 50%, rgba(255,255,255,0.15) 75%, transparent 75%, transparent)}.progress-bar-info{background-color:#9954bb}.progress-striped .progress-bar-info{background-image:-webkit-linear-gradient(45deg, rgba(255,255,255,0.15) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.15) 50%, rgba(255,255,255,0.15) 75%, transparent 75%, transparent);background-image:-o-linear-gradient(45deg, rgba(255,255,255,0.15) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.15) 50%, rgba(255,255,255,0.15) 75%, transparent 75%, transparent);background-image:linear-gradient(45deg, rgba(255,255,255,0.15) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.15) 50%, rgba(255,255,255,0.15) 75%, transparent 75%, transparent)}.progress-bar-warning{background-color:#ff7518}.progress-striped .progress-bar-warning{background-image:-webkit-linear-gradient(45deg, rgba(255,255,255,0.15) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.15) 50%, rgba(255,255,255,0.15) 75%, transparent 75%, transparent);background-image:-o-linear-gradient(45deg, rgba(255,255,255,0.15) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.15) 50%, rgba(255,255,255,0.15) 75%, transparent 75%, transparent);background-image:linear-gradient(45deg, rgba(255,255,255,0.15) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.15) 50%, rgba(255,255,255,0.15) 75%, transparent 75%, transparent)}.progress-bar-danger{background-color:#ff0039}.progress-striped .progress-bar-danger{background-image:-webkit-linear-gradient(45deg, rgba(255,255,255,0.15) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.15) 50%, rgba(255,255,255,0.15) 75%, transparent 75%, transparent);background-image:-o-linear-gradient(45deg, rgba(255,255,255,0.15) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.15) 50%, rgba(255,255,255,0.15) 75%, transparent 75%, transparent);background-image:linear-gradient(45deg, rgba(255,255,255,0.15) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.15) 50%, rgba(255,255,255,0.15) 75%, transparent 75%, transparent)}.media{margin-top:15px}.media:first-child{margin-top:0}.media,.media-body{zoom:1;overflow:hidden}.media-body{width:10000px}.media-object{display:block}.media-object.img-thumbnail{max-width:none}.media-right,.media>.pull-right{padding-left:10px}.media-left,.media>.pull-left{padding-right:10px}.media-left,.media-right,.media-body{display:table-cell;vertical-align:top}.media-middle{vertical-align:middle}.media-bottom{vertical-align:bottom}.media-heading{margin-top:0;margin-bottom:5px}.media-list{padding-left:0;list-style:none}.list-group{margin-bottom:20px;padding-left:0}.list-group-item{position:relative;display:block;padding:10px 15px;margin-bottom:-1px;background-color:#ffffff;border:1px solid #dddddd}.list-group-item:first-child{border-top-right-radius:0;border-top-left-radius:0}.list-group-item:last-child{margin-bottom:0;border-bottom-right-radius:0;border-bottom-left-radius:0}a.list-group-item,button.list-group-item{color:#555555}a.list-group-item .list-group-item-heading,button.list-group-item .list-group-item-heading{color:#333333}a.list-group-item:hover,button.list-group-item:hover,a.list-group-item:focus,button.list-group-item:focus{text-decoration:none;color:#555555;background-color:#f5f5f5}button.list-group-item{width:100%;text-align:left}.list-group-item.disabled,.list-group-item.disabled:hover,.list-group-item.disabled:focus{background-color:#e6e6e6;color:#999999;cursor:not-allowed}.list-group-item.disabled .list-group-item-heading,.list-group-item.disabled:hover .list-group-item-heading,.list-group-item.disabled:focus .list-group-item-heading{color:inherit}.list-group-item.disabled .list-group-item-text,.list-group-item.disabled:hover .list-group-item-text,.list-group-item.disabled:focus .list-group-item-text{color:#999999}.list-group-item.active,.list-group-item.active:hover,.list-group-item.active:focus{z-index:2;color:#ffffff;background-color:#2780e3;border-color:#dddddd}.list-group-item.active .list-group-item-heading,.list-group-item.active:hover .list-group-item-heading,.list-group-item.active:focus .list-group-item-heading,.list-group-item.active .list-group-item-heading>small,.list-group-item.active:hover .list-group-item-heading>small,.list-group-item.active:focus .list-group-item-heading>small,.list-group-item.active .list-group-item-heading>.small,.list-group-item.active:hover .list-group-item-heading>.small,.list-group-item.active:focus .list-group-item-heading>.small{color:inherit}.list-group-item.active .list-group-item-text,.list-group-item.active:hover .list-group-item-text,.list-group-item.active:focus .list-group-item-text{color:#dceafa}.list-group-item-success{color:#ffffff;background-color:#3fb618}a.list-group-item-success,button.list-group-item-success{color:#ffffff}a.list-group-item-success .list-group-item-heading,button.list-group-item-success .list-group-item-heading{color:inherit}a.list-group-item-success:hover,button.list-group-item-success:hover,a.list-group-item-success:focus,button.list-group-item-success:focus{color:#ffffff;background-color:#379f15}a.list-group-item-success.active,button.list-group-item-success.active,a.list-group-item-success.active:hover,button.list-group-item-success.active:hover,a.list-group-item-success.active:focus,button.list-group-item-success.active:focus{color:#fff;background-color:#ffffff;border-color:#ffffff}.list-group-item-info{color:#ffffff;background-color:#9954bb}a.list-group-item-info,button.list-group-item-info{color:#ffffff}a.list-group-item-info .list-group-item-heading,button.list-group-item-info .list-group-item-heading{color:inherit}a.list-group-item-info:hover,button.list-group-item-info:hover,a.list-group-item-info:focus,button.list-group-item-info:focus{color:#ffffff;background-color:#8d46b0}a.list-group-item-info.active,button.list-group-item-info.active,a.list-group-item-info.active:hover,button.list-group-item-info.active:hover,a.list-group-item-info.active:focus,button.list-group-item-info.active:focus{color:#fff;background-color:#ffffff;border-color:#ffffff}.list-group-item-warning{color:#ffffff;background-color:#ff7518}a.list-group-item-warning,button.list-group-item-warning{color:#ffffff}a.list-group-item-warning .list-group-item-heading,button.list-group-item-warning .list-group-item-heading{color:inherit}a.list-group-item-warning:hover,button.list-group-item-warning:hover,a.list-group-item-warning:focus,button.list-group-item-warning:focus{color:#ffffff;background-color:#fe6600}a.list-group-item-warning.active,button.list-group-item-warning.active,a.list-group-item-warning.active:hover,button.list-group-item-warning.active:hover,a.list-group-item-warning.active:focus,button.list-group-item-warning.active:focus{color:#fff;background-color:#ffffff;border-color:#ffffff}.list-group-item-danger{color:#ffffff;background-color:#ff0039}a.list-group-item-danger,button.list-group-item-danger{color:#ffffff}a.list-group-item-danger .list-group-item-heading,button.list-group-item-danger .list-group-item-heading{color:inherit}a.list-group-item-danger:hover,button.list-group-item-danger:hover,a.list-group-item-danger:focus,button.list-group-item-danger:focus{color:#ffffff;background-color:#e60033}a.list-group-item-danger.active,button.list-group-item-danger.active,a.list-group-item-danger.active:hover,button.list-group-item-danger.active:hover,a.list-group-item-danger.active:focus,button.list-group-item-danger.active:focus{color:#fff;background-color:#ffffff;border-color:#ffffff}.list-group-item-heading{margin-top:0;margin-bottom:5px}.list-group-item-text{margin-bottom:0;line-height:1.3}.panel{margin-bottom:21px;background-color:#ffffff;border:1px solid transparent;border-radius:0;-webkit-box-shadow:0 1px 1px rgba(0,0,0,0.05);box-shadow:0 1px 1px rgba(0,0,0,0.05)}.panel-body{padding:15px}.panel-heading{padding:10px 15px;border-bottom:1px solid transparent;border-top-right-radius:-1;border-top-left-radius:-1}.panel-heading>.dropdown .dropdown-toggle{color:inherit}.panel-title{margin-top:0;margin-bottom:0;font-size:17px;color:inherit}.panel-title>a,.panel-title>small,.panel-title>.small,.panel-title>small>a,.panel-title>.small>a{color:inherit}.panel-footer{padding:10px 15px;background-color:#f5f5f5;border-top:1px solid #dddddd;border-bottom-right-radius:-1;border-bottom-left-radius:-1}.panel>.list-group,.panel>.panel-collapse>.list-group{margin-bottom:0}.panel>.list-group .list-group-item,.panel>.panel-collapse>.list-group .list-group-item{border-width:1px 0;border-radius:0}.panel>.list-group:first-child .list-group-item:first-child,.panel>.panel-collapse>.list-group:first-child .list-group-item:first-child{border-top:0;border-top-right-radius:-1;border-top-left-radius:-1}.panel>.list-group:last-child .list-group-item:last-child,.panel>.panel-collapse>.list-group:last-child .list-group-item:last-child{border-bottom:0;border-bottom-right-radius:-1;border-bottom-left-radius:-1}.panel>.panel-heading+.panel-collapse>.list-group .list-group-item:first-child{border-top-right-radius:0;border-top-left-radius:0}.panel-heading+.list-group .list-group-item:first-child{border-top-width:0}.list-group+.panel-footer{border-top-width:0}.panel>.table,.panel>.table-responsive>.table,.panel>.panel-collapse>.table{margin-bottom:0}.panel>.table caption,.panel>.table-responsive>.table caption,.panel>.panel-collapse>.table caption{padding-left:15px;padding-right:15px}.panel>.table:first-child,.panel>.table-responsive:first-child>.table:first-child{border-top-right-radius:-1;border-top-left-radius:-1}.panel>.table:first-child>thead:first-child>tr:first-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child,.panel>.table:first-child>tbody:first-child>tr:first-child,.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child{border-top-left-radius:-1;border-top-right-radius:-1}.panel>.table:first-child>thead:first-child>tr:first-child td:first-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child td:first-child,.panel>.table:first-child>tbody:first-child>tr:first-child td:first-child,.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child td:first-child,.panel>.table:first-child>thead:first-child>tr:first-child th:first-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child th:first-child,.panel>.table:first-child>tbody:first-child>tr:first-child th:first-child,.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child th:first-child{border-top-left-radius:-1}.panel>.table:first-child>thead:first-child>tr:first-child td:last-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child td:last-child,.panel>.table:first-child>tbody:first-child>tr:first-child td:last-child,.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child td:last-child,.panel>.table:first-child>thead:first-child>tr:first-child th:last-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child th:last-child,.panel>.table:first-child>tbody:first-child>tr:first-child th:last-child,.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child th:last-child{border-top-right-radius:-1}.panel>.table:last-child,.panel>.table-responsive:last-child>.table:last-child{border-bottom-right-radius:-1;border-bottom-left-radius:-1}.panel>.table:last-child>tbody:last-child>tr:last-child,.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child,.panel>.table:last-child>tfoot:last-child>tr:last-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child{border-bottom-left-radius:-1;border-bottom-right-radius:-1}.panel>.table:last-child>tbody:last-child>tr:last-child td:first-child,.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child td:first-child,.panel>.table:last-child>tfoot:last-child>tr:last-child td:first-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child td:first-child,.panel>.table:last-child>tbody:last-child>tr:last-child th:first-child,.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child th:first-child,.panel>.table:last-child>tfoot:last-child>tr:last-child th:first-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child th:first-child{border-bottom-left-radius:-1}.panel>.table:last-child>tbody:last-child>tr:last-child td:last-child,.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child td:last-child,.panel>.table:last-child>tfoot:last-child>tr:last-child td:last-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child td:last-child,.panel>.table:last-child>tbody:last-child>tr:last-child th:last-child,.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child th:last-child,.panel>.table:last-child>tfoot:last-child>tr:last-child th:last-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child th:last-child{border-bottom-right-radius:-1}.panel>.panel-body+.table,.panel>.panel-body+.table-responsive,.panel>.table+.panel-body,.panel>.table-responsive+.panel-body{border-top:1px solid #dddddd}.panel>.table>tbody:first-child>tr:first-child th,.panel>.table>tbody:first-child>tr:first-child td{border-top:0}.panel>.table-bordered,.panel>.table-responsive>.table-bordered{border:0}.panel>.table-bordered>thead>tr>th:first-child,.panel>.table-responsive>.table-bordered>thead>tr>th:first-child,.panel>.table-bordered>tbody>tr>th:first-child,.panel>.table-responsive>.table-bordered>tbody>tr>th:first-child,.panel>.table-bordered>tfoot>tr>th:first-child,.panel>.table-responsive>.table-bordered>tfoot>tr>th:first-child,.panel>.table-bordered>thead>tr>td:first-child,.panel>.table-responsive>.table-bordered>thead>tr>td:first-child,.panel>.table-bordered>tbody>tr>td:first-child,.panel>.table-responsive>.table-bordered>tbody>tr>td:first-child,.panel>.table-bordered>tfoot>tr>td:first-child,.panel>.table-responsive>.table-bordered>tfoot>tr>td:first-child{border-left:0}.panel>.table-bordered>thead>tr>th:last-child,.panel>.table-responsive>.table-bordered>thead>tr>th:last-child,.panel>.table-bordered>tbody>tr>th:last-child,.panel>.table-responsive>.table-bordered>tbody>tr>th:last-child,.panel>.table-bordered>tfoot>tr>th:last-child,.panel>.table-responsive>.table-bordered>tfoot>tr>th:last-child,.panel>.table-bordered>thead>tr>td:last-child,.panel>.table-responsive>.table-bordered>thead>tr>td:last-child,.panel>.table-bordered>tbody>tr>td:last-child,.panel>.table-responsive>.table-bordered>tbody>tr>td:last-child,.panel>.table-bordered>tfoot>tr>td:last-child,.panel>.table-responsive>.table-bordered>tfoot>tr>td:last-child{border-right:0}.panel>.table-bordered>thead>tr:first-child>td,.panel>.table-responsive>.table-bordered>thead>tr:first-child>td,.panel>.table-bordered>tbody>tr:first-child>td,.panel>.table-responsive>.table-bordered>tbody>tr:first-child>td,.panel>.table-bordered>thead>tr:first-child>th,.panel>.table-responsive>.table-bordered>thead>tr:first-child>th,.panel>.table-bordered>tbody>tr:first-child>th,.panel>.table-responsive>.table-bordered>tbody>tr:first-child>th{border-bottom:0}.panel>.table-bordered>tbody>tr:last-child>td,.panel>.table-responsive>.table-bordered>tbody>tr:last-child>td,.panel>.table-bordered>tfoot>tr:last-child>td,.panel>.table-responsive>.table-bordered>tfoot>tr:last-child>td,.panel>.table-bordered>tbody>tr:last-child>th,.panel>.table-responsive>.table-bordered>tbody>tr:last-child>th,.panel>.table-bordered>tfoot>tr:last-child>th,.panel>.table-responsive>.table-bordered>tfoot>tr:last-child>th{border-bottom:0}.panel>.table-responsive{border:0;margin-bottom:0}.panel-group{margin-bottom:21px}.panel-group .panel{margin-bottom:0;border-radius:0}.panel-group .panel+.panel{margin-top:5px}.panel-group .panel-heading{border-bottom:0}.panel-group .panel-heading+.panel-collapse>.panel-body,.panel-group .panel-heading+.panel-collapse>.list-group{border-top:1px solid #dddddd}.panel-group .panel-footer{border-top:0}.panel-group .panel-footer+.panel-collapse .panel-body{border-bottom:1px solid #dddddd}.panel-default{border-color:#dddddd}.panel-default>.panel-heading{color:#333333;background-color:#f5f5f5;border-color:#dddddd}.panel-default>.panel-heading+.panel-collapse>.panel-body{border-top-color:#dddddd}.panel-default>.panel-heading .badge{color:#f5f5f5;background-color:#333333}.panel-default>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#dddddd}.panel-primary{border-color:#2780e3}.panel-primary>.panel-heading{color:#ffffff;background-color:#2780e3;border-color:#2780e3}.panel-primary>.panel-heading+.panel-collapse>.panel-body{border-top-color:#2780e3}.panel-primary>.panel-heading .badge{color:#2780e3;background-color:#ffffff}.panel-primary>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#2780e3}.panel-success{border-color:#4e9f15}.panel-success>.panel-heading{color:#ffffff;background-color:#3fb618;border-color:#4e9f15}.panel-success>.panel-heading+.panel-collapse>.panel-body{border-top-color:#4e9f15}.panel-success>.panel-heading .badge{color:#3fb618;background-color:#ffffff}.panel-success>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#4e9f15}.panel-info{border-color:#7643a8}.panel-info>.panel-heading{color:#ffffff;background-color:#9954bb;border-color:#7643a8}.panel-info>.panel-heading+.panel-collapse>.panel-body{border-top-color:#7643a8}.panel-info>.panel-heading .badge{color:#9954bb;background-color:#ffffff}.panel-info>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#7643a8}.panel-warning{border-color:#ff4309}.panel-warning>.panel-heading{color:#ffffff;background-color:#ff7518;border-color:#ff4309}.panel-warning>.panel-heading+.panel-collapse>.panel-body{border-top-color:#ff4309}.panel-warning>.panel-heading .badge{color:#ff7518;background-color:#ffffff}.panel-warning>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#ff4309}.panel-danger{border-color:#f0005e}.panel-danger>.panel-heading{color:#ffffff;background-color:#ff0039;border-color:#f0005e}.panel-danger>.panel-heading+.panel-collapse>.panel-body{border-top-color:#f0005e}.panel-danger>.panel-heading .badge{color:#ff0039;background-color:#ffffff}.panel-danger>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#f0005e}.embed-responsive{position:relative;display:block;height:0;padding:0;overflow:hidden}.embed-responsive .embed-responsive-item,.embed-responsive iframe,.embed-responsive embed,.embed-responsive object,.embed-responsive video{position:absolute;top:0;left:0;bottom:0;height:100%;width:100%;border:0}.embed-responsive-16by9{padding-bottom:56.25%}.embed-responsive-4by3{padding-bottom:75%}.well{min-height:20px;padding:19px;margin-bottom:20px;background-color:#f5f5f5;border:1px solid #e3e3e3;border-radius:0;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,0.05);box-shadow:inset 0 1px 1px rgba(0,0,0,0.05)}.well blockquote{border-color:#ddd;border-color:rgba(0,0,0,0.15)}.well-lg{padding:24px;border-radius:0}.well-sm{padding:9px;border-radius:0}.close{float:right;font-size:22.5px;font-weight:bold;line-height:1;color:#ffffff;text-shadow:0 1px 0 #ffffff;opacity:0.2;filter:alpha(opacity=20)}.close:hover,.close:focus{color:#ffffff;text-decoration:none;cursor:pointer;opacity:0.5;filter:alpha(opacity=50)}button.close{padding:0;cursor:pointer;background:transparent;border:0;-webkit-appearance:none}.modal-open{overflow:hidden}.modal{display:none;overflow:hidden;position:fixed;top:0;right:0;bottom:0;left:0;z-index:1050;-webkit-overflow-scrolling:touch;outline:0}.modal.fade .modal-dialog{-webkit-transform:translate(0, -25%);-ms-transform:translate(0, -25%);-o-transform:translate(0, -25%);transform:translate(0, -25%);-webkit-transition:-webkit-transform .3s ease-out;-o-transition:-o-transform .3s ease-out;transition:transform .3s ease-out}.modal.in .modal-dialog{-webkit-transform:translate(0, 0);-ms-transform:translate(0, 0);-o-transform:translate(0, 0);transform:translate(0, 0)}.modal-open .modal{overflow-x:hidden;overflow-y:auto}.modal-dialog{position:relative;width:auto;margin:10px}.modal-content{position:relative;background-color:#ffffff;border:1px solid #999999;border:1px solid transparent;border-radius:0;-webkit-box-shadow:0 3px 9px rgba(0,0,0,0.5);box-shadow:0 3px 9px rgba(0,0,0,0.5);-webkit-background-clip:padding-box;background-clip:padding-box;outline:0}.modal-backdrop{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1040;background-color:#000000}.modal-backdrop.fade{opacity:0;filter:alpha(opacity=0)}.modal-backdrop.in{opacity:0.5;filter:alpha(opacity=50)}.modal-header{padding:15px;border-bottom:1px solid #e5e5e5}.modal-header .close{margin-top:-2px}.modal-title{margin:0;line-height:1.42857143}.modal-body{position:relative;padding:20px}.modal-footer{padding:20px;text-align:right;border-top:1px solid #e5e5e5}.modal-footer .btn+.btn{margin-left:5px;margin-bottom:0}.modal-footer .btn-group .btn+.btn{margin-left:-1px}.modal-footer .btn-block+.btn-block{margin-left:0}.modal-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}@media (min-width:768px){.modal-dialog{width:600px;margin:30px auto}.modal-content{-webkit-box-shadow:0 5px 15px rgba(0,0,0,0.5);box-shadow:0 5px 15px rgba(0,0,0,0.5)}.modal-sm{width:300px}}@media (min-width:992px){.modal-lg{width:900px}}.tooltip{position:absolute;z-index:1070;display:block;font-family:"Source Sans Pro",Calibri,Candara,Arial,sans-serif;font-style:normal;font-weight:normal;letter-spacing:normal;line-break:auto;line-height:1.42857143;text-align:left;text-align:start;text-decoration:none;text-shadow:none;text-transform:none;white-space:normal;word-break:normal;word-spacing:normal;word-wrap:normal;font-size:13px;opacity:0;filter:alpha(opacity=0)}.tooltip.in{opacity:0.9;filter:alpha(opacity=90)}.tooltip.top{margin-top:-3px;padding:5px 0}.tooltip.right{margin-left:3px;padding:0 5px}.tooltip.bottom{margin-top:3px;padding:5px 0}.tooltip.left{margin-left:-3px;padding:0 5px}.tooltip-inner{max-width:200px;padding:3px 8px;color:#ffffff;text-align:center;background-color:#000000;border-radius:0}.tooltip-arrow{position:absolute;width:0;height:0;border-color:transparent;border-style:solid}.tooltip.top .tooltip-arrow{bottom:0;left:50%;margin-left:-5px;border-width:5px 5px 0;border-top-color:#000000}.tooltip.top-left .tooltip-arrow{bottom:0;right:5px;margin-bottom:-5px;border-width:5px 5px 0;border-top-color:#000000}.tooltip.top-right .tooltip-arrow{bottom:0;left:5px;margin-bottom:-5px;border-width:5px 5px 0;border-top-color:#000000}.tooltip.right .tooltip-arrow{top:50%;left:0;margin-top:-5px;border-width:5px 5px 5px 0;border-right-color:#000000}.tooltip.left .tooltip-arrow{top:50%;right:0;margin-top:-5px;border-width:5px 0 5px 5px;border-left-color:#000000}.tooltip.bottom .tooltip-arrow{top:0;left:50%;margin-left:-5px;border-width:0 5px 5px;border-bottom-color:#000000}.tooltip.bottom-left .tooltip-arrow{top:0;right:5px;margin-top:-5px;border-width:0 5px 5px;border-bottom-color:#000000}.tooltip.bottom-right .tooltip-arrow{top:0;left:5px;margin-top:-5px;border-width:0 5px 5px;border-bottom-color:#000000}.popover{position:absolute;top:0;left:0;z-index:1060;display:none;max-width:276px;padding:1px;font-family:"Source Sans Pro",Calibri,Candara,Arial,sans-serif;font-style:normal;font-weight:normal;letter-spacing:normal;line-break:auto;line-height:1.42857143;text-align:left;text-align:start;text-decoration:none;text-shadow:none;text-transform:none;white-space:normal;word-break:normal;word-spacing:normal;word-wrap:normal;font-size:15px;background-color:#ffffff;-webkit-background-clip:padding-box;background-clip:padding-box;border:1px solid #cccccc;border:1px solid rgba(0,0,0,0.2);border-radius:0;-webkit-box-shadow:0 5px 10px rgba(0,0,0,0.2);box-shadow:0 5px 10px rgba(0,0,0,0.2)}.popover.top{margin-top:-10px}.popover.right{margin-left:10px}.popover.bottom{margin-top:10px}.popover.left{margin-left:-10px}.popover-title{margin:0;padding:8px 14px;font-size:15px;background-color:#f7f7f7;border-bottom:1px solid #ebebeb;border-radius:-1 -1 0 0}.popover-content{padding:9px 14px}.popover>.arrow,.popover>.arrow:after{position:absolute;display:block;width:0;height:0;border-color:transparent;border-style:solid}.popover>.arrow{border-width:11px}.popover>.arrow:after{border-width:10px;content:""}.popover.top>.arrow{left:50%;margin-left:-11px;border-bottom-width:0;border-top-color:#999999;border-top-color:rgba(0,0,0,0.25);bottom:-11px}.popover.top>.arrow:after{content:" ";bottom:1px;margin-left:-10px;border-bottom-width:0;border-top-color:#ffffff}.popover.right>.arrow{top:50%;left:-11px;margin-top:-11px;border-left-width:0;border-right-color:#999999;border-right-color:rgba(0,0,0,0.25)}.popover.right>.arrow:after{content:" ";left:1px;bottom:-10px;border-left-width:0;border-right-color:#ffffff}.popover.bottom>.arrow{left:50%;margin-left:-11px;border-top-width:0;border-bottom-color:#999999;border-bottom-color:rgba(0,0,0,0.25);top:-11px}.popover.bottom>.arrow:after{content:" ";top:1px;margin-left:-10px;border-top-width:0;border-bottom-color:#ffffff}.popover.left>.arrow{top:50%;right:-11px;margin-top:-11px;border-right-width:0;border-left-color:#999999;border-left-color:rgba(0,0,0,0.25)}.popover.left>.arrow:after{content:" ";right:1px;border-right-width:0;border-left-color:#ffffff;bottom:-10px}.carousel{position:relative}.carousel-inner{position:relative;overflow:hidden;width:100%}.carousel-inner>.item{display:none;position:relative;-webkit-transition:.6s ease-in-out left;-o-transition:.6s ease-in-out left;transition:.6s ease-in-out left}.carousel-inner>.item>img,.carousel-inner>.item>a>img{line-height:1}@media all and (transform-3d),(-webkit-transform-3d){.carousel-inner>.item{-webkit-transition:-webkit-transform .6s ease-in-out;-o-transition:-o-transform .6s ease-in-out;transition:transform .6s ease-in-out;-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-perspective:1000px;perspective:1000px}.carousel-inner>.item.next,.carousel-inner>.item.active.right{-webkit-transform:translate3d(100%, 0, 0);transform:translate3d(100%, 0, 0);left:0}.carousel-inner>.item.prev,.carousel-inner>.item.active.left{-webkit-transform:translate3d(-100%, 0, 0);transform:translate3d(-100%, 0, 0);left:0}.carousel-inner>.item.next.left,.carousel-inner>.item.prev.right,.carousel-inner>.item.active{-webkit-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0);left:0}}.carousel-inner>.active,.carousel-inner>.next,.carousel-inner>.prev{display:block}.carousel-inner>.active{left:0}.carousel-inner>.next,.carousel-inner>.prev{position:absolute;top:0;width:100%}.carousel-inner>.next{left:100%}.carousel-inner>.prev{left:-100%}.carousel-inner>.next.left,.carousel-inner>.prev.right{left:0}.carousel-inner>.active.left{left:-100%}.carousel-inner>.active.right{left:100%}.carousel-control{position:absolute;top:0;left:0;bottom:0;width:15%;opacity:0.5;filter:alpha(opacity=50);font-size:20px;color:#ffffff;text-align:center;text-shadow:0 1px 2px rgba(0,0,0,0.6);background-color:rgba(0,0,0,0)}.carousel-control.left{background-image:-webkit-linear-gradient(left, rgba(0,0,0,0.5) 0, rgba(0,0,0,0.0001) 100%);background-image:-o-linear-gradient(left, rgba(0,0,0,0.5) 0, rgba(0,0,0,0.0001) 100%);background-image:-webkit-gradient(linear, left top, right top, from(rgba(0,0,0,0.5)), to(rgba(0,0,0,0.0001)));background-image:linear-gradient(to right, rgba(0,0,0,0.5) 0, rgba(0,0,0,0.0001) 100%);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#80000000', endColorstr='#00000000', GradientType=1)}.carousel-control.right{left:auto;right:0;background-image:-webkit-linear-gradient(left, rgba(0,0,0,0.0001) 0, rgba(0,0,0,0.5) 100%);background-image:-o-linear-gradient(left, rgba(0,0,0,0.0001) 0, rgba(0,0,0,0.5) 100%);background-image:-webkit-gradient(linear, left top, right top, from(rgba(0,0,0,0.0001)), to(rgba(0,0,0,0.5)));background-image:linear-gradient(to right, rgba(0,0,0,0.0001) 0, rgba(0,0,0,0.5) 100%);background-repeat:repeat-x;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#00000000', endColorstr='#80000000', GradientType=1)}.carousel-control:hover,.carousel-control:focus{outline:0;color:#ffffff;text-decoration:none;opacity:0.9;filter:alpha(opacity=90)}.carousel-control .icon-prev,.carousel-control .icon-next,.carousel-control .glyphicon-chevron-left,.carousel-control .glyphicon-chevron-right{position:absolute;top:50%;margin-top:-10px;z-index:5;display:inline-block}.carousel-control .icon-prev,.carousel-control .glyphicon-chevron-left{left:50%;margin-left:-10px}.carousel-control .icon-next,.carousel-control .glyphicon-chevron-right{right:50%;margin-right:-10px}.carousel-control .icon-prev,.carousel-control .icon-next{width:20px;height:20px;line-height:1;font-family:serif}.carousel-control .icon-prev:before{content:'\2039'}.carousel-control .icon-next:before{content:'\203a'}.carousel-indicators{position:absolute;bottom:10px;left:50%;z-index:15;width:60%;margin-left:-30%;padding-left:0;list-style:none;text-align:center}.carousel-indicators li{display:inline-block;width:10px;height:10px;margin:1px;text-indent:-999px;border:1px solid #ffffff;border-radius:10px;cursor:pointer;background-color:#000 \9;background-color:rgba(0,0,0,0)}.carousel-indicators .active{margin:0;width:12px;height:12px;background-color:#ffffff}.carousel-caption{position:absolute;left:15%;right:15%;bottom:20px;z-index:10;padding-top:20px;padding-bottom:20px;color:#ffffff;text-align:center;text-shadow:0 1px 2px rgba(0,0,0,0.6)}.carousel-caption .btn{text-shadow:none}@media screen and (min-width:768px){.carousel-control .glyphicon-chevron-left,.carousel-control .glyphicon-chevron-right,.carousel-control .icon-prev,.carousel-control .icon-next{width:30px;height:30px;margin-top:-10px;font-size:30px}.carousel-control .glyphicon-chevron-left,.carousel-control .icon-prev{margin-left:-10px}.carousel-control .glyphicon-chevron-right,.carousel-control .icon-next{margin-right:-10px}.carousel-caption{left:20%;right:20%;padding-bottom:30px}.carousel-indicators{bottom:20px}}.clearfix:before,.clearfix:after,.dl-horizontal dd:before,.dl-horizontal dd:after,.container:before,.container:after,.container-fluid:before,.container-fluid:after,.row:before,.row:after,.form-horizontal .form-group:before,.form-horizontal .form-group:after,.btn-toolbar:before,.btn-toolbar:after,.btn-group-vertical>.btn-group:before,.btn-group-vertical>.btn-group:after,.nav:before,.nav:after,.navbar:before,.navbar:after,.navbar-header:before,.navbar-header:after,.navbar-collapse:before,.navbar-collapse:after,.pager:before,.pager:after,.panel-body:before,.panel-body:after,.modal-header:before,.modal-header:after,.modal-footer:before,.modal-footer:after{content:" ";display:table}.clearfix:after,.dl-horizontal dd:after,.container:after,.container-fluid:after,.row:after,.form-horizontal .form-group:after,.btn-toolbar:after,.btn-group-vertical>.btn-group:after,.nav:after,.navbar:after,.navbar-header:after,.navbar-collapse:after,.pager:after,.panel-body:after,.modal-header:after,.modal-footer:after{clear:both}.center-block{display:block;margin-left:auto;margin-right:auto}.pull-right{float:right !important}.pull-left{float:left !important}.hide{display:none !important}.show{display:block !important}.invisible{visibility:hidden}.text-hide{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.hidden{display:none !important}.affix{position:fixed}@-ms-viewport{width:device-width}.visible-xs,.visible-sm,.visible-md,.visible-lg{display:none !important}.visible-xs-block,.visible-xs-inline,.visible-xs-inline-block,.visible-sm-block,.visible-sm-inline,.visible-sm-inline-block,.visible-md-block,.visible-md-inline,.visible-md-inline-block,.visible-lg-block,.visible-lg-inline,.visible-lg-inline-block{display:none !important}@media (max-width:767px){.visible-xs{display:block !important}table.visible-xs{display:table !important}tr.visible-xs{display:table-row !important}th.visible-xs,td.visible-xs{display:table-cell !important}}@media (max-width:767px){.visible-xs-block{display:block !important}}@media (max-width:767px){.visible-xs-inline{display:inline !important}}@media (max-width:767px){.visible-xs-inline-block{display:inline-block !important}}@media (min-width:768px) and (max-width:991px){.visible-sm{display:block !important}table.visible-sm{display:table !important}tr.visible-sm{display:table-row !important}th.visible-sm,td.visible-sm{display:table-cell !important}}@media (min-width:768px) and (max-width:991px){.visible-sm-block{display:block !important}}@media (min-width:768px) and (max-width:991px){.visible-sm-inline{display:inline !important}}@media (min-width:768px) and (max-width:991px){.visible-sm-inline-block{display:inline-block !important}}@media (min-width:992px) and (max-width:1199px){.visible-md{display:block !important}table.visible-md{display:table !important}tr.visible-md{display:table-row !important}th.visible-md,td.visible-md{display:table-cell !important}}@media (min-width:992px) and (max-width:1199px){.visible-md-block{display:block !important}}@media (min-width:992px) and (max-width:1199px){.visible-md-inline{display:inline !important}}@media (min-width:992px) and (max-width:1199px){.visible-md-inline-block{display:inline-block !important}}@media (min-width:1200px){.visible-lg{display:block !important}table.visible-lg{display:table !important}tr.visible-lg{display:table-row !important}th.visible-lg,td.visible-lg{display:table-cell !important}}@media (min-width:1200px){.visible-lg-block{display:block !important}}@media (min-width:1200px){.visible-lg-inline{display:inline !important}}@media (min-width:1200px){.visible-lg-inline-block{display:inline-block !important}}@media (max-width:767px){.hidden-xs{display:none !important}}@media (min-width:768px) and (max-width:991px){.hidden-sm{display:none !important}}@media (min-width:992px) and (max-width:1199px){.hidden-md{display:none !important}}@media (min-width:1200px){.hidden-lg{display:none !important}}.visible-print{display:none !important}@media print{.visible-print{display:block !important}table.visible-print{display:table !important}tr.visible-print{display:table-row !important}th.visible-print,td.visible-print{display:table-cell !important}}.visible-print-block{display:none !important}@media print{.visible-print-block{display:block !important}}.visible-print-inline{display:none !important}@media print{.visible-print-inline{display:inline !important}}.visible-print-inline-block{display:none !important}@media print{.visible-print-inline-block{display:inline-block !important}}@media print{.hidden-print{display:none !important}}.navbar-inverse .badge{background-color:#fff;color:#2780e3}body{-webkit-font-smoothing:antialiased}.text-primary,.text-primary:hover{color:#2780e3}.text-success,.text-success:hover{color:#3fb618}.text-danger,.text-danger:hover{color:#ff0039}.text-warning,.text-warning:hover{color:#ff7518}.text-info,.text-info:hover{color:#9954bb}table a:not(.btn),.table a:not(.btn){text-decoration:underline}table .dropdown-menu a,.table .dropdown-menu a{text-decoration:none}table .success,.table .success,table .warning,.table .warning,table .danger,.table .danger,table .info,.table .info{color:#fff}table .success a,.table .success a,table .warning a,.table .warning a,table .danger a,.table .danger a,table .info a,.table .info a{color:#fff}.has-warning .help-block,.has-warning .control-label,.has-warning .radio,.has-warning .checkbox,.has-warning .radio-inline,.has-warning .checkbox-inline,.has-warning.radio label,.has-warning.checkbox label,.has-warning.radio-inline label,.has-warning.checkbox-inline label,.has-warning .form-control-feedback{color:#ff7518}.has-warning .form-control,.has-warning .form-control:focus,.has-warning .input-group-addon{border:1px solid #ff7518}.has-error .help-block,.has-error .control-label,.has-error .radio,.has-error .checkbox,.has-error .radio-inline,.has-error .checkbox-inline,.has-error.radio label,.has-error.checkbox label,.has-error.radio-inline label,.has-error.checkbox-inline label,.has-error .form-control-feedback{color:#ff0039}.has-error .form-control,.has-error .form-control:focus,.has-error .input-group-addon{border:1px solid #ff0039}.has-success .help-block,.has-success .control-label,.has-success .radio,.has-success .checkbox,.has-success .radio-inline,.has-success .checkbox-inline,.has-success.radio label,.has-success.checkbox label,.has-success.radio-inline label,.has-success.checkbox-inline label,.has-success .form-control-feedback{color:#3fb618}.has-success .form-control,.has-success .form-control:focus,.has-success .input-group-addon{border:1px solid #3fb618}.nav-pills>li>a{border-radius:0}.dropdown-menu>li>a:hover,.dropdown-menu>li>a:focus{background-image:none}.close{text-decoration:none;text-shadow:none;opacity:0.4}.close:hover,.close:focus{opacity:1}.alert{border:none}.alert .alert-link{text-decoration:underline;color:#fff}.label{border-radius:0}.progress{height:8px;-webkit-box-shadow:none;box-shadow:none}.progress .progress-bar{font-size:8px;line-height:8px}.panel-heading,.panel-footer{border-top-right-radius:0;border-top-left-radius:0}.panel-default .close{color:#333333}a.list-group-item-success.active{background-color:#3fb618}a.list-group-item-success.active:hover,a.list-group-item-success.active:focus{background-color:#379f15}a.list-group-item-warning.active{background-color:#ff7518}a.list-group-item-warning.active:hover,a.list-group-item-warning.active:focus{background-color:#fe6600}a.list-group-item-danger.active{background-color:#ff0039}a.list-group-item-danger.active:hover,a.list-group-item-danger.active:focus{background-color:#e60033}.modal .close{color:#333333}.popover{color:#333333}
</style>
<script>/*!
 * Bootstrap v3.3.5 (http://getbootstrap.com)
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under the MIT license
 */
if("undefined"==typeof jQuery)throw new Error("Bootstrap's JavaScript requires jQuery");+function(a){"use strict";var b=a.fn.jquery.split(" ")[0].split(".");if(b[0]<2&&b[1]<9||1==b[0]&&9==b[1]&&b[2]<1)throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher")}(jQuery),+function(a){"use strict";function b(){var a=document.createElement("bootstrap"),b={WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd otransitionend",transition:"transitionend"};for(var c in b)if(void 0!==a.style[c])return{end:b[c]};return!1}a.fn.emulateTransitionEnd=function(b){var c=!1,d=this;a(this).one("bsTransitionEnd",function(){c=!0});var e=function(){c||a(d).trigger(a.support.transition.end)};return setTimeout(e,b),this},a(function(){a.support.transition=b(),a.support.transition&&(a.event.special.bsTransitionEnd={bindType:a.support.transition.end,delegateType:a.support.transition.end,handle:function(b){return a(b.target).is(this)?b.handleObj.handler.apply(this,arguments):void 0}})})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var c=a(this),e=c.data("bs.alert");e||c.data("bs.alert",e=new d(this)),"string"==typeof b&&e[b].call(c)})}var c='[data-dismiss="alert"]',d=function(b){a(b).on("click",c,this.close)};d.VERSION="3.3.5",d.TRANSITION_DURATION=150,d.prototype.close=function(b){function c(){g.detach().trigger("closed.bs.alert").remove()}var e=a(this),f=e.attr("data-target");f||(f=e.attr("href"),f=f&&f.replace(/.*(?=#[^\s]*$)/,""));var g=a(f);b&&b.preventDefault(),g.length||(g=e.closest(".alert")),g.trigger(b=a.Event("close.bs.alert")),b.isDefaultPrevented()||(g.removeClass("in"),a.support.transition&&g.hasClass("fade")?g.one("bsTransitionEnd",c).emulateTransitionEnd(d.TRANSITION_DURATION):c())};var e=a.fn.alert;a.fn.alert=b,a.fn.alert.Constructor=d,a.fn.alert.noConflict=function(){return a.fn.alert=e,this},a(document).on("click.bs.alert.data-api",c,d.prototype.close)}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.button"),f="object"==typeof b&&b;e||d.data("bs.button",e=new c(this,f)),"toggle"==b?e.toggle():b&&e.setState(b)})}var c=function(b,d){this.$element=a(b),this.options=a.extend({},c.DEFAULTS,d),this.isLoading=!1};c.VERSION="3.3.5",c.DEFAULTS={loadingText:"loading..."},c.prototype.setState=function(b){var c="disabled",d=this.$element,e=d.is("input")?"val":"html",f=d.data();b+="Text",null==f.resetText&&d.data("resetText",d[e]()),setTimeout(a.proxy(function(){d[e](null==f[b]?this.options[b]:f[b]),"loadingText"==b?(this.isLoading=!0,d.addClass(c).attr(c,c)):this.isLoading&&(this.isLoading=!1,d.removeClass(c).removeAttr(c))},this),0)},c.prototype.toggle=function(){var a=!0,b=this.$element.closest('[data-toggle="buttons"]');if(b.length){var c=this.$element.find("input");"radio"==c.prop("type")?(c.prop("checked")&&(a=!1),b.find(".active").removeClass("active"),this.$element.addClass("active")):"checkbox"==c.prop("type")&&(c.prop("checked")!==this.$element.hasClass("active")&&(a=!1),this.$element.toggleClass("active")),c.prop("checked",this.$element.hasClass("active")),a&&c.trigger("change")}else this.$element.attr("aria-pressed",!this.$element.hasClass("active")),this.$element.toggleClass("active")};var d=a.fn.button;a.fn.button=b,a.fn.button.Constructor=c,a.fn.button.noConflict=function(){return a.fn.button=d,this},a(document).on("click.bs.button.data-api",'[data-toggle^="button"]',function(c){var d=a(c.target);d.hasClass("btn")||(d=d.closest(".btn")),b.call(d,"toggle"),a(c.target).is('input[type="radio"]')||a(c.target).is('input[type="checkbox"]')||c.preventDefault()}).on("focus.bs.button.data-api blur.bs.button.data-api",'[data-toggle^="button"]',function(b){a(b.target).closest(".btn").toggleClass("focus",/^focus(in)?$/.test(b.type))})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.carousel"),f=a.extend({},c.DEFAULTS,d.data(),"object"==typeof b&&b),g="string"==typeof b?b:f.slide;e||d.data("bs.carousel",e=new c(this,f)),"number"==typeof b?e.to(b):g?e[g]():f.interval&&e.pause().cycle()})}var c=function(b,c){this.$element=a(b),this.$indicators=this.$element.find(".carousel-indicators"),this.options=c,this.paused=null,this.sliding=null,this.interval=null,this.$active=null,this.$items=null,this.options.keyboard&&this.$element.on("keydown.bs.carousel",a.proxy(this.keydown,this)),"hover"==this.options.pause&&!("ontouchstart"in document.documentElement)&&this.$element.on("mouseenter.bs.carousel",a.proxy(this.pause,this)).on("mouseleave.bs.carousel",a.proxy(this.cycle,this))};c.VERSION="3.3.5",c.TRANSITION_DURATION=600,c.DEFAULTS={interval:5e3,pause:"hover",wrap:!0,keyboard:!0},c.prototype.keydown=function(a){if(!/input|textarea/i.test(a.target.tagName)){switch(a.which){case 37:this.prev();break;case 39:this.next();break;default:return}a.preventDefault()}},c.prototype.cycle=function(b){return b||(this.paused=!1),this.interval&&clearInterval(this.interval),this.options.interval&&!this.paused&&(this.interval=setInterval(a.proxy(this.next,this),this.options.interval)),this},c.prototype.getItemIndex=function(a){return this.$items=a.parent().children(".item"),this.$items.index(a||this.$active)},c.prototype.getItemForDirection=function(a,b){var c=this.getItemIndex(b),d="prev"==a&&0===c||"next"==a&&c==this.$items.length-1;if(d&&!this.options.wrap)return b;var e="prev"==a?-1:1,f=(c+e)%this.$items.length;return this.$items.eq(f)},c.prototype.to=function(a){var b=this,c=this.getItemIndex(this.$active=this.$element.find(".item.active"));return a>this.$items.length-1||0>a?void 0:this.sliding?this.$element.one("slid.bs.carousel",function(){b.to(a)}):c==a?this.pause().cycle():this.slide(a>c?"next":"prev",this.$items.eq(a))},c.prototype.pause=function(b){return b||(this.paused=!0),this.$element.find(".next, .prev").length&&a.support.transition&&(this.$element.trigger(a.support.transition.end),this.cycle(!0)),this.interval=clearInterval(this.interval),this},c.prototype.next=function(){return this.sliding?void 0:this.slide("next")},c.prototype.prev=function(){return this.sliding?void 0:this.slide("prev")},c.prototype.slide=function(b,d){var e=this.$element.find(".item.active"),f=d||this.getItemForDirection(b,e),g=this.interval,h="next"==b?"left":"right",i=this;if(f.hasClass("active"))return this.sliding=!1;var j=f[0],k=a.Event("slide.bs.carousel",{relatedTarget:j,direction:h});if(this.$element.trigger(k),!k.isDefaultPrevented()){if(this.sliding=!0,g&&this.pause(),this.$indicators.length){this.$indicators.find(".active").removeClass("active");var l=a(this.$indicators.children()[this.getItemIndex(f)]);l&&l.addClass("active")}var m=a.Event("slid.bs.carousel",{relatedTarget:j,direction:h});return a.support.transition&&this.$element.hasClass("slide")?(f.addClass(b),f[0].offsetWidth,e.addClass(h),f.addClass(h),e.one("bsTransitionEnd",function(){f.removeClass([b,h].join(" ")).addClass("active"),e.removeClass(["active",h].join(" ")),i.sliding=!1,setTimeout(function(){i.$element.trigger(m)},0)}).emulateTransitionEnd(c.TRANSITION_DURATION)):(e.removeClass("active"),f.addClass("active"),this.sliding=!1,this.$element.trigger(m)),g&&this.cycle(),this}};var d=a.fn.carousel;a.fn.carousel=b,a.fn.carousel.Constructor=c,a.fn.carousel.noConflict=function(){return a.fn.carousel=d,this};var e=function(c){var d,e=a(this),f=a(e.attr("data-target")||(d=e.attr("href"))&&d.replace(/.*(?=#[^\s]+$)/,""));if(f.hasClass("carousel")){var g=a.extend({},f.data(),e.data()),h=e.attr("data-slide-to");h&&(g.interval=!1),b.call(f,g),h&&f.data("bs.carousel").to(h),c.preventDefault()}};a(document).on("click.bs.carousel.data-api","[data-slide]",e).on("click.bs.carousel.data-api","[data-slide-to]",e),a(window).on("load",function(){a('[data-ride="carousel"]').each(function(){var c=a(this);b.call(c,c.data())})})}(jQuery),+function(a){"use strict";function b(b){var c,d=b.attr("data-target")||(c=b.attr("href"))&&c.replace(/.*(?=#[^\s]+$)/,"");return a(d)}function c(b){return this.each(function(){var c=a(this),e=c.data("bs.collapse"),f=a.extend({},d.DEFAULTS,c.data(),"object"==typeof b&&b);!e&&f.toggle&&/show|hide/.test(b)&&(f.toggle=!1),e||c.data("bs.collapse",e=new d(this,f)),"string"==typeof b&&e[b]()})}var d=function(b,c){this.$element=a(b),this.options=a.extend({},d.DEFAULTS,c),this.$trigger=a('[data-toggle="collapse"][href="#'+b.id+'"],[data-toggle="collapse"][data-target="#'+b.id+'"]'),this.transitioning=null,this.options.parent?this.$parent=this.getParent():this.addAriaAndCollapsedClass(this.$element,this.$trigger),this.options.toggle&&this.toggle()};d.VERSION="3.3.5",d.TRANSITION_DURATION=350,d.DEFAULTS={toggle:!0},d.prototype.dimension=function(){var a=this.$element.hasClass("width");return a?"width":"height"},d.prototype.show=function(){if(!this.transitioning&&!this.$element.hasClass("in")){var b,e=this.$parent&&this.$parent.children(".panel").children(".in, .collapsing");if(!(e&&e.length&&(b=e.data("bs.collapse"),b&&b.transitioning))){var f=a.Event("show.bs.collapse");if(this.$element.trigger(f),!f.isDefaultPrevented()){e&&e.length&&(c.call(e,"hide"),b||e.data("bs.collapse",null));var g=this.dimension();this.$element.removeClass("collapse").addClass("collapsing")[g](0).attr("aria-expanded",!0),this.$trigger.removeClass("collapsed").attr("aria-expanded",!0),this.transitioning=1;var h=function(){this.$element.removeClass("collapsing").addClass("collapse in")[g](""),this.transitioning=0,this.$element.trigger("shown.bs.collapse")};if(!a.support.transition)return h.call(this);var i=a.camelCase(["scroll",g].join("-"));this.$element.one("bsTransitionEnd",a.proxy(h,this)).emulateTransitionEnd(d.TRANSITION_DURATION)[g](this.$element[0][i])}}}},d.prototype.hide=function(){if(!this.transitioning&&this.$element.hasClass("in")){var b=a.Event("hide.bs.collapse");if(this.$element.trigger(b),!b.isDefaultPrevented()){var c=this.dimension();this.$element[c](this.$element[c]())[0].offsetHeight,this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded",!1),this.$trigger.addClass("collapsed").attr("aria-expanded",!1),this.transitioning=1;var e=function(){this.transitioning=0,this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse")};return a.support.transition?void this.$element[c](0).one("bsTransitionEnd",a.proxy(e,this)).emulateTransitionEnd(d.TRANSITION_DURATION):e.call(this)}}},d.prototype.toggle=function(){this[this.$element.hasClass("in")?"hide":"show"]()},d.prototype.getParent=function(){return a(this.options.parent).find('[data-toggle="collapse"][data-parent="'+this.options.parent+'"]').each(a.proxy(function(c,d){var e=a(d);this.addAriaAndCollapsedClass(b(e),e)},this)).end()},d.prototype.addAriaAndCollapsedClass=function(a,b){var c=a.hasClass("in");a.attr("aria-expanded",c),b.toggleClass("collapsed",!c).attr("aria-expanded",c)};var e=a.fn.collapse;a.fn.collapse=c,a.fn.collapse.Constructor=d,a.fn.collapse.noConflict=function(){return a.fn.collapse=e,this},a(document).on("click.bs.collapse.data-api",'[data-toggle="collapse"]',function(d){var e=a(this);e.attr("data-target")||d.preventDefault();var f=b(e),g=f.data("bs.collapse"),h=g?"toggle":e.data();c.call(f,h)})}(jQuery),+function(a){"use strict";function b(b){var c=b.attr("data-target");c||(c=b.attr("href"),c=c&&/#[A-Za-z]/.test(c)&&c.replace(/.*(?=#[^\s]*$)/,""));var d=c&&a(c);return d&&d.length?d:b.parent()}function c(c){c&&3===c.which||(a(e).remove(),a(f).each(function(){var d=a(this),e=b(d),f={relatedTarget:this};e.hasClass("open")&&(c&&"click"==c.type&&/input|textarea/i.test(c.target.tagName)&&a.contains(e[0],c.target)||(e.trigger(c=a.Event("hide.bs.dropdown",f)),c.isDefaultPrevented()||(d.attr("aria-expanded","false"),e.removeClass("open").trigger("hidden.bs.dropdown",f))))}))}function d(b){return this.each(function(){var c=a(this),d=c.data("bs.dropdown");d||c.data("bs.dropdown",d=new g(this)),"string"==typeof b&&d[b].call(c)})}var e=".dropdown-backdrop",f='[data-toggle="dropdown"]',g=function(b){a(b).on("click.bs.dropdown",this.toggle)};g.VERSION="3.3.5",g.prototype.toggle=function(d){var e=a(this);if(!e.is(".disabled, :disabled")){var f=b(e),g=f.hasClass("open");if(c(),!g){"ontouchstart"in document.documentElement&&!f.closest(".navbar-nav").length&&a(document.createElement("div")).addClass("dropdown-backdrop").insertAfter(a(this)).on("click",c);var h={relatedTarget:this};if(f.trigger(d=a.Event("show.bs.dropdown",h)),d.isDefaultPrevented())return;e.trigger("focus").attr("aria-expanded","true"),f.toggleClass("open").trigger("shown.bs.dropdown",h)}return!1}},g.prototype.keydown=function(c){if(/(38|40|27|32)/.test(c.which)&&!/input|textarea/i.test(c.target.tagName)){var d=a(this);if(c.preventDefault(),c.stopPropagation(),!d.is(".disabled, :disabled")){var e=b(d),g=e.hasClass("open");if(!g&&27!=c.which||g&&27==c.which)return 27==c.which&&e.find(f).trigger("focus"),d.trigger("click");var h=" li:not(.disabled):visible a",i=e.find(".dropdown-menu"+h);if(i.length){var j=i.index(c.target);38==c.which&&j>0&&j--,40==c.which&&j<i.length-1&&j++,~j||(j=0),i.eq(j).trigger("focus")}}}};var h=a.fn.dropdown;a.fn.dropdown=d,a.fn.dropdown.Constructor=g,a.fn.dropdown.noConflict=function(){return a.fn.dropdown=h,this},a(document).on("click.bs.dropdown.data-api",c).on("click.bs.dropdown.data-api",".dropdown form",function(a){a.stopPropagation()}).on("click.bs.dropdown.data-api",f,g.prototype.toggle).on("keydown.bs.dropdown.data-api",f,g.prototype.keydown).on("keydown.bs.dropdown.data-api",".dropdown-menu",g.prototype.keydown)}(jQuery),+function(a){"use strict";function b(b,d){return this.each(function(){var e=a(this),f=e.data("bs.modal"),g=a.extend({},c.DEFAULTS,e.data(),"object"==typeof b&&b);f||e.data("bs.modal",f=new c(this,g)),"string"==typeof b?f[b](d):g.show&&f.show(d)})}var c=function(b,c){this.options=c,this.$body=a(document.body),this.$element=a(b),this.$dialog=this.$element.find(".modal-dialog"),this.$backdrop=null,this.isShown=null,this.originalBodyPad=null,this.scrollbarWidth=0,this.ignoreBackdropClick=!1,this.options.remote&&this.$element.find(".modal-content").load(this.options.remote,a.proxy(function(){this.$element.trigger("loaded.bs.modal")},this))};c.VERSION="3.3.5",c.TRANSITION_DURATION=300,c.BACKDROP_TRANSITION_DURATION=150,c.DEFAULTS={backdrop:!0,keyboard:!0,show:!0},c.prototype.toggle=function(a){return this.isShown?this.hide():this.show(a)},c.prototype.show=function(b){var d=this,e=a.Event("show.bs.modal",{relatedTarget:b});this.$element.trigger(e),this.isShown||e.isDefaultPrevented()||(this.isShown=!0,this.checkScrollbar(),this.setScrollbar(),this.$body.addClass("modal-open"),this.escape(),this.resize(),this.$element.on("click.dismiss.bs.modal",'[data-dismiss="modal"]',a.proxy(this.hide,this)),this.$dialog.on("mousedown.dismiss.bs.modal",function(){d.$element.one("mouseup.dismiss.bs.modal",function(b){a(b.target).is(d.$element)&&(d.ignoreBackdropClick=!0)})}),this.backdrop(function(){var e=a.support.transition&&d.$element.hasClass("fade");d.$element.parent().length||d.$element.appendTo(d.$body),d.$element.show().scrollTop(0),d.adjustDialog(),e&&d.$element[0].offsetWidth,d.$element.addClass("in"),d.enforceFocus();var f=a.Event("shown.bs.modal",{relatedTarget:b});e?d.$dialog.one("bsTransitionEnd",function(){d.$element.trigger("focus").trigger(f)}).emulateTransitionEnd(c.TRANSITION_DURATION):d.$element.trigger("focus").trigger(f)}))},c.prototype.hide=function(b){b&&b.preventDefault(),b=a.Event("hide.bs.modal"),this.$element.trigger(b),this.isShown&&!b.isDefaultPrevented()&&(this.isShown=!1,this.escape(),this.resize(),a(document).off("focusin.bs.modal"),this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"),this.$dialog.off("mousedown.dismiss.bs.modal"),a.support.transition&&this.$element.hasClass("fade")?this.$element.one("bsTransitionEnd",a.proxy(this.hideModal,this)).emulateTransitionEnd(c.TRANSITION_DURATION):this.hideModal())},c.prototype.enforceFocus=function(){a(document).off("focusin.bs.modal").on("focusin.bs.modal",a.proxy(function(a){this.$element[0]===a.target||this.$element.has(a.target).length||this.$element.trigger("focus")},this))},c.prototype.escape=function(){this.isShown&&this.options.keyboard?this.$element.on("keydown.dismiss.bs.modal",a.proxy(function(a){27==a.which&&this.hide()},this)):this.isShown||this.$element.off("keydown.dismiss.bs.modal")},c.prototype.resize=function(){this.isShown?a(window).on("resize.bs.modal",a.proxy(this.handleUpdate,this)):a(window).off("resize.bs.modal")},c.prototype.hideModal=function(){var a=this;this.$element.hide(),this.backdrop(function(){a.$body.removeClass("modal-open"),a.resetAdjustments(),a.resetScrollbar(),a.$element.trigger("hidden.bs.modal")})},c.prototype.removeBackdrop=function(){this.$backdrop&&this.$backdrop.remove(),this.$backdrop=null},c.prototype.backdrop=function(b){var d=this,e=this.$element.hasClass("fade")?"fade":"";if(this.isShown&&this.options.backdrop){var f=a.support.transition&&e;if(this.$backdrop=a(document.createElement("div")).addClass("modal-backdrop "+e).appendTo(this.$body),this.$element.on("click.dismiss.bs.modal",a.proxy(function(a){return this.ignoreBackdropClick?void(this.ignoreBackdropClick=!1):void(a.target===a.currentTarget&&("static"==this.options.backdrop?this.$element[0].focus():this.hide()))},this)),f&&this.$backdrop[0].offsetWidth,this.$backdrop.addClass("in"),!b)return;f?this.$backdrop.one("bsTransitionEnd",b).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION):b()}else if(!this.isShown&&this.$backdrop){this.$backdrop.removeClass("in");var g=function(){d.removeBackdrop(),b&&b()};a.support.transition&&this.$element.hasClass("fade")?this.$backdrop.one("bsTransitionEnd",g).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION):g()}else b&&b()},c.prototype.handleUpdate=function(){this.adjustDialog()},c.prototype.adjustDialog=function(){var a=this.$element[0].scrollHeight>document.documentElement.clientHeight;this.$element.css({paddingLeft:!this.bodyIsOverflowing&&a?this.scrollbarWidth:"",paddingRight:this.bodyIsOverflowing&&!a?this.scrollbarWidth:""})},c.prototype.resetAdjustments=function(){this.$element.css({paddingLeft:"",paddingRight:""})},c.prototype.checkScrollbar=function(){var a=window.innerWidth;if(!a){var b=document.documentElement.getBoundingClientRect();a=b.right-Math.abs(b.left)}this.bodyIsOverflowing=document.body.clientWidth<a,this.scrollbarWidth=this.measureScrollbar()},c.prototype.setScrollbar=function(){var a=parseInt(this.$body.css("padding-right")||0,10);this.originalBodyPad=document.body.style.paddingRight||"",this.bodyIsOverflowing&&this.$body.css("padding-right",a+this.scrollbarWidth)},c.prototype.resetScrollbar=function(){this.$body.css("padding-right",this.originalBodyPad)},c.prototype.measureScrollbar=function(){var a=document.createElement("div");a.className="modal-scrollbar-measure",this.$body.append(a);var b=a.offsetWidth-a.clientWidth;return this.$body[0].removeChild(a),b};var d=a.fn.modal;a.fn.modal=b,a.fn.modal.Constructor=c,a.fn.modal.noConflict=function(){return a.fn.modal=d,this},a(document).on("click.bs.modal.data-api",'[data-toggle="modal"]',function(c){var d=a(this),e=d.attr("href"),f=a(d.attr("data-target")||e&&e.replace(/.*(?=#[^\s]+$)/,"")),g=f.data("bs.modal")?"toggle":a.extend({remote:!/#/.test(e)&&e},f.data(),d.data());d.is("a")&&c.preventDefault(),f.one("show.bs.modal",function(a){a.isDefaultPrevented()||f.one("hidden.bs.modal",function(){d.is(":visible")&&d.trigger("focus")})}),b.call(f,g,this)})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.tooltip"),f="object"==typeof b&&b;(e||!/destroy|hide/.test(b))&&(e||d.data("bs.tooltip",e=new c(this,f)),"string"==typeof b&&e[b]())})}var c=function(a,b){this.type=null,this.options=null,this.enabled=null,this.timeout=null,this.hoverState=null,this.$element=null,this.inState=null,this.init("tooltip",a,b)};c.VERSION="3.3.5",c.TRANSITION_DURATION=150,c.DEFAULTS={animation:!0,placement:"top",selector:!1,template:'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",title:"",delay:0,html:!1,container:!1,viewport:{selector:"body",padding:0}},c.prototype.init=function(b,c,d){if(this.enabled=!0,this.type=b,this.$element=a(c),this.options=this.getOptions(d),this.$viewport=this.options.viewport&&a(a.isFunction(this.options.viewport)?this.options.viewport.call(this,this.$element):this.options.viewport.selector||this.options.viewport),this.inState={click:!1,hover:!1,focus:!1},this.$element[0]instanceof document.constructor&&!this.options.selector)throw new Error("`selector` option must be specified when initializing "+this.type+" on the window.document object!");for(var e=this.options.trigger.split(" "),f=e.length;f--;){var g=e[f];if("click"==g)this.$element.on("click."+this.type,this.options.selector,a.proxy(this.toggle,this));else if("manual"!=g){var h="hover"==g?"mouseenter":"focusin",i="hover"==g?"mouseleave":"focusout";this.$element.on(h+"."+this.type,this.options.selector,a.proxy(this.enter,this)),this.$element.on(i+"."+this.type,this.options.selector,a.proxy(this.leave,this))}}this.options.selector?this._options=a.extend({},this.options,{trigger:"manual",selector:""}):this.fixTitle()},c.prototype.getDefaults=function(){return c.DEFAULTS},c.prototype.getOptions=function(b){return b=a.extend({},this.getDefaults(),this.$element.data(),b),b.delay&&"number"==typeof b.delay&&(b.delay={show:b.delay,hide:b.delay}),b},c.prototype.getDelegateOptions=function(){var b={},c=this.getDefaults();return this._options&&a.each(this._options,function(a,d){c[a]!=d&&(b[a]=d)}),b},c.prototype.enter=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget).data("bs."+this.type);return c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c)),b instanceof a.Event&&(c.inState["focusin"==b.type?"focus":"hover"]=!0),c.tip().hasClass("in")||"in"==c.hoverState?void(c.hoverState="in"):(clearTimeout(c.timeout),c.hoverState="in",c.options.delay&&c.options.delay.show?void(c.timeout=setTimeout(function(){"in"==c.hoverState&&c.show()},c.options.delay.show)):c.show())},c.prototype.isInStateTrue=function(){for(var a in this.inState)if(this.inState[a])return!0;return!1},c.prototype.leave=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget).data("bs."+this.type);return c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c)),b instanceof a.Event&&(c.inState["focusout"==b.type?"focus":"hover"]=!1),c.isInStateTrue()?void 0:(clearTimeout(c.timeout),c.hoverState="out",c.options.delay&&c.options.delay.hide?void(c.timeout=setTimeout(function(){"out"==c.hoverState&&c.hide()},c.options.delay.hide)):c.hide())},c.prototype.show=function(){var b=a.Event("show.bs."+this.type);if(this.hasContent()&&this.enabled){this.$element.trigger(b);var d=a.contains(this.$element[0].ownerDocument.documentElement,this.$element[0]);if(b.isDefaultPrevented()||!d)return;var e=this,f=this.tip(),g=this.getUID(this.type);this.setContent(),f.attr("id",g),this.$element.attr("aria-describedby",g),this.options.animation&&f.addClass("fade");var h="function"==typeof this.options.placement?this.options.placement.call(this,f[0],this.$element[0]):this.options.placement,i=/\s?auto?\s?/i,j=i.test(h);j&&(h=h.replace(i,"")||"top"),f.detach().css({top:0,left:0,display:"block"}).addClass(h).data("bs."+this.type,this),this.options.container?f.appendTo(this.options.container):f.insertAfter(this.$element),this.$element.trigger("inserted.bs."+this.type);var k=this.getPosition(),l=f[0].offsetWidth,m=f[0].offsetHeight;if(j){var n=h,o=this.getPosition(this.$viewport);h="bottom"==h&&k.bottom+m>o.bottom?"top":"top"==h&&k.top-m<o.top?"bottom":"right"==h&&k.right+l>o.width?"left":"left"==h&&k.left-l<o.left?"right":h,f.removeClass(n).addClass(h)}var p=this.getCalculatedOffset(h,k,l,m);this.applyPlacement(p,h);var q=function(){var a=e.hoverState;e.$element.trigger("shown.bs."+e.type),e.hoverState=null,"out"==a&&e.leave(e)};a.support.transition&&this.$tip.hasClass("fade")?f.one("bsTransitionEnd",q).emulateTransitionEnd(c.TRANSITION_DURATION):q()}},c.prototype.applyPlacement=function(b,c){var d=this.tip(),e=d[0].offsetWidth,f=d[0].offsetHeight,g=parseInt(d.css("margin-top"),10),h=parseInt(d.css("margin-left"),10);isNaN(g)&&(g=0),isNaN(h)&&(h=0),b.top+=g,b.left+=h,a.offset.setOffset(d[0],a.extend({using:function(a){d.css({top:Math.round(a.top),left:Math.round(a.left)})}},b),0),d.addClass("in");var i=d[0].offsetWidth,j=d[0].offsetHeight;"top"==c&&j!=f&&(b.top=b.top+f-j);var k=this.getViewportAdjustedDelta(c,b,i,j);k.left?b.left+=k.left:b.top+=k.top;var l=/top|bottom/.test(c),m=l?2*k.left-e+i:2*k.top-f+j,n=l?"offsetWidth":"offsetHeight";d.offset(b),this.replaceArrow(m,d[0][n],l)},c.prototype.replaceArrow=function(a,b,c){this.arrow().css(c?"left":"top",50*(1-a/b)+"%").css(c?"top":"left","")},c.prototype.setContent=function(){var a=this.tip(),b=this.getTitle();a.find(".tooltip-inner")[this.options.html?"html":"text"](b),a.removeClass("fade in top bottom left right")},c.prototype.hide=function(b){function d(){"in"!=e.hoverState&&f.detach(),e.$element.removeAttr("aria-describedby").trigger("hidden.bs."+e.type),b&&b()}var e=this,f=a(this.$tip),g=a.Event("hide.bs."+this.type);return this.$element.trigger(g),g.isDefaultPrevented()?void 0:(f.removeClass("in"),a.support.transition&&f.hasClass("fade")?f.one("bsTransitionEnd",d).emulateTransitionEnd(c.TRANSITION_DURATION):d(),this.hoverState=null,this)},c.prototype.fixTitle=function(){var a=this.$element;(a.attr("title")||"string"!=typeof a.attr("data-original-title"))&&a.attr("data-original-title",a.attr("title")||"").attr("title","")},c.prototype.hasContent=function(){return this.getTitle()},c.prototype.getPosition=function(b){b=b||this.$element;var c=b[0],d="BODY"==c.tagName,e=c.getBoundingClientRect();null==e.width&&(e=a.extend({},e,{width:e.right-e.left,height:e.bottom-e.top}));var f=d?{top:0,left:0}:b.offset(),g={scroll:d?document.documentElement.scrollTop||document.body.scrollTop:b.scrollTop()},h=d?{width:a(window).width(),height:a(window).height()}:null;return a.extend({},e,g,h,f)},c.prototype.getCalculatedOffset=function(a,b,c,d){return"bottom"==a?{top:b.top+b.height,left:b.left+b.width/2-c/2}:"top"==a?{top:b.top-d,left:b.left+b.width/2-c/2}:"left"==a?{top:b.top+b.height/2-d/2,left:b.left-c}:{top:b.top+b.height/2-d/2,left:b.left+b.width}},c.prototype.getViewportAdjustedDelta=function(a,b,c,d){var e={top:0,left:0};if(!this.$viewport)return e;var f=this.options.viewport&&this.options.viewport.padding||0,g=this.getPosition(this.$viewport);if(/right|left/.test(a)){var h=b.top-f-g.scroll,i=b.top+f-g.scroll+d;h<g.top?e.top=g.top-h:i>g.top+g.height&&(e.top=g.top+g.height-i)}else{var j=b.left-f,k=b.left+f+c;j<g.left?e.left=g.left-j:k>g.right&&(e.left=g.left+g.width-k)}return e},c.prototype.getTitle=function(){var a,b=this.$element,c=this.options;return a=b.attr("data-original-title")||("function"==typeof c.title?c.title.call(b[0]):c.title)},c.prototype.getUID=function(a){do a+=~~(1e6*Math.random());while(document.getElementById(a));return a},c.prototype.tip=function(){if(!this.$tip&&(this.$tip=a(this.options.template),1!=this.$tip.length))throw new Error(this.type+" `template` option must consist of exactly 1 top-level element!");return this.$tip},c.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".tooltip-arrow")},c.prototype.enable=function(){this.enabled=!0},c.prototype.disable=function(){this.enabled=!1},c.prototype.toggleEnabled=function(){this.enabled=!this.enabled},c.prototype.toggle=function(b){var c=this;b&&(c=a(b.currentTarget).data("bs."+this.type),c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data("bs."+this.type,c))),b?(c.inState.click=!c.inState.click,c.isInStateTrue()?c.enter(c):c.leave(c)):c.tip().hasClass("in")?c.leave(c):c.enter(c)},c.prototype.destroy=function(){var a=this;clearTimeout(this.timeout),this.hide(function(){a.$element.off("."+a.type).removeData("bs."+a.type),a.$tip&&a.$tip.detach(),a.$tip=null,a.$arrow=null,a.$viewport=null})};var d=a.fn.tooltip;a.fn.tooltip=b,a.fn.tooltip.Constructor=c,a.fn.tooltip.noConflict=function(){return a.fn.tooltip=d,this}}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.popover"),f="object"==typeof b&&b;(e||!/destroy|hide/.test(b))&&(e||d.data("bs.popover",e=new c(this,f)),"string"==typeof b&&e[b]())})}var c=function(a,b){this.init("popover",a,b)};if(!a.fn.tooltip)throw new Error("Popover requires tooltip.js");c.VERSION="3.3.5",c.DEFAULTS=a.extend({},a.fn.tooltip.Constructor.DEFAULTS,{placement:"right",trigger:"click",content:"",template:'<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'}),c.prototype=a.extend({},a.fn.tooltip.Constructor.prototype),c.prototype.constructor=c,c.prototype.getDefaults=function(){return c.DEFAULTS},c.prototype.setContent=function(){var a=this.tip(),b=this.getTitle(),c=this.getContent();a.find(".popover-title")[this.options.html?"html":"text"](b),a.find(".popover-content").children().detach().end()[this.options.html?"string"==typeof c?"html":"append":"text"](c),a.removeClass("fade top bottom left right in"),a.find(".popover-title").html()||a.find(".popover-title").hide()},c.prototype.hasContent=function(){return this.getTitle()||this.getContent()},c.prototype.getContent=function(){var a=this.$element,b=this.options;return a.attr("data-content")||("function"==typeof b.content?b.content.call(a[0]):b.content)},c.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".arrow")};var d=a.fn.popover;a.fn.popover=b,a.fn.popover.Constructor=c,a.fn.popover.noConflict=function(){return a.fn.popover=d,this}}(jQuery),+function(a){"use strict";function b(c,d){this.$body=a(document.body),this.$scrollElement=a(a(c).is(document.body)?window:c),this.options=a.extend({},b.DEFAULTS,d),this.selector=(this.options.target||"")+" .nav li > a",this.offsets=[],this.targets=[],this.activeTarget=null,this.scrollHeight=0,this.$scrollElement.on("scroll.bs.scrollspy",a.proxy(this.process,this)),this.refresh(),this.process()}function c(c){return this.each(function(){var d=a(this),e=d.data("bs.scrollspy"),f="object"==typeof c&&c;e||d.data("bs.scrollspy",e=new b(this,f)),"string"==typeof c&&e[c]()})}b.VERSION="3.3.5",b.DEFAULTS={offset:10},b.prototype.getScrollHeight=function(){return this.$scrollElement[0].scrollHeight||Math.max(this.$body[0].scrollHeight,document.documentElement.scrollHeight)},b.prototype.refresh=function(){var b=this,c="offset",d=0;this.offsets=[],this.targets=[],this.scrollHeight=this.getScrollHeight(),a.isWindow(this.$scrollElement[0])||(c="position",d=this.$scrollElement.scrollTop()),this.$body.find(this.selector).map(function(){var b=a(this),e=b.data("target")||b.attr("href"),f=/^#./.test(e)&&a(e);return f&&f.length&&f.is(":visible")&&[[f[c]().top+d,e]]||null}).sort(function(a,b){return a[0]-b[0]}).each(function(){b.offsets.push(this[0]),b.targets.push(this[1])})},b.prototype.process=function(){var a,b=this.$scrollElement.scrollTop()+this.options.offset,c=this.getScrollHeight(),d=this.options.offset+c-this.$scrollElement.height(),e=this.offsets,f=this.targets,g=this.activeTarget;if(this.scrollHeight!=c&&this.refresh(),b>=d)return g!=(a=f[f.length-1])&&this.activate(a);if(g&&b<e[0])return this.activeTarget=null,this.clear();for(a=e.length;a--;)g!=f[a]&&b>=e[a]&&(void 0===e[a+1]||b<e[a+1])&&this.activate(f[a])},b.prototype.activate=function(b){this.activeTarget=b,this.clear();var c=this.selector+'[data-target="'+b+'"],'+this.selector+'[href="'+b+'"]',d=a(c).parents("li").addClass("active");d.parent(".dropdown-menu").length&&(d=d.closest("li.dropdown").addClass("active")),
d.trigger("activate.bs.scrollspy")},b.prototype.clear=function(){a(this.selector).parentsUntil(this.options.target,".active").removeClass("active")};var d=a.fn.scrollspy;a.fn.scrollspy=c,a.fn.scrollspy.Constructor=b,a.fn.scrollspy.noConflict=function(){return a.fn.scrollspy=d,this},a(window).on("load.bs.scrollspy.data-api",function(){a('[data-spy="scroll"]').each(function(){var b=a(this);c.call(b,b.data())})})}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.tab");e||d.data("bs.tab",e=new c(this)),"string"==typeof b&&e[b]()})}var c=function(b){this.element=a(b)};c.VERSION="3.3.5",c.TRANSITION_DURATION=150,c.prototype.show=function(){var b=this.element,c=b.closest("ul:not(.dropdown-menu)"),d=b.data("target");if(d||(d=b.attr("href"),d=d&&d.replace(/.*(?=#[^\s]*$)/,"")),!b.parent("li").hasClass("active")){var e=c.find(".active:last a"),f=a.Event("hide.bs.tab",{relatedTarget:b[0]}),g=a.Event("show.bs.tab",{relatedTarget:e[0]});if(e.trigger(f),b.trigger(g),!g.isDefaultPrevented()&&!f.isDefaultPrevented()){var h=a(d);this.activate(b.closest("li"),c),this.activate(h,h.parent(),function(){e.trigger({type:"hidden.bs.tab",relatedTarget:b[0]}),b.trigger({type:"shown.bs.tab",relatedTarget:e[0]})})}}},c.prototype.activate=function(b,d,e){function f(){g.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded",!1),b.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded",!0),h?(b[0].offsetWidth,b.addClass("in")):b.removeClass("fade"),b.parent(".dropdown-menu").length&&b.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded",!0),e&&e()}var g=d.find("> .active"),h=e&&a.support.transition&&(g.length&&g.hasClass("fade")||!!d.find("> .fade").length);g.length&&h?g.one("bsTransitionEnd",f).emulateTransitionEnd(c.TRANSITION_DURATION):f(),g.removeClass("in")};var d=a.fn.tab;a.fn.tab=b,a.fn.tab.Constructor=c,a.fn.tab.noConflict=function(){return a.fn.tab=d,this};var e=function(c){c.preventDefault(),b.call(a(this),"show")};a(document).on("click.bs.tab.data-api",'[data-toggle="tab"]',e).on("click.bs.tab.data-api",'[data-toggle="pill"]',e)}(jQuery),+function(a){"use strict";function b(b){return this.each(function(){var d=a(this),e=d.data("bs.affix"),f="object"==typeof b&&b;e||d.data("bs.affix",e=new c(this,f)),"string"==typeof b&&e[b]()})}var c=function(b,d){this.options=a.extend({},c.DEFAULTS,d),this.$target=a(this.options.target).on("scroll.bs.affix.data-api",a.proxy(this.checkPosition,this)).on("click.bs.affix.data-api",a.proxy(this.checkPositionWithEventLoop,this)),this.$element=a(b),this.affixed=null,this.unpin=null,this.pinnedOffset=null,this.checkPosition()};c.VERSION="3.3.5",c.RESET="affix affix-top affix-bottom",c.DEFAULTS={offset:0,target:window},c.prototype.getState=function(a,b,c,d){var e=this.$target.scrollTop(),f=this.$element.offset(),g=this.$target.height();if(null!=c&&"top"==this.affixed)return c>e?"top":!1;if("bottom"==this.affixed)return null!=c?e+this.unpin<=f.top?!1:"bottom":a-d>=e+g?!1:"bottom";var h=null==this.affixed,i=h?e:f.top,j=h?g:b;return null!=c&&c>=e?"top":null!=d&&i+j>=a-d?"bottom":!1},c.prototype.getPinnedOffset=function(){if(this.pinnedOffset)return this.pinnedOffset;this.$element.removeClass(c.RESET).addClass("affix");var a=this.$target.scrollTop(),b=this.$element.offset();return this.pinnedOffset=b.top-a},c.prototype.checkPositionWithEventLoop=function(){setTimeout(a.proxy(this.checkPosition,this),1)},c.prototype.checkPosition=function(){if(this.$element.is(":visible")){var b=this.$element.height(),d=this.options.offset,e=d.top,f=d.bottom,g=Math.max(a(document).height(),a(document.body).height());"object"!=typeof d&&(f=e=d),"function"==typeof e&&(e=d.top(this.$element)),"function"==typeof f&&(f=d.bottom(this.$element));var h=this.getState(g,b,e,f);if(this.affixed!=h){null!=this.unpin&&this.$element.css("top","");var i="affix"+(h?"-"+h:""),j=a.Event(i+".bs.affix");if(this.$element.trigger(j),j.isDefaultPrevented())return;this.affixed=h,this.unpin="bottom"==h?this.getPinnedOffset():null,this.$element.removeClass(c.RESET).addClass(i).trigger(i.replace("affix","affixed")+".bs.affix")}"bottom"==h&&this.$element.offset({top:g-b-f})}};var d=a.fn.affix;a.fn.affix=b,a.fn.affix.Constructor=c,a.fn.affix.noConflict=function(){return a.fn.affix=d,this},a(window).on("load",function(){a('[data-spy="affix"]').each(function(){var c=a(this),d=c.data();d.offset=d.offset||{},null!=d.offsetBottom&&(d.offset.bottom=d.offsetBottom),null!=d.offsetTop&&(d.offset.top=d.offsetTop),b.call(c,d)})})}(jQuery);</script>
<script>/**
* @preserve HTML5 Shiv 3.7.2 | @afarkas @jdalton @jon_neal @rem | MIT/GPL2 Licensed
*/
// Only run this code in IE 8
if (!!window.navigator.userAgent.match("MSIE 8")) {
!function(a,b){function c(a,b){var c=a.createElement("p"),d=a.getElementsByTagName("head")[0]||a.documentElement;return c.innerHTML="x<style>"+b+"</style>",d.insertBefore(c.lastChild,d.firstChild)}function d(){var a=t.elements;return"string"==typeof a?a.split(" "):a}function e(a,b){var c=t.elements;"string"!=typeof c&&(c=c.join(" ")),"string"!=typeof a&&(a=a.join(" ")),t.elements=c+" "+a,j(b)}function f(a){var b=s[a[q]];return b||(b={},r++,a[q]=r,s[r]=b),b}function g(a,c,d){if(c||(c=b),l)return c.createElement(a);d||(d=f(c));var e;return e=d.cache[a]?d.cache[a].cloneNode():p.test(a)?(d.cache[a]=d.createElem(a)).cloneNode():d.createElem(a),!e.canHaveChildren||o.test(a)||e.tagUrn?e:d.frag.appendChild(e)}function h(a,c){if(a||(a=b),l)return a.createDocumentFragment();c=c||f(a);for(var e=c.frag.cloneNode(),g=0,h=d(),i=h.length;i>g;g++)e.createElement(h[g]);return e}function i(a,b){b.cache||(b.cache={},b.createElem=a.createElement,b.createFrag=a.createDocumentFragment,b.frag=b.createFrag()),a.createElement=function(c){return t.shivMethods?g(c,a,b):b.createElem(c)},a.createDocumentFragment=Function("h,f","return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&("+d().join().replace(/[\w\-:]+/g,function(a){return b.createElem(a),b.frag.createElement(a),'c("'+a+'")'})+");return n}")(t,b.frag)}function j(a){a||(a=b);var d=f(a);return!t.shivCSS||k||d.hasCSS||(d.hasCSS=!!c(a,"article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}mark{background:#FF0;color:#000}template{display:none}")),l||i(a,d),a}var k,l,m="3.7.2",n=a.html5||{},o=/^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i,p=/^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i,q="_html5shiv",r=0,s={};!function(){try{var a=b.createElement("a");a.innerHTML="<xyz></xyz>",k="hidden"in a,l=1==a.childNodes.length||function(){b.createElement("a");var a=b.createDocumentFragment();return"undefined"==typeof a.cloneNode||"undefined"==typeof a.createDocumentFragment||"undefined"==typeof a.createElement}()}catch(c){k=!0,l=!0}}();var t={elements:n.elements||"abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output picture progress section summary template time video",version:m,shivCSS:n.shivCSS!==!1,supportsUnknownElements:l,shivMethods:n.shivMethods!==!1,type:"default",shivDocument:j,createElement:g,createDocumentFragment:h,addElements:e};a.html5=t,j(b)}(this,document);
};
</script>
<script>/*! Respond.js v1.4.2: min/max-width media query polyfill * Copyright 2013 Scott Jehl
 * Licensed under https://github.com/scottjehl/Respond/blob/master/LICENSE-MIT
 *  */

// Only run this code in IE 8
if (!!window.navigator.userAgent.match("MSIE 8")) {
!function(a){"use strict";a.matchMedia=a.matchMedia||function(a){var b,c=a.documentElement,d=c.firstElementChild||c.firstChild,e=a.createElement("body"),f=a.createElement("div");return f.id="mq-test-1",f.style.cssText="position:absolute;top:-100em",e.style.background="none",e.appendChild(f),function(a){return f.innerHTML='&shy;<style media="'+a+'"> #mq-test-1 { width: 42px; }</style>',c.insertBefore(e,d),b=42===f.offsetWidth,c.removeChild(e),{matches:b,media:a}}}(a.document)}(this),function(a){"use strict";function b(){u(!0)}var c={};a.respond=c,c.update=function(){};var d=[],e=function(){var b=!1;try{b=new a.XMLHttpRequest}catch(c){b=new a.ActiveXObject("Microsoft.XMLHTTP")}return function(){return b}}(),f=function(a,b){var c=e();c&&(c.open("GET",a,!0),c.onreadystatechange=function(){4!==c.readyState||200!==c.status&&304!==c.status||b(c.responseText)},4!==c.readyState&&c.send(null))};if(c.ajax=f,c.queue=d,c.regex={media:/@media[^\{]+\{([^\{\}]*\{[^\}\{]*\})+/gi,keyframes:/@(?:\-(?:o|moz|webkit)\-)?keyframes[^\{]+\{(?:[^\{\}]*\{[^\}\{]*\})+[^\}]*\}/gi,urls:/(url\()['"]?([^\/\)'"][^:\)'"]+)['"]?(\))/g,findStyles:/@media *([^\{]+)\{([\S\s]+?)$/,only:/(only\s+)?([a-zA-Z]+)\s?/,minw:/\([\s]*min\-width\s*:[\s]*([\s]*[0-9\.]+)(px|em)[\s]*\)/,maxw:/\([\s]*max\-width\s*:[\s]*([\s]*[0-9\.]+)(px|em)[\s]*\)/},c.mediaQueriesSupported=a.matchMedia&&null!==a.matchMedia("only all")&&a.matchMedia("only all").matches,!c.mediaQueriesSupported){var g,h,i,j=a.document,k=j.documentElement,l=[],m=[],n=[],o={},p=30,q=j.getElementsByTagName("head")[0]||k,r=j.getElementsByTagName("base")[0],s=q.getElementsByTagName("link"),t=function(){var a,b=j.createElement("div"),c=j.body,d=k.style.fontSize,e=c&&c.style.fontSize,f=!1;return b.style.cssText="position:absolute;font-size:1em;width:1em",c||(c=f=j.createElement("body"),c.style.background="none"),k.style.fontSize="100%",c.style.fontSize="100%",c.appendChild(b),f&&k.insertBefore(c,k.firstChild),a=b.offsetWidth,f?k.removeChild(c):c.removeChild(b),k.style.fontSize=d,e&&(c.style.fontSize=e),a=i=parseFloat(a)},u=function(b){var c="clientWidth",d=k[c],e="CSS1Compat"===j.compatMode&&d||j.body[c]||d,f={},o=s[s.length-1],r=(new Date).getTime();if(b&&g&&p>r-g)return a.clearTimeout(h),h=a.setTimeout(u,p),void 0;g=r;for(var v in l)if(l.hasOwnProperty(v)){var w=l[v],x=w.minw,y=w.maxw,z=null===x,A=null===y,B="em";x&&(x=parseFloat(x)*(x.indexOf(B)>-1?i||t():1)),y&&(y=parseFloat(y)*(y.indexOf(B)>-1?i||t():1)),w.hasquery&&(z&&A||!(z||e>=x)||!(A||y>=e))||(f[w.media]||(f[w.media]=[]),f[w.media].push(m[w.rules]))}for(var C in n)n.hasOwnProperty(C)&&n[C]&&n[C].parentNode===q&&q.removeChild(n[C]);n.length=0;for(var D in f)if(f.hasOwnProperty(D)){var E=j.createElement("style"),F=f[D].join("\n");E.type="text/css",E.media=D,q.insertBefore(E,o.nextSibling),E.styleSheet?E.styleSheet.cssText=F:E.appendChild(j.createTextNode(F)),n.push(E)}},v=function(a,b,d){var e=a.replace(c.regex.keyframes,"").match(c.regex.media),f=e&&e.length||0;b=b.substring(0,b.lastIndexOf("/"));var g=function(a){return a.replace(c.regex.urls,"$1"+b+"$2$3")},h=!f&&d;b.length&&(b+="/"),h&&(f=1);for(var i=0;f>i;i++){var j,k,n,o;h?(j=d,m.push(g(a))):(j=e[i].match(c.regex.findStyles)&&RegExp.$1,m.push(RegExp.$2&&g(RegExp.$2))),n=j.split(","),o=n.length;for(var p=0;o>p;p++)k=n[p],l.push({media:k.split("(")[0].match(c.regex.only)&&RegExp.$2||"all",rules:m.length-1,hasquery:k.indexOf("(")>-1,minw:k.match(c.regex.minw)&&parseFloat(RegExp.$1)+(RegExp.$2||""),maxw:k.match(c.regex.maxw)&&parseFloat(RegExp.$1)+(RegExp.$2||"")})}u()},w=function(){if(d.length){var b=d.shift();f(b.href,function(c){v(c,b.href,b.media),o[b.href]=!0,a.setTimeout(function(){w()},0)})}},x=function(){for(var b=0;b<s.length;b++){var c=s[b],e=c.href,f=c.media,g=c.rel&&"stylesheet"===c.rel.toLowerCase();e&&g&&!o[e]&&(c.styleSheet&&c.styleSheet.rawCssText?(v(c.styleSheet.rawCssText,e,f),o[e]=!0):(!/^([a-zA-Z:]*\/\/)/.test(e)&&!r||e.replace(RegExp.$1,"").split("/")[0]===a.location.host)&&("//"===e.substring(0,2)&&(e=a.location.protocol+e),d.push({href:e,media:f})))}w()};x(),c.update=x,c.getEmValue=t,a.addEventListener?a.addEventListener("resize",b,!1):a.attachEvent&&a.attachEvent("onresize",b)}}(this);
};
</script>
<style>h1 {font-size: 34px;}
h1.title {font-size: 38px;}
h2 {font-size: 30px;}
h3 {font-size: 24px;}
h4 {font-size: 18px;}
h5 {font-size: 16px;}
h6 {font-size: 12px;}
code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
pre:not([class]) { background-color: white }</style>
<script>/*! jQuery UI - v1.13.2 - 2022-07-14
* http://jqueryui.com
* Includes: widget.js, position.js, data.js, disable-selection.js, effect.js, effects/effect-blind.js, effects/effect-bounce.js, effects/effect-clip.js, effects/effect-drop.js, effects/effect-explode.js, effects/effect-fade.js, effects/effect-fold.js, effects/effect-highlight.js, effects/effect-puff.js, effects/effect-pulsate.js, effects/effect-scale.js, effects/effect-shake.js, effects/effect-size.js, effects/effect-slide.js, effects/effect-transfer.js, focusable.js, form-reset-mixin.js, jquery-patch.js, keycode.js, labels.js, scroll-parent.js, tabbable.js, unique-id.js, widgets/accordion.js, widgets/autocomplete.js, widgets/button.js, widgets/checkboxradio.js, widgets/controlgroup.js, widgets/datepicker.js, widgets/dialog.js, widgets/draggable.js, widgets/droppable.js, widgets/menu.js, widgets/mouse.js, widgets/progressbar.js, widgets/resizable.js, widgets/selectable.js, widgets/selectmenu.js, widgets/slider.js, widgets/sortable.js, widgets/spinner.js, widgets/tabs.js, widgets/tooltip.js
* Copyright jQuery Foundation and other contributors; Licensed MIT */

!function(t){"use strict";"function"==typeof define&&define.amd?define(["jquery"],t):t(jQuery)}(function(V){"use strict";V.ui=V.ui||{};V.ui.version="1.13.2";var n,i=0,a=Array.prototype.hasOwnProperty,r=Array.prototype.slice;V.cleanData=(n=V.cleanData,function(t){for(var e,i,s=0;null!=(i=t[s]);s++)(e=V._data(i,"events"))&&e.remove&&V(i).triggerHandler("remove");n(t)}),V.widget=function(t,i,e){var s,n,o,a={},r=t.split(".")[0],l=r+"-"+(t=t.split(".")[1]);return e||(e=i,i=V.Widget),Array.isArray(e)&&(e=V.extend.apply(null,[{}].concat(e))),V.expr.pseudos[l.toLowerCase()]=function(t){return!!V.data(t,l)},V[r]=V[r]||{},s=V[r][t],n=V[r][t]=function(t,e){if(!this||!this._createWidget)return new n(t,e);arguments.length&&this._createWidget(t,e)},V.extend(n,s,{version:e.version,_proto:V.extend({},e),_childConstructors:[]}),(o=new i).options=V.widget.extend({},o.options),V.each(e,function(e,s){function n(){return i.prototype[e].apply(this,arguments)}function o(t){return i.prototype[e].apply(this,t)}a[e]="function"==typeof s?function(){var t,e=this._super,i=this._superApply;return this._super=n,this._superApply=o,t=s.apply(this,arguments),this._super=e,this._superApply=i,t}:s}),n.prototype=V.widget.extend(o,{widgetEventPrefix:s&&o.widgetEventPrefix||t},a,{constructor:n,namespace:r,widgetName:t,widgetFullName:l}),s?(V.each(s._childConstructors,function(t,e){var i=e.prototype;V.widget(i.namespace+"."+i.widgetName,n,e._proto)}),delete s._childConstructors):i._childConstructors.push(n),V.widget.bridge(t,n),n},V.widget.extend=function(t){for(var e,i,s=r.call(arguments,1),n=0,o=s.length;n<o;n++)for(e in s[n])i=s[n][e],a.call(s[n],e)&&void 0!==i&&(V.isPlainObject(i)?t[e]=V.isPlainObject(t[e])?V.widget.extend({},t[e],i):V.widget.extend({},i):t[e]=i);return t},V.widget.bridge=function(o,e){var a=e.prototype.widgetFullName||o;V.fn[o]=function(i){var t="string"==typeof i,s=r.call(arguments,1),n=this;return t?this.length||"instance"!==i?this.each(function(){var t,e=V.data(this,a);return"instance"===i?(n=e,!1):e?"function"!=typeof e[i]||"_"===i.charAt(0)?V.error("no such method '"+i+"' for "+o+" widget instance"):(t=e[i].apply(e,s))!==e&&void 0!==t?(n=t&&t.jquery?n.pushStack(t.get()):t,!1):void 0:V.error("cannot call methods on "+o+" prior to initialization; attempted to call method '"+i+"'")}):n=void 0:(s.length&&(i=V.widget.extend.apply(null,[i].concat(s))),this.each(function(){var t=V.data(this,a);t?(t.option(i||{}),t._init&&t._init()):V.data(this,a,new e(i,this))})),n}},V.Widget=function(){},V.Widget._childConstructors=[],V.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{classes:{},disabled:!1,create:null},_createWidget:function(t,e){e=V(e||this.defaultElement||this)[0],this.element=V(e),this.uuid=i++,this.eventNamespace="."+this.widgetName+this.uuid,this.bindings=V(),this.hoverable=V(),this.focusable=V(),this.classesElementLookup={},e!==this&&(V.data(e,this.widgetFullName,this),this._on(!0,this.element,{remove:function(t){t.target===e&&this.destroy()}}),this.document=V(e.style?e.ownerDocument:e.document||e),this.window=V(this.document[0].defaultView||this.document[0].parentWindow)),this.options=V.widget.extend({},this.options,this._getCreateOptions(),t),this._create(),this.options.disabled&&this._setOptionDisabled(this.options.disabled),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:function(){return{}},_getCreateEventData:V.noop,_create:V.noop,_init:V.noop,destroy:function(){var i=this;this._destroy(),V.each(this.classesElementLookup,function(t,e){i._removeClass(e,t)}),this.element.off(this.eventNamespace).removeData(this.widgetFullName),this.widget().off(this.eventNamespace).removeAttr("aria-disabled"),this.bindings.off(this.eventNamespace)},_destroy:V.noop,widget:function(){return this.element},option:function(t,e){var i,s,n,o=t;if(0===arguments.length)return V.widget.extend({},this.options);if("string"==typeof t)if(o={},t=(i=t.split(".")).shift(),i.length){for(s=o[t]=V.widget.extend({},this.options[t]),n=0;n<i.length-1;n++)s[i[n]]=s[i[n]]||{},s=s[i[n]];if(t=i.pop(),1===arguments.length)return void 0===s[t]?null:s[t];s[t]=e}else{if(1===arguments.length)return void 0===this.options[t]?null:this.options[t];o[t]=e}return this._setOptions(o),this},_setOptions:function(t){for(var e in t)this._setOption(e,t[e]);return this},_setOption:function(t,e){return"classes"===t&&this._setOptionClasses(e),this.options[t]=e,"disabled"===t&&this._setOptionDisabled(e),this},_setOptionClasses:function(t){var e,i,s;for(e in t)s=this.classesElementLookup[e],t[e]!==this.options.classes[e]&&s&&s.length&&(i=V(s.get()),this._removeClass(s,e),i.addClass(this._classes({element:i,keys:e,classes:t,add:!0})))},_setOptionDisabled:function(t){this._toggleClass(this.widget(),this.widgetFullName+"-disabled",null,!!t),t&&(this._removeClass(this.hoverable,null,"ui-state-hover"),this._removeClass(this.focusable,null,"ui-state-focus"))},enable:function(){return this._setOptions({disabled:!1})},disable:function(){return this._setOptions({disabled:!0})},_classes:function(n){var o=[],a=this;function t(t,e){for(var i,s=0;s<t.length;s++)i=a.classesElementLookup[t[s]]||V(),i=n.add?(function(){var i=[];n.element.each(function(t,e){V.map(a.classesElementLookup,function(t){return t}).some(function(t){return t.is(e)})||i.push(e)}),a._on(V(i),{remove:"_untrackClassesElement"})}(),V(V.uniqueSort(i.get().concat(n.element.get())))):V(i.not(n.element).get()),a.classesElementLookup[t[s]]=i,o.push(t[s]),e&&n.classes[t[s]]&&o.push(n.classes[t[s]])}return(n=V.extend({element:this.element,classes:this.options.classes||{}},n)).keys&&t(n.keys.match(/\S+/g)||[],!0),n.extra&&t(n.extra.match(/\S+/g)||[]),o.join(" ")},_untrackClassesElement:function(i){var s=this;V.each(s.classesElementLookup,function(t,e){-1!==V.inArray(i.target,e)&&(s.classesElementLookup[t]=V(e.not(i.target).get()))}),this._off(V(i.target))},_removeClass:function(t,e,i){return this._toggleClass(t,e,i,!1)},_addClass:function(t,e,i){return this._toggleClass(t,e,i,!0)},_toggleClass:function(t,e,i,s){var n="string"==typeof t||null===t,i={extra:n?e:i,keys:n?t:e,element:n?this.element:t,add:s="boolean"==typeof s?s:i};return i.element.toggleClass(this._classes(i),s),this},_on:function(n,o,t){var a,r=this;"boolean"!=typeof n&&(t=o,o=n,n=!1),t?(o=a=V(o),this.bindings=this.bindings.add(o)):(t=o,o=this.element,a=this.widget()),V.each(t,function(t,e){function i(){if(n||!0!==r.options.disabled&&!V(this).hasClass("ui-state-disabled"))return("string"==typeof e?r[e]:e).apply(r,arguments)}"string"!=typeof e&&(i.guid=e.guid=e.guid||i.guid||V.guid++);var s=t.match(/^([\w:-]*)\s*(.*)$/),t=s[1]+r.eventNamespace,s=s[2];s?a.on(t,s,i):o.on(t,i)})},_off:function(t,e){e=(e||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,t.off(e),this.bindings=V(this.bindings.not(t).get()),this.focusable=V(this.focusable.not(t).get()),this.hoverable=V(this.hoverable.not(t).get())},_delay:function(t,e){var i=this;return setTimeout(function(){return("string"==typeof t?i[t]:t).apply(i,arguments)},e||0)},_hoverable:function(t){this.hoverable=this.hoverable.add(t),this._on(t,{mouseenter:function(t){this._addClass(V(t.currentTarget),null,"ui-state-hover")},mouseleave:function(t){this._removeClass(V(t.currentTarget),null,"ui-state-hover")}})},_focusable:function(t){this.focusable=this.focusable.add(t),this._on(t,{focusin:function(t){this._addClass(V(t.currentTarget),null,"ui-state-focus")},focusout:function(t){this._removeClass(V(t.currentTarget),null,"ui-state-focus")}})},_trigger:function(t,e,i){var s,n,o=this.options[t];if(i=i||{},(e=V.Event(e)).type=(t===this.widgetEventPrefix?t:this.widgetEventPrefix+t).toLowerCase(),e.target=this.element[0],n=e.originalEvent)for(s in n)s in e||(e[s]=n[s]);return this.element.trigger(e,i),!("function"==typeof o&&!1===o.apply(this.element[0],[e].concat(i))||e.isDefaultPrevented())}},V.each({show:"fadeIn",hide:"fadeOut"},function(o,a){V.Widget.prototype["_"+o]=function(e,t,i){var s,n=(t="string"==typeof t?{effect:t}:t)?!0!==t&&"number"!=typeof t&&t.effect||a:o;"number"==typeof(t=t||{})?t={duration:t}:!0===t&&(t={}),s=!V.isEmptyObject(t),t.complete=i,t.delay&&e.delay(t.delay),s&&V.effects&&V.effects.effect[n]?e[o](t):n!==o&&e[n]?e[n](t.duration,t.easing,i):e.queue(function(t){V(this)[o](),i&&i.call(e[0]),t()})}});var s,x,k,o,l,h,c,u,C;V.widget;function D(t,e,i){return[parseFloat(t[0])*(u.test(t[0])?e/100:1),parseFloat(t[1])*(u.test(t[1])?i/100:1)]}function I(t,e){return parseInt(V.css(t,e),10)||0}function T(t){return null!=t&&t===t.window}x=Math.max,k=Math.abs,o=/left|center|right/,l=/top|center|bottom/,h=/[\+\-]\d+(\.[\d]+)?%?/,c=/^\w+/,u=/%$/,C=V.fn.position,V.position={scrollbarWidth:function(){if(void 0!==s)return s;var t,e=V("<div style='display:block;position:absolute;width:200px;height:200px;overflow:hidden;'><div style='height:300px;width:auto;'></div></div>"),i=e.children()[0];return V("body").append(e),t=i.offsetWidth,e.css("overflow","scroll"),t===(i=i.offsetWidth)&&(i=e[0].clientWidth),e.remove(),s=t-i},getScrollInfo:function(t){var e=t.isWindow||t.isDocument?"":t.element.css("overflow-x"),i=t.isWindow||t.isDocument?"":t.element.css("overflow-y"),e="scroll"===e||"auto"===e&&t.width<t.element[0].scrollWidth;return{width:"scroll"===i||"auto"===i&&t.height<t.element[0].scrollHeight?V.position.scrollbarWidth():0,height:e?V.position.scrollbarWidth():0}},getWithinInfo:function(t){var e=V(t||window),i=T(e[0]),s=!!e[0]&&9===e[0].nodeType;return{element:e,isWindow:i,isDocument:s,offset:!i&&!s?V(t).offset():{left:0,top:0},scrollLeft:e.scrollLeft(),scrollTop:e.scrollTop(),width:e.outerWidth(),height:e.outerHeight()}}},V.fn.position=function(u){if(!u||!u.of)return C.apply(this,arguments);var d,p,f,g,m,t,_="string"==typeof(u=V.extend({},u)).of?V(document).find(u.of):V(u.of),v=V.position.getWithinInfo(u.within),b=V.position.getScrollInfo(v),y=(u.collision||"flip").split(" "),w={},e=9===(t=(e=_)[0]).nodeType?{width:e.width(),height:e.height(),offset:{top:0,left:0}}:T(t)?{width:e.width(),height:e.height(),offset:{top:e.scrollTop(),left:e.scrollLeft()}}:t.preventDefault?{width:0,height:0,offset:{top:t.pageY,left:t.pageX}}:{width:e.outerWidth(),height:e.outerHeight(),offset:e.offset()};return _[0].preventDefault&&(u.at="left top"),p=e.width,f=e.height,m=V.extend({},g=e.offset),V.each(["my","at"],function(){var t,e,i=(u[this]||"").split(" ");(i=1===i.length?o.test(i[0])?i.concat(["center"]):l.test(i[0])?["center"].concat(i):["center","center"]:i)[0]=o.test(i[0])?i[0]:"center",i[1]=l.test(i[1])?i[1]:"center",t=h.exec(i[0]),e=h.exec(i[1]),w[this]=[t?t[0]:0,e?e[0]:0],u[this]=[c.exec(i[0])[0],c.exec(i[1])[0]]}),1===y.length&&(y[1]=y[0]),"right"===u.at[0]?m.left+=p:"center"===u.at[0]&&(m.left+=p/2),"bottom"===u.at[1]?m.top+=f:"center"===u.at[1]&&(m.top+=f/2),d=D(w.at,p,f),m.left+=d[0],m.top+=d[1],this.each(function(){var i,t,a=V(this),r=a.outerWidth(),l=a.outerHeight(),e=I(this,"marginLeft"),s=I(this,"marginTop"),n=r+e+I(this,"marginRight")+b.width,o=l+s+I(this,"marginBottom")+b.height,h=V.extend({},m),c=D(w.my,a.outerWidth(),a.outerHeight());"right"===u.my[0]?h.left-=r:"center"===u.my[0]&&(h.left-=r/2),"bottom"===u.my[1]?h.top-=l:"center"===u.my[1]&&(h.top-=l/2),h.left+=c[0],h.top+=c[1],i={marginLeft:e,marginTop:s},V.each(["left","top"],function(t,e){V.ui.position[y[t]]&&V.ui.position[y[t]][e](h,{targetWidth:p,targetHeight:f,elemWidth:r,elemHeight:l,collisionPosition:i,collisionWidth:n,collisionHeight:o,offset:[d[0]+c[0],d[1]+c[1]],my:u.my,at:u.at,within:v,elem:a})}),u.using&&(t=function(t){var e=g.left-h.left,i=e+p-r,s=g.top-h.top,n=s+f-l,o={target:{element:_,left:g.left,top:g.top,width:p,height:f},element:{element:a,left:h.left,top:h.top,width:r,height:l},horizontal:i<0?"left":0<e?"right":"center",vertical:n<0?"top":0<s?"bottom":"middle"};p<r&&k(e+i)<p&&(o.horizontal="center"),f<l&&k(s+n)<f&&(o.vertical="middle"),x(k(e),k(i))>x(k(s),k(n))?o.important="horizontal":o.important="vertical",u.using.call(this,t,o)}),a.offset(V.extend(h,{using:t}))})},V.ui.position={fit:{left:function(t,e){var i=e.within,s=i.isWindow?i.scrollLeft:i.offset.left,n=i.width,o=t.left-e.collisionPosition.marginLeft,a=s-o,r=o+e.collisionWidth-n-s;e.collisionWidth>n?0<a&&r<=0?(i=t.left+a+e.collisionWidth-n-s,t.left+=a-i):t.left=!(0<r&&a<=0)&&r<a?s+n-e.collisionWidth:s:0<a?t.left+=a:0<r?t.left-=r:t.left=x(t.left-o,t.left)},top:function(t,e){var i=e.within,s=i.isWindow?i.scrollTop:i.offset.top,n=e.within.height,o=t.top-e.collisionPosition.marginTop,a=s-o,r=o+e.collisionHeight-n-s;e.collisionHeight>n?0<a&&r<=0?(i=t.top+a+e.collisionHeight-n-s,t.top+=a-i):t.top=!(0<r&&a<=0)&&r<a?s+n-e.collisionHeight:s:0<a?t.top+=a:0<r?t.top-=r:t.top=x(t.top-o,t.top)}},flip:{left:function(t,e){var i=e.within,s=i.offset.left+i.scrollLeft,n=i.width,o=i.isWindow?i.scrollLeft:i.offset.left,a=t.left-e.collisionPosition.marginLeft,r=a-o,l=a+e.collisionWidth-n-o,h="left"===e.my[0]?-e.elemWidth:"right"===e.my[0]?e.elemWidth:0,i="left"===e.at[0]?e.targetWidth:"right"===e.at[0]?-e.targetWidth:0,a=-2*e.offset[0];r<0?((s=t.left+h+i+a+e.collisionWidth-n-s)<0||s<k(r))&&(t.left+=h+i+a):0<l&&(0<(o=t.left-e.collisionPosition.marginLeft+h+i+a-o)||k(o)<l)&&(t.left+=h+i+a)},top:function(t,e){var i=e.within,s=i.offset.top+i.scrollTop,n=i.height,o=i.isWindow?i.scrollTop:i.offset.top,a=t.top-e.collisionPosition.marginTop,r=a-o,l=a+e.collisionHeight-n-o,h="top"===e.my[1]?-e.elemHeight:"bottom"===e.my[1]?e.elemHeight:0,i="top"===e.at[1]?e.targetHeight:"bottom"===e.at[1]?-e.targetHeight:0,a=-2*e.offset[1];r<0?((s=t.top+h+i+a+e.collisionHeight-n-s)<0||s<k(r))&&(t.top+=h+i+a):0<l&&(0<(o=t.top-e.collisionPosition.marginTop+h+i+a-o)||k(o)<l)&&(t.top+=h+i+a)}},flipfit:{left:function(){V.ui.position.flip.left.apply(this,arguments),V.ui.position.fit.left.apply(this,arguments)},top:function(){V.ui.position.flip.top.apply(this,arguments),V.ui.position.fit.top.apply(this,arguments)}}};V.ui.position,V.extend(V.expr.pseudos,{data:V.expr.createPseudo?V.expr.createPseudo(function(e){return function(t){return!!V.data(t,e)}}):function(t,e,i){return!!V.data(t,i[3])}}),V.fn.extend({disableSelection:(t="onselectstart"in document.createElement("div")?"selectstart":"mousedown",function(){return this.on(t+".ui-disableSelection",function(t){t.preventDefault()})}),enableSelection:function(){return this.off(".ui-disableSelection")}});var t,d=V,p={},e=p.toString,f=/^([\-+])=\s*(\d+\.?\d*)/,g=[{re:/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,parse:function(t){return[t[1],t[2],t[3],t[4]]}},{re:/rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,parse:function(t){return[2.55*t[1],2.55*t[2],2.55*t[3],t[4]]}},{re:/#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?/,parse:function(t){return[parseInt(t[1],16),parseInt(t[2],16),parseInt(t[3],16),t[4]?(parseInt(t[4],16)/255).toFixed(2):1]}},{re:/#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?/,parse:function(t){return[parseInt(t[1]+t[1],16),parseInt(t[2]+t[2],16),parseInt(t[3]+t[3],16),t[4]?(parseInt(t[4]+t[4],16)/255).toFixed(2):1]}},{re:/hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,space:"hsla",parse:function(t){return[t[1],t[2]/100,t[3]/100,t[4]]}}],m=d.Color=function(t,e,i,s){return new d.Color.fn.parse(t,e,i,s)},_={rgba:{props:{red:{idx:0,type:"byte"},green:{idx:1,type:"byte"},blue:{idx:2,type:"byte"}}},hsla:{props:{hue:{idx:0,type:"degrees"},saturation:{idx:1,type:"percent"},lightness:{idx:2,type:"percent"}}}},v={byte:{floor:!0,max:255},percent:{max:1},degrees:{mod:360,floor:!0}},b=m.support={},y=d("<p>")[0],w=d.each;function P(t){return null==t?t+"":"object"==typeof t?p[e.call(t)]||"object":typeof t}function M(t,e,i){var s=v[e.type]||{};return null==t?i||!e.def?null:e.def:(t=s.floor?~~t:parseFloat(t),isNaN(t)?e.def:s.mod?(t+s.mod)%s.mod:Math.min(s.max,Math.max(0,t)))}function S(s){var n=m(),o=n._rgba=[];return s=s.toLowerCase(),w(g,function(t,e){var i=e.re.exec(s),i=i&&e.parse(i),e=e.space||"rgba";if(i)return i=n[e](i),n[_[e].cache]=i[_[e].cache],o=n._rgba=i._rgba,!1}),o.length?("0,0,0,0"===o.join()&&d.extend(o,B.transparent),n):B[s]}function H(t,e,i){return 6*(i=(i+1)%1)<1?t+(e-t)*i*6:2*i<1?e:3*i<2?t+(e-t)*(2/3-i)*6:t}y.style.cssText="background-color:rgba(1,1,1,.5)",b.rgba=-1<y.style.backgroundColor.indexOf("rgba"),w(_,function(t,e){e.cache="_"+t,e.props.alpha={idx:3,type:"percent",def:1}}),d.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(t,e){p["[object "+e+"]"]=e.toLowerCase()}),(m.fn=d.extend(m.prototype,{parse:function(n,t,e,i){if(void 0===n)return this._rgba=[null,null,null,null],this;(n.jquery||n.nodeType)&&(n=d(n).css(t),t=void 0);var o=this,s=P(n),a=this._rgba=[];return void 0!==t&&(n=[n,t,e,i],s="array"),"string"===s?this.parse(S(n)||B._default):"array"===s?(w(_.rgba.props,function(t,e){a[e.idx]=M(n[e.idx],e)}),this):"object"===s?(w(_,n instanceof m?function(t,e){n[e.cache]&&(o[e.cache]=n[e.cache].slice())}:function(t,i){var s=i.cache;w(i.props,function(t,e){if(!o[s]&&i.to){if("alpha"===t||null==n[t])return;o[s]=i.to(o._rgba)}o[s][e.idx]=M(n[t],e,!0)}),o[s]&&d.inArray(null,o[s].slice(0,3))<0&&(null==o[s][3]&&(o[s][3]=1),i.from&&(o._rgba=i.from(o[s])))}),this):void 0},is:function(t){var n=m(t),o=!0,a=this;return w(_,function(t,e){var i,s=n[e.cache];return s&&(i=a[e.cache]||e.to&&e.to(a._rgba)||[],w(e.props,function(t,e){if(null!=s[e.idx])return o=s[e.idx]===i[e.idx]})),o}),o},_space:function(){var i=[],s=this;return w(_,function(t,e){s[e.cache]&&i.push(t)}),i.pop()},transition:function(t,a){var e=(h=m(t))._space(),i=_[e],t=0===this.alpha()?m("transparent"):this,r=t[i.cache]||i.to(t._rgba),l=r.slice(),h=h[i.cache];return w(i.props,function(t,e){var i=e.idx,s=r[i],n=h[i],o=v[e.type]||{};null!==n&&(null===s?l[i]=n:(o.mod&&(n-s>o.mod/2?s+=o.mod:s-n>o.mod/2&&(s-=o.mod)),l[i]=M((n-s)*a+s,e)))}),this[e](l)},blend:function(t){if(1===this._rgba[3])return this;var e=this._rgba.slice(),i=e.pop(),s=m(t)._rgba;return m(d.map(e,function(t,e){return(1-i)*s[e]+i*t}))},toRgbaString:function(){var t="rgba(",e=d.map(this._rgba,function(t,e){return null!=t?t:2<e?1:0});return 1===e[3]&&(e.pop(),t="rgb("),t+e.join()+")"},toHslaString:function(){var t="hsla(",e=d.map(this.hsla(),function(t,e){return null==t&&(t=2<e?1:0),t=e&&e<3?Math.round(100*t)+"%":t});return 1===e[3]&&(e.pop(),t="hsl("),t+e.join()+")"},toHexString:function(t){var e=this._rgba.slice(),i=e.pop();return t&&e.push(~~(255*i)),"#"+d.map(e,function(t){return 1===(t=(t||0).toString(16)).length?"0"+t:t}).join("")},toString:function(){return 0===this._rgba[3]?"transparent":this.toRgbaString()}})).parse.prototype=m.fn,_.hsla.to=function(t){if(null==t[0]||null==t[1]||null==t[2])return[null,null,null,t[3]];var e=t[0]/255,i=t[1]/255,s=t[2]/255,n=t[3],o=Math.max(e,i,s),a=Math.min(e,i,s),r=o-a,l=o+a,t=.5*l,i=a===o?0:e===o?60*(i-s)/r+360:i===o?60*(s-e)/r+120:60*(e-i)/r+240,l=0==r?0:t<=.5?r/l:r/(2-l);return[Math.round(i)%360,l,t,null==n?1:n]},_.hsla.from=function(t){if(null==t[0]||null==t[1]||null==t[2])return[null,null,null,t[3]];var e=t[0]/360,i=t[1],s=t[2],t=t[3],i=s<=.5?s*(1+i):s+i-s*i,s=2*s-i;return[Math.round(255*H(s,i,e+1/3)),Math.round(255*H(s,i,e)),Math.round(255*H(s,i,e-1/3)),t]},w(_,function(l,t){var e=t.props,o=t.cache,a=t.to,r=t.from;m.fn[l]=function(t){if(a&&!this[o]&&(this[o]=a(this._rgba)),void 0===t)return this[o].slice();var i=P(t),s="array"===i||"object"===i?t:arguments,n=this[o].slice();return w(e,function(t,e){t=s["object"===i?t:e.idx];null==t&&(t=n[e.idx]),n[e.idx]=M(t,e)}),r?((t=m(r(n)))[o]=n,t):m(n)},w(e,function(a,r){m.fn[a]||(m.fn[a]=function(t){var e,i=P(t),s="alpha"===a?this._hsla?"hsla":"rgba":l,n=this[s](),o=n[r.idx];return"undefined"===i?o:("function"===i&&(i=P(t=t.call(this,o))),null==t&&r.empty?this:("string"===i&&(e=f.exec(t))&&(t=o+parseFloat(e[2])*("+"===e[1]?1:-1)),n[r.idx]=t,this[s](n)))})})}),(m.hook=function(t){t=t.split(" ");w(t,function(t,o){d.cssHooks[o]={set:function(t,e){var i,s,n="";if("transparent"!==e&&("string"!==P(e)||(i=S(e)))){if(e=m(i||e),!b.rgba&&1!==e._rgba[3]){for(s="backgroundColor"===o?t.parentNode:t;(""===n||"transparent"===n)&&s&&s.style;)try{n=d.css(s,"backgroundColor"),s=s.parentNode}catch(t){}e=e.blend(n&&"transparent"!==n?n:"_default")}e=e.toRgbaString()}try{t.style[o]=e}catch(t){}}},d.fx.step[o]=function(t){t.colorInit||(t.start=m(t.elem,o),t.end=m(t.end),t.colorInit=!0),d.cssHooks[o].set(t.elem,t.start.transition(t.end,t.pos))}})})("backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor"),d.cssHooks.borderColor={expand:function(i){var s={};return w(["Top","Right","Bottom","Left"],function(t,e){s["border"+e+"Color"]=i}),s}};var z,A,O,N,E,W,F,L,R,Y,B=d.Color.names={aqua:"#00ffff",black:"#000000",blue:"#0000ff",fuchsia:"#ff00ff",gray:"#808080",green:"#008000",lime:"#00ff00",maroon:"#800000",navy:"#000080",olive:"#808000",purple:"#800080",red:"#ff0000",silver:"#c0c0c0",teal:"#008080",white:"#ffffff",yellow:"#ffff00",transparent:[null,null,null,0],_default:"#ffffff"},j="ui-effects-",q="ui-effects-style",K="ui-effects-animated";function U(t){var e,i,s=t.ownerDocument.defaultView?t.ownerDocument.defaultView.getComputedStyle(t,null):t.currentStyle,n={};if(s&&s.length&&s[0]&&s[s[0]])for(i=s.length;i--;)"string"==typeof s[e=s[i]]&&(n[e.replace(/-([\da-z])/gi,function(t,e){return e.toUpperCase()})]=s[e]);else for(e in s)"string"==typeof s[e]&&(n[e]=s[e]);return n}function X(t,e,i,s){return t={effect:t=V.isPlainObject(t)?(e=t).effect:t},"function"==typeof(e=null==e?{}:e)&&(s=e,i=null,e={}),"number"!=typeof e&&!V.fx.speeds[e]||(s=i,i=e,e={}),"function"==typeof i&&(s=i,i=null),e&&V.extend(t,e),i=i||e.duration,t.duration=V.fx.off?0:"number"==typeof i?i:i in V.fx.speeds?V.fx.speeds[i]:V.fx.speeds._default,t.complete=s||e.complete,t}function $(t){return!t||"number"==typeof t||V.fx.speeds[t]||("string"==typeof t&&!V.effects.effect[t]||("function"==typeof t||"object"==typeof t&&!t.effect))}function G(t,e){var i=e.outerWidth(),e=e.outerHeight(),t=/^rect\((-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto)\)$/.exec(t)||["",0,i,e,0];return{top:parseFloat(t[1])||0,right:"auto"===t[2]?i:parseFloat(t[2]),bottom:"auto"===t[3]?e:parseFloat(t[3]),left:parseFloat(t[4])||0}}V.effects={effect:{}},N=["add","remove","toggle"],E={border:1,borderBottom:1,borderColor:1,borderLeft:1,borderRight:1,borderTop:1,borderWidth:1,margin:1,padding:1},V.each(["borderLeftStyle","borderRightStyle","borderBottomStyle","borderTopStyle"],function(t,e){V.fx.step[e]=function(t){("none"!==t.end&&!t.setAttr||1===t.pos&&!t.setAttr)&&(d.style(t.elem,e,t.end),t.setAttr=!0)}}),V.fn.addBack||(V.fn.addBack=function(t){return this.add(null==t?this.prevObject:this.prevObject.filter(t))}),V.effects.animateClass=function(n,t,e,i){var o=V.speed(t,e,i);return this.queue(function(){var i=V(this),t=i.attr("class")||"",e=(e=o.children?i.find("*").addBack():i).map(function(){return{el:V(this),start:U(this)}}),s=function(){V.each(N,function(t,e){n[e]&&i[e+"Class"](n[e])})};s(),e=e.map(function(){return this.end=U(this.el[0]),this.diff=function(t,e){var i,s,n={};for(i in e)s=e[i],t[i]!==s&&(E[i]||!V.fx.step[i]&&isNaN(parseFloat(s))||(n[i]=s));return n}(this.start,this.end),this}),i.attr("class",t),e=e.map(function(){var t=this,e=V.Deferred(),i=V.extend({},o,{queue:!1,complete:function(){e.resolve(t)}});return this.el.animate(this.diff,i),e.promise()}),V.when.apply(V,e.get()).done(function(){s(),V.each(arguments,function(){var e=this.el;V.each(this.diff,function(t){e.css(t,"")})}),o.complete.call(i[0])})})},V.fn.extend({addClass:(O=V.fn.addClass,function(t,e,i,s){return e?V.effects.animateClass.call(this,{add:t},e,i,s):O.apply(this,arguments)}),removeClass:(A=V.fn.removeClass,function(t,e,i,s){return 1<arguments.length?V.effects.animateClass.call(this,{remove:t},e,i,s):A.apply(this,arguments)}),toggleClass:(z=V.fn.toggleClass,function(t,e,i,s,n){return"boolean"==typeof e||void 0===e?i?V.effects.animateClass.call(this,e?{add:t}:{remove:t},i,s,n):z.apply(this,arguments):V.effects.animateClass.call(this,{toggle:t},e,i,s)}),switchClass:function(t,e,i,s,n){return V.effects.animateClass.call(this,{add:e,remove:t},i,s,n)}}),V.expr&&V.expr.pseudos&&V.expr.pseudos.animated&&(V.expr.pseudos.animated=(W=V.expr.pseudos.animated,function(t){return!!V(t).data(K)||W(t)})),!1!==V.uiBackCompat&&V.extend(V.effects,{save:function(t,e){for(var i=0,s=e.length;i<s;i++)null!==e[i]&&t.data(j+e[i],t[0].style[e[i]])},restore:function(t,e){for(var i,s=0,n=e.length;s<n;s++)null!==e[s]&&(i=t.data(j+e[s]),t.css(e[s],i))},setMode:function(t,e){return e="toggle"===e?t.is(":hidden")?"show":"hide":e},createWrapper:function(i){if(i.parent().is(".ui-effects-wrapper"))return i.parent();var s={width:i.outerWidth(!0),height:i.outerHeight(!0),float:i.css("float")},t=V("<div></div>").addClass("ui-effects-wrapper").css({fontSize:"100%",background:"transparent",border:"none",margin:0,padding:0}),e={width:i.width(),height:i.height()},n=document.activeElement;try{n.id}catch(t){n=document.body}return i.wrap(t),i[0]!==n&&!V.contains(i[0],n)||V(n).trigger("focus"),t=i.parent(),"static"===i.css("position")?(t.css({position:"relative"}),i.css({position:"relative"})):(V.extend(s,{position:i.css("position"),zIndex:i.css("z-index")}),V.each(["top","left","bottom","right"],function(t,e){s[e]=i.css(e),isNaN(parseInt(s[e],10))&&(s[e]="auto")}),i.css({position:"relative",top:0,left:0,right:"auto",bottom:"auto"})),i.css(e),t.css(s).show()},removeWrapper:function(t){var e=document.activeElement;return t.parent().is(".ui-effects-wrapper")&&(t.parent().replaceWith(t),t[0]!==e&&!V.contains(t[0],e)||V(e).trigger("focus")),t}}),V.extend(V.effects,{version:"1.13.2",define:function(t,e,i){return i||(i=e,e="effect"),V.effects.effect[t]=i,V.effects.effect[t].mode=e,i},scaledDimensions:function(t,e,i){if(0===e)return{height:0,width:0,outerHeight:0,outerWidth:0};var s="horizontal"!==i?(e||100)/100:1,e="vertical"!==i?(e||100)/100:1;return{height:t.height()*e,width:t.width()*s,outerHeight:t.outerHeight()*e,outerWidth:t.outerWidth()*s}},clipToBox:function(t){return{width:t.clip.right-t.clip.left,height:t.clip.bottom-t.clip.top,left:t.clip.left,top:t.clip.top}},unshift:function(t,e,i){var s=t.queue();1<e&&s.splice.apply(s,[1,0].concat(s.splice(e,i))),t.dequeue()},saveStyle:function(t){t.data(q,t[0].style.cssText)},restoreStyle:function(t){t[0].style.cssText=t.data(q)||"",t.removeData(q)},mode:function(t,e){t=t.is(":hidden");return"toggle"===e&&(e=t?"show":"hide"),e=(t?"hide"===e:"show"===e)?"none":e},getBaseline:function(t,e){var i,s;switch(t[0]){case"top":i=0;break;case"middle":i=.5;break;case"bottom":i=1;break;default:i=t[0]/e.height}switch(t[1]){case"left":s=0;break;case"center":s=.5;break;case"right":s=1;break;default:s=t[1]/e.width}return{x:s,y:i}},createPlaceholder:function(t){var e,i=t.css("position"),s=t.position();return t.css({marginTop:t.css("marginTop"),marginBottom:t.css("marginBottom"),marginLeft:t.css("marginLeft"),marginRight:t.css("marginRight")}).outerWidth(t.outerWidth()).outerHeight(t.outerHeight()),/^(static|relative)/.test(i)&&(i="absolute",e=V("<"+t[0].nodeName+">").insertAfter(t).css({display:/^(inline|ruby)/.test(t.css("display"))?"inline-block":"block",visibility:"hidden",marginTop:t.css("marginTop"),marginBottom:t.css("marginBottom"),marginLeft:t.css("marginLeft"),marginRight:t.css("marginRight"),float:t.css("float")}).outerWidth(t.outerWidth()).outerHeight(t.outerHeight()).addClass("ui-effects-placeholder"),t.data(j+"placeholder",e)),t.css({position:i,left:s.left,top:s.top}),e},removePlaceholder:function(t){var e=j+"placeholder",i=t.data(e);i&&(i.remove(),t.removeData(e))},cleanUp:function(t){V.effects.restoreStyle(t),V.effects.removePlaceholder(t)},setTransition:function(s,t,n,o){return o=o||{},V.each(t,function(t,e){var i=s.cssUnit(e);0<i[0]&&(o[e]=i[0]*n+i[1])}),o}}),V.fn.extend({effect:function(){function t(t){var e=V(this),i=V.effects.mode(e,r)||o;e.data(K,!0),l.push(i),o&&("show"===i||i===o&&"hide"===i)&&e.show(),o&&"none"===i||V.effects.saveStyle(e),"function"==typeof t&&t()}var s=X.apply(this,arguments),n=V.effects.effect[s.effect],o=n.mode,e=s.queue,i=e||"fx",a=s.complete,r=s.mode,l=[];return V.fx.off||!n?r?this[r](s.duration,a):this.each(function(){a&&a.call(this)}):!1===e?this.each(t).each(h):this.queue(i,t).queue(i,h);function h(t){var e=V(this);function i(){"function"==typeof a&&a.call(e[0]),"function"==typeof t&&t()}s.mode=l.shift(),!1===V.uiBackCompat||o?"none"===s.mode?(e[r](),i()):n.call(e[0],s,function(){e.removeData(K),V.effects.cleanUp(e),"hide"===s.mode&&e.hide(),i()}):(e.is(":hidden")?"hide"===r:"show"===r)?(e[r](),i()):n.call(e[0],s,i)}},show:(R=V.fn.show,function(t){if($(t))return R.apply(this,arguments);t=X.apply(this,arguments);return t.mode="show",this.effect.call(this,t)}),hide:(L=V.fn.hide,function(t){if($(t))return L.apply(this,arguments);t=X.apply(this,arguments);return t.mode="hide",this.effect.call(this,t)}),toggle:(F=V.fn.toggle,function(t){if($(t)||"boolean"==typeof t)return F.apply(this,arguments);t=X.apply(this,arguments);return t.mode="toggle",this.effect.call(this,t)}),cssUnit:function(t){var i=this.css(t),s=[];return V.each(["em","px","%","pt"],function(t,e){0<i.indexOf(e)&&(s=[parseFloat(i),e])}),s},cssClip:function(t){return t?this.css("clip","rect("+t.top+"px "+t.right+"px "+t.bottom+"px "+t.left+"px)"):G(this.css("clip"),this)},transfer:function(t,e){var i=V(this),s=V(t.to),n="fixed"===s.css("position"),o=V("body"),a=n?o.scrollTop():0,r=n?o.scrollLeft():0,o=s.offset(),o={top:o.top-a,left:o.left-r,height:s.innerHeight(),width:s.innerWidth()},s=i.offset(),l=V("<div class='ui-effects-transfer'></div>");l.appendTo("body").addClass(t.className).css({top:s.top-a,left:s.left-r,height:i.innerHeight(),width:i.innerWidth(),position:n?"fixed":"absolute"}).animate(o,t.duration,t.easing,function(){l.remove(),"function"==typeof e&&e()})}}),V.fx.step.clip=function(t){t.clipInit||(t.start=V(t.elem).cssClip(),"string"==typeof t.end&&(t.end=G(t.end,t.elem)),t.clipInit=!0),V(t.elem).cssClip({top:t.pos*(t.end.top-t.start.top)+t.start.top,right:t.pos*(t.end.right-t.start.right)+t.start.right,bottom:t.pos*(t.end.bottom-t.start.bottom)+t.start.bottom,left:t.pos*(t.end.left-t.start.left)+t.start.left})},Y={},V.each(["Quad","Cubic","Quart","Quint","Expo"],function(e,t){Y[t]=function(t){return Math.pow(t,e+2)}}),V.extend(Y,{Sine:function(t){return 1-Math.cos(t*Math.PI/2)},Circ:function(t){return 1-Math.sqrt(1-t*t)},Elastic:function(t){return 0===t||1===t?t:-Math.pow(2,8*(t-1))*Math.sin((80*(t-1)-7.5)*Math.PI/15)},Back:function(t){return t*t*(3*t-2)},Bounce:function(t){for(var e,i=4;t<((e=Math.pow(2,--i))-1)/11;);return 1/Math.pow(4,3-i)-7.5625*Math.pow((3*e-2)/22-t,2)}}),V.each(Y,function(t,e){V.easing["easeIn"+t]=e,V.easing["easeOut"+t]=function(t){return 1-e(1-t)},V.easing["easeInOut"+t]=function(t){return t<.5?e(2*t)/2:1-e(-2*t+2)/2}});y=V.effects,V.effects.define("blind","hide",function(t,e){var i={up:["bottom","top"],vertical:["bottom","top"],down:["top","bottom"],left:["right","left"],horizontal:["right","left"],right:["left","right"]},s=V(this),n=t.direction||"up",o=s.cssClip(),a={clip:V.extend({},o)},r=V.effects.createPlaceholder(s);a.clip[i[n][0]]=a.clip[i[n][1]],"show"===t.mode&&(s.cssClip(a.clip),r&&r.css(V.effects.clipToBox(a)),a.clip=o),r&&r.animate(V.effects.clipToBox(a),t.duration,t.easing),s.animate(a,{queue:!1,duration:t.duration,easing:t.easing,complete:e})}),V.effects.define("bounce",function(t,e){var i,s,n=V(this),o=t.mode,a="hide"===o,r="show"===o,l=t.direction||"up",h=t.distance,c=t.times||5,o=2*c+(r||a?1:0),u=t.duration/o,d=t.easing,p="up"===l||"down"===l?"top":"left",f="up"===l||"left"===l,g=0,t=n.queue().length;for(V.effects.createPlaceholder(n),l=n.css(p),h=h||n["top"==p?"outerHeight":"outerWidth"]()/3,r&&((s={opacity:1})[p]=l,n.css("opacity",0).css(p,f?2*-h:2*h).animate(s,u,d)),a&&(h/=Math.pow(2,c-1)),(s={})[p]=l;g<c;g++)(i={})[p]=(f?"-=":"+=")+h,n.animate(i,u,d).animate(s,u,d),h=a?2*h:h/2;a&&((i={opacity:0})[p]=(f?"-=":"+=")+h,n.animate(i,u,d)),n.queue(e),V.effects.unshift(n,t,1+o)}),V.effects.define("clip","hide",function(t,e){var i={},s=V(this),n=t.direction||"vertical",o="both"===n,a=o||"horizontal"===n,o=o||"vertical"===n,n=s.cssClip();i.clip={top:o?(n.bottom-n.top)/2:n.top,right:a?(n.right-n.left)/2:n.right,bottom:o?(n.bottom-n.top)/2:n.bottom,left:a?(n.right-n.left)/2:n.left},V.effects.createPlaceholder(s),"show"===t.mode&&(s.cssClip(i.clip),i.clip=n),s.animate(i,{queue:!1,duration:t.duration,easing:t.easing,complete:e})}),V.effects.define("drop","hide",function(t,e){var i=V(this),s="show"===t.mode,n=t.direction||"left",o="up"===n||"down"===n?"top":"left",a="up"===n||"left"===n?"-=":"+=",r="+="==a?"-=":"+=",l={opacity:0};V.effects.createPlaceholder(i),n=t.distance||i["top"==o?"outerHeight":"outerWidth"](!0)/2,l[o]=a+n,s&&(i.css(l),l[o]=r+n,l.opacity=1),i.animate(l,{queue:!1,duration:t.duration,easing:t.easing,complete:e})}),V.effects.define("explode","hide",function(t,e){var i,s,n,o,a,r,l=t.pieces?Math.round(Math.sqrt(t.pieces)):3,h=l,c=V(this),u="show"===t.mode,d=c.show().css("visibility","hidden").offset(),p=Math.ceil(c.outerWidth()/h),f=Math.ceil(c.outerHeight()/l),g=[];function m(){g.push(this),g.length===l*h&&(c.css({visibility:"visible"}),V(g).remove(),e())}for(i=0;i<l;i++)for(o=d.top+i*f,r=i-(l-1)/2,s=0;s<h;s++)n=d.left+s*p,a=s-(h-1)/2,c.clone().appendTo("body").wrap("<div></div>").css({position:"absolute",visibility:"visible",left:-s*p,top:-i*f}).parent().addClass("ui-effects-explode").css({position:"absolute",overflow:"hidden",width:p,height:f,left:n+(u?a*p:0),top:o+(u?r*f:0),opacity:u?0:1}).animate({left:n+(u?0:a*p),top:o+(u?0:r*f),opacity:u?1:0},t.duration||500,t.easing,m)}),V.effects.define("fade","toggle",function(t,e){var i="show"===t.mode;V(this).css("opacity",i?0:1).animate({opacity:i?1:0},{queue:!1,duration:t.duration,easing:t.easing,complete:e})}),V.effects.define("fold","hide",function(e,t){var i=V(this),s=e.mode,n="show"===s,o="hide"===s,a=e.size||15,r=/([0-9]+)%/.exec(a),l=!!e.horizFirst?["right","bottom"]:["bottom","right"],h=e.duration/2,c=V.effects.createPlaceholder(i),u=i.cssClip(),d={clip:V.extend({},u)},p={clip:V.extend({},u)},f=[u[l[0]],u[l[1]]],s=i.queue().length;r&&(a=parseInt(r[1],10)/100*f[o?0:1]),d.clip[l[0]]=a,p.clip[l[0]]=a,p.clip[l[1]]=0,n&&(i.cssClip(p.clip),c&&c.css(V.effects.clipToBox(p)),p.clip=u),i.queue(function(t){c&&c.animate(V.effects.clipToBox(d),h,e.easing).animate(V.effects.clipToBox(p),h,e.easing),t()}).animate(d,h,e.easing).animate(p,h,e.easing).queue(t),V.effects.unshift(i,s,4)}),V.effects.define("highlight","show",function(t,e){var i=V(this),s={backgroundColor:i.css("backgroundColor")};"hide"===t.mode&&(s.opacity=0),V.effects.saveStyle(i),i.css({backgroundImage:"none",backgroundColor:t.color||"#ffff99"}).animate(s,{queue:!1,duration:t.duration,easing:t.easing,complete:e})}),V.effects.define("size",function(s,e){var n,i=V(this),t=["fontSize"],o=["borderTopWidth","borderBottomWidth","paddingTop","paddingBottom"],a=["borderLeftWidth","borderRightWidth","paddingLeft","paddingRight"],r=s.mode,l="effect"!==r,h=s.scale||"both",c=s.origin||["middle","center"],u=i.css("position"),d=i.position(),p=V.effects.scaledDimensions(i),f=s.from||p,g=s.to||V.effects.scaledDimensions(i,0);V.effects.createPlaceholder(i),"show"===r&&(r=f,f=g,g=r),n={from:{y:f.height/p.height,x:f.width/p.width},to:{y:g.height/p.height,x:g.width/p.width}},"box"!==h&&"both"!==h||(n.from.y!==n.to.y&&(f=V.effects.setTransition(i,o,n.from.y,f),g=V.effects.setTransition(i,o,n.to.y,g)),n.from.x!==n.to.x&&(f=V.effects.setTransition(i,a,n.from.x,f),g=V.effects.setTransition(i,a,n.to.x,g))),"content"!==h&&"both"!==h||n.from.y!==n.to.y&&(f=V.effects.setTransition(i,t,n.from.y,f),g=V.effects.setTransition(i,t,n.to.y,g)),c&&(c=V.effects.getBaseline(c,p),f.top=(p.outerHeight-f.outerHeight)*c.y+d.top,f.left=(p.outerWidth-f.outerWidth)*c.x+d.left,g.top=(p.outerHeight-g.outerHeight)*c.y+d.top,g.left=(p.outerWidth-g.outerWidth)*c.x+d.left),delete f.outerHeight,delete f.outerWidth,i.css(f),"content"!==h&&"both"!==h||(o=o.concat(["marginTop","marginBottom"]).concat(t),a=a.concat(["marginLeft","marginRight"]),i.find("*[width]").each(function(){var t=V(this),e=V.effects.scaledDimensions(t),i={height:e.height*n.from.y,width:e.width*n.from.x,outerHeight:e.outerHeight*n.from.y,outerWidth:e.outerWidth*n.from.x},e={height:e.height*n.to.y,width:e.width*n.to.x,outerHeight:e.height*n.to.y,outerWidth:e.width*n.to.x};n.from.y!==n.to.y&&(i=V.effects.setTransition(t,o,n.from.y,i),e=V.effects.setTransition(t,o,n.to.y,e)),n.from.x!==n.to.x&&(i=V.effects.setTransition(t,a,n.from.x,i),e=V.effects.setTransition(t,a,n.to.x,e)),l&&V.effects.saveStyle(t),t.css(i),t.animate(e,s.duration,s.easing,function(){l&&V.effects.restoreStyle(t)})})),i.animate(g,{queue:!1,duration:s.duration,easing:s.easing,complete:function(){var t=i.offset();0===g.opacity&&i.css("opacity",f.opacity),l||(i.css("position","static"===u?"relative":u).offset(t),V.effects.saveStyle(i)),e()}})}),V.effects.define("scale",function(t,e){var i=V(this),s=t.mode,s=parseInt(t.percent,10)||(0===parseInt(t.percent,10)||"effect"!==s?0:100),s=V.extend(!0,{from:V.effects.scaledDimensions(i),to:V.effects.scaledDimensions(i,s,t.direction||"both"),origin:t.origin||["middle","center"]},t);t.fade&&(s.from.opacity=1,s.to.opacity=0),V.effects.effect.size.call(this,s,e)}),V.effects.define("puff","hide",function(t,e){t=V.extend(!0,{},t,{fade:!0,percent:parseInt(t.percent,10)||150});V.effects.effect.scale.call(this,t,e)}),V.effects.define("pulsate","show",function(t,e){var i=V(this),s=t.mode,n="show"===s,o=2*(t.times||5)+(n||"hide"===s?1:0),a=t.duration/o,r=0,l=1,s=i.queue().length;for(!n&&i.is(":visible")||(i.css("opacity",0).show(),r=1);l<o;l++)i.animate({opacity:r},a,t.easing),r=1-r;i.animate({opacity:r},a,t.easing),i.queue(e),V.effects.unshift(i,s,1+o)}),V.effects.define("shake",function(t,e){var i=1,s=V(this),n=t.direction||"left",o=t.distance||20,a=t.times||3,r=2*a+1,l=Math.round(t.duration/r),h="up"===n||"down"===n?"top":"left",c="up"===n||"left"===n,u={},d={},p={},n=s.queue().length;for(V.effects.createPlaceholder(s),u[h]=(c?"-=":"+=")+o,d[h]=(c?"+=":"-=")+2*o,p[h]=(c?"-=":"+=")+2*o,s.animate(u,l,t.easing);i<a;i++)s.animate(d,l,t.easing).animate(p,l,t.easing);s.animate(d,l,t.easing).animate(u,l/2,t.easing).queue(e),V.effects.unshift(s,n,1+r)}),V.effects.define("slide","show",function(t,e){var i,s,n=V(this),o={up:["bottom","top"],down:["top","bottom"],left:["right","left"],right:["left","right"]},a=t.mode,r=t.direction||"left",l="up"===r||"down"===r?"top":"left",h="up"===r||"left"===r,c=t.distance||n["top"==l?"outerHeight":"outerWidth"](!0),u={};V.effects.createPlaceholder(n),i=n.cssClip(),s=n.position()[l],u[l]=(h?-1:1)*c+s,u.clip=n.cssClip(),u.clip[o[r][1]]=u.clip[o[r][0]],"show"===a&&(n.cssClip(u.clip),n.css(l,u[l]),u.clip=i,u[l]=s),n.animate(u,{queue:!1,duration:t.duration,easing:t.easing,complete:e})}),y=!1!==V.uiBackCompat?V.effects.define("transfer",function(t,e){V(this).transfer(t,e)}):y;V.ui.focusable=function(t,e){var i,s,n,o,a=t.nodeName.toLowerCase();return"area"===a?(s=(i=t.parentNode).name,!(!t.href||!s||"map"!==i.nodeName.toLowerCase())&&(0<(s=V("img[usemap='#"+s+"']")).length&&s.is(":visible"))):(/^(input|select|textarea|button|object)$/.test(a)?(n=!t.disabled)&&(o=V(t).closest("fieldset")[0])&&(n=!o.disabled):n="a"===a&&t.href||e,n&&V(t).is(":visible")&&function(t){var e=t.css("visibility");for(;"inherit"===e;)t=t.parent(),e=t.css("visibility");return"visible"===e}(V(t)))},V.extend(V.expr.pseudos,{focusable:function(t){return V.ui.focusable(t,null!=V.attr(t,"tabindex"))}});var Q,J;V.ui.focusable,V.fn._form=function(){return"string"==typeof this[0].form?this.closest("form"):V(this[0].form)},V.ui.formResetMixin={_formResetHandler:function(){var e=V(this);setTimeout(function(){var t=e.data("ui-form-reset-instances");V.each(t,function(){this.refresh()})})},_bindFormResetHandler:function(){var t;this.form=this.element._form(),this.form.length&&((t=this.form.data("ui-form-reset-instances")||[]).length||this.form.on("reset.ui-form-reset",this._formResetHandler),t.push(this),this.form.data("ui-form-reset-instances",t))},_unbindFormResetHandler:function(){var t;this.form.length&&((t=this.form.data("ui-form-reset-instances")).splice(V.inArray(this,t),1),t.length?this.form.data("ui-form-reset-instances",t):this.form.removeData("ui-form-reset-instances").off("reset.ui-form-reset"))}};V.expr.pseudos||(V.expr.pseudos=V.expr[":"]),V.uniqueSort||(V.uniqueSort=V.unique),V.escapeSelector||(Q=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g,J=function(t,e){return e?"\0"===t?"":t.slice(0,-1)+"\\"+t.charCodeAt(t.length-1).toString(16)+" ":"\\"+t},V.escapeSelector=function(t){return(t+"").replace(Q,J)}),V.fn.even&&V.fn.odd||V.fn.extend({even:function(){return this.filter(function(t){return t%2==0})},odd:function(){return this.filter(function(t){return t%2==1})}});var Z;V.ui.keyCode={BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38},V.fn.labels=function(){var t,e,i;return this.length?this[0].labels&&this[0].labels.length?this.pushStack(this[0].labels):(e=this.eq(0).parents("label"),(t=this.attr("id"))&&(i=(i=this.eq(0).parents().last()).add((i.length?i:this).siblings()),t="label[for='"+V.escapeSelector(t)+"']",e=e.add(i.find(t).addBack(t))),this.pushStack(e)):this.pushStack([])},V.fn.scrollParent=function(t){var e=this.css("position"),i="absolute"===e,s=t?/(auto|scroll|hidden)/:/(auto|scroll)/,t=this.parents().filter(function(){var t=V(this);return(!i||"static"!==t.css("position"))&&s.test(t.css("overflow")+t.css("overflow-y")+t.css("overflow-x"))}).eq(0);return"fixed"!==e&&t.length?t:V(this[0].ownerDocument||document)},V.extend(V.expr.pseudos,{tabbable:function(t){var e=V.attr(t,"tabindex"),i=null!=e;return(!i||0<=e)&&V.ui.focusable(t,i)}}),V.fn.extend({uniqueId:(Z=0,function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++Z)})}),removeUniqueId:function(){return this.each(function(){/^ui-id-\d+$/.test(this.id)&&V(this).removeAttr("id")})}}),V.widget("ui.accordion",{version:"1.13.2",options:{active:0,animate:{},classes:{"ui-accordion-header":"ui-corner-top","ui-accordion-header-collapsed":"ui-corner-all","ui-accordion-content":"ui-corner-bottom"},collapsible:!1,event:"click",header:function(t){return t.find("> li > :first-child").add(t.find("> :not(li)").even())},heightStyle:"auto",icons:{activeHeader:"ui-icon-triangle-1-s",header:"ui-icon-triangle-1-e"},activate:null,beforeActivate:null},hideProps:{borderTopWidth:"hide",borderBottomWidth:"hide",paddingTop:"hide",paddingBottom:"hide",height:"hide"},showProps:{borderTopWidth:"show",borderBottomWidth:"show",paddingTop:"show",paddingBottom:"show",height:"show"},_create:function(){var t=this.options;this.prevShow=this.prevHide=V(),this._addClass("ui-accordion","ui-widget ui-helper-reset"),this.element.attr("role","tablist"),t.collapsible||!1!==t.active&&null!=t.active||(t.active=0),this._processPanels(),t.active<0&&(t.active+=this.headers.length),this._refresh()},_getCreateEventData:function(){return{header:this.active,panel:this.active.length?this.active.next():V()}},_createIcons:function(){var t,e=this.options.icons;e&&(t=V("<span>"),this._addClass(t,"ui-accordion-header-icon","ui-icon "+e.header),t.prependTo(this.headers),t=this.active.children(".ui-accordion-header-icon"),this._removeClass(t,e.header)._addClass(t,null,e.activeHeader)._addClass(this.headers,"ui-accordion-icons"))},_destroyIcons:function(){this._removeClass(this.headers,"ui-accordion-icons"),this.headers.children(".ui-accordion-header-icon").remove()},_destroy:function(){var t;this.element.removeAttr("role"),this.headers.removeAttr("role aria-expanded aria-selected aria-controls tabIndex").removeUniqueId(),this._destroyIcons(),t=this.headers.next().css("display","").removeAttr("role aria-hidden aria-labelledby").removeUniqueId(),"content"!==this.options.heightStyle&&t.css("height","")},_setOption:function(t,e){"active"!==t?("event"===t&&(this.options.event&&this._off(this.headers,this.options.event),this._setupEvents(e)),this._super(t,e),"collapsible"!==t||e||!1!==this.options.active||this._activate(0),"icons"===t&&(this._destroyIcons(),e&&this._createIcons())):this._activate(e)},_setOptionDisabled:function(t){this._super(t),this.element.attr("aria-disabled",t),this._toggleClass(null,"ui-state-disabled",!!t),this._toggleClass(this.headers.add(this.headers.next()),null,"ui-state-disabled",!!t)},_keydown:function(t){if(!t.altKey&&!t.ctrlKey){var e=V.ui.keyCode,i=this.headers.length,s=this.headers.index(t.target),n=!1;switch(t.keyCode){case e.RIGHT:case e.DOWN:n=this.headers[(s+1)%i];break;case e.LEFT:case e.UP:n=this.headers[(s-1+i)%i];break;case e.SPACE:case e.ENTER:this._eventHandler(t);break;case e.HOME:n=this.headers[0];break;case e.END:n=this.headers[i-1]}n&&(V(t.target).attr("tabIndex",-1),V(n).attr("tabIndex",0),V(n).trigger("focus"),t.preventDefault())}},_panelKeyDown:function(t){t.keyCode===V.ui.keyCode.UP&&t.ctrlKey&&V(t.currentTarget).prev().trigger("focus")},refresh:function(){var t=this.options;this._processPanels(),!1===t.active&&!0===t.collapsible||!this.headers.length?(t.active=!1,this.active=V()):!1===t.active?this._activate(0):this.active.length&&!V.contains(this.element[0],this.active[0])?this.headers.length===this.headers.find(".ui-state-disabled").length?(t.active=!1,this.active=V()):this._activate(Math.max(0,t.active-1)):t.active=this.headers.index(this.active),this._destroyIcons(),this._refresh()},_processPanels:function(){var t=this.headers,e=this.panels;"function"==typeof this.options.header?this.headers=this.options.header(this.element):this.headers=this.element.find(this.options.header),this._addClass(this.headers,"ui-accordion-header ui-accordion-header-collapsed","ui-state-default"),this.panels=this.headers.next().filter(":not(.ui-accordion-content-active)").hide(),this._addClass(this.panels,"ui-accordion-content","ui-helper-reset ui-widget-content"),e&&(this._off(t.not(this.headers)),this._off(e.not(this.panels)))},_refresh:function(){var i,t=this.options,e=t.heightStyle,s=this.element.parent();this.active=this._findActive(t.active),this._addClass(this.active,"ui-accordion-header-active","ui-state-active")._removeClass(this.active,"ui-accordion-header-collapsed"),this._addClass(this.active.next(),"ui-accordion-content-active"),this.active.next().show(),this.headers.attr("role","tab").each(function(){var t=V(this),e=t.uniqueId().attr("id"),i=t.next(),s=i.uniqueId().attr("id");t.attr("aria-controls",s),i.attr("aria-labelledby",e)}).next().attr("role","tabpanel"),this.headers.not(this.active).attr({"aria-selected":"false","aria-expanded":"false",tabIndex:-1}).next().attr({"aria-hidden":"true"}).hide(),this.active.length?this.active.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0}).next().attr({"aria-hidden":"false"}):this.headers.eq(0).attr("tabIndex",0),this._createIcons(),this._setupEvents(t.event),"fill"===e?(i=s.height(),this.element.siblings(":visible").each(function(){var t=V(this),e=t.css("position");"absolute"!==e&&"fixed"!==e&&(i-=t.outerHeight(!0))}),this.headers.each(function(){i-=V(this).outerHeight(!0)}),this.headers.next().each(function(){V(this).height(Math.max(0,i-V(this).innerHeight()+V(this).height()))}).css("overflow","auto")):"auto"===e&&(i=0,this.headers.next().each(function(){var t=V(this).is(":visible");t||V(this).show(),i=Math.max(i,V(this).css("height","").height()),t||V(this).hide()}).height(i))},_activate:function(t){t=this._findActive(t)[0];t!==this.active[0]&&(t=t||this.active[0],this._eventHandler({target:t,currentTarget:t,preventDefault:V.noop}))},_findActive:function(t){return"number"==typeof t?this.headers.eq(t):V()},_setupEvents:function(t){var i={keydown:"_keydown"};t&&V.each(t.split(" "),function(t,e){i[e]="_eventHandler"}),this._off(this.headers.add(this.headers.next())),this._on(this.headers,i),this._on(this.headers.next(),{keydown:"_panelKeyDown"}),this._hoverable(this.headers),this._focusable(this.headers)},_eventHandler:function(t){var e=this.options,i=this.active,s=V(t.currentTarget),n=s[0]===i[0],o=n&&e.collapsible,a=o?V():s.next(),r=i.next(),a={oldHeader:i,oldPanel:r,newHeader:o?V():s,newPanel:a};t.preventDefault(),n&&!e.collapsible||!1===this._trigger("beforeActivate",t,a)||(e.active=!o&&this.headers.index(s),this.active=n?V():s,this._toggle(a),this._removeClass(i,"ui-accordion-header-active","ui-state-active"),e.icons&&(i=i.children(".ui-accordion-header-icon"),this._removeClass(i,null,e.icons.activeHeader)._addClass(i,null,e.icons.header)),n||(this._removeClass(s,"ui-accordion-header-collapsed")._addClass(s,"ui-accordion-header-active","ui-state-active"),e.icons&&(n=s.children(".ui-accordion-header-icon"),this._removeClass(n,null,e.icons.header)._addClass(n,null,e.icons.activeHeader)),this._addClass(s.next(),"ui-accordion-content-active")))},_toggle:function(t){var e=t.newPanel,i=this.prevShow.length?this.prevShow:t.oldPanel;this.prevShow.add(this.prevHide).stop(!0,!0),this.prevShow=e,this.prevHide=i,this.options.animate?this._animate(e,i,t):(i.hide(),e.show(),this._toggleComplete(t)),i.attr({"aria-hidden":"true"}),i.prev().attr({"aria-selected":"false","aria-expanded":"false"}),e.length&&i.length?i.prev().attr({tabIndex:-1,"aria-expanded":"false"}):e.length&&this.headers.filter(function(){return 0===parseInt(V(this).attr("tabIndex"),10)}).attr("tabIndex",-1),e.attr("aria-hidden","false").prev().attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0})},_animate:function(t,i,e){var s,n,o,a=this,r=0,l=t.css("box-sizing"),h=t.length&&(!i.length||t.index()<i.index()),c=this.options.animate||{},u=h&&c.down||c,h=function(){a._toggleComplete(e)};return n=(n="string"==typeof u?u:n)||u.easing||c.easing,o=(o="number"==typeof u?u:o)||u.duration||c.duration,i.length?t.length?(s=t.show().outerHeight(),i.animate(this.hideProps,{duration:o,easing:n,step:function(t,e){e.now=Math.round(t)}}),void t.hide().animate(this.showProps,{duration:o,easing:n,complete:h,step:function(t,e){e.now=Math.round(t),"height"!==e.prop?"content-box"===l&&(r+=e.now):"content"!==a.options.heightStyle&&(e.now=Math.round(s-i.outerHeight()-r),r=0)}})):i.animate(this.hideProps,o,n,h):t.animate(this.showProps,o,n,h)},_toggleComplete:function(t){var e=t.oldPanel,i=e.prev();this._removeClass(e,"ui-accordion-content-active"),this._removeClass(i,"ui-accordion-header-active")._addClass(i,"ui-accordion-header-collapsed"),e.length&&(e.parent()[0].className=e.parent()[0].className),this._trigger("activate",null,t)}}),V.ui.safeActiveElement=function(e){var i;try{i=e.activeElement}catch(t){i=e.body}return i=!(i=i||e.body).nodeName?e.body:i},V.widget("ui.menu",{version:"1.13.2",defaultElement:"<ul>",delay:300,options:{icons:{submenu:"ui-icon-caret-1-e"},items:"> *",menus:"ul",position:{my:"left top",at:"right top"},role:"menu",blur:null,focus:null,select:null},_create:function(){this.activeMenu=this.element,this.mouseHandled=!1,this.lastMousePosition={x:null,y:null},this.element.uniqueId().attr({role:this.options.role,tabIndex:0}),this._addClass("ui-menu","ui-widget ui-widget-content"),this._on({"mousedown .ui-menu-item":function(t){t.preventDefault(),this._activateItem(t)},"click .ui-menu-item":function(t){var e=V(t.target),i=V(V.ui.safeActiveElement(this.document[0]));!this.mouseHandled&&e.not(".ui-state-disabled").length&&(this.select(t),t.isPropagationStopped()||(this.mouseHandled=!0),e.has(".ui-menu").length?this.expand(t):!this.element.is(":focus")&&i.closest(".ui-menu").length&&(this.element.trigger("focus",[!0]),this.active&&1===this.active.parents(".ui-menu").length&&clearTimeout(this.timer)))},"mouseenter .ui-menu-item":"_activateItem","mousemove .ui-menu-item":"_activateItem",mouseleave:"collapseAll","mouseleave .ui-menu":"collapseAll",focus:function(t,e){var i=this.active||this._menuItems().first();e||this.focus(t,i)},blur:function(t){this._delay(function(){V.contains(this.element[0],V.ui.safeActiveElement(this.document[0]))||this.collapseAll(t)})},keydown:"_keydown"}),this.refresh(),this._on(this.document,{click:function(t){this._closeOnDocumentClick(t)&&this.collapseAll(t,!0),this.mouseHandled=!1}})},_activateItem:function(t){var e,i;this.previousFilter||t.clientX===this.lastMousePosition.x&&t.clientY===this.lastMousePosition.y||(this.lastMousePosition={x:t.clientX,y:t.clientY},e=V(t.target).closest(".ui-menu-item"),i=V(t.currentTarget),e[0]===i[0]&&(i.is(".ui-state-active")||(this._removeClass(i.siblings().children(".ui-state-active"),null,"ui-state-active"),this.focus(t,i))))},_destroy:function(){var t=this.element.find(".ui-menu-item").removeAttr("role aria-disabled").children(".ui-menu-item-wrapper").removeUniqueId().removeAttr("tabIndex role aria-haspopup");this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeAttr("role aria-labelledby aria-expanded aria-hidden aria-disabled tabIndex").removeUniqueId().show(),t.children().each(function(){var t=V(this);t.data("ui-menu-submenu-caret")&&t.remove()})},_keydown:function(t){var e,i,s,n=!0;switch(t.keyCode){case V.ui.keyCode.PAGE_UP:this.previousPage(t);break;case V.ui.keyCode.PAGE_DOWN:this.nextPage(t);break;case V.ui.keyCode.HOME:this._move("first","first",t);break;case V.ui.keyCode.END:this._move("last","last",t);break;case V.ui.keyCode.UP:this.previous(t);break;case V.ui.keyCode.DOWN:this.next(t);break;case V.ui.keyCode.LEFT:this.collapse(t);break;case V.ui.keyCode.RIGHT:this.active&&!this.active.is(".ui-state-disabled")&&this.expand(t);break;case V.ui.keyCode.ENTER:case V.ui.keyCode.SPACE:this._activate(t);break;case V.ui.keyCode.ESCAPE:this.collapse(t);break;default:e=this.previousFilter||"",s=n=!1,i=96<=t.keyCode&&t.keyCode<=105?(t.keyCode-96).toString():String.fromCharCode(t.keyCode),clearTimeout(this.filterTimer),i===e?s=!0:i=e+i,e=this._filterMenuItems(i),(e=s&&-1!==e.index(this.active.next())?this.active.nextAll(".ui-menu-item"):e).length||(i=String.fromCharCode(t.keyCode),e=this._filterMenuItems(i)),e.length?(this.focus(t,e),this.previousFilter=i,this.filterTimer=this._delay(function(){delete this.previousFilter},1e3)):delete this.previousFilter}n&&t.preventDefault()},_activate:function(t){this.active&&!this.active.is(".ui-state-disabled")&&(this.active.children("[aria-haspopup='true']").length?this.expand(t):this.select(t))},refresh:function(){var t,e,s=this,n=this.options.icons.submenu,i=this.element.find(this.options.menus);this._toggleClass("ui-menu-icons",null,!!this.element.find(".ui-icon").length),e=i.filter(":not(.ui-menu)").hide().attr({role:this.options.role,"aria-hidden":"true","aria-expanded":"false"}).each(function(){var t=V(this),e=t.prev(),i=V("<span>").data("ui-menu-submenu-caret",!0);s._addClass(i,"ui-menu-icon","ui-icon "+n),e.attr("aria-haspopup","true").prepend(i),t.attr("aria-labelledby",e.attr("id"))}),this._addClass(e,"ui-menu","ui-widget ui-widget-content ui-front"),(t=i.add(this.element).find(this.options.items)).not(".ui-menu-item").each(function(){var t=V(this);s._isDivider(t)&&s._addClass(t,"ui-menu-divider","ui-widget-content")}),i=(e=t.not(".ui-menu-item, .ui-menu-divider")).children().not(".ui-menu").uniqueId().attr({tabIndex:-1,role:this._itemRole()}),this._addClass(e,"ui-menu-item")._addClass(i,"ui-menu-item-wrapper"),t.filter(".ui-state-disabled").attr("aria-disabled","true"),this.active&&!V.contains(this.element[0],this.active[0])&&this.blur()},_itemRole:function(){return{menu:"menuitem",listbox:"option"}[this.options.role]},_setOption:function(t,e){var i;"icons"===t&&(i=this.element.find(".ui-menu-icon"),this._removeClass(i,null,this.options.icons.submenu)._addClass(i,null,e.submenu)),this._super(t,e)},_setOptionDisabled:function(t){this._super(t),this.element.attr("aria-disabled",String(t)),this._toggleClass(null,"ui-state-disabled",!!t)},focus:function(t,e){var i;this.blur(t,t&&"focus"===t.type),this._scrollIntoView(e),this.active=e.first(),i=this.active.children(".ui-menu-item-wrapper"),this._addClass(i,null,"ui-state-active"),this.options.role&&this.element.attr("aria-activedescendant",i.attr("id")),i=this.active.parent().closest(".ui-menu-item").children(".ui-menu-item-wrapper"),this._addClass(i,null,"ui-state-active"),t&&"keydown"===t.type?this._close():this.timer=this._delay(function(){this._close()},this.delay),(i=e.children(".ui-menu")).length&&t&&/^mouse/.test(t.type)&&this._startOpening(i),this.activeMenu=e.parent(),this._trigger("focus",t,{item:e})},_scrollIntoView:function(t){var e,i,s;this._hasScroll()&&(i=parseFloat(V.css(this.activeMenu[0],"borderTopWidth"))||0,s=parseFloat(V.css(this.activeMenu[0],"paddingTop"))||0,e=t.offset().top-this.activeMenu.offset().top-i-s,i=this.activeMenu.scrollTop(),s=this.activeMenu.height(),t=t.outerHeight(),e<0?this.activeMenu.scrollTop(i+e):s<e+t&&this.activeMenu.scrollTop(i+e-s+t))},blur:function(t,e){e||clearTimeout(this.timer),this.active&&(this._removeClass(this.active.children(".ui-menu-item-wrapper"),null,"ui-state-active"),this._trigger("blur",t,{item:this.active}),this.active=null)},_startOpening:function(t){clearTimeout(this.timer),"true"===t.attr("aria-hidden")&&(this.timer=this._delay(function(){this._close(),this._open(t)},this.delay))},_open:function(t){var e=V.extend({of:this.active},this.options.position);clearTimeout(this.timer),this.element.find(".ui-menu").not(t.parents(".ui-menu")).hide().attr("aria-hidden","true"),t.show().removeAttr("aria-hidden").attr("aria-expanded","true").position(e)},collapseAll:function(e,i){clearTimeout(this.timer),this.timer=this._delay(function(){var t=i?this.element:V(e&&e.target).closest(this.element.find(".ui-menu"));t.length||(t=this.element),this._close(t),this.blur(e),this._removeClass(t.find(".ui-state-active"),null,"ui-state-active"),this.activeMenu=t},i?0:this.delay)},_close:function(t){(t=t||(this.active?this.active.parent():this.element)).find(".ui-menu").hide().attr("aria-hidden","true").attr("aria-expanded","false")},_closeOnDocumentClick:function(t){return!V(t.target).closest(".ui-menu").length},_isDivider:function(t){return!/[^\-\u2014\u2013\s]/.test(t.text())},collapse:function(t){var e=this.active&&this.active.parent().closest(".ui-menu-item",this.element);e&&e.length&&(this._close(),this.focus(t,e))},expand:function(t){var e=this.active&&this._menuItems(this.active.children(".ui-menu")).first();e&&e.length&&(this._open(e.parent()),this._delay(function(){this.focus(t,e)}))},next:function(t){this._move("next","first",t)},previous:function(t){this._move("prev","last",t)},isFirstItem:function(){return this.active&&!this.active.prevAll(".ui-menu-item").length},isLastItem:function(){return this.active&&!this.active.nextAll(".ui-menu-item").length},_menuItems:function(t){return(t||this.element).find(this.options.items).filter(".ui-menu-item")},_move:function(t,e,i){var s;(s=this.active?"first"===t||"last"===t?this.active["first"===t?"prevAll":"nextAll"](".ui-menu-item").last():this.active[t+"All"](".ui-menu-item").first():s)&&s.length&&this.active||(s=this._menuItems(this.activeMenu)[e]()),this.focus(i,s)},nextPage:function(t){var e,i,s;this.active?this.isLastItem()||(this._hasScroll()?(i=this.active.offset().top,s=this.element.innerHeight(),0===V.fn.jquery.indexOf("3.2.")&&(s+=this.element[0].offsetHeight-this.element.outerHeight()),this.active.nextAll(".ui-menu-item").each(function(){return(e=V(this)).offset().top-i-s<0}),this.focus(t,e)):this.focus(t,this._menuItems(this.activeMenu)[this.active?"last":"first"]())):this.next(t)},previousPage:function(t){var e,i,s;this.active?this.isFirstItem()||(this._hasScroll()?(i=this.active.offset().top,s=this.element.innerHeight(),0===V.fn.jquery.indexOf("3.2.")&&(s+=this.element[0].offsetHeight-this.element.outerHeight()),this.active.prevAll(".ui-menu-item").each(function(){return 0<(e=V(this)).offset().top-i+s}),this.focus(t,e)):this.focus(t,this._menuItems(this.activeMenu).first())):this.next(t)},_hasScroll:function(){return this.element.outerHeight()<this.element.prop("scrollHeight")},select:function(t){this.active=this.active||V(t.target).closest(".ui-menu-item");var e={item:this.active};this.active.has(".ui-menu").length||this.collapseAll(t,!0),this._trigger("select",t,e)},_filterMenuItems:function(t){var t=t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&"),e=new RegExp("^"+t,"i");return this.activeMenu.find(this.options.items).filter(".ui-menu-item").filter(function(){return e.test(String.prototype.trim.call(V(this).children(".ui-menu-item-wrapper").text()))})}});V.widget("ui.autocomplete",{version:"1.13.2",defaultElement:"<input>",options:{appendTo:null,autoFocus:!1,delay:300,minLength:1,position:{my:"left top",at:"left bottom",collision:"none"},source:null,change:null,close:null,focus:null,open:null,response:null,search:null,select:null},requestIndex:0,pending:0,liveRegionTimer:null,_create:function(){var i,s,n,t=this.element[0].nodeName.toLowerCase(),e="textarea"===t,t="input"===t;this.isMultiLine=e||!t&&this._isContentEditable(this.element),this.valueMethod=this.element[e||t?"val":"text"],this.isNewMenu=!0,this._addClass("ui-autocomplete-input"),this.element.attr("autocomplete","off"),this._on(this.element,{keydown:function(t){if(this.element.prop("readOnly"))s=n=i=!0;else{s=n=i=!1;var e=V.ui.keyCode;switch(t.keyCode){case e.PAGE_UP:i=!0,this._move("previousPage",t);break;case e.PAGE_DOWN:i=!0,this._move("nextPage",t);break;case e.UP:i=!0,this._keyEvent("previous",t);break;case e.DOWN:i=!0,this._keyEvent("next",t);break;case e.ENTER:this.menu.active&&(i=!0,t.preventDefault(),this.menu.select(t));break;case e.TAB:this.menu.active&&this.menu.select(t);break;case e.ESCAPE:this.menu.element.is(":visible")&&(this.isMultiLine||this._value(this.term),this.close(t),t.preventDefault());break;default:s=!0,this._searchTimeout(t)}}},keypress:function(t){if(i)return i=!1,void(this.isMultiLine&&!this.menu.element.is(":visible")||t.preventDefault());if(!s){var e=V.ui.keyCode;switch(t.keyCode){case e.PAGE_UP:this._move("previousPage",t);break;case e.PAGE_DOWN:this._move("nextPage",t);break;case e.UP:this._keyEvent("previous",t);break;case e.DOWN:this._keyEvent("next",t)}}},input:function(t){if(n)return n=!1,void t.preventDefault();this._searchTimeout(t)},focus:function(){this.selectedItem=null,this.previous=this._value()},blur:function(t){clearTimeout(this.searching),this.close(t),this._change(t)}}),this._initSource(),this.menu=V("<ul>").appendTo(this._appendTo()).menu({role:null}).hide().attr({unselectable:"on"}).menu("instance"),this._addClass(this.menu.element,"ui-autocomplete","ui-front"),this._on(this.menu.element,{mousedown:function(t){t.preventDefault()},menufocus:function(t,e){var i,s;if(this.isNewMenu&&(this.isNewMenu=!1,t.originalEvent&&/^mouse/.test(t.originalEvent.type)))return this.menu.blur(),void this.document.one("mousemove",function(){V(t.target).trigger(t.originalEvent)});s=e.item.data("ui-autocomplete-item"),!1!==this._trigger("focus",t,{item:s})&&t.originalEvent&&/^key/.test(t.originalEvent.type)&&this._value(s.value),(i=e.item.attr("aria-label")||s.value)&&String.prototype.trim.call(i).length&&(clearTimeout(this.liveRegionTimer),this.liveRegionTimer=this._delay(function(){this.liveRegion.html(V("<div>").text(i))},100))},menuselect:function(t,e){var i=e.item.data("ui-autocomplete-item"),s=this.previous;this.element[0]!==V.ui.safeActiveElement(this.document[0])&&(this.element.trigger("focus"),this.previous=s,this._delay(function(){this.previous=s,this.selectedItem=i})),!1!==this._trigger("select",t,{item:i})&&this._value(i.value),this.term=this._value(),this.close(t),this.selectedItem=i}}),this.liveRegion=V("<div>",{role:"status","aria-live":"assertive","aria-relevant":"additions"}).appendTo(this.document[0].body),this._addClass(this.liveRegion,null,"ui-helper-hidden-accessible"),this._on(this.window,{beforeunload:function(){this.element.removeAttr("autocomplete")}})},_destroy:function(){clearTimeout(this.searching),this.element.removeAttr("autocomplete"),this.menu.element.remove(),this.liveRegion.remove()},_setOption:function(t,e){this._super(t,e),"source"===t&&this._initSource(),"appendTo"===t&&this.menu.element.appendTo(this._appendTo()),"disabled"===t&&e&&this.xhr&&this.xhr.abort()},_isEventTargetInWidget:function(t){var e=this.menu.element[0];return t.target===this.element[0]||t.target===e||V.contains(e,t.target)},_closeOnClickOutside:function(t){this._isEventTargetInWidget(t)||this.close()},_appendTo:function(){var t=this.options.appendTo;return t=!(t=!(t=t&&(t.jquery||t.nodeType?V(t):this.document.find(t).eq(0)))||!t[0]?this.element.closest(".ui-front, dialog"):t).length?this.document[0].body:t},_initSource:function(){var i,s,n=this;Array.isArray(this.options.source)?(i=this.options.source,this.source=function(t,e){e(V.ui.autocomplete.filter(i,t.term))}):"string"==typeof this.options.source?(s=this.options.source,this.source=function(t,e){n.xhr&&n.xhr.abort(),n.xhr=V.ajax({url:s,data:t,dataType:"json",success:function(t){e(t)},error:function(){e([])}})}):this.source=this.options.source},_searchTimeout:function(s){clearTimeout(this.searching),this.searching=this._delay(function(){var t=this.term===this._value(),e=this.menu.element.is(":visible"),i=s.altKey||s.ctrlKey||s.metaKey||s.shiftKey;t&&(e||i)||(this.selectedItem=null,this.search(null,s))},this.options.delay)},search:function(t,e){return t=null!=t?t:this._value(),this.term=this._value(),t.length<this.options.minLength?this.close(e):!1!==this._trigger("search",e)?this._search(t):void 0},_search:function(t){this.pending++,this._addClass("ui-autocomplete-loading"),this.cancelSearch=!1,this.source({term:t},this._response())},_response:function(){var e=++this.requestIndex;return function(t){e===this.requestIndex&&this.__response(t),this.pending--,this.pending||this._removeClass("ui-autocomplete-loading")}.bind(this)},__response:function(t){t=t&&this._normalize(t),this._trigger("response",null,{content:t}),!this.options.disabled&&t&&t.length&&!this.cancelSearch?(this._suggest(t),this._trigger("open")):this._close()},close:function(t){this.cancelSearch=!0,this._close(t)},_close:function(t){this._off(this.document,"mousedown"),this.menu.element.is(":visible")&&(this.menu.element.hide(),this.menu.blur(),this.isNewMenu=!0,this._trigger("close",t))},_change:function(t){this.previous!==this._value()&&this._trigger("change",t,{item:this.selectedItem})},_normalize:function(t){return t.length&&t[0].label&&t[0].value?t:V.map(t,function(t){return"string"==typeof t?{label:t,value:t}:V.extend({},t,{label:t.label||t.value,value:t.value||t.label})})},_suggest:function(t){var e=this.menu.element.empty();this._renderMenu(e,t),this.isNewMenu=!0,this.menu.refresh(),e.show(),this._resizeMenu(),e.position(V.extend({of:this.element},this.options.position)),this.options.autoFocus&&this.menu.next(),this._on(this.document,{mousedown:"_closeOnClickOutside"})},_resizeMenu:function(){var t=this.menu.element;t.outerWidth(Math.max(t.width("").outerWidth()+1,this.element.outerWidth()))},_renderMenu:function(i,t){var s=this;V.each(t,function(t,e){s._renderItemData(i,e)})},_renderItemData:function(t,e){return this._renderItem(t,e).data("ui-autocomplete-item",e)},_renderItem:function(t,e){return V("<li>").append(V("<div>").text(e.label)).appendTo(t)},_move:function(t,e){if(this.menu.element.is(":visible"))return this.menu.isFirstItem()&&/^previous/.test(t)||this.menu.isLastItem()&&/^next/.test(t)?(this.isMultiLine||this._value(this.term),void this.menu.blur()):void this.menu[t](e);this.search(null,e)},widget:function(){return this.menu.element},_value:function(){return this.valueMethod.apply(this.element,arguments)},_keyEvent:function(t,e){this.isMultiLine&&!this.menu.element.is(":visible")||(this._move(t,e),e.preventDefault())},_isContentEditable:function(t){if(!t.length)return!1;var e=t.prop("contentEditable");return"inherit"===e?this._isContentEditable(t.parent()):"true"===e}}),V.extend(V.ui.autocomplete,{escapeRegex:function(t){return t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&")},filter:function(t,e){var i=new RegExp(V.ui.autocomplete.escapeRegex(e),"i");return V.grep(t,function(t){return i.test(t.label||t.value||t)})}}),V.widget("ui.autocomplete",V.ui.autocomplete,{options:{messages:{noResults:"No search results.",results:function(t){return t+(1<t?" results are":" result is")+" available, use up and down arrow keys to navigate."}}},__response:function(t){var e;this._superApply(arguments),this.options.disabled||this.cancelSearch||(e=t&&t.length?this.options.messages.results(t.length):this.options.messages.noResults,clearTimeout(this.liveRegionTimer),this.liveRegionTimer=this._delay(function(){this.liveRegion.html(V("<div>").text(e))},100))}});V.ui.autocomplete;var tt=/ui-corner-([a-z]){2,6}/g;V.widget("ui.controlgroup",{version:"1.13.2",defaultElement:"<div>",options:{direction:"horizontal",disabled:null,onlyVisible:!0,items:{button:"input[type=button], input[type=submit], input[type=reset], button, a",controlgroupLabel:".ui-controlgroup-label",checkboxradio:"input[type='checkbox'], input[type='radio']",selectmenu:"select",spinner:".ui-spinner-input"}},_create:function(){this._enhance()},_enhance:function(){this.element.attr("role","toolbar"),this.refresh()},_destroy:function(){this._callChildMethod("destroy"),this.childWidgets.removeData("ui-controlgroup-data"),this.element.removeAttr("role"),this.options.items.controlgroupLabel&&this.element.find(this.options.items.controlgroupLabel).find(".ui-controlgroup-label-contents").contents().unwrap()},_initWidgets:function(){var o=this,a=[];V.each(this.options.items,function(s,t){var e,n={};if(t)return"controlgroupLabel"===s?((e=o.element.find(t)).each(function(){var t=V(this);t.children(".ui-controlgroup-label-contents").length||t.contents().wrapAll("<span class='ui-controlgroup-label-contents'></span>")}),o._addClass(e,null,"ui-widget ui-widget-content ui-state-default"),void(a=a.concat(e.get()))):void(V.fn[s]&&(n=o["_"+s+"Options"]?o["_"+s+"Options"]("middle"):{classes:{}},o.element.find(t).each(function(){var t=V(this),e=t[s]("instance"),i=V.widget.extend({},n);"button"===s&&t.parent(".ui-spinner").length||((e=e||t[s]()[s]("instance"))&&(i.classes=o._resolveClassesValues(i.classes,e)),t[s](i),i=t[s]("widget"),V.data(i[0],"ui-controlgroup-data",e||t[s]("instance")),a.push(i[0]))})))}),this.childWidgets=V(V.uniqueSort(a)),this._addClass(this.childWidgets,"ui-controlgroup-item")},_callChildMethod:function(e){this.childWidgets.each(function(){var t=V(this).data("ui-controlgroup-data");t&&t[e]&&t[e]()})},_updateCornerClass:function(t,e){e=this._buildSimpleOptions(e,"label").classes.label;this._removeClass(t,null,"ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all"),this._addClass(t,null,e)},_buildSimpleOptions:function(t,e){var i="vertical"===this.options.direction,s={classes:{}};return s.classes[e]={middle:"",first:"ui-corner-"+(i?"top":"left"),last:"ui-corner-"+(i?"bottom":"right"),only:"ui-corner-all"}[t],s},_spinnerOptions:function(t){t=this._buildSimpleOptions(t,"ui-spinner");return t.classes["ui-spinner-up"]="",t.classes["ui-spinner-down"]="",t},_buttonOptions:function(t){return this._buildSimpleOptions(t,"ui-button")},_checkboxradioOptions:function(t){return this._buildSimpleOptions(t,"ui-checkboxradio-label")},_selectmenuOptions:function(t){var e="vertical"===this.options.direction;return{width:e&&"auto",classes:{middle:{"ui-selectmenu-button-open":"","ui-selectmenu-button-closed":""},first:{"ui-selectmenu-button-open":"ui-corner-"+(e?"top":"tl"),"ui-selectmenu-button-closed":"ui-corner-"+(e?"top":"left")},last:{"ui-selectmenu-button-open":e?"":"ui-corner-tr","ui-selectmenu-button-closed":"ui-corner-"+(e?"bottom":"right")},only:{"ui-selectmenu-button-open":"ui-corner-top","ui-selectmenu-button-closed":"ui-corner-all"}}[t]}},_resolveClassesValues:function(i,s){var n={};return V.each(i,function(t){var e=s.options.classes[t]||"",e=String.prototype.trim.call(e.replace(tt,""));n[t]=(e+" "+i[t]).replace(/\s+/g," ")}),n},_setOption:function(t,e){"direction"===t&&this._removeClass("ui-controlgroup-"+this.options.direction),this._super(t,e),"disabled"!==t?this.refresh():this._callChildMethod(e?"disable":"enable")},refresh:function(){var n,o=this;this._addClass("ui-controlgroup ui-controlgroup-"+this.options.direction),"horizontal"===this.options.direction&&this._addClass(null,"ui-helper-clearfix"),this._initWidgets(),n=this.childWidgets,(n=this.options.onlyVisible?n.filter(":visible"):n).length&&(V.each(["first","last"],function(t,e){var i,s=n[e]().data("ui-controlgroup-data");s&&o["_"+s.widgetName+"Options"]?((i=o["_"+s.widgetName+"Options"](1===n.length?"only":e)).classes=o._resolveClassesValues(i.classes,s),s.element[s.widgetName](i)):o._updateCornerClass(n[e](),e)}),this._callChildMethod("refresh"))}});V.widget("ui.checkboxradio",[V.ui.formResetMixin,{version:"1.13.2",options:{disabled:null,label:null,icon:!0,classes:{"ui-checkboxradio-label":"ui-corner-all","ui-checkboxradio-icon":"ui-corner-all"}},_getCreateOptions:function(){var t,e=this._super()||{};return this._readType(),t=this.element.labels(),this.label=V(t[t.length-1]),this.label.length||V.error("No label found for checkboxradio widget"),this.originalLabel="",(t=this.label.contents().not(this.element[0])).length&&(this.originalLabel+=t.clone().wrapAll("<div></div>").parent().html()),this.originalLabel&&(e.label=this.originalLabel),null!=(t=this.element[0].disabled)&&(e.disabled=t),e},_create:function(){var t=this.element[0].checked;this._bindFormResetHandler(),null==this.options.disabled&&(this.options.disabled=this.element[0].disabled),this._setOption("disabled",this.options.disabled),this._addClass("ui-checkboxradio","ui-helper-hidden-accessible"),this._addClass(this.label,"ui-checkboxradio-label","ui-button ui-widget"),"radio"===this.type&&this._addClass(this.label,"ui-checkboxradio-radio-label"),this.options.label&&this.options.label!==this.originalLabel?this._updateLabel():this.originalLabel&&(this.options.label=this.originalLabel),this._enhance(),t&&this._addClass(this.label,"ui-checkboxradio-checked","ui-state-active"),this._on({change:"_toggleClasses",focus:function(){this._addClass(this.label,null,"ui-state-focus ui-visual-focus")},blur:function(){this._removeClass(this.label,null,"ui-state-focus ui-visual-focus")}})},_readType:function(){var t=this.element[0].nodeName.toLowerCase();this.type=this.element[0].type,"input"===t&&/radio|checkbox/.test(this.type)||V.error("Can't create checkboxradio on element.nodeName="+t+" and element.type="+this.type)},_enhance:function(){this._updateIcon(this.element[0].checked)},widget:function(){return this.label},_getRadioGroup:function(){var t=this.element[0].name,e="input[name='"+V.escapeSelector(t)+"']";return t?(this.form.length?V(this.form[0].elements).filter(e):V(e).filter(function(){return 0===V(this)._form().length})).not(this.element):V([])},_toggleClasses:function(){var t=this.element[0].checked;this._toggleClass(this.label,"ui-checkboxradio-checked","ui-state-active",t),this.options.icon&&"checkbox"===this.type&&this._toggleClass(this.icon,null,"ui-icon-check ui-state-checked",t)._toggleClass(this.icon,null,"ui-icon-blank",!t),"radio"===this.type&&this._getRadioGroup().each(function(){var t=V(this).checkboxradio("instance");t&&t._removeClass(t.label,"ui-checkboxradio-checked","ui-state-active")})},_destroy:function(){this._unbindFormResetHandler(),this.icon&&(this.icon.remove(),this.iconSpace.remove())},_setOption:function(t,e){if("label"!==t||e){if(this._super(t,e),"disabled"===t)return this._toggleClass(this.label,null,"ui-state-disabled",e),void(this.element[0].disabled=e);this.refresh()}},_updateIcon:function(t){var e="ui-icon ui-icon-background ";this.options.icon?(this.icon||(this.icon=V("<span>"),this.iconSpace=V("<span> </span>"),this._addClass(this.iconSpace,"ui-checkboxradio-icon-space")),"checkbox"===this.type?(e+=t?"ui-icon-check ui-state-checked":"ui-icon-blank",this._removeClass(this.icon,null,t?"ui-icon-blank":"ui-icon-check")):e+="ui-icon-blank",this._addClass(this.icon,"ui-checkboxradio-icon",e),t||this._removeClass(this.icon,null,"ui-icon-check ui-state-checked"),this.icon.prependTo(this.label).after(this.iconSpace)):void 0!==this.icon&&(this.icon.remove(),this.iconSpace.remove(),delete this.icon)},_updateLabel:function(){var t=this.label.contents().not(this.element[0]);this.icon&&(t=t.not(this.icon[0])),(t=this.iconSpace?t.not(this.iconSpace[0]):t).remove(),this.label.append(this.options.label)},refresh:function(){var t=this.element[0].checked,e=this.element[0].disabled;this._updateIcon(t),this._toggleClass(this.label,"ui-checkboxradio-checked","ui-state-active",t),null!==this.options.label&&this._updateLabel(),e!==this.options.disabled&&this._setOptions({disabled:e})}}]);var et;V.ui.checkboxradio;V.widget("ui.button",{version:"1.13.2",defaultElement:"<button>",options:{classes:{"ui-button":"ui-corner-all"},disabled:null,icon:null,iconPosition:"beginning",label:null,showLabel:!0},_getCreateOptions:function(){var t,e=this._super()||{};return this.isInput=this.element.is("input"),null!=(t=this.element[0].disabled)&&(e.disabled=t),this.originalLabel=this.isInput?this.element.val():this.element.html(),this.originalLabel&&(e.label=this.originalLabel),e},_create:function(){!this.option.showLabel&!this.options.icon&&(this.options.showLabel=!0),null==this.options.disabled&&(this.options.disabled=this.element[0].disabled||!1),this.hasTitle=!!this.element.attr("title"),this.options.label&&this.options.label!==this.originalLabel&&(this.isInput?this.element.val(this.options.label):this.element.html(this.options.label)),this._addClass("ui-button","ui-widget"),this._setOption("disabled",this.options.disabled),this._enhance(),this.element.is("a")&&this._on({keyup:function(t){t.keyCode===V.ui.keyCode.SPACE&&(t.preventDefault(),this.element[0].click?this.element[0].click():this.element.trigger("click"))}})},_enhance:function(){this.element.is("button")||this.element.attr("role","button"),this.options.icon&&(this._updateIcon("icon",this.options.icon),this._updateTooltip())},_updateTooltip:function(){this.title=this.element.attr("title"),this.options.showLabel||this.title||this.element.attr("title",this.options.label)},_updateIcon:function(t,e){var i="iconPosition"!==t,s=i?this.options.iconPosition:e,t="top"===s||"bottom"===s;this.icon?i&&this._removeClass(this.icon,null,this.options.icon):(this.icon=V("<span>"),this._addClass(this.icon,"ui-button-icon","ui-icon"),this.options.showLabel||this._addClass("ui-button-icon-only")),i&&this._addClass(this.icon,null,e),this._attachIcon(s),t?(this._addClass(this.icon,null,"ui-widget-icon-block"),this.iconSpace&&this.iconSpace.remove()):(this.iconSpace||(this.iconSpace=V("<span> </span>"),this._addClass(this.iconSpace,"ui-button-icon-space")),this._removeClass(this.icon,null,"ui-wiget-icon-block"),this._attachIconSpace(s))},_destroy:function(){this.element.removeAttr("role"),this.icon&&this.icon.remove(),this.iconSpace&&this.iconSpace.remove(),this.hasTitle||this.element.removeAttr("title")},_attachIconSpace:function(t){this.icon[/^(?:end|bottom)/.test(t)?"before":"after"](this.iconSpace)},_attachIcon:function(t){this.element[/^(?:end|bottom)/.test(t)?"append":"prepend"](this.icon)},_setOptions:function(t){var e=(void 0===t.showLabel?this.options:t).showLabel,i=(void 0===t.icon?this.options:t).icon;e||i||(t.showLabel=!0),this._super(t)},_setOption:function(t,e){"icon"===t&&(e?this._updateIcon(t,e):this.icon&&(this.icon.remove(),this.iconSpace&&this.iconSpace.remove())),"iconPosition"===t&&this._updateIcon(t,e),"showLabel"===t&&(this._toggleClass("ui-button-icon-only",null,!e),this._updateTooltip()),"label"===t&&(this.isInput?this.element.val(e):(this.element.html(e),this.icon&&(this._attachIcon(this.options.iconPosition),this._attachIconSpace(this.options.iconPosition)))),this._super(t,e),"disabled"===t&&(this._toggleClass(null,"ui-state-disabled",e),(this.element[0].disabled=e)&&this.element.trigger("blur"))},refresh:function(){var t=this.element.is("input, button")?this.element[0].disabled:this.element.hasClass("ui-button-disabled");t!==this.options.disabled&&this._setOptions({disabled:t}),this._updateTooltip()}}),!1!==V.uiBackCompat&&(V.widget("ui.button",V.ui.button,{options:{text:!0,icons:{primary:null,secondary:null}},_create:function(){this.options.showLabel&&!this.options.text&&(this.options.showLabel=this.options.text),!this.options.showLabel&&this.options.text&&(this.options.text=this.options.showLabel),this.options.icon||!this.options.icons.primary&&!this.options.icons.secondary?this.options.icon&&(this.options.icons.primary=this.options.icon):this.options.icons.primary?this.options.icon=this.options.icons.primary:(this.options.icon=this.options.icons.secondary,this.options.iconPosition="end"),this._super()},_setOption:function(t,e){"text"!==t?("showLabel"===t&&(this.options.text=e),"icon"===t&&(this.options.icons.primary=e),"icons"===t&&(e.primary?(this._super("icon",e.primary),this._super("iconPosition","beginning")):e.secondary&&(this._super("icon",e.secondary),this._super("iconPosition","end"))),this._superApply(arguments)):this._super("showLabel",e)}}),V.fn.button=(et=V.fn.button,function(i){var t="string"==typeof i,s=Array.prototype.slice.call(arguments,1),n=this;return t?this.length||"instance"!==i?this.each(function(){var t=V(this).attr("type"),e=V.data(this,"ui-"+("checkbox"!==t&&"radio"!==t?"button":"checkboxradio"));return"instance"===i?(n=e,!1):e?"function"!=typeof e[i]||"_"===i.charAt(0)?V.error("no such method '"+i+"' for button widget instance"):(t=e[i].apply(e,s))!==e&&void 0!==t?(n=t&&t.jquery?n.pushStack(t.get()):t,!1):void 0:V.error("cannot call methods on button prior to initialization; attempted to call method '"+i+"'")}):n=void 0:(s.length&&(i=V.widget.extend.apply(null,[i].concat(s))),this.each(function(){var t=V(this).attr("type"),e="checkbox"!==t&&"radio"!==t?"button":"checkboxradio",t=V.data(this,"ui-"+e);t?(t.option(i||{}),t._init&&t._init()):"button"!=e?V(this).checkboxradio(V.extend({icon:!1},i)):et.call(V(this),i)})),n}),V.fn.buttonset=function(){return V.ui.controlgroup||V.error("Controlgroup widget missing"),"option"===arguments[0]&&"items"===arguments[1]&&arguments[2]?this.controlgroup.apply(this,[arguments[0],"items.button",arguments[2]]):"option"===arguments[0]&&"items"===arguments[1]?this.controlgroup.apply(this,[arguments[0],"items.button"]):("object"==typeof arguments[0]&&arguments[0].items&&(arguments[0].items={button:arguments[0].items}),this.controlgroup.apply(this,arguments))});var it;V.ui.button;function st(){this._curInst=null,this._keyEvent=!1,this._disabledInputs=[],this._datepickerShowing=!1,this._inDialog=!1,this._mainDivId="ui-datepicker-div",this._inlineClass="ui-datepicker-inline",this._appendClass="ui-datepicker-append",this._triggerClass="ui-datepicker-trigger",this._dialogClass="ui-datepicker-dialog",this._disableClass="ui-datepicker-disabled",this._unselectableClass="ui-datepicker-unselectable",this._currentClass="ui-datepicker-current-day",this._dayOverClass="ui-datepicker-days-cell-over",this.regional=[],this.regional[""]={closeText:"Done",prevText:"Prev",nextText:"Next",currentText:"Today",monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],monthNamesShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],dayNamesShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],dayNamesMin:["Su","Mo","Tu","We","Th","Fr","Sa"],weekHeader:"Wk",dateFormat:"mm/dd/yy",firstDay:0,isRTL:!1,showMonthAfterYear:!1,yearSuffix:"",selectMonthLabel:"Select month",selectYearLabel:"Select year"},this._defaults={showOn:"focus",showAnim:"fadeIn",showOptions:{},defaultDate:null,appendText:"",buttonText:"...",buttonImage:"",buttonImageOnly:!1,hideIfNoPrevNext:!1,navigationAsDateFormat:!1,gotoCurrent:!1,changeMonth:!1,changeYear:!1,yearRange:"c-10:c+10",showOtherMonths:!1,selectOtherMonths:!1,showWeek:!1,calculateWeek:this.iso8601Week,shortYearCutoff:"+10",minDate:null,maxDate:null,duration:"fast",beforeShowDay:null,beforeShow:null,onSelect:null,onChangeMonthYear:null,onClose:null,onUpdateDatepicker:null,numberOfMonths:1,showCurrentAtPos:0,stepMonths:1,stepBigMonths:12,altField:"",altFormat:"",constrainInput:!0,showButtonPanel:!1,autoSize:!1,disabled:!1},V.extend(this._defaults,this.regional[""]),this.regional.en=V.extend(!0,{},this.regional[""]),this.regional["en-US"]=V.extend(!0,{},this.regional.en),this.dpDiv=nt(V("<div id='"+this._mainDivId+"' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"))}function nt(t){var e="button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";return t.on("mouseout",e,function(){V(this).removeClass("ui-state-hover"),-1!==this.className.indexOf("ui-datepicker-prev")&&V(this).removeClass("ui-datepicker-prev-hover"),-1!==this.className.indexOf("ui-datepicker-next")&&V(this).removeClass("ui-datepicker-next-hover")}).on("mouseover",e,ot)}function ot(){V.datepicker._isDisabledDatepicker((it.inline?it.dpDiv.parent():it.input)[0])||(V(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover"),V(this).addClass("ui-state-hover"),-1!==this.className.indexOf("ui-datepicker-prev")&&V(this).addClass("ui-datepicker-prev-hover"),-1!==this.className.indexOf("ui-datepicker-next")&&V(this).addClass("ui-datepicker-next-hover"))}function at(t,e){for(var i in V.extend(t,e),e)null==e[i]&&(t[i]=e[i]);return t}V.extend(V.ui,{datepicker:{version:"1.13.2"}}),V.extend(st.prototype,{markerClassName:"hasDatepicker",maxRows:4,_widgetDatepicker:function(){return this.dpDiv},setDefaults:function(t){return at(this._defaults,t||{}),this},_attachDatepicker:function(t,e){var i,s=t.nodeName.toLowerCase(),n="div"===s||"span"===s;t.id||(this.uuid+=1,t.id="dp"+this.uuid),(i=this._newInst(V(t),n)).settings=V.extend({},e||{}),"input"===s?this._connectDatepicker(t,i):n&&this._inlineDatepicker(t,i)},_newInst:function(t,e){return{id:t[0].id.replace(/([^A-Za-z0-9_\-])/g,"\\\\$1"),input:t,selectedDay:0,selectedMonth:0,selectedYear:0,drawMonth:0,drawYear:0,inline:e,dpDiv:e?nt(V("<div class='"+this._inlineClass+" ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")):this.dpDiv}},_connectDatepicker:function(t,e){var i=V(t);e.append=V([]),e.trigger=V([]),i.hasClass(this.markerClassName)||(this._attachments(i,e),i.addClass(this.markerClassName).on("keydown",this._doKeyDown).on("keypress",this._doKeyPress).on("keyup",this._doKeyUp),this._autoSize(e),V.data(t,"datepicker",e),e.settings.disabled&&this._disableDatepicker(t))},_attachments:function(t,e){var i,s=this._get(e,"appendText"),n=this._get(e,"isRTL");e.append&&e.append.remove(),s&&(e.append=V("<span>").addClass(this._appendClass).text(s),t[n?"before":"after"](e.append)),t.off("focus",this._showDatepicker),e.trigger&&e.trigger.remove(),"focus"!==(i=this._get(e,"showOn"))&&"both"!==i||t.on("focus",this._showDatepicker),"button"!==i&&"both"!==i||(s=this._get(e,"buttonText"),i=this._get(e,"buttonImage"),this._get(e,"buttonImageOnly")?e.trigger=V("<img>").addClass(this._triggerClass).attr({src:i,alt:s,title:s}):(e.trigger=V("<button type='button'>").addClass(this._triggerClass),i?e.trigger.html(V("<img>").attr({src:i,alt:s,title:s})):e.trigger.text(s)),t[n?"before":"after"](e.trigger),e.trigger.on("click",function(){return V.datepicker._datepickerShowing&&V.datepicker._lastInput===t[0]?V.datepicker._hideDatepicker():(V.datepicker._datepickerShowing&&V.datepicker._lastInput!==t[0]&&V.datepicker._hideDatepicker(),V.datepicker._showDatepicker(t[0])),!1}))},_autoSize:function(t){var e,i,s,n,o,a;this._get(t,"autoSize")&&!t.inline&&(o=new Date(2009,11,20),(a=this._get(t,"dateFormat")).match(/[DM]/)&&(e=function(t){for(n=s=i=0;n<t.length;n++)t[n].length>i&&(i=t[n].length,s=n);return s},o.setMonth(e(this._get(t,a.match(/MM/)?"monthNames":"monthNamesShort"))),o.setDate(e(this._get(t,a.match(/DD/)?"dayNames":"dayNamesShort"))+20-o.getDay())),t.input.attr("size",this._formatDate(t,o).length))},_inlineDatepicker:function(t,e){var i=V(t);i.hasClass(this.markerClassName)||(i.addClass(this.markerClassName).append(e.dpDiv),V.data(t,"datepicker",e),this._setDate(e,this._getDefaultDate(e),!0),this._updateDatepicker(e),this._updateAlternate(e),e.settings.disabled&&this._disableDatepicker(t),e.dpDiv.css("display","block"))},_dialogDatepicker:function(t,e,i,s,n){var o,a=this._dialogInst;return a||(this.uuid+=1,o="dp"+this.uuid,this._dialogInput=V("<input type='text' id='"+o+"' style='position: absolute; top: -100px; width: 0px;'/>"),this._dialogInput.on("keydown",this._doKeyDown),V("body").append(this._dialogInput),(a=this._dialogInst=this._newInst(this._dialogInput,!1)).settings={},V.data(this._dialogInput[0],"datepicker",a)),at(a.settings,s||{}),e=e&&e.constructor===Date?this._formatDate(a,e):e,this._dialogInput.val(e),this._pos=n?n.length?n:[n.pageX,n.pageY]:null,this._pos||(o=document.documentElement.clientWidth,s=document.documentElement.clientHeight,e=document.documentElement.scrollLeft||document.body.scrollLeft,n=document.documentElement.scrollTop||document.body.scrollTop,this._pos=[o/2-100+e,s/2-150+n]),this._dialogInput.css("left",this._pos[0]+20+"px").css("top",this._pos[1]+"px"),a.settings.onSelect=i,this._inDialog=!0,this.dpDiv.addClass(this._dialogClass),this._showDatepicker(this._dialogInput[0]),V.blockUI&&V.blockUI(this.dpDiv),V.data(this._dialogInput[0],"datepicker",a),this},_destroyDatepicker:function(t){var e,i=V(t),s=V.data(t,"datepicker");i.hasClass(this.markerClassName)&&(e=t.nodeName.toLowerCase(),V.removeData(t,"datepicker"),"input"===e?(s.append.remove(),s.trigger.remove(),i.removeClass(this.markerClassName).off("focus",this._showDatepicker).off("keydown",this._doKeyDown).off("keypress",this._doKeyPress).off("keyup",this._doKeyUp)):"div"!==e&&"span"!==e||i.removeClass(this.markerClassName).empty(),it===s&&(it=null,this._curInst=null))},_enableDatepicker:function(e){var t,i=V(e),s=V.data(e,"datepicker");i.hasClass(this.markerClassName)&&("input"===(t=e.nodeName.toLowerCase())?(e.disabled=!1,s.trigger.filter("button").each(function(){this.disabled=!1}).end().filter("img").css({opacity:"1.0",cursor:""})):"div"!==t&&"span"!==t||((i=i.children("."+this._inlineClass)).children().removeClass("ui-state-disabled"),i.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled",!1)),this._disabledInputs=V.map(this._disabledInputs,function(t){return t===e?null:t}))},_disableDatepicker:function(e){var t,i=V(e),s=V.data(e,"datepicker");i.hasClass(this.markerClassName)&&("input"===(t=e.nodeName.toLowerCase())?(e.disabled=!0,s.trigger.filter("button").each(function(){this.disabled=!0}).end().filter("img").css({opacity:"0.5",cursor:"default"})):"div"!==t&&"span"!==t||((i=i.children("."+this._inlineClass)).children().addClass("ui-state-disabled"),i.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled",!0)),this._disabledInputs=V.map(this._disabledInputs,function(t){return t===e?null:t}),this._disabledInputs[this._disabledInputs.length]=e)},_isDisabledDatepicker:function(t){if(!t)return!1;for(var e=0;e<this._disabledInputs.length;e++)if(this._disabledInputs[e]===t)return!0;return!1},_getInst:function(t){try{return V.data(t,"datepicker")}catch(t){throw"Missing instance data for this datepicker"}},_optionDatepicker:function(t,e,i){var s,n,o=this._getInst(t);if(2===arguments.length&&"string"==typeof e)return"defaults"===e?V.extend({},V.datepicker._defaults):o?"all"===e?V.extend({},o.settings):this._get(o,e):null;s=e||{},"string"==typeof e&&((s={})[e]=i),o&&(this._curInst===o&&this._hideDatepicker(),n=this._getDateDatepicker(t,!0),e=this._getMinMaxDate(o,"min"),i=this._getMinMaxDate(o,"max"),at(o.settings,s),null!==e&&void 0!==s.dateFormat&&void 0===s.minDate&&(o.settings.minDate=this._formatDate(o,e)),null!==i&&void 0!==s.dateFormat&&void 0===s.maxDate&&(o.settings.maxDate=this._formatDate(o,i)),"disabled"in s&&(s.disabled?this._disableDatepicker(t):this._enableDatepicker(t)),this._attachments(V(t),o),this._autoSize(o),this._setDate(o,n),this._updateAlternate(o),this._updateDatepicker(o))},_changeDatepicker:function(t,e,i){this._optionDatepicker(t,e,i)},_refreshDatepicker:function(t){t=this._getInst(t);t&&this._updateDatepicker(t)},_setDateDatepicker:function(t,e){t=this._getInst(t);t&&(this._setDate(t,e),this._updateDatepicker(t),this._updateAlternate(t))},_getDateDatepicker:function(t,e){t=this._getInst(t);return t&&!t.inline&&this._setDateFromField(t,e),t?this._getDate(t):null},_doKeyDown:function(t){var e,i,s=V.datepicker._getInst(t.target),n=!0,o=s.dpDiv.is(".ui-datepicker-rtl");if(s._keyEvent=!0,V.datepicker._datepickerShowing)switch(t.keyCode){case 9:V.datepicker._hideDatepicker(),n=!1;break;case 13:return(i=V("td."+V.datepicker._dayOverClass+":not(."+V.datepicker._currentClass+")",s.dpDiv))[0]&&V.datepicker._selectDay(t.target,s.selectedMonth,s.selectedYear,i[0]),(e=V.datepicker._get(s,"onSelect"))?(i=V.datepicker._formatDate(s),e.apply(s.input?s.input[0]:null,[i,s])):V.datepicker._hideDatepicker(),!1;case 27:V.datepicker._hideDatepicker();break;case 33:V.datepicker._adjustDate(t.target,t.ctrlKey?-V.datepicker._get(s,"stepBigMonths"):-V.datepicker._get(s,"stepMonths"),"M");break;case 34:V.datepicker._adjustDate(t.target,t.ctrlKey?+V.datepicker._get(s,"stepBigMonths"):+V.datepicker._get(s,"stepMonths"),"M");break;case 35:(t.ctrlKey||t.metaKey)&&V.datepicker._clearDate(t.target),n=t.ctrlKey||t.metaKey;break;case 36:(t.ctrlKey||t.metaKey)&&V.datepicker._gotoToday(t.target),n=t.ctrlKey||t.metaKey;break;case 37:(t.ctrlKey||t.metaKey)&&V.datepicker._adjustDate(t.target,o?1:-1,"D"),n=t.ctrlKey||t.metaKey,t.originalEvent.altKey&&V.datepicker._adjustDate(t.target,t.ctrlKey?-V.datepicker._get(s,"stepBigMonths"):-V.datepicker._get(s,"stepMonths"),"M");break;case 38:(t.ctrlKey||t.metaKey)&&V.datepicker._adjustDate(t.target,-7,"D"),n=t.ctrlKey||t.metaKey;break;case 39:(t.ctrlKey||t.metaKey)&&V.datepicker._adjustDate(t.target,o?-1:1,"D"),n=t.ctrlKey||t.metaKey,t.originalEvent.altKey&&V.datepicker._adjustDate(t.target,t.ctrlKey?+V.datepicker._get(s,"stepBigMonths"):+V.datepicker._get(s,"stepMonths"),"M");break;case 40:(t.ctrlKey||t.metaKey)&&V.datepicker._adjustDate(t.target,7,"D"),n=t.ctrlKey||t.metaKey;break;default:n=!1}else 36===t.keyCode&&t.ctrlKey?V.datepicker._showDatepicker(this):n=!1;n&&(t.preventDefault(),t.stopPropagation())},_doKeyPress:function(t){var e,i=V.datepicker._getInst(t.target);if(V.datepicker._get(i,"constrainInput"))return e=V.datepicker._possibleChars(V.datepicker._get(i,"dateFormat")),i=String.fromCharCode(null==t.charCode?t.keyCode:t.charCode),t.ctrlKey||t.metaKey||i<" "||!e||-1<e.indexOf(i)},_doKeyUp:function(t){t=V.datepicker._getInst(t.target);if(t.input.val()!==t.lastVal)try{V.datepicker.parseDate(V.datepicker._get(t,"dateFormat"),t.input?t.input.val():null,V.datepicker._getFormatConfig(t))&&(V.datepicker._setDateFromField(t),V.datepicker._updateAlternate(t),V.datepicker._updateDatepicker(t))}catch(t){}return!0},_showDatepicker:function(t){var e,i,s,n;"input"!==(t=t.target||t).nodeName.toLowerCase()&&(t=V("input",t.parentNode)[0]),V.datepicker._isDisabledDatepicker(t)||V.datepicker._lastInput===t||(n=V.datepicker._getInst(t),V.datepicker._curInst&&V.datepicker._curInst!==n&&(V.datepicker._curInst.dpDiv.stop(!0,!0),n&&V.datepicker._datepickerShowing&&V.datepicker._hideDatepicker(V.datepicker._curInst.input[0])),!1!==(i=(s=V.datepicker._get(n,"beforeShow"))?s.apply(t,[t,n]):{})&&(at(n.settings,i),n.lastVal=null,V.datepicker._lastInput=t,V.datepicker._setDateFromField(n),V.datepicker._inDialog&&(t.value=""),V.datepicker._pos||(V.datepicker._pos=V.datepicker._findPos(t),V.datepicker._pos[1]+=t.offsetHeight),e=!1,V(t).parents().each(function(){return!(e|="fixed"===V(this).css("position"))}),s={left:V.datepicker._pos[0],top:V.datepicker._pos[1]},V.datepicker._pos=null,n.dpDiv.empty(),n.dpDiv.css({position:"absolute",display:"block",top:"-1000px"}),V.datepicker._updateDatepicker(n),s=V.datepicker._checkOffset(n,s,e),n.dpDiv.css({position:V.datepicker._inDialog&&V.blockUI?"static":e?"fixed":"absolute",display:"none",left:s.left+"px",top:s.top+"px"}),n.inline||(i=V.datepicker._get(n,"showAnim"),s=V.datepicker._get(n,"duration"),n.dpDiv.css("z-index",function(t){for(var e,i;t.length&&t[0]!==document;){if(("absolute"===(e=t.css("position"))||"relative"===e||"fixed"===e)&&(i=parseInt(t.css("zIndex"),10),!isNaN(i)&&0!==i))return i;t=t.parent()}return 0}(V(t))+1),V.datepicker._datepickerShowing=!0,V.effects&&V.effects.effect[i]?n.dpDiv.show(i,V.datepicker._get(n,"showOptions"),s):n.dpDiv[i||"show"](i?s:null),V.datepicker._shouldFocusInput(n)&&n.input.trigger("focus"),V.datepicker._curInst=n)))},_updateDatepicker:function(t){this.maxRows=4,(it=t).dpDiv.empty().append(this._generateHTML(t)),this._attachHandlers(t);var e,i=this._getNumberOfMonths(t),s=i[1],n=t.dpDiv.find("."+this._dayOverClass+" a"),o=V.datepicker._get(t,"onUpdateDatepicker");0<n.length&&ot.apply(n.get(0)),t.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width(""),1<s&&t.dpDiv.addClass("ui-datepicker-multi-"+s).css("width",17*s+"em"),t.dpDiv[(1!==i[0]||1!==i[1]?"add":"remove")+"Class"]("ui-datepicker-multi"),t.dpDiv[(this._get(t,"isRTL")?"add":"remove")+"Class"]("ui-datepicker-rtl"),t===V.datepicker._curInst&&V.datepicker._datepickerShowing&&V.datepicker._shouldFocusInput(t)&&t.input.trigger("focus"),t.yearshtml&&(e=t.yearshtml,setTimeout(function(){e===t.yearshtml&&t.yearshtml&&t.dpDiv.find("select.ui-datepicker-year").first().replaceWith(t.yearshtml),e=t.yearshtml=null},0)),o&&o.apply(t.input?t.input[0]:null,[t])},_shouldFocusInput:function(t){return t.input&&t.input.is(":visible")&&!t.input.is(":disabled")&&!t.input.is(":focus")},_checkOffset:function(t,e,i){var s=t.dpDiv.outerWidth(),n=t.dpDiv.outerHeight(),o=t.input?t.input.outerWidth():0,a=t.input?t.input.outerHeight():0,r=document.documentElement.clientWidth+(i?0:V(document).scrollLeft()),l=document.documentElement.clientHeight+(i?0:V(document).scrollTop());return e.left-=this._get(t,"isRTL")?s-o:0,e.left-=i&&e.left===t.input.offset().left?V(document).scrollLeft():0,e.top-=i&&e.top===t.input.offset().top+a?V(document).scrollTop():0,e.left-=Math.min(e.left,e.left+s>r&&s<r?Math.abs(e.left+s-r):0),e.top-=Math.min(e.top,e.top+n>l&&n<l?Math.abs(n+a):0),e},_findPos:function(t){for(var e=this._getInst(t),i=this._get(e,"isRTL");t&&("hidden"===t.type||1!==t.nodeType||V.expr.pseudos.hidden(t));)t=t[i?"previousSibling":"nextSibling"];return[(e=V(t).offset()).left,e.top]},_hideDatepicker:function(t){var e,i,s=this._curInst;!s||t&&s!==V.data(t,"datepicker")||this._datepickerShowing&&(e=this._get(s,"showAnim"),i=this._get(s,"duration"),t=function(){V.datepicker._tidyDialog(s)},V.effects&&(V.effects.effect[e]||V.effects[e])?s.dpDiv.hide(e,V.datepicker._get(s,"showOptions"),i,t):s.dpDiv["slideDown"===e?"slideUp":"fadeIn"===e?"fadeOut":"hide"](e?i:null,t),e||t(),this._datepickerShowing=!1,(t=this._get(s,"onClose"))&&t.apply(s.input?s.input[0]:null,[s.input?s.input.val():"",s]),this._lastInput=null,this._inDialog&&(this._dialogInput.css({position:"absolute",left:"0",top:"-100px"}),V.blockUI&&(V.unblockUI(),V("body").append(this.dpDiv))),this._inDialog=!1)},_tidyDialog:function(t){t.dpDiv.removeClass(this._dialogClass).off(".ui-datepicker-calendar")},_checkExternalClick:function(t){var e;V.datepicker._curInst&&(e=V(t.target),t=V.datepicker._getInst(e[0]),(e[0].id===V.datepicker._mainDivId||0!==e.parents("#"+V.datepicker._mainDivId).length||e.hasClass(V.datepicker.markerClassName)||e.closest("."+V.datepicker._triggerClass).length||!V.datepicker._datepickerShowing||V.datepicker._inDialog&&V.blockUI)&&(!e.hasClass(V.datepicker.markerClassName)||V.datepicker._curInst===t)||V.datepicker._hideDatepicker())},_adjustDate:function(t,e,i){var s=V(t),t=this._getInst(s[0]);this._isDisabledDatepicker(s[0])||(this._adjustInstDate(t,e,i),this._updateDatepicker(t))},_gotoToday:function(t){var e=V(t),i=this._getInst(e[0]);this._get(i,"gotoCurrent")&&i.currentDay?(i.selectedDay=i.currentDay,i.drawMonth=i.selectedMonth=i.currentMonth,i.drawYear=i.selectedYear=i.currentYear):(t=new Date,i.selectedDay=t.getDate(),i.drawMonth=i.selectedMonth=t.getMonth(),i.drawYear=i.selectedYear=t.getFullYear()),this._notifyChange(i),this._adjustDate(e)},_selectMonthYear:function(t,e,i){var s=V(t),t=this._getInst(s[0]);t["selected"+("M"===i?"Month":"Year")]=t["draw"+("M"===i?"Month":"Year")]=parseInt(e.options[e.selectedIndex].value,10),this._notifyChange(t),this._adjustDate(s)},_selectDay:function(t,e,i,s){var n=V(t);V(s).hasClass(this._unselectableClass)||this._isDisabledDatepicker(n[0])||((n=this._getInst(n[0])).selectedDay=n.currentDay=parseInt(V("a",s).attr("data-date")),n.selectedMonth=n.currentMonth=e,n.selectedYear=n.currentYear=i,this._selectDate(t,this._formatDate(n,n.currentDay,n.currentMonth,n.currentYear)))},_clearDate:function(t){t=V(t);this._selectDate(t,"")},_selectDate:function(t,e){var i=V(t),t=this._getInst(i[0]);e=null!=e?e:this._formatDate(t),t.input&&t.input.val(e),this._updateAlternate(t),(i=this._get(t,"onSelect"))?i.apply(t.input?t.input[0]:null,[e,t]):t.input&&t.input.trigger("change"),t.inline?this._updateDatepicker(t):(this._hideDatepicker(),this._lastInput=t.input[0],"object"!=typeof t.input[0]&&t.input.trigger("focus"),this._lastInput=null)},_updateAlternate:function(t){var e,i,s=this._get(t,"altField");s&&(e=this._get(t,"altFormat")||this._get(t,"dateFormat"),i=this._getDate(t),t=this.formatDate(e,i,this._getFormatConfig(t)),V(document).find(s).val(t))},noWeekends:function(t){t=t.getDay();return[0<t&&t<6,""]},iso8601Week:function(t){var e=new Date(t.getTime());return e.setDate(e.getDate()+4-(e.getDay()||7)),t=e.getTime(),e.setMonth(0),e.setDate(1),Math.floor(Math.round((t-e)/864e5)/7)+1},parseDate:function(e,n,t){if(null==e||null==n)throw"Invalid arguments";if(""===(n="object"==typeof n?n.toString():n+""))return null;for(var i,s,o,a=0,r=(t?t.shortYearCutoff:null)||this._defaults.shortYearCutoff,r="string"!=typeof r?r:(new Date).getFullYear()%100+parseInt(r,10),l=(t?t.dayNamesShort:null)||this._defaults.dayNamesShort,h=(t?t.dayNames:null)||this._defaults.dayNames,c=(t?t.monthNamesShort:null)||this._defaults.monthNamesShort,u=(t?t.monthNames:null)||this._defaults.monthNames,d=-1,p=-1,f=-1,g=-1,m=!1,_=function(t){t=w+1<e.length&&e.charAt(w+1)===t;return t&&w++,t},v=function(t){var e=_(t),e="@"===t?14:"!"===t?20:"y"===t&&e?4:"o"===t?3:2,e=new RegExp("^\\d{"+("y"===t?e:1)+","+e+"}"),e=n.substring(a).match(e);if(!e)throw"Missing number at position "+a;return a+=e[0].length,parseInt(e[0],10)},b=function(t,e,i){var s=-1,e=V.map(_(t)?i:e,function(t,e){return[[e,t]]}).sort(function(t,e){return-(t[1].length-e[1].length)});if(V.each(e,function(t,e){var i=e[1];if(n.substr(a,i.length).toLowerCase()===i.toLowerCase())return s=e[0],a+=i.length,!1}),-1!==s)return s+1;throw"Unknown name at position "+a},y=function(){if(n.charAt(a)!==e.charAt(w))throw"Unexpected literal at position "+a;a++},w=0;w<e.length;w++)if(m)"'"!==e.charAt(w)||_("'")?y():m=!1;else switch(e.charAt(w)){case"d":f=v("d");break;case"D":b("D",l,h);break;case"o":g=v("o");break;case"m":p=v("m");break;case"M":p=b("M",c,u);break;case"y":d=v("y");break;case"@":d=(o=new Date(v("@"))).getFullYear(),p=o.getMonth()+1,f=o.getDate();break;case"!":d=(o=new Date((v("!")-this._ticksTo1970)/1e4)).getFullYear(),p=o.getMonth()+1,f=o.getDate();break;case"'":_("'")?y():m=!0;break;default:y()}if(a<n.length&&(s=n.substr(a),!/^\s+/.test(s)))throw"Extra/unparsed characters found in date: "+s;if(-1===d?d=(new Date).getFullYear():d<100&&(d+=(new Date).getFullYear()-(new Date).getFullYear()%100+(d<=r?0:-100)),-1<g)for(p=1,f=g;;){if(f<=(i=this._getDaysInMonth(d,p-1)))break;p++,f-=i}if((o=this._daylightSavingAdjust(new Date(d,p-1,f))).getFullYear()!==d||o.getMonth()+1!==p||o.getDate()!==f)throw"Invalid date";return o},ATOM:"yy-mm-dd",COOKIE:"D, dd M yy",ISO_8601:"yy-mm-dd",RFC_822:"D, d M y",RFC_850:"DD, dd-M-y",RFC_1036:"D, d M y",RFC_1123:"D, d M yy",RFC_2822:"D, d M yy",RSS:"D, d M y",TICKS:"!",TIMESTAMP:"@",W3C:"yy-mm-dd",_ticksTo1970:24*(718685+Math.floor(492.5)-Math.floor(19.7)+Math.floor(4.925))*60*60*1e7,formatDate:function(e,t,i){if(!t)return"";function s(t,e,i){var s=""+e;if(c(t))for(;s.length<i;)s="0"+s;return s}function n(t,e,i,s){return(c(t)?s:i)[e]}var o,a=(i?i.dayNamesShort:null)||this._defaults.dayNamesShort,r=(i?i.dayNames:null)||this._defaults.dayNames,l=(i?i.monthNamesShort:null)||this._defaults.monthNamesShort,h=(i?i.monthNames:null)||this._defaults.monthNames,c=function(t){t=o+1<e.length&&e.charAt(o+1)===t;return t&&o++,t},u="",d=!1;if(t)for(o=0;o<e.length;o++)if(d)"'"!==e.charAt(o)||c("'")?u+=e.charAt(o):d=!1;else switch(e.charAt(o)){case"d":u+=s("d",t.getDate(),2);break;case"D":u+=n("D",t.getDay(),a,r);break;case"o":u+=s("o",Math.round((new Date(t.getFullYear(),t.getMonth(),t.getDate()).getTime()-new Date(t.getFullYear(),0,0).getTime())/864e5),3);break;case"m":u+=s("m",t.getMonth()+1,2);break;case"M":u+=n("M",t.getMonth(),l,h);break;case"y":u+=c("y")?t.getFullYear():(t.getFullYear()%100<10?"0":"")+t.getFullYear()%100;break;case"@":u+=t.getTime();break;case"!":u+=1e4*t.getTime()+this._ticksTo1970;break;case"'":c("'")?u+="'":d=!0;break;default:u+=e.charAt(o)}return u},_possibleChars:function(e){for(var t="",i=!1,s=function(t){t=n+1<e.length&&e.charAt(n+1)===t;return t&&n++,t},n=0;n<e.length;n++)if(i)"'"!==e.charAt(n)||s("'")?t+=e.charAt(n):i=!1;else switch(e.charAt(n)){case"d":case"m":case"y":case"@":t+="0123456789";break;case"D":case"M":return null;case"'":s("'")?t+="'":i=!0;break;default:t+=e.charAt(n)}return t},_get:function(t,e){return(void 0!==t.settings[e]?t.settings:this._defaults)[e]},_setDateFromField:function(t,e){if(t.input.val()!==t.lastVal){var i=this._get(t,"dateFormat"),s=t.lastVal=t.input?t.input.val():null,n=this._getDefaultDate(t),o=n,a=this._getFormatConfig(t);try{o=this.parseDate(i,s,a)||n}catch(t){s=e?"":s}t.selectedDay=o.getDate(),t.drawMonth=t.selectedMonth=o.getMonth(),t.drawYear=t.selectedYear=o.getFullYear(),t.currentDay=s?o.getDate():0,t.currentMonth=s?o.getMonth():0,t.currentYear=s?o.getFullYear():0,this._adjustInstDate(t)}},_getDefaultDate:function(t){return this._restrictMinMax(t,this._determineDate(t,this._get(t,"defaultDate"),new Date))},_determineDate:function(r,t,e){var i,s,t=null==t||""===t?e:"string"==typeof t?function(t){try{return V.datepicker.parseDate(V.datepicker._get(r,"dateFormat"),t,V.datepicker._getFormatConfig(r))}catch(t){}for(var e=(t.toLowerCase().match(/^c/)?V.datepicker._getDate(r):null)||new Date,i=e.getFullYear(),s=e.getMonth(),n=e.getDate(),o=/([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,a=o.exec(t);a;){switch(a[2]||"d"){case"d":case"D":n+=parseInt(a[1],10);break;case"w":case"W":n+=7*parseInt(a[1],10);break;case"m":case"M":s+=parseInt(a[1],10),n=Math.min(n,V.datepicker._getDaysInMonth(i,s));break;case"y":case"Y":i+=parseInt(a[1],10),n=Math.min(n,V.datepicker._getDaysInMonth(i,s))}a=o.exec(t)}return new Date(i,s,n)}(t):"number"==typeof t?isNaN(t)?e:(i=t,(s=new Date).setDate(s.getDate()+i),s):new Date(t.getTime());return(t=t&&"Invalid Date"===t.toString()?e:t)&&(t.setHours(0),t.setMinutes(0),t.setSeconds(0),t.setMilliseconds(0)),this._daylightSavingAdjust(t)},_daylightSavingAdjust:function(t){return t?(t.setHours(12<t.getHours()?t.getHours()+2:0),t):null},_setDate:function(t,e,i){var s=!e,n=t.selectedMonth,o=t.selectedYear,e=this._restrictMinMax(t,this._determineDate(t,e,new Date));t.selectedDay=t.currentDay=e.getDate(),t.drawMonth=t.selectedMonth=t.currentMonth=e.getMonth(),t.drawYear=t.selectedYear=t.currentYear=e.getFullYear(),n===t.selectedMonth&&o===t.selectedYear||i||this._notifyChange(t),this._adjustInstDate(t),t.input&&t.input.val(s?"":this._formatDate(t))},_getDate:function(t){return!t.currentYear||t.input&&""===t.input.val()?null:this._daylightSavingAdjust(new Date(t.currentYear,t.currentMonth,t.currentDay))},_attachHandlers:function(t){var e=this._get(t,"stepMonths"),i="#"+t.id.replace(/\\\\/g,"\\");t.dpDiv.find("[data-handler]").map(function(){var t={prev:function(){V.datepicker._adjustDate(i,-e,"M")},next:function(){V.datepicker._adjustDate(i,+e,"M")},hide:function(){V.datepicker._hideDatepicker()},today:function(){V.datepicker._gotoToday(i)},selectDay:function(){return V.datepicker._selectDay(i,+this.getAttribute("data-month"),+this.getAttribute("data-year"),this),!1},selectMonth:function(){return V.datepicker._selectMonthYear(i,this,"M"),!1},selectYear:function(){return V.datepicker._selectMonthYear(i,this,"Y"),!1}};V(this).on(this.getAttribute("data-event"),t[this.getAttribute("data-handler")])})},_generateHTML:function(t){var e,i,s,n,o,a,r,l,h,c,u,d,p,f,g,m,_,v,b,y,w,x,k,C,D,I,T,P,M,S,H,z,A=new Date,O=this._daylightSavingAdjust(new Date(A.getFullYear(),A.getMonth(),A.getDate())),N=this._get(t,"isRTL"),E=this._get(t,"showButtonPanel"),W=this._get(t,"hideIfNoPrevNext"),F=this._get(t,"navigationAsDateFormat"),L=this._getNumberOfMonths(t),R=this._get(t,"showCurrentAtPos"),A=this._get(t,"stepMonths"),Y=1!==L[0]||1!==L[1],B=this._daylightSavingAdjust(t.currentDay?new Date(t.currentYear,t.currentMonth,t.currentDay):new Date(9999,9,9)),j=this._getMinMaxDate(t,"min"),q=this._getMinMaxDate(t,"max"),K=t.drawMonth-R,U=t.drawYear;if(K<0&&(K+=12,U--),q)for(e=this._daylightSavingAdjust(new Date(q.getFullYear(),q.getMonth()-L[0]*L[1]+1,q.getDate())),e=j&&e<j?j:e;this._daylightSavingAdjust(new Date(U,K,1))>e;)--K<0&&(K=11,U--);for(t.drawMonth=K,t.drawYear=U,R=this._get(t,"prevText"),R=F?this.formatDate(R,this._daylightSavingAdjust(new Date(U,K-A,1)),this._getFormatConfig(t)):R,i=this._canAdjustMonth(t,-1,U,K)?V("<a>").attr({class:"ui-datepicker-prev ui-corner-all","data-handler":"prev","data-event":"click",title:R}).append(V("<span>").addClass("ui-icon ui-icon-circle-triangle-"+(N?"e":"w")).text(R))[0].outerHTML:W?"":V("<a>").attr({class:"ui-datepicker-prev ui-corner-all ui-state-disabled",title:R}).append(V("<span>").addClass("ui-icon ui-icon-circle-triangle-"+(N?"e":"w")).text(R))[0].outerHTML,R=this._get(t,"nextText"),R=F?this.formatDate(R,this._daylightSavingAdjust(new Date(U,K+A,1)),this._getFormatConfig(t)):R,s=this._canAdjustMonth(t,1,U,K)?V("<a>").attr({class:"ui-datepicker-next ui-corner-all","data-handler":"next","data-event":"click",title:R}).append(V("<span>").addClass("ui-icon ui-icon-circle-triangle-"+(N?"w":"e")).text(R))[0].outerHTML:W?"":V("<a>").attr({class:"ui-datepicker-next ui-corner-all ui-state-disabled",title:R}).append(V("<span>").attr("class","ui-icon ui-icon-circle-triangle-"+(N?"w":"e")).text(R))[0].outerHTML,A=this._get(t,"currentText"),W=this._get(t,"gotoCurrent")&&t.currentDay?B:O,A=F?this.formatDate(A,W,this._getFormatConfig(t)):A,R="",t.inline||(R=V("<button>").attr({type:"button",class:"ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all","data-handler":"hide","data-event":"click"}).text(this._get(t,"closeText"))[0].outerHTML),F="",E&&(F=V("<div class='ui-datepicker-buttonpane ui-widget-content'>").append(N?R:"").append(this._isInRange(t,W)?V("<button>").attr({type:"button",class:"ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all","data-handler":"today","data-event":"click"}).text(A):"").append(N?"":R)[0].outerHTML),n=parseInt(this._get(t,"firstDay"),10),n=isNaN(n)?0:n,o=this._get(t,"showWeek"),a=this._get(t,"dayNames"),r=this._get(t,"dayNamesMin"),l=this._get(t,"monthNames"),h=this._get(t,"monthNamesShort"),c=this._get(t,"beforeShowDay"),u=this._get(t,"showOtherMonths"),d=this._get(t,"selectOtherMonths"),p=this._getDefaultDate(t),f="",m=0;m<L[0];m++){for(_="",this.maxRows=4,v=0;v<L[1];v++){if(b=this._daylightSavingAdjust(new Date(U,K,t.selectedDay)),y=" ui-corner-all",w="",Y){if(w+="<div class='ui-datepicker-group",1<L[1])switch(v){case 0:w+=" ui-datepicker-group-first",y=" ui-corner-"+(N?"right":"left");break;case L[1]-1:w+=" ui-datepicker-group-last",y=" ui-corner-"+(N?"left":"right");break;default:w+=" ui-datepicker-group-middle",y=""}w+="'>"}for(w+="<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix"+y+"'>"+(/all|left/.test(y)&&0===m?N?s:i:"")+(/all|right/.test(y)&&0===m?N?i:s:"")+this._generateMonthYearHeader(t,K,U,j,q,0<m||0<v,l,h)+"</div><table class='ui-datepicker-calendar'><thead><tr>",x=o?"<th class='ui-datepicker-week-col'>"+this._get(t,"weekHeader")+"</th>":"",g=0;g<7;g++)x+="<th scope='col'"+(5<=(g+n+6)%7?" class='ui-datepicker-week-end'":"")+"><span title='"+a[k=(g+n)%7]+"'>"+r[k]+"</span></th>";for(w+=x+"</tr></thead><tbody>",D=this._getDaysInMonth(U,K),U===t.selectedYear&&K===t.selectedMonth&&(t.selectedDay=Math.min(t.selectedDay,D)),C=(this._getFirstDayOfMonth(U,K)-n+7)%7,D=Math.ceil((C+D)/7),I=Y&&this.maxRows>D?this.maxRows:D,this.maxRows=I,T=this._daylightSavingAdjust(new Date(U,K,1-C)),P=0;P<I;P++){for(w+="<tr>",M=o?"<td class='ui-datepicker-week-col'>"+this._get(t,"calculateWeek")(T)+"</td>":"",g=0;g<7;g++)S=c?c.apply(t.input?t.input[0]:null,[T]):[!0,""],z=(H=T.getMonth()!==K)&&!d||!S[0]||j&&T<j||q&&q<T,M+="<td class='"+(5<=(g+n+6)%7?" ui-datepicker-week-end":"")+(H?" ui-datepicker-other-month":"")+(T.getTime()===b.getTime()&&K===t.selectedMonth&&t._keyEvent||p.getTime()===T.getTime()&&p.getTime()===b.getTime()?" "+this._dayOverClass:"")+(z?" "+this._unselectableClass+" ui-state-disabled":"")+(H&&!u?"":" "+S[1]+(T.getTime()===B.getTime()?" "+this._currentClass:"")+(T.getTime()===O.getTime()?" ui-datepicker-today":""))+"'"+(H&&!u||!S[2]?"":" title='"+S[2].replace(/'/g,"&#39;")+"'")+(z?"":" data-handler='selectDay' data-event='click' data-month='"+T.getMonth()+"' data-year='"+T.getFullYear()+"'")+">"+(H&&!u?"&#xa0;":z?"<span class='ui-state-default'>"+T.getDate()+"</span>":"<a class='ui-state-default"+(T.getTime()===O.getTime()?" ui-state-highlight":"")+(T.getTime()===B.getTime()?" ui-state-active":"")+(H?" ui-priority-secondary":"")+"' href='#' aria-current='"+(T.getTime()===B.getTime()?"true":"false")+"' data-date='"+T.getDate()+"'>"+T.getDate()+"</a>")+"</td>",T.setDate(T.getDate()+1),T=this._daylightSavingAdjust(T);w+=M+"</tr>"}11<++K&&(K=0,U++),_+=w+="</tbody></table>"+(Y?"</div>"+(0<L[0]&&v===L[1]-1?"<div class='ui-datepicker-row-break'></div>":""):"")}f+=_}return f+=F,t._keyEvent=!1,f},_generateMonthYearHeader:function(t,e,i,s,n,o,a,r){var l,h,c,u,d,p,f=this._get(t,"changeMonth"),g=this._get(t,"changeYear"),m=this._get(t,"showMonthAfterYear"),_=this._get(t,"selectMonthLabel"),v=this._get(t,"selectYearLabel"),b="<div class='ui-datepicker-title'>",y="";if(o||!f)y+="<span class='ui-datepicker-month'>"+a[e]+"</span>";else{for(l=s&&s.getFullYear()===i,h=n&&n.getFullYear()===i,y+="<select class='ui-datepicker-month' aria-label='"+_+"' data-handler='selectMonth' data-event='change'>",c=0;c<12;c++)(!l||c>=s.getMonth())&&(!h||c<=n.getMonth())&&(y+="<option value='"+c+"'"+(c===e?" selected='selected'":"")+">"+r[c]+"</option>");y+="</select>"}if(m||(b+=y+(!o&&f&&g?"":"&#xa0;")),!t.yearshtml)if(t.yearshtml="",o||!g)b+="<span class='ui-datepicker-year'>"+i+"</span>";else{for(a=this._get(t,"yearRange").split(":"),u=(new Date).getFullYear(),d=(_=function(t){t=t.match(/c[+\-].*/)?i+parseInt(t.substring(1),10):t.match(/[+\-].*/)?u+parseInt(t,10):parseInt(t,10);return isNaN(t)?u:t})(a[0]),p=Math.max(d,_(a[1]||"")),d=s?Math.max(d,s.getFullYear()):d,p=n?Math.min(p,n.getFullYear()):p,t.yearshtml+="<select class='ui-datepicker-year' aria-label='"+v+"' data-handler='selectYear' data-event='change'>";d<=p;d++)t.yearshtml+="<option value='"+d+"'"+(d===i?" selected='selected'":"")+">"+d+"</option>";t.yearshtml+="</select>",b+=t.yearshtml,t.yearshtml=null}return b+=this._get(t,"yearSuffix"),m&&(b+=(!o&&f&&g?"":"&#xa0;")+y),b+="</div>"},_adjustInstDate:function(t,e,i){var s=t.selectedYear+("Y"===i?e:0),n=t.selectedMonth+("M"===i?e:0),e=Math.min(t.selectedDay,this._getDaysInMonth(s,n))+("D"===i?e:0),e=this._restrictMinMax(t,this._daylightSavingAdjust(new Date(s,n,e)));t.selectedDay=e.getDate(),t.drawMonth=t.selectedMonth=e.getMonth(),t.drawYear=t.selectedYear=e.getFullYear(),"M"!==i&&"Y"!==i||this._notifyChange(t)},_restrictMinMax:function(t,e){var i=this._getMinMaxDate(t,"min"),t=this._getMinMaxDate(t,"max"),e=i&&e<i?i:e;return t&&t<e?t:e},_notifyChange:function(t){var e=this._get(t,"onChangeMonthYear");e&&e.apply(t.input?t.input[0]:null,[t.selectedYear,t.selectedMonth+1,t])},_getNumberOfMonths:function(t){t=this._get(t,"numberOfMonths");return null==t?[1,1]:"number"==typeof t?[1,t]:t},_getMinMaxDate:function(t,e){return this._determineDate(t,this._get(t,e+"Date"),null)},_getDaysInMonth:function(t,e){return 32-this._daylightSavingAdjust(new Date(t,e,32)).getDate()},_getFirstDayOfMonth:function(t,e){return new Date(t,e,1).getDay()},_canAdjustMonth:function(t,e,i,s){var n=this._getNumberOfMonths(t),n=this._daylightSavingAdjust(new Date(i,s+(e<0?e:n[0]*n[1]),1));return e<0&&n.setDate(this._getDaysInMonth(n.getFullYear(),n.getMonth())),this._isInRange(t,n)},_isInRange:function(t,e){var i=this._getMinMaxDate(t,"min"),s=this._getMinMaxDate(t,"max"),n=null,o=null,a=this._get(t,"yearRange");return a&&(t=a.split(":"),a=(new Date).getFullYear(),n=parseInt(t[0],10),o=parseInt(t[1],10),t[0].match(/[+\-].*/)&&(n+=a),t[1].match(/[+\-].*/)&&(o+=a)),(!i||e.getTime()>=i.getTime())&&(!s||e.getTime()<=s.getTime())&&(!n||e.getFullYear()>=n)&&(!o||e.getFullYear()<=o)},_getFormatConfig:function(t){var e=this._get(t,"shortYearCutoff");return{shortYearCutoff:e="string"!=typeof e?e:(new Date).getFullYear()%100+parseInt(e,10),dayNamesShort:this._get(t,"dayNamesShort"),dayNames:this._get(t,"dayNames"),monthNamesShort:this._get(t,"monthNamesShort"),monthNames:this._get(t,"monthNames")}},_formatDate:function(t,e,i,s){e||(t.currentDay=t.selectedDay,t.currentMonth=t.selectedMonth,t.currentYear=t.selectedYear);e=e?"object"==typeof e?e:this._daylightSavingAdjust(new Date(s,i,e)):this._daylightSavingAdjust(new Date(t.currentYear,t.currentMonth,t.currentDay));return this.formatDate(this._get(t,"dateFormat"),e,this._getFormatConfig(t))}}),V.fn.datepicker=function(t){if(!this.length)return this;V.datepicker.initialized||(V(document).on("mousedown",V.datepicker._checkExternalClick),V.datepicker.initialized=!0),0===V("#"+V.datepicker._mainDivId).length&&V("body").append(V.datepicker.dpDiv);var e=Array.prototype.slice.call(arguments,1);return"string"==typeof t&&("isDisabled"===t||"getDate"===t||"widget"===t)||"option"===t&&2===arguments.length&&"string"==typeof arguments[1]?V.datepicker["_"+t+"Datepicker"].apply(V.datepicker,[this[0]].concat(e)):this.each(function(){"string"==typeof t?V.datepicker["_"+t+"Datepicker"].apply(V.datepicker,[this].concat(e)):V.datepicker._attachDatepicker(this,t)})},V.datepicker=new st,V.datepicker.initialized=!1,V.datepicker.uuid=(new Date).getTime(),V.datepicker.version="1.13.2";V.datepicker,V.ui.ie=!!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());var rt=!1;V(document).on("mouseup",function(){rt=!1});V.widget("ui.mouse",{version:"1.13.2",options:{cancel:"input, textarea, button, select, option",distance:1,delay:0},_mouseInit:function(){var e=this;this.element.on("mousedown."+this.widgetName,function(t){return e._mouseDown(t)}).on("click."+this.widgetName,function(t){if(!0===V.data(t.target,e.widgetName+".preventClickEvent"))return V.removeData(t.target,e.widgetName+".preventClickEvent"),t.stopImmediatePropagation(),!1}),this.started=!1},_mouseDestroy:function(){this.element.off("."+this.widgetName),this._mouseMoveDelegate&&this.document.off("mousemove."+this.widgetName,this._mouseMoveDelegate).off("mouseup."+this.widgetName,this._mouseUpDelegate)},_mouseDown:function(t){if(!rt){this._mouseMoved=!1,this._mouseStarted&&this._mouseUp(t),this._mouseDownEvent=t;var e=this,i=1===t.which,s=!("string"!=typeof this.options.cancel||!t.target.nodeName)&&V(t.target).closest(this.options.cancel).length;return i&&!s&&this._mouseCapture(t)?(this.mouseDelayMet=!this.options.delay,this.mouseDelayMet||(this._mouseDelayTimer=setTimeout(function(){e.mouseDelayMet=!0},this.options.delay)),this._mouseDistanceMet(t)&&this._mouseDelayMet(t)&&(this._mouseStarted=!1!==this._mouseStart(t),!this._mouseStarted)?(t.preventDefault(),!0):(!0===V.data(t.target,this.widgetName+".preventClickEvent")&&V.removeData(t.target,this.widgetName+".preventClickEvent"),this._mouseMoveDelegate=function(t){return e._mouseMove(t)},this._mouseUpDelegate=function(t){return e._mouseUp(t)},this.document.on("mousemove."+this.widgetName,this._mouseMoveDelegate).on("mouseup."+this.widgetName,this._mouseUpDelegate),t.preventDefault(),rt=!0)):!0}},_mouseMove:function(t){if(this._mouseMoved){if(V.ui.ie&&(!document.documentMode||document.documentMode<9)&&!t.button)return this._mouseUp(t);if(!t.which)if(t.originalEvent.altKey||t.originalEvent.ctrlKey||t.originalEvent.metaKey||t.originalEvent.shiftKey)this.ignoreMissingWhich=!0;else if(!this.ignoreMissingWhich)return this._mouseUp(t)}return(t.which||t.button)&&(this._mouseMoved=!0),this._mouseStarted?(this._mouseDrag(t),t.preventDefault()):(this._mouseDistanceMet(t)&&this._mouseDelayMet(t)&&(this._mouseStarted=!1!==this._mouseStart(this._mouseDownEvent,t),this._mouseStarted?this._mouseDrag(t):this._mouseUp(t)),!this._mouseStarted)},_mouseUp:function(t){this.document.off("mousemove."+this.widgetName,this._mouseMoveDelegate).off("mouseup."+this.widgetName,this._mouseUpDelegate),this._mouseStarted&&(this._mouseStarted=!1,t.target===this._mouseDownEvent.target&&V.data(t.target,this.widgetName+".preventClickEvent",!0),this._mouseStop(t)),this._mouseDelayTimer&&(clearTimeout(this._mouseDelayTimer),delete this._mouseDelayTimer),this.ignoreMissingWhich=!1,rt=!1,t.preventDefault()},_mouseDistanceMet:function(t){return Math.max(Math.abs(this._mouseDownEvent.pageX-t.pageX),Math.abs(this._mouseDownEvent.pageY-t.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return!0}}),V.ui.plugin={add:function(t,e,i){var s,n=V.ui[t].prototype;for(s in i)n.plugins[s]=n.plugins[s]||[],n.plugins[s].push([e,i[s]])},call:function(t,e,i,s){var n,o=t.plugins[e];if(o&&(s||t.element[0].parentNode&&11!==t.element[0].parentNode.nodeType))for(n=0;n<o.length;n++)t.options[o[n][0]]&&o[n][1].apply(t.element,i)}},V.ui.safeBlur=function(t){t&&"body"!==t.nodeName.toLowerCase()&&V(t).trigger("blur")};V.widget("ui.draggable",V.ui.mouse,{version:"1.13.2",widgetEventPrefix:"drag",options:{addClasses:!0,appendTo:"parent",axis:!1,connectToSortable:!1,containment:!1,cursor:"auto",cursorAt:!1,grid:!1,handle:!1,helper:"original",iframeFix:!1,opacity:!1,refreshPositions:!1,revert:!1,revertDuration:500,scope:"default",scroll:!0,scrollSensitivity:20,scrollSpeed:20,snap:!1,snapMode:"both",snapTolerance:20,stack:!1,zIndex:!1,drag:null,start:null,stop:null},_create:function(){"original"===this.options.helper&&this._setPositionRelative(),this.options.addClasses&&this._addClass("ui-draggable"),this._setHandleClassName(),this._mouseInit()},_setOption:function(t,e){this._super(t,e),"handle"===t&&(this._removeHandleClassName(),this._setHandleClassName())},_destroy:function(){(this.helper||this.element).is(".ui-draggable-dragging")?this.destroyOnClear=!0:(this._removeHandleClassName(),this._mouseDestroy())},_mouseCapture:function(t){var e=this.options;return!(this.helper||e.disabled||0<V(t.target).closest(".ui-resizable-handle").length)&&(this.handle=this._getHandle(t),!!this.handle&&(this._blurActiveElement(t),this._blockFrames(!0===e.iframeFix?"iframe":e.iframeFix),!0))},_blockFrames:function(t){this.iframeBlocks=this.document.find(t).map(function(){var t=V(this);return V("<div>").css("position","absolute").appendTo(t.parent()).outerWidth(t.outerWidth()).outerHeight(t.outerHeight()).offset(t.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_blurActiveElement:function(t){var e=V.ui.safeActiveElement(this.document[0]);V(t.target).closest(e).length||V.ui.safeBlur(e)},_mouseStart:function(t){var e=this.options;return this.helper=this._createHelper(t),this._addClass(this.helper,"ui-draggable-dragging"),this._cacheHelperProportions(),V.ui.ddmanager&&(V.ui.ddmanager.current=this),this._cacheMargins(),this.cssPosition=this.helper.css("position"),this.scrollParent=this.helper.scrollParent(!0),this.offsetParent=this.helper.offsetParent(),this.hasFixedAncestor=0<this.helper.parents().filter(function(){return"fixed"===V(this).css("position")}).length,this.positionAbs=this.element.offset(),this._refreshOffsets(t),this.originalPosition=this.position=this._generatePosition(t,!1),this.originalPageX=t.pageX,this.originalPageY=t.pageY,e.cursorAt&&this._adjustOffsetFromHelper(e.cursorAt),this._setContainment(),!1===this._trigger("start",t)?(this._clear(),!1):(this._cacheHelperProportions(),V.ui.ddmanager&&!e.dropBehaviour&&V.ui.ddmanager.prepareOffsets(this,t),this._mouseDrag(t,!0),V.ui.ddmanager&&V.ui.ddmanager.dragStart(this,t),!0)},_refreshOffsets:function(t){this.offset={top:this.positionAbs.top-this.margins.top,left:this.positionAbs.left-this.margins.left,scroll:!1,parent:this._getParentOffset(),relative:this._getRelativeOffset()},this.offset.click={left:t.pageX-this.offset.left,top:t.pageY-this.offset.top}},_mouseDrag:function(t,e){if(this.hasFixedAncestor&&(this.offset.parent=this._getParentOffset()),this.position=this._generatePosition(t,!0),this.positionAbs=this._convertPositionTo("absolute"),!e){e=this._uiHash();if(!1===this._trigger("drag",t,e))return this._mouseUp(new V.Event("mouseup",t)),!1;this.position=e.position}return this.helper[0].style.left=this.position.left+"px",this.helper[0].style.top=this.position.top+"px",V.ui.ddmanager&&V.ui.ddmanager.drag(this,t),!1},_mouseStop:function(t){var e=this,i=!1;return V.ui.ddmanager&&!this.options.dropBehaviour&&(i=V.ui.ddmanager.drop(this,t)),this.dropped&&(i=this.dropped,this.dropped=!1),"invalid"===this.options.revert&&!i||"valid"===this.options.revert&&i||!0===this.options.revert||"function"==typeof this.options.revert&&this.options.revert.call(this.element,i)?V(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,10),function(){!1!==e._trigger("stop",t)&&e._clear()}):!1!==this._trigger("stop",t)&&this._clear(),!1},_mouseUp:function(t){return this._unblockFrames(),V.ui.ddmanager&&V.ui.ddmanager.dragStop(this,t),this.handleElement.is(t.target)&&this.element.trigger("focus"),V.ui.mouse.prototype._mouseUp.call(this,t)},cancel:function(){return this.helper.is(".ui-draggable-dragging")?this._mouseUp(new V.Event("mouseup",{target:this.element[0]})):this._clear(),this},_getHandle:function(t){return!this.options.handle||!!V(t.target).closest(this.element.find(this.options.handle)).length},_setHandleClassName:function(){this.handleElement=this.options.handle?this.element.find(this.options.handle):this.element,this._addClass(this.handleElement,"ui-draggable-handle")},_removeHandleClassName:function(){this._removeClass(this.handleElement,"ui-draggable-handle")},_createHelper:function(t){var e=this.options,i="function"==typeof e.helper,t=i?V(e.helper.apply(this.element[0],[t])):"clone"===e.helper?this.element.clone().removeAttr("id"):this.element;return t.parents("body").length||t.appendTo("parent"===e.appendTo?this.element[0].parentNode:e.appendTo),i&&t[0]===this.element[0]&&this._setPositionRelative(),t[0]===this.element[0]||/(fixed|absolute)/.test(t.css("position"))||t.css("position","absolute"),t},_setPositionRelative:function(){/^(?:r|a|f)/.test(this.element.css("position"))||(this.element[0].style.position="relative")},_adjustOffsetFromHelper:function(t){"string"==typeof t&&(t=t.split(" ")),"left"in(t=Array.isArray(t)?{left:+t[0],top:+t[1]||0}:t)&&(this.offset.click.left=t.left+this.margins.left),"right"in t&&(this.offset.click.left=this.helperProportions.width-t.right+this.margins.left),"top"in t&&(this.offset.click.top=t.top+this.margins.top),"bottom"in t&&(this.offset.click.top=this.helperProportions.height-t.bottom+this.margins.top)},_isRootNode:function(t){return/(html|body)/i.test(t.tagName)||t===this.document[0]},_getParentOffset:function(){var t=this.offsetParent.offset(),e=this.document[0];return"absolute"===this.cssPosition&&this.scrollParent[0]!==e&&V.contains(this.scrollParent[0],this.offsetParent[0])&&(t.left+=this.scrollParent.scrollLeft(),t.top+=this.scrollParent.scrollTop()),{top:(t=this._isRootNode(this.offsetParent[0])?{top:0,left:0}:t).top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:t.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"!==this.cssPosition)return{top:0,left:0};var t=this.element.position(),e=this._isRootNode(this.scrollParent[0]);return{top:t.top-(parseInt(this.helper.css("top"),10)||0)+(e?0:this.scrollParent.scrollTop()),left:t.left-(parseInt(this.helper.css("left"),10)||0)+(e?0:this.scrollParent.scrollLeft())}},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var t,e,i,s=this.options,n=this.document[0];this.relativeContainer=null,s.containment?"window"!==s.containment?"document"!==s.containment?s.containment.constructor!==Array?("parent"===s.containment&&(s.containment=this.helper[0].parentNode),(i=(e=V(s.containment))[0])&&(t=/(scroll|auto)/.test(e.css("overflow")),this.containment=[(parseInt(e.css("borderLeftWidth"),10)||0)+(parseInt(e.css("paddingLeft"),10)||0),(parseInt(e.css("borderTopWidth"),10)||0)+(parseInt(e.css("paddingTop"),10)||0),(t?Math.max(i.scrollWidth,i.offsetWidth):i.offsetWidth)-(parseInt(e.css("borderRightWidth"),10)||0)-(parseInt(e.css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(t?Math.max(i.scrollHeight,i.offsetHeight):i.offsetHeight)-(parseInt(e.css("borderBottomWidth"),10)||0)-(parseInt(e.css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom],this.relativeContainer=e)):this.containment=s.containment:this.containment=[0,0,V(n).width()-this.helperProportions.width-this.margins.left,(V(n).height()||n.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]:this.containment=[V(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,V(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,V(window).scrollLeft()+V(window).width()-this.helperProportions.width-this.margins.left,V(window).scrollTop()+(V(window).height()||n.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]:this.containment=null},_convertPositionTo:function(t,e){e=e||this.position;var i="absolute"===t?1:-1,t=this._isRootNode(this.scrollParent[0]);return{top:e.top+this.offset.relative.top*i+this.offset.parent.top*i-("fixed"===this.cssPosition?-this.offset.scroll.top:t?0:this.offset.scroll.top)*i,left:e.left+this.offset.relative.left*i+this.offset.parent.left*i-("fixed"===this.cssPosition?-this.offset.scroll.left:t?0:this.offset.scroll.left)*i}},_generatePosition:function(t,e){var i,s=this.options,n=this._isRootNode(this.scrollParent[0]),o=t.pageX,a=t.pageY;return n&&this.offset.scroll||(this.offset.scroll={top:this.scrollParent.scrollTop(),left:this.scrollParent.scrollLeft()}),e&&(this.containment&&(i=this.relativeContainer?(i=this.relativeContainer.offset(),[this.containment[0]+i.left,this.containment[1]+i.top,this.containment[2]+i.left,this.containment[3]+i.top]):this.containment,t.pageX-this.offset.click.left<i[0]&&(o=i[0]+this.offset.click.left),t.pageY-this.offset.click.top<i[1]&&(a=i[1]+this.offset.click.top),t.pageX-this.offset.click.left>i[2]&&(o=i[2]+this.offset.click.left),t.pageY-this.offset.click.top>i[3]&&(a=i[3]+this.offset.click.top)),s.grid&&(t=s.grid[1]?this.originalPageY+Math.round((a-this.originalPageY)/s.grid[1])*s.grid[1]:this.originalPageY,a=!i||t-this.offset.click.top>=i[1]||t-this.offset.click.top>i[3]?t:t-this.offset.click.top>=i[1]?t-s.grid[1]:t+s.grid[1],t=s.grid[0]?this.originalPageX+Math.round((o-this.originalPageX)/s.grid[0])*s.grid[0]:this.originalPageX,o=!i||t-this.offset.click.left>=i[0]||t-this.offset.click.left>i[2]?t:t-this.offset.click.left>=i[0]?t-s.grid[0]:t+s.grid[0]),"y"===s.axis&&(o=this.originalPageX),"x"===s.axis&&(a=this.originalPageY)),{top:a-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.offset.scroll.top:n?0:this.offset.scroll.top),left:o-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.offset.scroll.left:n?0:this.offset.scroll.left)}},_clear:function(){this._removeClass(this.helper,"ui-draggable-dragging"),this.helper[0]===this.element[0]||this.cancelHelperRemoval||this.helper.remove(),this.helper=null,this.cancelHelperRemoval=!1,this.destroyOnClear&&this.destroy()},_trigger:function(t,e,i){return i=i||this._uiHash(),V.ui.plugin.call(this,t,[e,i,this],!0),/^(drag|start|stop)/.test(t)&&(this.positionAbs=this._convertPositionTo("absolute"),i.offset=this.positionAbs),V.Widget.prototype._trigger.call(this,t,e,i)},plugins:{},_uiHash:function(){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}}),V.ui.plugin.add("draggable","connectToSortable",{start:function(e,t,i){var s=V.extend({},t,{item:i.element});i.sortables=[],V(i.options.connectToSortable).each(function(){var t=V(this).sortable("instance");t&&!t.options.disabled&&(i.sortables.push(t),t.refreshPositions(),t._trigger("activate",e,s))})},stop:function(e,t,i){var s=V.extend({},t,{item:i.element});i.cancelHelperRemoval=!1,V.each(i.sortables,function(){var t=this;t.isOver?(t.isOver=0,i.cancelHelperRemoval=!0,t.cancelHelperRemoval=!1,t._storedCSS={position:t.placeholder.css("position"),top:t.placeholder.css("top"),left:t.placeholder.css("left")},t._mouseStop(e),t.options.helper=t.options._helper):(t.cancelHelperRemoval=!0,t._trigger("deactivate",e,s))})},drag:function(i,s,n){V.each(n.sortables,function(){var t=!1,e=this;e.positionAbs=n.positionAbs,e.helperProportions=n.helperProportions,e.offset.click=n.offset.click,e._intersectsWith(e.containerCache)&&(t=!0,V.each(n.sortables,function(){return this.positionAbs=n.positionAbs,this.helperProportions=n.helperProportions,this.offset.click=n.offset.click,t=this!==e&&this._intersectsWith(this.containerCache)&&V.contains(e.element[0],this.element[0])?!1:t})),t?(e.isOver||(e.isOver=1,n._parent=s.helper.parent(),e.currentItem=s.helper.appendTo(e.element).data("ui-sortable-item",!0),e.options._helper=e.options.helper,e.options.helper=function(){return s.helper[0]},i.target=e.currentItem[0],e._mouseCapture(i,!0),e._mouseStart(i,!0,!0),e.offset.click.top=n.offset.click.top,e.offset.click.left=n.offset.click.left,e.offset.parent.left-=n.offset.parent.left-e.offset.parent.left,e.offset.parent.top-=n.offset.parent.top-e.offset.parent.top,n._trigger("toSortable",i),n.dropped=e.element,V.each(n.sortables,function(){this.refreshPositions()}),n.currentItem=n.element,e.fromOutside=n),e.currentItem&&(e._mouseDrag(i),s.position=e.position)):e.isOver&&(e.isOver=0,e.cancelHelperRemoval=!0,e.options._revert=e.options.revert,e.options.revert=!1,e._trigger("out",i,e._uiHash(e)),e._mouseStop(i,!0),e.options.revert=e.options._revert,e.options.helper=e.options._helper,e.placeholder&&e.placeholder.remove(),s.helper.appendTo(n._parent),n._refreshOffsets(i),s.position=n._generatePosition(i,!0),n._trigger("fromSortable",i),n.dropped=!1,V.each(n.sortables,function(){this.refreshPositions()}))})}}),V.ui.plugin.add("draggable","cursor",{start:function(t,e,i){var s=V("body"),i=i.options;s.css("cursor")&&(i._cursor=s.css("cursor")),s.css("cursor",i.cursor)},stop:function(t,e,i){i=i.options;i._cursor&&V("body").css("cursor",i._cursor)}}),V.ui.plugin.add("draggable","opacity",{start:function(t,e,i){e=V(e.helper),i=i.options;e.css("opacity")&&(i._opacity=e.css("opacity")),e.css("opacity",i.opacity)},stop:function(t,e,i){i=i.options;i._opacity&&V(e.helper).css("opacity",i._opacity)}}),V.ui.plugin.add("draggable","scroll",{start:function(t,e,i){i.scrollParentNotHidden||(i.scrollParentNotHidden=i.helper.scrollParent(!1)),i.scrollParentNotHidden[0]!==i.document[0]&&"HTML"!==i.scrollParentNotHidden[0].tagName&&(i.overflowOffset=i.scrollParentNotHidden.offset())},drag:function(t,e,i){var s=i.options,n=!1,o=i.scrollParentNotHidden[0],a=i.document[0];o!==a&&"HTML"!==o.tagName?(s.axis&&"x"===s.axis||(i.overflowOffset.top+o.offsetHeight-t.pageY<s.scrollSensitivity?o.scrollTop=n=o.scrollTop+s.scrollSpeed:t.pageY-i.overflowOffset.top<s.scrollSensitivity&&(o.scrollTop=n=o.scrollTop-s.scrollSpeed)),s.axis&&"y"===s.axis||(i.overflowOffset.left+o.offsetWidth-t.pageX<s.scrollSensitivity?o.scrollLeft=n=o.scrollLeft+s.scrollSpeed:t.pageX-i.overflowOffset.left<s.scrollSensitivity&&(o.scrollLeft=n=o.scrollLeft-s.scrollSpeed))):(s.axis&&"x"===s.axis||(t.pageY-V(a).scrollTop()<s.scrollSensitivity?n=V(a).scrollTop(V(a).scrollTop()-s.scrollSpeed):V(window).height()-(t.pageY-V(a).scrollTop())<s.scrollSensitivity&&(n=V(a).scrollTop(V(a).scrollTop()+s.scrollSpeed))),s.axis&&"y"===s.axis||(t.pageX-V(a).scrollLeft()<s.scrollSensitivity?n=V(a).scrollLeft(V(a).scrollLeft()-s.scrollSpeed):V(window).width()-(t.pageX-V(a).scrollLeft())<s.scrollSensitivity&&(n=V(a).scrollLeft(V(a).scrollLeft()+s.scrollSpeed)))),!1!==n&&V.ui.ddmanager&&!s.dropBehaviour&&V.ui.ddmanager.prepareOffsets(i,t)}}),V.ui.plugin.add("draggable","snap",{start:function(t,e,i){var s=i.options;i.snapElements=[],V(s.snap.constructor!==String?s.snap.items||":data(ui-draggable)":s.snap).each(function(){var t=V(this),e=t.offset();this!==i.element[0]&&i.snapElements.push({item:this,width:t.outerWidth(),height:t.outerHeight(),top:e.top,left:e.left})})},drag:function(t,e,i){for(var s,n,o,a,r,l,h,c,u,d=i.options,p=d.snapTolerance,f=e.offset.left,g=f+i.helperProportions.width,m=e.offset.top,_=m+i.helperProportions.height,v=i.snapElements.length-1;0<=v;v--)l=(r=i.snapElements[v].left-i.margins.left)+i.snapElements[v].width,c=(h=i.snapElements[v].top-i.margins.top)+i.snapElements[v].height,g<r-p||l+p<f||_<h-p||c+p<m||!V.contains(i.snapElements[v].item.ownerDocument,i.snapElements[v].item)?(i.snapElements[v].snapping&&i.options.snap.release&&i.options.snap.release.call(i.element,t,V.extend(i._uiHash(),{snapItem:i.snapElements[v].item})),i.snapElements[v].snapping=!1):("inner"!==d.snapMode&&(s=Math.abs(h-_)<=p,n=Math.abs(c-m)<=p,o=Math.abs(r-g)<=p,a=Math.abs(l-f)<=p,s&&(e.position.top=i._convertPositionTo("relative",{top:h-i.helperProportions.height,left:0}).top),n&&(e.position.top=i._convertPositionTo("relative",{top:c,left:0}).top),o&&(e.position.left=i._convertPositionTo("relative",{top:0,left:r-i.helperProportions.width}).left),a&&(e.position.left=i._convertPositionTo("relative",{top:0,left:l}).left)),u=s||n||o||a,"outer"!==d.snapMode&&(s=Math.abs(h-m)<=p,n=Math.abs(c-_)<=p,o=Math.abs(r-f)<=p,a=Math.abs(l-g)<=p,s&&(e.position.top=i._convertPositionTo("relative",{top:h,left:0}).top),n&&(e.position.top=i._convertPositionTo("relative",{top:c-i.helperProportions.height,left:0}).top),o&&(e.position.left=i._convertPositionTo("relative",{top:0,left:r}).left),a&&(e.position.left=i._convertPositionTo("relative",{top:0,left:l-i.helperProportions.width}).left)),!i.snapElements[v].snapping&&(s||n||o||a||u)&&i.options.snap.snap&&i.options.snap.snap.call(i.element,t,V.extend(i._uiHash(),{snapItem:i.snapElements[v].item})),i.snapElements[v].snapping=s||n||o||a||u)}}),V.ui.plugin.add("draggable","stack",{start:function(t,e,i){var s,i=i.options,i=V.makeArray(V(i.stack)).sort(function(t,e){return(parseInt(V(t).css("zIndex"),10)||0)-(parseInt(V(e).css("zIndex"),10)||0)});i.length&&(s=parseInt(V(i[0]).css("zIndex"),10)||0,V(i).each(function(t){V(this).css("zIndex",s+t)}),this.css("zIndex",s+i.length))}}),V.ui.plugin.add("draggable","zIndex",{start:function(t,e,i){e=V(e.helper),i=i.options;e.css("zIndex")&&(i._zIndex=e.css("zIndex")),e.css("zIndex",i.zIndex)},stop:function(t,e,i){i=i.options;i._zIndex&&V(e.helper).css("zIndex",i._zIndex)}});V.ui.draggable;V.widget("ui.resizable",V.ui.mouse,{version:"1.13.2",widgetEventPrefix:"resize",options:{alsoResize:!1,animate:!1,animateDuration:"slow",animateEasing:"swing",aspectRatio:!1,autoHide:!1,classes:{"ui-resizable-se":"ui-icon ui-icon-gripsmall-diagonal-se"},containment:!1,ghost:!1,grid:!1,handles:"e,s,se",helper:!1,maxHeight:null,maxWidth:null,minHeight:10,minWidth:10,zIndex:90,resize:null,start:null,stop:null},_num:function(t){return parseFloat(t)||0},_isNumber:function(t){return!isNaN(parseFloat(t))},_hasScroll:function(t,e){if("hidden"===V(t).css("overflow"))return!1;var i=e&&"left"===e?"scrollLeft":"scrollTop",e=!1;if(0<t[i])return!0;try{t[i]=1,e=0<t[i],t[i]=0}catch(t){}return e},_create:function(){var t,e=this.options,i=this;this._addClass("ui-resizable"),V.extend(this,{_aspectRatio:!!e.aspectRatio,aspectRatio:e.aspectRatio,originalElement:this.element,_proportionallyResizeElements:[],_helper:e.helper||e.ghost||e.animate?e.helper||"ui-resizable-helper":null}),this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)&&(this.element.wrap(V("<div class='ui-wrapper'></div>").css({overflow:"hidden",position:this.element.css("position"),width:this.element.outerWidth(),height:this.element.outerHeight(),top:this.element.css("top"),left:this.element.css("left")})),this.element=this.element.parent().data("ui-resizable",this.element.resizable("instance")),this.elementIsWrapper=!0,t={marginTop:this.originalElement.css("marginTop"),marginRight:this.originalElement.css("marginRight"),marginBottom:this.originalElement.css("marginBottom"),marginLeft:this.originalElement.css("marginLeft")},this.element.css(t),this.originalElement.css("margin",0),this.originalResizeStyle=this.originalElement.css("resize"),this.originalElement.css("resize","none"),this._proportionallyResizeElements.push(this.originalElement.css({position:"static",zoom:1,display:"block"})),this.originalElement.css(t),this._proportionallyResize()),this._setupHandles(),e.autoHide&&V(this.element).on("mouseenter",function(){e.disabled||(i._removeClass("ui-resizable-autohide"),i._handles.show())}).on("mouseleave",function(){e.disabled||i.resizing||(i._addClass("ui-resizable-autohide"),i._handles.hide())}),this._mouseInit()},_destroy:function(){this._mouseDestroy(),this._addedHandles.remove();function t(t){V(t).removeData("resizable").removeData("ui-resizable").off(".resizable")}var e;return this.elementIsWrapper&&(t(this.element),e=this.element,this.originalElement.css({position:e.css("position"),width:e.outerWidth(),height:e.outerHeight(),top:e.css("top"),left:e.css("left")}).insertAfter(e),e.remove()),this.originalElement.css("resize",this.originalResizeStyle),t(this.originalElement),this},_setOption:function(t,e){switch(this._super(t,e),t){case"handles":this._removeHandles(),this._setupHandles();break;case"aspectRatio":this._aspectRatio=!!e}},_setupHandles:function(){var t,e,i,s,n,o=this.options,a=this;if(this.handles=o.handles||(V(".ui-resizable-handle",this.element).length?{n:".ui-resizable-n",e:".ui-resizable-e",s:".ui-resizable-s",w:".ui-resizable-w",se:".ui-resizable-se",sw:".ui-resizable-sw",ne:".ui-resizable-ne",nw:".ui-resizable-nw"}:"e,s,se"),this._handles=V(),this._addedHandles=V(),this.handles.constructor===String)for("all"===this.handles&&(this.handles="n,e,s,w,se,sw,ne,nw"),i=this.handles.split(","),this.handles={},e=0;e<i.length;e++)s="ui-resizable-"+(t=String.prototype.trim.call(i[e])),n=V("<div>"),this._addClass(n,"ui-resizable-handle "+s),n.css({zIndex:o.zIndex}),this.handles[t]=".ui-resizable-"+t,this.element.children(this.handles[t]).length||(this.element.append(n),this._addedHandles=this._addedHandles.add(n));this._renderAxis=function(t){var e,i,s;for(e in t=t||this.element,this.handles)this.handles[e].constructor===String?this.handles[e]=this.element.children(this.handles[e]).first().show():(this.handles[e].jquery||this.handles[e].nodeType)&&(this.handles[e]=V(this.handles[e]),this._on(this.handles[e],{mousedown:a._mouseDown})),this.elementIsWrapper&&this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)&&(i=V(this.handles[e],this.element),s=/sw|ne|nw|se|n|s/.test(e)?i.outerHeight():i.outerWidth(),i=["padding",/ne|nw|n/.test(e)?"Top":/se|sw|s/.test(e)?"Bottom":/^e$/.test(e)?"Right":"Left"].join(""),t.css(i,s),this._proportionallyResize()),this._handles=this._handles.add(this.handles[e])},this._renderAxis(this.element),this._handles=this._handles.add(this.element.find(".ui-resizable-handle")),this._handles.disableSelection(),this._handles.on("mouseover",function(){a.resizing||(this.className&&(n=this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)),a.axis=n&&n[1]?n[1]:"se")}),o.autoHide&&(this._handles.hide(),this._addClass("ui-resizable-autohide"))},_removeHandles:function(){this._addedHandles.remove()},_mouseCapture:function(t){var e,i,s=!1;for(e in this.handles)(i=V(this.handles[e])[0])!==t.target&&!V.contains(i,t.target)||(s=!0);return!this.options.disabled&&s},_mouseStart:function(t){var e,i,s=this.options,n=this.element;return this.resizing=!0,this._renderProxy(),e=this._num(this.helper.css("left")),i=this._num(this.helper.css("top")),s.containment&&(e+=V(s.containment).scrollLeft()||0,i+=V(s.containment).scrollTop()||0),this.offset=this.helper.offset(),this.position={left:e,top:i},this.size=this._helper?{width:this.helper.width(),height:this.helper.height()}:{width:n.width(),height:n.height()},this.originalSize=this._helper?{width:n.outerWidth(),height:n.outerHeight()}:{width:n.width(),height:n.height()},this.sizeDiff={width:n.outerWidth()-n.width(),height:n.outerHeight()-n.height()},this.originalPosition={left:e,top:i},this.originalMousePosition={left:t.pageX,top:t.pageY},this.aspectRatio="number"==typeof s.aspectRatio?s.aspectRatio:this.originalSize.width/this.originalSize.height||1,s=V(".ui-resizable-"+this.axis).css("cursor"),V("body").css("cursor","auto"===s?this.axis+"-resize":s),this._addClass("ui-resizable-resizing"),this._propagate("start",t),!0},_mouseDrag:function(t){var e=this.originalMousePosition,i=this.axis,s=t.pageX-e.left||0,e=t.pageY-e.top||0,i=this._change[i];return this._updatePrevProperties(),i&&(e=i.apply(this,[t,s,e]),this._updateVirtualBoundaries(t.shiftKey),(this._aspectRatio||t.shiftKey)&&(e=this._updateRatio(e,t)),e=this._respectSize(e,t),this._updateCache(e),this._propagate("resize",t),e=this._applyChanges(),!this._helper&&this._proportionallyResizeElements.length&&this._proportionallyResize(),V.isEmptyObject(e)||(this._updatePrevProperties(),this._trigger("resize",t,this.ui()),this._applyChanges())),!1},_mouseStop:function(t){this.resizing=!1;var e,i,s,n=this.options,o=this;return this._helper&&(s=(e=(i=this._proportionallyResizeElements).length&&/textarea/i.test(i[0].nodeName))&&this._hasScroll(i[0],"left")?0:o.sizeDiff.height,i=e?0:o.sizeDiff.width,e={width:o.helper.width()-i,height:o.helper.height()-s},i=parseFloat(o.element.css("left"))+(o.position.left-o.originalPosition.left)||null,s=parseFloat(o.element.css("top"))+(o.position.top-o.originalPosition.top)||null,n.animate||this.element.css(V.extend(e,{top:s,left:i})),o.helper.height(o.size.height),o.helper.width(o.size.width),this._helper&&!n.animate&&this._proportionallyResize()),V("body").css("cursor","auto"),this._removeClass("ui-resizable-resizing"),this._propagate("stop",t),this._helper&&this.helper.remove(),!1},_updatePrevProperties:function(){this.prevPosition={top:this.position.top,left:this.position.left},this.prevSize={width:this.size.width,height:this.size.height}},_applyChanges:function(){var t={};return this.position.top!==this.prevPosition.top&&(t.top=this.position.top+"px"),this.position.left!==this.prevPosition.left&&(t.left=this.position.left+"px"),this.size.width!==this.prevSize.width&&(t.width=this.size.width+"px"),this.size.height!==this.prevSize.height&&(t.height=this.size.height+"px"),this.helper.css(t),t},_updateVirtualBoundaries:function(t){var e,i,s=this.options,n={minWidth:this._isNumber(s.minWidth)?s.minWidth:0,maxWidth:this._isNumber(s.maxWidth)?s.maxWidth:1/0,minHeight:this._isNumber(s.minHeight)?s.minHeight:0,maxHeight:this._isNumber(s.maxHeight)?s.maxHeight:1/0};(this._aspectRatio||t)&&(e=n.minHeight*this.aspectRatio,i=n.minWidth/this.aspectRatio,s=n.maxHeight*this.aspectRatio,t=n.maxWidth/this.aspectRatio,e>n.minWidth&&(n.minWidth=e),i>n.minHeight&&(n.minHeight=i),s<n.maxWidth&&(n.maxWidth=s),t<n.maxHeight&&(n.maxHeight=t)),this._vBoundaries=n},_updateCache:function(t){this.offset=this.helper.offset(),this._isNumber(t.left)&&(this.position.left=t.left),this._isNumber(t.top)&&(this.position.top=t.top),this._isNumber(t.height)&&(this.size.height=t.height),this._isNumber(t.width)&&(this.size.width=t.width)},_updateRatio:function(t){var e=this.position,i=this.size,s=this.axis;return this._isNumber(t.height)?t.width=t.height*this.aspectRatio:this._isNumber(t.width)&&(t.height=t.width/this.aspectRatio),"sw"===s&&(t.left=e.left+(i.width-t.width),t.top=null),"nw"===s&&(t.top=e.top+(i.height-t.height),t.left=e.left+(i.width-t.width)),t},_respectSize:function(t){var e=this._vBoundaries,i=this.axis,s=this._isNumber(t.width)&&e.maxWidth&&e.maxWidth<t.width,n=this._isNumber(t.height)&&e.maxHeight&&e.maxHeight<t.height,o=this._isNumber(t.width)&&e.minWidth&&e.minWidth>t.width,a=this._isNumber(t.height)&&e.minHeight&&e.minHeight>t.height,r=this.originalPosition.left+this.originalSize.width,l=this.originalPosition.top+this.originalSize.height,h=/sw|nw|w/.test(i),i=/nw|ne|n/.test(i);return o&&(t.width=e.minWidth),a&&(t.height=e.minHeight),s&&(t.width=e.maxWidth),n&&(t.height=e.maxHeight),o&&h&&(t.left=r-e.minWidth),s&&h&&(t.left=r-e.maxWidth),a&&i&&(t.top=l-e.minHeight),n&&i&&(t.top=l-e.maxHeight),t.width||t.height||t.left||!t.top?t.width||t.height||t.top||!t.left||(t.left=null):t.top=null,t},_getPaddingPlusBorderDimensions:function(t){for(var e=0,i=[],s=[t.css("borderTopWidth"),t.css("borderRightWidth"),t.css("borderBottomWidth"),t.css("borderLeftWidth")],n=[t.css("paddingTop"),t.css("paddingRight"),t.css("paddingBottom"),t.css("paddingLeft")];e<4;e++)i[e]=parseFloat(s[e])||0,i[e]+=parseFloat(n[e])||0;return{height:i[0]+i[2],width:i[1]+i[3]}},_proportionallyResize:function(){if(this._proportionallyResizeElements.length)for(var t,e=0,i=this.helper||this.element;e<this._proportionallyResizeElements.length;e++)t=this._proportionallyResizeElements[e],this.outerDimensions||(this.outerDimensions=this._getPaddingPlusBorderDimensions(t)),t.css({height:i.height()-this.outerDimensions.height||0,width:i.width()-this.outerDimensions.width||0})},_renderProxy:function(){var t=this.element,e=this.options;this.elementOffset=t.offset(),this._helper?(this.helper=this.helper||V("<div></div>").css({overflow:"hidden"}),this._addClass(this.helper,this._helper),this.helper.css({width:this.element.outerWidth(),height:this.element.outerHeight(),position:"absolute",left:this.elementOffset.left+"px",top:this.elementOffset.top+"px",zIndex:++e.zIndex}),this.helper.appendTo("body").disableSelection()):this.helper=this.element},_change:{e:function(t,e){return{width:this.originalSize.width+e}},w:function(t,e){var i=this.originalSize;return{left:this.originalPosition.left+e,width:i.width-e}},n:function(t,e,i){var s=this.originalSize;return{top:this.originalPosition.top+i,height:s.height-i}},s:function(t,e,i){return{height:this.originalSize.height+i}},se:function(t,e,i){return V.extend(this._change.s.apply(this,arguments),this._change.e.apply(this,[t,e,i]))},sw:function(t,e,i){return V.extend(this._change.s.apply(this,arguments),this._change.w.apply(this,[t,e,i]))},ne:function(t,e,i){return V.extend(this._change.n.apply(this,arguments),this._change.e.apply(this,[t,e,i]))},nw:function(t,e,i){return V.extend(this._change.n.apply(this,arguments),this._change.w.apply(this,[t,e,i]))}},_propagate:function(t,e){V.ui.plugin.call(this,t,[e,this.ui()]),"resize"!==t&&this._trigger(t,e,this.ui())},plugins:{},ui:function(){return{originalElement:this.originalElement,element:this.element,helper:this.helper,position:this.position,size:this.size,originalSize:this.originalSize,originalPosition:this.originalPosition}}}),V.ui.plugin.add("resizable","animate",{stop:function(e){var i=V(this).resizable("instance"),t=i.options,s=i._proportionallyResizeElements,n=s.length&&/textarea/i.test(s[0].nodeName),o=n&&i._hasScroll(s[0],"left")?0:i.sizeDiff.height,a=n?0:i.sizeDiff.width,n={width:i.size.width-a,height:i.size.height-o},a=parseFloat(i.element.css("left"))+(i.position.left-i.originalPosition.left)||null,o=parseFloat(i.element.css("top"))+(i.position.top-i.originalPosition.top)||null;i.element.animate(V.extend(n,o&&a?{top:o,left:a}:{}),{duration:t.animateDuration,easing:t.animateEasing,step:function(){var t={width:parseFloat(i.element.css("width")),height:parseFloat(i.element.css("height")),top:parseFloat(i.element.css("top")),left:parseFloat(i.element.css("left"))};s&&s.length&&V(s[0]).css({width:t.width,height:t.height}),i._updateCache(t),i._propagate("resize",e)}})}}),V.ui.plugin.add("resizable","containment",{start:function(){var i,s,n=V(this).resizable("instance"),t=n.options,e=n.element,o=t.containment,a=o instanceof V?o.get(0):/parent/.test(o)?e.parent().get(0):o;a&&(n.containerElement=V(a),/document/.test(o)||o===document?(n.containerOffset={left:0,top:0},n.containerPosition={left:0,top:0},n.parentData={element:V(document),left:0,top:0,width:V(document).width(),height:V(document).height()||document.body.parentNode.scrollHeight}):(i=V(a),s=[],V(["Top","Right","Left","Bottom"]).each(function(t,e){s[t]=n._num(i.css("padding"+e))}),n.containerOffset=i.offset(),n.containerPosition=i.position(),n.containerSize={height:i.innerHeight()-s[3],width:i.innerWidth()-s[1]},t=n.containerOffset,e=n.containerSize.height,o=n.containerSize.width,o=n._hasScroll(a,"left")?a.scrollWidth:o,e=n._hasScroll(a)?a.scrollHeight:e,n.parentData={element:a,left:t.left,top:t.top,width:o,height:e}))},resize:function(t){var e=V(this).resizable("instance"),i=e.options,s=e.containerOffset,n=e.position,o=e._aspectRatio||t.shiftKey,a={top:0,left:0},r=e.containerElement,t=!0;r[0]!==document&&/static/.test(r.css("position"))&&(a=s),n.left<(e._helper?s.left:0)&&(e.size.width=e.size.width+(e._helper?e.position.left-s.left:e.position.left-a.left),o&&(e.size.height=e.size.width/e.aspectRatio,t=!1),e.position.left=i.helper?s.left:0),n.top<(e._helper?s.top:0)&&(e.size.height=e.size.height+(e._helper?e.position.top-s.top:e.position.top),o&&(e.size.width=e.size.height*e.aspectRatio,t=!1),e.position.top=e._helper?s.top:0),i=e.containerElement.get(0)===e.element.parent().get(0),n=/relative|absolute/.test(e.containerElement.css("position")),i&&n?(e.offset.left=e.parentData.left+e.position.left,e.offset.top=e.parentData.top+e.position.top):(e.offset.left=e.element.offset().left,e.offset.top=e.element.offset().top),n=Math.abs(e.sizeDiff.width+(e._helper?e.offset.left-a.left:e.offset.left-s.left)),s=Math.abs(e.sizeDiff.height+(e._helper?e.offset.top-a.top:e.offset.top-s.top)),n+e.size.width>=e.parentData.width&&(e.size.width=e.parentData.width-n,o&&(e.size.height=e.size.width/e.aspectRatio,t=!1)),s+e.size.height>=e.parentData.height&&(e.size.height=e.parentData.height-s,o&&(e.size.width=e.size.height*e.aspectRatio,t=!1)),t||(e.position.left=e.prevPosition.left,e.position.top=e.prevPosition.top,e.size.width=e.prevSize.width,e.size.height=e.prevSize.height)},stop:function(){var t=V(this).resizable("instance"),e=t.options,i=t.containerOffset,s=t.containerPosition,n=t.containerElement,o=V(t.helper),a=o.offset(),r=o.outerWidth()-t.sizeDiff.width,o=o.outerHeight()-t.sizeDiff.height;t._helper&&!e.animate&&/relative/.test(n.css("position"))&&V(this).css({left:a.left-s.left-i.left,width:r,height:o}),t._helper&&!e.animate&&/static/.test(n.css("position"))&&V(this).css({left:a.left-s.left-i.left,width:r,height:o})}}),V.ui.plugin.add("resizable","alsoResize",{start:function(){var t=V(this).resizable("instance").options;V(t.alsoResize).each(function(){var t=V(this);t.data("ui-resizable-alsoresize",{width:parseFloat(t.width()),height:parseFloat(t.height()),left:parseFloat(t.css("left")),top:parseFloat(t.css("top"))})})},resize:function(t,i){var e=V(this).resizable("instance"),s=e.options,n=e.originalSize,o=e.originalPosition,a={height:e.size.height-n.height||0,width:e.size.width-n.width||0,top:e.position.top-o.top||0,left:e.position.left-o.left||0};V(s.alsoResize).each(function(){var t=V(this),s=V(this).data("ui-resizable-alsoresize"),n={},e=t.parents(i.originalElement[0]).length?["width","height"]:["width","height","top","left"];V.each(e,function(t,e){var i=(s[e]||0)+(a[e]||0);i&&0<=i&&(n[e]=i||null)}),t.css(n)})},stop:function(){V(this).removeData("ui-resizable-alsoresize")}}),V.ui.plugin.add("resizable","ghost",{start:function(){var t=V(this).resizable("instance"),e=t.size;t.ghost=t.originalElement.clone(),t.ghost.css({opacity:.25,display:"block",position:"relative",height:e.height,width:e.width,margin:0,left:0,top:0}),t._addClass(t.ghost,"ui-resizable-ghost"),!1!==V.uiBackCompat&&"string"==typeof t.options.ghost&&t.ghost.addClass(this.options.ghost),t.ghost.appendTo(t.helper)},resize:function(){var t=V(this).resizable("instance");t.ghost&&t.ghost.css({position:"relative",height:t.size.height,width:t.size.width})},stop:function(){var t=V(this).resizable("instance");t.ghost&&t.helper&&t.helper.get(0).removeChild(t.ghost.get(0))}}),V.ui.plugin.add("resizable","grid",{resize:function(){var t,e=V(this).resizable("instance"),i=e.options,s=e.size,n=e.originalSize,o=e.originalPosition,a=e.axis,r="number"==typeof i.grid?[i.grid,i.grid]:i.grid,l=r[0]||1,h=r[1]||1,c=Math.round((s.width-n.width)/l)*l,u=Math.round((s.height-n.height)/h)*h,d=n.width+c,p=n.height+u,f=i.maxWidth&&i.maxWidth<d,g=i.maxHeight&&i.maxHeight<p,m=i.minWidth&&i.minWidth>d,s=i.minHeight&&i.minHeight>p;i.grid=r,m&&(d+=l),s&&(p+=h),f&&(d-=l),g&&(p-=h),/^(se|s|e)$/.test(a)?(e.size.width=d,e.size.height=p):/^(ne)$/.test(a)?(e.size.width=d,e.size.height=p,e.position.top=o.top-u):/^(sw)$/.test(a)?(e.size.width=d,e.size.height=p,e.position.left=o.left-c):((p-h<=0||d-l<=0)&&(t=e._getPaddingPlusBorderDimensions(this)),0<p-h?(e.size.height=p,e.position.top=o.top-u):(p=h-t.height,e.size.height=p,e.position.top=o.top+n.height-p),0<d-l?(e.size.width=d,e.position.left=o.left-c):(d=l-t.width,e.size.width=d,e.position.left=o.left+n.width-d))}});V.ui.resizable;V.widget("ui.dialog",{version:"1.13.2",options:{appendTo:"body",autoOpen:!0,buttons:[],classes:{"ui-dialog":"ui-corner-all","ui-dialog-titlebar":"ui-corner-all"},closeOnEscape:!0,closeText:"Close",draggable:!0,hide:null,height:"auto",maxHeight:null,maxWidth:null,minHeight:150,minWidth:150,modal:!1,position:{my:"center",at:"center",of:window,collision:"fit",using:function(t){var e=V(this).css(t).offset().top;e<0&&V(this).css("top",t.top-e)}},resizable:!0,show:null,title:null,width:300,beforeClose:null,close:null,drag:null,dragStart:null,dragStop:null,focus:null,open:null,resize:null,resizeStart:null,resizeStop:null},sizeRelatedOptions:{buttons:!0,height:!0,maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0,width:!0},resizableRelatedOptions:{maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0},_create:function(){this.originalCss={display:this.element[0].style.display,width:this.element[0].style.width,minHeight:this.element[0].style.minHeight,maxHeight:this.element[0].style.maxHeight,height:this.element[0].style.height},this.originalPosition={parent:this.element.parent(),index:this.element.parent().children().index(this.element)},this.originalTitle=this.element.attr("title"),null==this.options.title&&null!=this.originalTitle&&(this.options.title=this.originalTitle),this.options.disabled&&(this.options.disabled=!1),this._createWrapper(),this.element.show().removeAttr("title").appendTo(this.uiDialog),this._addClass("ui-dialog-content","ui-widget-content"),this._createTitlebar(),this._createButtonPane(),this.options.draggable&&V.fn.draggable&&this._makeDraggable(),this.options.resizable&&V.fn.resizable&&this._makeResizable(),this._isOpen=!1,this._trackFocus()},_init:function(){this.options.autoOpen&&this.open()},_appendTo:function(){var t=this.options.appendTo;return t&&(t.jquery||t.nodeType)?V(t):this.document.find(t||"body").eq(0)},_destroy:function(){var t,e=this.originalPosition;this._untrackInstance(),this._destroyOverlay(),this.element.removeUniqueId().css(this.originalCss).detach(),this.uiDialog.remove(),this.originalTitle&&this.element.attr("title",this.originalTitle),(t=e.parent.children().eq(e.index)).length&&t[0]!==this.element[0]?t.before(this.element):e.parent.append(this.element)},widget:function(){return this.uiDialog},disable:V.noop,enable:V.noop,close:function(t){var e=this;this._isOpen&&!1!==this._trigger("beforeClose",t)&&(this._isOpen=!1,this._focusedElement=null,this._destroyOverlay(),this._untrackInstance(),this.opener.filter(":focusable").trigger("focus").length||V.ui.safeBlur(V.ui.safeActiveElement(this.document[0])),this._hide(this.uiDialog,this.options.hide,function(){e._trigger("close",t)}))},isOpen:function(){return this._isOpen},moveToTop:function(){this._moveToTop()},_moveToTop:function(t,e){var i=!1,s=this.uiDialog.siblings(".ui-front:visible").map(function(){return+V(this).css("z-index")}).get(),s=Math.max.apply(null,s);return s>=+this.uiDialog.css("z-index")&&(this.uiDialog.css("z-index",s+1),i=!0),i&&!e&&this._trigger("focus",t),i},open:function(){var t=this;this._isOpen?this._moveToTop()&&this._focusTabbable():(this._isOpen=!0,this.opener=V(V.ui.safeActiveElement(this.document[0])),this._size(),this._position(),this._createOverlay(),this._moveToTop(null,!0),this.overlay&&this.overlay.css("z-index",this.uiDialog.css("z-index")-1),this._show(this.uiDialog,this.options.show,function(){t._focusTabbable(),t._trigger("focus")}),this._makeFocusTarget(),this._trigger("open"))},_focusTabbable:function(){var t=this._focusedElement;(t=!(t=!(t=!(t=!(t=t||this.element.find("[autofocus]")).length?this.element.find(":tabbable"):t).length?this.uiDialogButtonPane.find(":tabbable"):t).length?this.uiDialogTitlebarClose.filter(":tabbable"):t).length?this.uiDialog:t).eq(0).trigger("focus")},_restoreTabbableFocus:function(){var t=V.ui.safeActiveElement(this.document[0]);this.uiDialog[0]===t||V.contains(this.uiDialog[0],t)||this._focusTabbable()},_keepFocus:function(t){t.preventDefault(),this._restoreTabbableFocus(),this._delay(this._restoreTabbableFocus)},_createWrapper:function(){this.uiDialog=V("<div>").hide().attr({tabIndex:-1,role:"dialog"}).appendTo(this._appendTo()),this._addClass(this.uiDialog,"ui-dialog","ui-widget ui-widget-content ui-front"),this._on(this.uiDialog,{keydown:function(t){if(this.options.closeOnEscape&&!t.isDefaultPrevented()&&t.keyCode&&t.keyCode===V.ui.keyCode.ESCAPE)return t.preventDefault(),void this.close(t);var e,i,s;t.keyCode!==V.ui.keyCode.TAB||t.isDefaultPrevented()||(e=this.uiDialog.find(":tabbable"),i=e.first(),s=e.last(),t.target!==s[0]&&t.target!==this.uiDialog[0]||t.shiftKey?t.target!==i[0]&&t.target!==this.uiDialog[0]||!t.shiftKey||(this._delay(function(){s.trigger("focus")}),t.preventDefault()):(this._delay(function(){i.trigger("focus")}),t.preventDefault()))},mousedown:function(t){this._moveToTop(t)&&this._focusTabbable()}}),this.element.find("[aria-describedby]").length||this.uiDialog.attr({"aria-describedby":this.element.uniqueId().attr("id")})},_createTitlebar:function(){var t;this.uiDialogTitlebar=V("<div>"),this._addClass(this.uiDialogTitlebar,"ui-dialog-titlebar","ui-widget-header ui-helper-clearfix"),this._on(this.uiDialogTitlebar,{mousedown:function(t){V(t.target).closest(".ui-dialog-titlebar-close")||this.uiDialog.trigger("focus")}}),this.uiDialogTitlebarClose=V("<button type='button'></button>").button({label:V("<a>").text(this.options.closeText).html(),icon:"ui-icon-closethick",showLabel:!1}).appendTo(this.uiDialogTitlebar),this._addClass(this.uiDialogTitlebarClose,"ui-dialog-titlebar-close"),this._on(this.uiDialogTitlebarClose,{click:function(t){t.preventDefault(),this.close(t)}}),t=V("<span>").uniqueId().prependTo(this.uiDialogTitlebar),this._addClass(t,"ui-dialog-title"),this._title(t),this.uiDialogTitlebar.prependTo(this.uiDialog),this.uiDialog.attr({"aria-labelledby":t.attr("id")})},_title:function(t){this.options.title?t.text(this.options.title):t.html("&#160;")},_createButtonPane:function(){this.uiDialogButtonPane=V("<div>"),this._addClass(this.uiDialogButtonPane,"ui-dialog-buttonpane","ui-widget-content ui-helper-clearfix"),this.uiButtonSet=V("<div>").appendTo(this.uiDialogButtonPane),this._addClass(this.uiButtonSet,"ui-dialog-buttonset"),this._createButtons()},_createButtons:function(){var s=this,t=this.options.buttons;this.uiDialogButtonPane.remove(),this.uiButtonSet.empty(),V.isEmptyObject(t)||Array.isArray(t)&&!t.length?this._removeClass(this.uiDialog,"ui-dialog-buttons"):(V.each(t,function(t,e){var i;e=V.extend({type:"button"},e="function"==typeof e?{click:e,text:t}:e),i=e.click,t={icon:e.icon,iconPosition:e.iconPosition,showLabel:e.showLabel,icons:e.icons,text:e.text},delete e.click,delete e.icon,delete e.iconPosition,delete e.showLabel,delete e.icons,"boolean"==typeof e.text&&delete e.text,V("<button></button>",e).button(t).appendTo(s.uiButtonSet).on("click",function(){i.apply(s.element[0],arguments)})}),this._addClass(this.uiDialog,"ui-dialog-buttons"),this.uiDialogButtonPane.appendTo(this.uiDialog))},_makeDraggable:function(){var n=this,o=this.options;function a(t){return{position:t.position,offset:t.offset}}this.uiDialog.draggable({cancel:".ui-dialog-content, .ui-dialog-titlebar-close",handle:".ui-dialog-titlebar",containment:"document",start:function(t,e){n._addClass(V(this),"ui-dialog-dragging"),n._blockFrames(),n._trigger("dragStart",t,a(e))},drag:function(t,e){n._trigger("drag",t,a(e))},stop:function(t,e){var i=e.offset.left-n.document.scrollLeft(),s=e.offset.top-n.document.scrollTop();o.position={my:"left top",at:"left"+(0<=i?"+":"")+i+" top"+(0<=s?"+":"")+s,of:n.window},n._removeClass(V(this),"ui-dialog-dragging"),n._unblockFrames(),n._trigger("dragStop",t,a(e))}})},_makeResizable:function(){var n=this,o=this.options,t=o.resizable,e=this.uiDialog.css("position"),t="string"==typeof t?t:"n,e,s,w,se,sw,ne,nw";function a(t){return{originalPosition:t.originalPosition,originalSize:t.originalSize,position:t.position,size:t.size}}this.uiDialog.resizable({cancel:".ui-dialog-content",containment:"document",alsoResize:this.element,maxWidth:o.maxWidth,maxHeight:o.maxHeight,minWidth:o.minWidth,minHeight:this._minHeight(),handles:t,start:function(t,e){n._addClass(V(this),"ui-dialog-resizing"),n._blockFrames(),n._trigger("resizeStart",t,a(e))},resize:function(t,e){n._trigger("resize",t,a(e))},stop:function(t,e){var i=n.uiDialog.offset(),s=i.left-n.document.scrollLeft(),i=i.top-n.document.scrollTop();o.height=n.uiDialog.height(),o.width=n.uiDialog.width(),o.position={my:"left top",at:"left"+(0<=s?"+":"")+s+" top"+(0<=i?"+":"")+i,of:n.window},n._removeClass(V(this),"ui-dialog-resizing"),n._unblockFrames(),n._trigger("resizeStop",t,a(e))}}).css("position",e)},_trackFocus:function(){this._on(this.widget(),{focusin:function(t){this._makeFocusTarget(),this._focusedElement=V(t.target)}})},_makeFocusTarget:function(){this._untrackInstance(),this._trackingInstances().unshift(this)},_untrackInstance:function(){var t=this._trackingInstances(),e=V.inArray(this,t);-1!==e&&t.splice(e,1)},_trackingInstances:function(){var t=this.document.data("ui-dialog-instances");return t||this.document.data("ui-dialog-instances",t=[]),t},_minHeight:function(){var t=this.options;return"auto"===t.height?t.minHeight:Math.min(t.minHeight,t.height)},_position:function(){var t=this.uiDialog.is(":visible");t||this.uiDialog.show(),this.uiDialog.position(this.options.position),t||this.uiDialog.hide()},_setOptions:function(t){var i=this,s=!1,n={};V.each(t,function(t,e){i._setOption(t,e),t in i.sizeRelatedOptions&&(s=!0),t in i.resizableRelatedOptions&&(n[t]=e)}),s&&(this._size(),this._position()),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option",n)},_setOption:function(t,e){var i,s=this.uiDialog;"disabled"!==t&&(this._super(t,e),"appendTo"===t&&this.uiDialog.appendTo(this._appendTo()),"buttons"===t&&this._createButtons(),"closeText"===t&&this.uiDialogTitlebarClose.button({label:V("<a>").text(""+this.options.closeText).html()}),"draggable"===t&&((i=s.is(":data(ui-draggable)"))&&!e&&s.draggable("destroy"),!i&&e&&this._makeDraggable()),"position"===t&&this._position(),"resizable"===t&&((i=s.is(":data(ui-resizable)"))&&!e&&s.resizable("destroy"),i&&"string"==typeof e&&s.resizable("option","handles",e),i||!1===e||this._makeResizable()),"title"===t&&this._title(this.uiDialogTitlebar.find(".ui-dialog-title")))},_size:function(){var t,e,i,s=this.options;this.element.show().css({width:"auto",minHeight:0,maxHeight:"none",height:0}),s.minWidth>s.width&&(s.width=s.minWidth),t=this.uiDialog.css({height:"auto",width:s.width}).outerHeight(),e=Math.max(0,s.minHeight-t),i="number"==typeof s.maxHeight?Math.max(0,s.maxHeight-t):"none","auto"===s.height?this.element.css({minHeight:e,maxHeight:i,height:"auto"}):this.element.height(Math.max(0,s.height-t)),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option","minHeight",this._minHeight())},_blockFrames:function(){this.iframeBlocks=this.document.find("iframe").map(function(){var t=V(this);return V("<div>").css({position:"absolute",width:t.outerWidth(),height:t.outerHeight()}).appendTo(t.parent()).offset(t.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_allowInteraction:function(t){return!!V(t.target).closest(".ui-dialog").length||!!V(t.target).closest(".ui-datepicker").length},_createOverlay:function(){var i,s;this.options.modal&&(i=V.fn.jquery.substring(0,4),s=!0,this._delay(function(){s=!1}),this.document.data("ui-dialog-overlays")||this.document.on("focusin.ui-dialog",function(t){var e;s||((e=this._trackingInstances()[0])._allowInteraction(t)||(t.preventDefault(),e._focusTabbable(),"3.4."!==i&&"3.5."!==i||e._delay(e._restoreTabbableFocus)))}.bind(this)),this.overlay=V("<div>").appendTo(this._appendTo()),this._addClass(this.overlay,null,"ui-widget-overlay ui-front"),this._on(this.overlay,{mousedown:"_keepFocus"}),this.document.data("ui-dialog-overlays",(this.document.data("ui-dialog-overlays")||0)+1))},_destroyOverlay:function(){var t;this.options.modal&&this.overlay&&((t=this.document.data("ui-dialog-overlays")-1)?this.document.data("ui-dialog-overlays",t):(this.document.off("focusin.ui-dialog"),this.document.removeData("ui-dialog-overlays")),this.overlay.remove(),this.overlay=null)}}),!1!==V.uiBackCompat&&V.widget("ui.dialog",V.ui.dialog,{options:{dialogClass:""},_createWrapper:function(){this._super(),this.uiDialog.addClass(this.options.dialogClass)},_setOption:function(t,e){"dialogClass"===t&&this.uiDialog.removeClass(this.options.dialogClass).addClass(e),this._superApply(arguments)}});V.ui.dialog;function lt(t,e,i){return e<=t&&t<e+i}V.widget("ui.droppable",{version:"1.13.2",widgetEventPrefix:"drop",options:{accept:"*",addClasses:!0,greedy:!1,scope:"default",tolerance:"intersect",activate:null,deactivate:null,drop:null,out:null,over:null},_create:function(){var t,e=this.options,i=e.accept;this.isover=!1,this.isout=!0,this.accept="function"==typeof i?i:function(t){return t.is(i)},this.proportions=function(){if(!arguments.length)return t=t||{width:this.element[0].offsetWidth,height:this.element[0].offsetHeight};t=arguments[0]},this._addToManager(e.scope),e.addClasses&&this._addClass("ui-droppable")},_addToManager:function(t){V.ui.ddmanager.droppables[t]=V.ui.ddmanager.droppables[t]||[],V.ui.ddmanager.droppables[t].push(this)},_splice:function(t){for(var e=0;e<t.length;e++)t[e]===this&&t.splice(e,1)},_destroy:function(){var t=V.ui.ddmanager.droppables[this.options.scope];this._splice(t)},_setOption:function(t,e){var i;"accept"===t?this.accept="function"==typeof e?e:function(t){return t.is(e)}:"scope"===t&&(i=V.ui.ddmanager.droppables[this.options.scope],this._splice(i),this._addToManager(e)),this._super(t,e)},_activate:function(t){var e=V.ui.ddmanager.current;this._addActiveClass(),e&&this._trigger("activate",t,this.ui(e))},_deactivate:function(t){var e=V.ui.ddmanager.current;this._removeActiveClass(),e&&this._trigger("deactivate",t,this.ui(e))},_over:function(t){var e=V.ui.ddmanager.current;e&&(e.currentItem||e.element)[0]!==this.element[0]&&this.accept.call(this.element[0],e.currentItem||e.element)&&(this._addHoverClass(),this._trigger("over",t,this.ui(e)))},_out:function(t){var e=V.ui.ddmanager.current;e&&(e.currentItem||e.element)[0]!==this.element[0]&&this.accept.call(this.element[0],e.currentItem||e.element)&&(this._removeHoverClass(),this._trigger("out",t,this.ui(e)))},_drop:function(e,t){var i=t||V.ui.ddmanager.current,s=!1;return!(!i||(i.currentItem||i.element)[0]===this.element[0])&&(this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function(){var t=V(this).droppable("instance");if(t.options.greedy&&!t.options.disabled&&t.options.scope===i.options.scope&&t.accept.call(t.element[0],i.currentItem||i.element)&&V.ui.intersect(i,V.extend(t,{offset:t.element.offset()}),t.options.tolerance,e))return!(s=!0)}),!s&&(!!this.accept.call(this.element[0],i.currentItem||i.element)&&(this._removeActiveClass(),this._removeHoverClass(),this._trigger("drop",e,this.ui(i)),this.element)))},ui:function(t){return{draggable:t.currentItem||t.element,helper:t.helper,position:t.position,offset:t.positionAbs}},_addHoverClass:function(){this._addClass("ui-droppable-hover")},_removeHoverClass:function(){this._removeClass("ui-droppable-hover")},_addActiveClass:function(){this._addClass("ui-droppable-active")},_removeActiveClass:function(){this._removeClass("ui-droppable-active")}}),V.ui.intersect=function(t,e,i,s){if(!e.offset)return!1;var n=(t.positionAbs||t.position.absolute).left+t.margins.left,o=(t.positionAbs||t.position.absolute).top+t.margins.top,a=n+t.helperProportions.width,r=o+t.helperProportions.height,l=e.offset.left,h=e.offset.top,c=l+e.proportions().width,u=h+e.proportions().height;switch(i){case"fit":return l<=n&&a<=c&&h<=o&&r<=u;case"intersect":return l<n+t.helperProportions.width/2&&a-t.helperProportions.width/2<c&&h<o+t.helperProportions.height/2&&r-t.helperProportions.height/2<u;case"pointer":return lt(s.pageY,h,e.proportions().height)&&lt(s.pageX,l,e.proportions().width);case"touch":return(h<=o&&o<=u||h<=r&&r<=u||o<h&&u<r)&&(l<=n&&n<=c||l<=a&&a<=c||n<l&&c<a);default:return!1}},!(V.ui.ddmanager={current:null,droppables:{default:[]},prepareOffsets:function(t,e){var i,s,n=V.ui.ddmanager.droppables[t.options.scope]||[],o=e?e.type:null,a=(t.currentItem||t.element).find(":data(ui-droppable)").addBack();t:for(i=0;i<n.length;i++)if(!(n[i].options.disabled||t&&!n[i].accept.call(n[i].element[0],t.currentItem||t.element))){for(s=0;s<a.length;s++)if(a[s]===n[i].element[0]){n[i].proportions().height=0;continue t}n[i].visible="none"!==n[i].element.css("display"),n[i].visible&&("mousedown"===o&&n[i]._activate.call(n[i],e),n[i].offset=n[i].element.offset(),n[i].proportions({width:n[i].element[0].offsetWidth,height:n[i].element[0].offsetHeight}))}},drop:function(t,e){var i=!1;return V.each((V.ui.ddmanager.droppables[t.options.scope]||[]).slice(),function(){this.options&&(!this.options.disabled&&this.visible&&V.ui.intersect(t,this,this.options.tolerance,e)&&(i=this._drop.call(this,e)||i),!this.options.disabled&&this.visible&&this.accept.call(this.element[0],t.currentItem||t.element)&&(this.isout=!0,this.isover=!1,this._deactivate.call(this,e)))}),i},dragStart:function(t,e){t.element.parentsUntil("body").on("scroll.droppable",function(){t.options.refreshPositions||V.ui.ddmanager.prepareOffsets(t,e)})},drag:function(n,o){n.options.refreshPositions&&V.ui.ddmanager.prepareOffsets(n,o),V.each(V.ui.ddmanager.droppables[n.options.scope]||[],function(){var t,e,i,s;this.options.disabled||this.greedyChild||!this.visible||(s=!(i=V.ui.intersect(n,this,this.options.tolerance,o))&&this.isover?"isout":i&&!this.isover?"isover":null)&&(this.options.greedy&&(e=this.options.scope,(i=this.element.parents(":data(ui-droppable)").filter(function(){return V(this).droppable("instance").options.scope===e})).length&&((t=V(i[0]).droppable("instance")).greedyChild="isover"===s)),t&&"isover"===s&&(t.isover=!1,t.isout=!0,t._out.call(t,o)),this[s]=!0,this["isout"===s?"isover":"isout"]=!1,this["isover"===s?"_over":"_out"].call(this,o),t&&"isout"===s&&(t.isout=!1,t.isover=!0,t._over.call(t,o)))})},dragStop:function(t,e){t.element.parentsUntil("body").off("scroll.droppable"),t.options.refreshPositions||V.ui.ddmanager.prepareOffsets(t,e)}})!==V.uiBackCompat&&V.widget("ui.droppable",V.ui.droppable,{options:{hoverClass:!1,activeClass:!1},_addActiveClass:function(){this._super(),this.options.activeClass&&this.element.addClass(this.options.activeClass)},_removeActiveClass:function(){this._super(),this.options.activeClass&&this.element.removeClass(this.options.activeClass)},_addHoverClass:function(){this._super(),this.options.hoverClass&&this.element.addClass(this.options.hoverClass)},_removeHoverClass:function(){this._super(),this.options.hoverClass&&this.element.removeClass(this.options.hoverClass)}});V.ui.droppable,V.widget("ui.progressbar",{version:"1.13.2",options:{classes:{"ui-progressbar":"ui-corner-all","ui-progressbar-value":"ui-corner-left","ui-progressbar-complete":"ui-corner-right"},max:100,value:0,change:null,complete:null},min:0,_create:function(){this.oldValue=this.options.value=this._constrainedValue(),this.element.attr({role:"progressbar","aria-valuemin":this.min}),this._addClass("ui-progressbar","ui-widget ui-widget-content"),this.valueDiv=V("<div>").appendTo(this.element),this._addClass(this.valueDiv,"ui-progressbar-value","ui-widget-header"),this._refreshValue()},_destroy:function(){this.element.removeAttr("role aria-valuemin aria-valuemax aria-valuenow"),this.valueDiv.remove()},value:function(t){if(void 0===t)return this.options.value;this.options.value=this._constrainedValue(t),this._refreshValue()},_constrainedValue:function(t){return void 0===t&&(t=this.options.value),this.indeterminate=!1===t,"number"!=typeof t&&(t=0),!this.indeterminate&&Math.min(this.options.max,Math.max(this.min,t))},_setOptions:function(t){var e=t.value;delete t.value,this._super(t),this.options.value=this._constrainedValue(e),this._refreshValue()},_setOption:function(t,e){"max"===t&&(e=Math.max(this.min,e)),this._super(t,e)},_setOptionDisabled:function(t){this._super(t),this.element.attr("aria-disabled",t),this._toggleClass(null,"ui-state-disabled",!!t)},_percentage:function(){return this.indeterminate?100:100*(this.options.value-this.min)/(this.options.max-this.min)},_refreshValue:function(){var t=this.options.value,e=this._percentage();this.valueDiv.toggle(this.indeterminate||t>this.min).width(e.toFixed(0)+"%"),this._toggleClass(this.valueDiv,"ui-progressbar-complete",null,t===this.options.max)._toggleClass("ui-progressbar-indeterminate",null,this.indeterminate),this.indeterminate?(this.element.removeAttr("aria-valuenow"),this.overlayDiv||(this.overlayDiv=V("<div>").appendTo(this.valueDiv),this._addClass(this.overlayDiv,"ui-progressbar-overlay"))):(this.element.attr({"aria-valuemax":this.options.max,"aria-valuenow":t}),this.overlayDiv&&(this.overlayDiv.remove(),this.overlayDiv=null)),this.oldValue!==t&&(this.oldValue=t,this._trigger("change")),t===this.options.max&&this._trigger("complete")}}),V.widget("ui.selectable",V.ui.mouse,{version:"1.13.2",options:{appendTo:"body",autoRefresh:!0,distance:0,filter:"*",tolerance:"touch",selected:null,selecting:null,start:null,stop:null,unselected:null,unselecting:null},_create:function(){var i=this;this._addClass("ui-selectable"),this.dragged=!1,this.refresh=function(){i.elementPos=V(i.element[0]).offset(),i.selectees=V(i.options.filter,i.element[0]),i._addClass(i.selectees,"ui-selectee"),i.selectees.each(function(){var t=V(this),e=t.offset(),e={left:e.left-i.elementPos.left,top:e.top-i.elementPos.top};V.data(this,"selectable-item",{element:this,$element:t,left:e.left,top:e.top,right:e.left+t.outerWidth(),bottom:e.top+t.outerHeight(),startselected:!1,selected:t.hasClass("ui-selected"),selecting:t.hasClass("ui-selecting"),unselecting:t.hasClass("ui-unselecting")})})},this.refresh(),this._mouseInit(),this.helper=V("<div>"),this._addClass(this.helper,"ui-selectable-helper")},_destroy:function(){this.selectees.removeData("selectable-item"),this._mouseDestroy()},_mouseStart:function(i){var s=this,t=this.options;this.opos=[i.pageX,i.pageY],this.elementPos=V(this.element[0]).offset(),this.options.disabled||(this.selectees=V(t.filter,this.element[0]),this._trigger("start",i),V(t.appendTo).append(this.helper),this.helper.css({left:i.pageX,top:i.pageY,width:0,height:0}),t.autoRefresh&&this.refresh(),this.selectees.filter(".ui-selected").each(function(){var t=V.data(this,"selectable-item");t.startselected=!0,i.metaKey||i.ctrlKey||(s._removeClass(t.$element,"ui-selected"),t.selected=!1,s._addClass(t.$element,"ui-unselecting"),t.unselecting=!0,s._trigger("unselecting",i,{unselecting:t.element}))}),V(i.target).parents().addBack().each(function(){var t,e=V.data(this,"selectable-item");if(e)return t=!i.metaKey&&!i.ctrlKey||!e.$element.hasClass("ui-selected"),s._removeClass(e.$element,t?"ui-unselecting":"ui-selected")._addClass(e.$element,t?"ui-selecting":"ui-unselecting"),e.unselecting=!t,e.selecting=t,(e.selected=t)?s._trigger("selecting",i,{selecting:e.element}):s._trigger("unselecting",i,{unselecting:e.element}),!1}))},_mouseDrag:function(s){if(this.dragged=!0,!this.options.disabled){var t,n=this,o=this.options,a=this.opos[0],r=this.opos[1],l=s.pageX,h=s.pageY;return l<a&&(t=l,l=a,a=t),h<r&&(t=h,h=r,r=t),this.helper.css({left:a,top:r,width:l-a,height:h-r}),this.selectees.each(function(){var t=V.data(this,"selectable-item"),e=!1,i={};t&&t.element!==n.element[0]&&(i.left=t.left+n.elementPos.left,i.right=t.right+n.elementPos.left,i.top=t.top+n.elementPos.top,i.bottom=t.bottom+n.elementPos.top,"touch"===o.tolerance?e=!(i.left>l||i.right<a||i.top>h||i.bottom<r):"fit"===o.tolerance&&(e=i.left>a&&i.right<l&&i.top>r&&i.bottom<h),e?(t.selected&&(n._removeClass(t.$element,"ui-selected"),t.selected=!1),t.unselecting&&(n._removeClass(t.$element,"ui-unselecting"),t.unselecting=!1),t.selecting||(n._addClass(t.$element,"ui-selecting"),t.selecting=!0,n._trigger("selecting",s,{selecting:t.element}))):(t.selecting&&((s.metaKey||s.ctrlKey)&&t.startselected?(n._removeClass(t.$element,"ui-selecting"),t.selecting=!1,n._addClass(t.$element,"ui-selected"),t.selected=!0):(n._removeClass(t.$element,"ui-selecting"),t.selecting=!1,t.startselected&&(n._addClass(t.$element,"ui-unselecting"),t.unselecting=!0),n._trigger("unselecting",s,{unselecting:t.element}))),t.selected&&(s.metaKey||s.ctrlKey||t.startselected||(n._removeClass(t.$element,"ui-selected"),t.selected=!1,n._addClass(t.$element,"ui-unselecting"),t.unselecting=!0,n._trigger("unselecting",s,{unselecting:t.element})))))}),!1}},_mouseStop:function(e){var i=this;return this.dragged=!1,V(".ui-unselecting",this.element[0]).each(function(){var t=V.data(this,"selectable-item");i._removeClass(t.$element,"ui-unselecting"),t.unselecting=!1,t.startselected=!1,i._trigger("unselected",e,{unselected:t.element})}),V(".ui-selecting",this.element[0]).each(function(){var t=V.data(this,"selectable-item");i._removeClass(t.$element,"ui-selecting")._addClass(t.$element,"ui-selected"),t.selecting=!1,t.selected=!0,t.startselected=!0,i._trigger("selected",e,{selected:t.element})}),this._trigger("stop",e),this.helper.remove(),!1}}),V.widget("ui.selectmenu",[V.ui.formResetMixin,{version:"1.13.2",defaultElement:"<select>",options:{appendTo:null,classes:{"ui-selectmenu-button-open":"ui-corner-top","ui-selectmenu-button-closed":"ui-corner-all"},disabled:null,icons:{button:"ui-icon-triangle-1-s"},position:{my:"left top",at:"left bottom",collision:"none"},width:!1,change:null,close:null,focus:null,open:null,select:null},_create:function(){var t=this.element.uniqueId().attr("id");this.ids={element:t,button:t+"-button",menu:t+"-menu"},this._drawButton(),this._drawMenu(),this._bindFormResetHandler(),this._rendered=!1,this.menuItems=V()},_drawButton:function(){var t,e=this,i=this._parseOption(this.element.find("option:selected"),this.element[0].selectedIndex);this.labels=this.element.labels().attr("for",this.ids.button),this._on(this.labels,{click:function(t){this.button.trigger("focus"),t.preventDefault()}}),this.element.hide(),this.button=V("<span>",{tabindex:this.options.disabled?-1:0,id:this.ids.button,role:"combobox","aria-expanded":"false","aria-autocomplete":"list","aria-owns":this.ids.menu,"aria-haspopup":"true",title:this.element.attr("title")}).insertAfter(this.element),this._addClass(this.button,"ui-selectmenu-button ui-selectmenu-button-closed","ui-button ui-widget"),t=V("<span>").appendTo(this.button),this._addClass(t,"ui-selectmenu-icon","ui-icon "+this.options.icons.button),this.buttonItem=this._renderButtonItem(i).appendTo(this.button),!1!==this.options.width&&this._resizeButton(),this._on(this.button,this._buttonEvents),this.button.one("focusin",function(){e._rendered||e._refreshMenu()})},_drawMenu:function(){var i=this;this.menu=V("<ul>",{"aria-hidden":"true","aria-labelledby":this.ids.button,id:this.ids.menu}),this.menuWrap=V("<div>").append(this.menu),this._addClass(this.menuWrap,"ui-selectmenu-menu","ui-front"),this.menuWrap.appendTo(this._appendTo()),this.menuInstance=this.menu.menu({classes:{"ui-menu":"ui-corner-bottom"},role:"listbox",select:function(t,e){t.preventDefault(),i._setSelection(),i._select(e.item.data("ui-selectmenu-item"),t)},focus:function(t,e){e=e.item.data("ui-selectmenu-item");null!=i.focusIndex&&e.index!==i.focusIndex&&(i._trigger("focus",t,{item:e}),i.isOpen||i._select(e,t)),i.focusIndex=e.index,i.button.attr("aria-activedescendant",i.menuItems.eq(e.index).attr("id"))}}).menu("instance"),this.menuInstance._off(this.menu,"mouseleave"),this.menuInstance._closeOnDocumentClick=function(){return!1},this.menuInstance._isDivider=function(){return!1}},refresh:function(){this._refreshMenu(),this.buttonItem.replaceWith(this.buttonItem=this._renderButtonItem(this._getSelectedItem().data("ui-selectmenu-item")||{})),null===this.options.width&&this._resizeButton()},_refreshMenu:function(){var t=this.element.find("option");this.menu.empty(),this._parseOptions(t),this._renderMenu(this.menu,this.items),this.menuInstance.refresh(),this.menuItems=this.menu.find("li").not(".ui-selectmenu-optgroup").find(".ui-menu-item-wrapper"),this._rendered=!0,t.length&&(t=this._getSelectedItem(),this.menuInstance.focus(null,t),this._setAria(t.data("ui-selectmenu-item")),this._setOption("disabled",this.element.prop("disabled")))},open:function(t){this.options.disabled||(this._rendered?(this._removeClass(this.menu.find(".ui-state-active"),null,"ui-state-active"),this.menuInstance.focus(null,this._getSelectedItem())):this._refreshMenu(),this.menuItems.length&&(this.isOpen=!0,this._toggleAttr(),this._resizeMenu(),this._position(),this._on(this.document,this._documentClick),this._trigger("open",t)))},_position:function(){this.menuWrap.position(V.extend({of:this.button},this.options.position))},close:function(t){this.isOpen&&(this.isOpen=!1,this._toggleAttr(),this.range=null,this._off(this.document),this._trigger("close",t))},widget:function(){return this.button},menuWidget:function(){return this.menu},_renderButtonItem:function(t){var e=V("<span>");return this._setText(e,t.label),this._addClass(e,"ui-selectmenu-text"),e},_renderMenu:function(s,t){var n=this,o="";V.each(t,function(t,e){var i;e.optgroup!==o&&(i=V("<li>",{text:e.optgroup}),n._addClass(i,"ui-selectmenu-optgroup","ui-menu-divider"+(e.element.parent("optgroup").prop("disabled")?" ui-state-disabled":"")),i.appendTo(s),o=e.optgroup),n._renderItemData(s,e)})},_renderItemData:function(t,e){return this._renderItem(t,e).data("ui-selectmenu-item",e)},_renderItem:function(t,e){var i=V("<li>"),s=V("<div>",{title:e.element.attr("title")});return e.disabled&&this._addClass(i,null,"ui-state-disabled"),this._setText(s,e.label),i.append(s).appendTo(t)},_setText:function(t,e){e?t.text(e):t.html("&#160;")},_move:function(t,e){var i,s=".ui-menu-item";this.isOpen?i=this.menuItems.eq(this.focusIndex).parent("li"):(i=this.menuItems.eq(this.element[0].selectedIndex).parent("li"),s+=":not(.ui-state-disabled)"),(s="first"===t||"last"===t?i["first"===t?"prevAll":"nextAll"](s).eq(-1):i[t+"All"](s).eq(0)).length&&this.menuInstance.focus(e,s)},_getSelectedItem:function(){return this.menuItems.eq(this.element[0].selectedIndex).parent("li")},_toggle:function(t){this[this.isOpen?"close":"open"](t)},_setSelection:function(){var t;this.range&&(window.getSelection?((t=window.getSelection()).removeAllRanges(),t.addRange(this.range)):this.range.select(),this.button.trigger("focus"))},_documentClick:{mousedown:function(t){this.isOpen&&(V(t.target).closest(".ui-selectmenu-menu, #"+V.escapeSelector(this.ids.button)).length||this.close(t))}},_buttonEvents:{mousedown:function(){var t;window.getSelection?(t=window.getSelection()).rangeCount&&(this.range=t.getRangeAt(0)):this.range=document.selection.createRange()},click:function(t){this._setSelection(),this._toggle(t)},keydown:function(t){var e=!0;switch(t.keyCode){case V.ui.keyCode.TAB:case V.ui.keyCode.ESCAPE:this.close(t),e=!1;break;case V.ui.keyCode.ENTER:this.isOpen&&this._selectFocusedItem(t);break;case V.ui.keyCode.UP:t.altKey?this._toggle(t):this._move("prev",t);break;case V.ui.keyCode.DOWN:t.altKey?this._toggle(t):this._move("next",t);break;case V.ui.keyCode.SPACE:this.isOpen?this._selectFocusedItem(t):this._toggle(t);break;case V.ui.keyCode.LEFT:this._move("prev",t);break;case V.ui.keyCode.RIGHT:this._move("next",t);break;case V.ui.keyCode.HOME:case V.ui.keyCode.PAGE_UP:this._move("first",t);break;case V.ui.keyCode.END:case V.ui.keyCode.PAGE_DOWN:this._move("last",t);break;default:this.menu.trigger(t),e=!1}e&&t.preventDefault()}},_selectFocusedItem:function(t){var e=this.menuItems.eq(this.focusIndex).parent("li");e.hasClass("ui-state-disabled")||this._select(e.data("ui-selectmenu-item"),t)},_select:function(t,e){var i=this.element[0].selectedIndex;this.element[0].selectedIndex=t.index,this.buttonItem.replaceWith(this.buttonItem=this._renderButtonItem(t)),this._setAria(t),this._trigger("select",e,{item:t}),t.index!==i&&this._trigger("change",e,{item:t}),this.close(e)},_setAria:function(t){t=this.menuItems.eq(t.index).attr("id");this.button.attr({"aria-labelledby":t,"aria-activedescendant":t}),this.menu.attr("aria-activedescendant",t)},_setOption:function(t,e){var i;"icons"===t&&(i=this.button.find("span.ui-icon"),this._removeClass(i,null,this.options.icons.button)._addClass(i,null,e.button)),this._super(t,e),"appendTo"===t&&this.menuWrap.appendTo(this._appendTo()),"width"===t&&this._resizeButton()},_setOptionDisabled:function(t){this._super(t),this.menuInstance.option("disabled",t),this.button.attr("aria-disabled",t),this._toggleClass(this.button,null,"ui-state-disabled",t),this.element.prop("disabled",t),t?(this.button.attr("tabindex",-1),this.close()):this.button.attr("tabindex",0)},_appendTo:function(){var t=this.options.appendTo;return t=!(t=!(t=t&&(t.jquery||t.nodeType?V(t):this.document.find(t).eq(0)))||!t[0]?this.element.closest(".ui-front, dialog"):t).length?this.document[0].body:t},_toggleAttr:function(){this.button.attr("aria-expanded",this.isOpen),this._removeClass(this.button,"ui-selectmenu-button-"+(this.isOpen?"closed":"open"))._addClass(this.button,"ui-selectmenu-button-"+(this.isOpen?"open":"closed"))._toggleClass(this.menuWrap,"ui-selectmenu-open",null,this.isOpen),this.menu.attr("aria-hidden",!this.isOpen)},_resizeButton:function(){var t=this.options.width;!1!==t?(null===t&&(t=this.element.show().outerWidth(),this.element.hide()),this.button.outerWidth(t)):this.button.css("width","")},_resizeMenu:function(){this.menu.outerWidth(Math.max(this.button.outerWidth(),this.menu.width("").outerWidth()+1))},_getCreateOptions:function(){var t=this._super();return t.disabled=this.element.prop("disabled"),t},_parseOptions:function(t){var i=this,s=[];t.each(function(t,e){e.hidden||s.push(i._parseOption(V(e),t))}),this.items=s},_parseOption:function(t,e){var i=t.parent("optgroup");return{element:t,index:e,value:t.val(),label:t.text(),optgroup:i.attr("label")||"",disabled:i.prop("disabled")||t.prop("disabled")}},_destroy:function(){this._unbindFormResetHandler(),this.menuWrap.remove(),this.button.remove(),this.element.show(),this.element.removeUniqueId(),this.labels.attr("for",this.ids.element)}}]),V.widget("ui.slider",V.ui.mouse,{version:"1.13.2",widgetEventPrefix:"slide",options:{animate:!1,classes:{"ui-slider":"ui-corner-all","ui-slider-handle":"ui-corner-all","ui-slider-range":"ui-corner-all ui-widget-header"},distance:0,max:100,min:0,orientation:"horizontal",range:!1,step:1,value:0,values:null,change:null,slide:null,start:null,stop:null},numPages:5,_create:function(){this._keySliding=!1,this._mouseSliding=!1,this._animateOff=!0,this._handleIndex=null,this._detectOrientation(),this._mouseInit(),this._calculateNewMax(),this._addClass("ui-slider ui-slider-"+this.orientation,"ui-widget ui-widget-content"),this._refresh(),this._animateOff=!1},_refresh:function(){this._createRange(),this._createHandles(),this._setupEvents(),this._refreshValue()},_createHandles:function(){var t,e=this.options,i=this.element.find(".ui-slider-handle"),s=[],n=e.values&&e.values.length||1;for(i.length>n&&(i.slice(n).remove(),i=i.slice(0,n)),t=i.length;t<n;t++)s.push("<span tabindex='0'></span>");this.handles=i.add(V(s.join("")).appendTo(this.element)),this._addClass(this.handles,"ui-slider-handle","ui-state-default"),this.handle=this.handles.eq(0),this.handles.each(function(t){V(this).data("ui-slider-handle-index",t).attr("tabIndex",0)})},_createRange:function(){var t=this.options;t.range?(!0===t.range&&(t.values?t.values.length&&2!==t.values.length?t.values=[t.values[0],t.values[0]]:Array.isArray(t.values)&&(t.values=t.values.slice(0)):t.values=[this._valueMin(),this._valueMin()]),this.range&&this.range.length?(this._removeClass(this.range,"ui-slider-range-min ui-slider-range-max"),this.range.css({left:"",bottom:""})):(this.range=V("<div>").appendTo(this.element),this._addClass(this.range,"ui-slider-range")),"min"!==t.range&&"max"!==t.range||this._addClass(this.range,"ui-slider-range-"+t.range)):(this.range&&this.range.remove(),this.range=null)},_setupEvents:function(){this._off(this.handles),this._on(this.handles,this._handleEvents),this._hoverable(this.handles),this._focusable(this.handles)},_destroy:function(){this.handles.remove(),this.range&&this.range.remove(),this._mouseDestroy()},_mouseCapture:function(t){var i,s,n,o,e,a,r=this,l=this.options;return!l.disabled&&(this.elementSize={width:this.element.outerWidth(),height:this.element.outerHeight()},this.elementOffset=this.element.offset(),a={x:t.pageX,y:t.pageY},i=this._normValueFromMouse(a),s=this._valueMax()-this._valueMin()+1,this.handles.each(function(t){var e=Math.abs(i-r.values(t));(e<s||s===e&&(t===r._lastChangedValue||r.values(t)===l.min))&&(s=e,n=V(this),o=t)}),!1!==this._start(t,o)&&(this._mouseSliding=!0,this._handleIndex=o,this._addClass(n,null,"ui-state-active"),n.trigger("focus"),e=n.offset(),a=!V(t.target).parents().addBack().is(".ui-slider-handle"),this._clickOffset=a?{left:0,top:0}:{left:t.pageX-e.left-n.width()/2,top:t.pageY-e.top-n.height()/2-(parseInt(n.css("borderTopWidth"),10)||0)-(parseInt(n.css("borderBottomWidth"),10)||0)+(parseInt(n.css("marginTop"),10)||0)},this.handles.hasClass("ui-state-hover")||this._slide(t,o,i),this._animateOff=!0))},_mouseStart:function(){return!0},_mouseDrag:function(t){var e={x:t.pageX,y:t.pageY},e=this._normValueFromMouse(e);return this._slide(t,this._handleIndex,e),!1},_mouseStop:function(t){return this._removeClass(this.handles,null,"ui-state-active"),this._mouseSliding=!1,this._stop(t,this._handleIndex),this._change(t,this._handleIndex),this._handleIndex=null,this._clickOffset=null,this._animateOff=!1},_detectOrientation:function(){this.orientation="vertical"===this.options.orientation?"vertical":"horizontal"},_normValueFromMouse:function(t){var e,t="horizontal"===this.orientation?(e=this.elementSize.width,t.x-this.elementOffset.left-(this._clickOffset?this._clickOffset.left:0)):(e=this.elementSize.height,t.y-this.elementOffset.top-(this._clickOffset?this._clickOffset.top:0)),t=t/e;return(t=1<t?1:t)<0&&(t=0),"vertical"===this.orientation&&(t=1-t),e=this._valueMax()-this._valueMin(),e=this._valueMin()+t*e,this._trimAlignValue(e)},_uiHash:function(t,e,i){var s={handle:this.handles[t],handleIndex:t,value:void 0!==e?e:this.value()};return this._hasMultipleValues()&&(s.value=void 0!==e?e:this.values(t),s.values=i||this.values()),s},_hasMultipleValues:function(){return this.options.values&&this.options.values.length},_start:function(t,e){return this._trigger("start",t,this._uiHash(e))},_slide:function(t,e,i){var s,n=this.value(),o=this.values();this._hasMultipleValues()&&(s=this.values(e?0:1),n=this.values(e),2===this.options.values.length&&!0===this.options.range&&(i=0===e?Math.min(s,i):Math.max(s,i)),o[e]=i),i!==n&&!1!==this._trigger("slide",t,this._uiHash(e,i,o))&&(this._hasMultipleValues()?this.values(e,i):this.value(i))},_stop:function(t,e){this._trigger("stop",t,this._uiHash(e))},_change:function(t,e){this._keySliding||this._mouseSliding||(this._lastChangedValue=e,this._trigger("change",t,this._uiHash(e)))},value:function(t){return arguments.length?(this.options.value=this._trimAlignValue(t),this._refreshValue(),void this._change(null,0)):this._value()},values:function(t,e){var i,s,n;if(1<arguments.length)return this.options.values[t]=this._trimAlignValue(e),this._refreshValue(),void this._change(null,t);if(!arguments.length)return this._values();if(!Array.isArray(t))return this._hasMultipleValues()?this._values(t):this.value();for(i=this.options.values,s=t,n=0;n<i.length;n+=1)i[n]=this._trimAlignValue(s[n]),this._change(null,n);this._refreshValue()},_setOption:function(t,e){var i,s=0;switch("range"===t&&!0===this.options.range&&("min"===e?(this.options.value=this._values(0),this.options.values=null):"max"===e&&(this.options.value=this._values(this.options.values.length-1),this.options.values=null)),Array.isArray(this.options.values)&&(s=this.options.values.length),this._super(t,e),t){case"orientation":this._detectOrientation(),this._removeClass("ui-slider-horizontal ui-slider-vertical")._addClass("ui-slider-"+this.orientation),this._refreshValue(),this.options.range&&this._refreshRange(e),this.handles.css("horizontal"===e?"bottom":"left","");break;case"value":this._animateOff=!0,this._refreshValue(),this._change(null,0),this._animateOff=!1;break;case"values":for(this._animateOff=!0,this._refreshValue(),i=s-1;0<=i;i--)this._change(null,i);this._animateOff=!1;break;case"step":case"min":case"max":this._animateOff=!0,this._calculateNewMax(),this._refreshValue(),this._animateOff=!1;break;case"range":this._animateOff=!0,this._refresh(),this._animateOff=!1}},_setOptionDisabled:function(t){this._super(t),this._toggleClass(null,"ui-state-disabled",!!t)},_value:function(){var t=this.options.value;return t=this._trimAlignValue(t)},_values:function(t){var e,i;if(arguments.length)return t=this.options.values[t],t=this._trimAlignValue(t);if(this._hasMultipleValues()){for(e=this.options.values.slice(),i=0;i<e.length;i+=1)e[i]=this._trimAlignValue(e[i]);return e}return[]},_trimAlignValue:function(t){if(t<=this._valueMin())return this._valueMin();if(t>=this._valueMax())return this._valueMax();var e=0<this.options.step?this.options.step:1,i=(t-this._valueMin())%e,t=t-i;return 2*Math.abs(i)>=e&&(t+=0<i?e:-e),parseFloat(t.toFixed(5))},_calculateNewMax:function(){var t=this.options.max,e=this._valueMin(),i=this.options.step;(t=Math.round((t-e)/i)*i+e)>this.options.max&&(t-=i),this.max=parseFloat(t.toFixed(this._precision()))},_precision:function(){var t=this._precisionOf(this.options.step);return t=null!==this.options.min?Math.max(t,this._precisionOf(this.options.min)):t},_precisionOf:function(t){var e=t.toString(),t=e.indexOf(".");return-1===t?0:e.length-t-1},_valueMin:function(){return this.options.min},_valueMax:function(){return this.max},_refreshRange:function(t){"vertical"===t&&this.range.css({width:"",left:""}),"horizontal"===t&&this.range.css({height:"",bottom:""})},_refreshValue:function(){var e,i,t,s,n,o=this.options.range,a=this.options,r=this,l=!this._animateOff&&a.animate,h={};this._hasMultipleValues()?this.handles.each(function(t){i=(r.values(t)-r._valueMin())/(r._valueMax()-r._valueMin())*100,h["horizontal"===r.orientation?"left":"bottom"]=i+"%",V(this).stop(1,1)[l?"animate":"css"](h,a.animate),!0===r.options.range&&("horizontal"===r.orientation?(0===t&&r.range.stop(1,1)[l?"animate":"css"]({left:i+"%"},a.animate),1===t&&r.range[l?"animate":"css"]({width:i-e+"%"},{queue:!1,duration:a.animate})):(0===t&&r.range.stop(1,1)[l?"animate":"css"]({bottom:i+"%"},a.animate),1===t&&r.range[l?"animate":"css"]({height:i-e+"%"},{queue:!1,duration:a.animate}))),e=i}):(t=this.value(),s=this._valueMin(),n=this._valueMax(),i=n!==s?(t-s)/(n-s)*100:0,h["horizontal"===this.orientation?"left":"bottom"]=i+"%",this.handle.stop(1,1)[l?"animate":"css"](h,a.animate),"min"===o&&"horizontal"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({width:i+"%"},a.animate),"max"===o&&"horizontal"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({width:100-i+"%"},a.animate),"min"===o&&"vertical"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({height:i+"%"},a.animate),"max"===o&&"vertical"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({height:100-i+"%"},a.animate))},_handleEvents:{keydown:function(t){var e,i,s,n=V(t.target).data("ui-slider-handle-index");switch(t.keyCode){case V.ui.keyCode.HOME:case V.ui.keyCode.END:case V.ui.keyCode.PAGE_UP:case V.ui.keyCode.PAGE_DOWN:case V.ui.keyCode.UP:case V.ui.keyCode.RIGHT:case V.ui.keyCode.DOWN:case V.ui.keyCode.LEFT:if(t.preventDefault(),!this._keySliding&&(this._keySliding=!0,this._addClass(V(t.target),null,"ui-state-active"),!1===this._start(t,n)))return}switch(s=this.options.step,e=i=this._hasMultipleValues()?this.values(n):this.value(),t.keyCode){case V.ui.keyCode.HOME:i=this._valueMin();break;case V.ui.keyCode.END:i=this._valueMax();break;case V.ui.keyCode.PAGE_UP:i=this._trimAlignValue(e+(this._valueMax()-this._valueMin())/this.numPages);break;case V.ui.keyCode.PAGE_DOWN:i=this._trimAlignValue(e-(this._valueMax()-this._valueMin())/this.numPages);break;case V.ui.keyCode.UP:case V.ui.keyCode.RIGHT:if(e===this._valueMax())return;i=this._trimAlignValue(e+s);break;case V.ui.keyCode.DOWN:case V.ui.keyCode.LEFT:if(e===this._valueMin())return;i=this._trimAlignValue(e-s)}this._slide(t,n,i)},keyup:function(t){var e=V(t.target).data("ui-slider-handle-index");this._keySliding&&(this._keySliding=!1,this._stop(t,e),this._change(t,e),this._removeClass(V(t.target),null,"ui-state-active"))}}}),V.widget("ui.sortable",V.ui.mouse,{version:"1.13.2",widgetEventPrefix:"sort",ready:!1,options:{appendTo:"parent",axis:!1,connectWith:!1,containment:!1,cursor:"auto",cursorAt:!1,dropOnEmpty:!0,forcePlaceholderSize:!1,forceHelperSize:!1,grid:!1,handle:!1,helper:"original",items:"> *",opacity:!1,placeholder:!1,revert:!1,scroll:!0,scrollSensitivity:20,scrollSpeed:20,scope:"default",tolerance:"intersect",zIndex:1e3,activate:null,beforeStop:null,change:null,deactivate:null,out:null,over:null,receive:null,remove:null,sort:null,start:null,stop:null,update:null},_isOverAxis:function(t,e,i){return e<=t&&t<e+i},_isFloating:function(t){return/left|right/.test(t.css("float"))||/inline|table-cell/.test(t.css("display"))},_create:function(){this.containerCache={},this._addClass("ui-sortable"),this.refresh(),this.offset=this.element.offset(),this._mouseInit(),this._setHandleClassName(),this.ready=!0},_setOption:function(t,e){this._super(t,e),"handle"===t&&this._setHandleClassName()},_setHandleClassName:function(){var t=this;this._removeClass(this.element.find(".ui-sortable-handle"),"ui-sortable-handle"),V.each(this.items,function(){t._addClass(this.instance.options.handle?this.item.find(this.instance.options.handle):this.item,"ui-sortable-handle")})},_destroy:function(){this._mouseDestroy();for(var t=this.items.length-1;0<=t;t--)this.items[t].item.removeData(this.widgetName+"-item");return this},_mouseCapture:function(t,e){var i=null,s=!1,n=this;return!this.reverting&&(!this.options.disabled&&"static"!==this.options.type&&(this._refreshItems(t),V(t.target).parents().each(function(){if(V.data(this,n.widgetName+"-item")===n)return i=V(this),!1}),!!(i=V.data(t.target,n.widgetName+"-item")===n?V(t.target):i)&&(!(this.options.handle&&!e&&(V(this.options.handle,i).find("*").addBack().each(function(){this===t.target&&(s=!0)}),!s))&&(this.currentItem=i,this._removeCurrentsFromItems(),!0))))},_mouseStart:function(t,e,i){var s,n,o=this.options;if((this.currentContainer=this).refreshPositions(),this.appendTo=V("parent"!==o.appendTo?o.appendTo:this.currentItem.parent()),this.helper=this._createHelper(t),this._cacheHelperProportions(),this._cacheMargins(),this.offset=this.currentItem.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},V.extend(this.offset,{click:{left:t.pageX-this.offset.left,top:t.pageY-this.offset.top},relative:this._getRelativeOffset()}),this.helper.css("position","absolute"),this.cssPosition=this.helper.css("position"),o.cursorAt&&this._adjustOffsetFromHelper(o.cursorAt),this.domPosition={prev:this.currentItem.prev()[0],parent:this.currentItem.parent()[0]},this.helper[0]!==this.currentItem[0]&&this.currentItem.hide(),this._createPlaceholder(),this.scrollParent=this.placeholder.scrollParent(),V.extend(this.offset,{parent:this._getParentOffset()}),o.containment&&this._setContainment(),o.cursor&&"auto"!==o.cursor&&(n=this.document.find("body"),this.storedCursor=n.css("cursor"),n.css("cursor",o.cursor),this.storedStylesheet=V("<style>*{ cursor: "+o.cursor+" !important; }</style>").appendTo(n)),o.zIndex&&(this.helper.css("zIndex")&&(this._storedZIndex=this.helper.css("zIndex")),this.helper.css("zIndex",o.zIndex)),o.opacity&&(this.helper.css("opacity")&&(this._storedOpacity=this.helper.css("opacity")),this.helper.css("opacity",o.opacity)),this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName&&(this.overflowOffset=this.scrollParent.offset()),this._trigger("start",t,this._uiHash()),this._preserveHelperProportions||this._cacheHelperProportions(),!i)for(s=this.containers.length-1;0<=s;s--)this.containers[s]._trigger("activate",t,this._uiHash(this));return V.ui.ddmanager&&(V.ui.ddmanager.current=this),V.ui.ddmanager&&!o.dropBehaviour&&V.ui.ddmanager.prepareOffsets(this,t),this.dragging=!0,this._addClass(this.helper,"ui-sortable-helper"),this.helper.parent().is(this.appendTo)||(this.helper.detach().appendTo(this.appendTo),this.offset.parent=this._getParentOffset()),this.position=this.originalPosition=this._generatePosition(t),this.originalPageX=t.pageX,this.originalPageY=t.pageY,this.lastPositionAbs=this.positionAbs=this._convertPositionTo("absolute"),this._mouseDrag(t),!0},_scroll:function(t){var e=this.options,i=!1;return this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName?(this.overflowOffset.top+this.scrollParent[0].offsetHeight-t.pageY<e.scrollSensitivity?this.scrollParent[0].scrollTop=i=this.scrollParent[0].scrollTop+e.scrollSpeed:t.pageY-this.overflowOffset.top<e.scrollSensitivity&&(this.scrollParent[0].scrollTop=i=this.scrollParent[0].scrollTop-e.scrollSpeed),this.overflowOffset.left+this.scrollParent[0].offsetWidth-t.pageX<e.scrollSensitivity?this.scrollParent[0].scrollLeft=i=this.scrollParent[0].scrollLeft+e.scrollSpeed:t.pageX-this.overflowOffset.left<e.scrollSensitivity&&(this.scrollParent[0].scrollLeft=i=this.scrollParent[0].scrollLeft-e.scrollSpeed)):(t.pageY-this.document.scrollTop()<e.scrollSensitivity?i=this.document.scrollTop(this.document.scrollTop()-e.scrollSpeed):this.window.height()-(t.pageY-this.document.scrollTop())<e.scrollSensitivity&&(i=this.document.scrollTop(this.document.scrollTop()+e.scrollSpeed)),t.pageX-this.document.scrollLeft()<e.scrollSensitivity?i=this.document.scrollLeft(this.document.scrollLeft()-e.scrollSpeed):this.window.width()-(t.pageX-this.document.scrollLeft())<e.scrollSensitivity&&(i=this.document.scrollLeft(this.document.scrollLeft()+e.scrollSpeed))),i},_mouseDrag:function(t){var e,i,s,n,o=this.options;for(this.position=this._generatePosition(t),this.positionAbs=this._convertPositionTo("absolute"),this.options.axis&&"y"===this.options.axis||(this.helper[0].style.left=this.position.left+"px"),this.options.axis&&"x"===this.options.axis||(this.helper[0].style.top=this.position.top+"px"),o.scroll&&!1!==this._scroll(t)&&(this._refreshItemPositions(!0),V.ui.ddmanager&&!o.dropBehaviour&&V.ui.ddmanager.prepareOffsets(this,t)),this.dragDirection={vertical:this._getDragVerticalDirection(),horizontal:this._getDragHorizontalDirection()},e=this.items.length-1;0<=e;e--)if(s=(i=this.items[e]).item[0],(n=this._intersectsWithPointer(i))&&i.instance===this.currentContainer&&!(s===this.currentItem[0]||this.placeholder[1===n?"next":"prev"]()[0]===s||V.contains(this.placeholder[0],s)||"semi-dynamic"===this.options.type&&V.contains(this.element[0],s))){if(this.direction=1===n?"down":"up","pointer"!==this.options.tolerance&&!this._intersectsWithSides(i))break;this._rearrange(t,i),this._trigger("change",t,this._uiHash());break}return this._contactContainers(t),V.ui.ddmanager&&V.ui.ddmanager.drag(this,t),this._trigger("sort",t,this._uiHash()),this.lastPositionAbs=this.positionAbs,!1},_mouseStop:function(t,e){var i,s,n,o;if(t)return V.ui.ddmanager&&!this.options.dropBehaviour&&V.ui.ddmanager.drop(this,t),this.options.revert?(s=(i=this).placeholder.offset(),o={},(n=this.options.axis)&&"x"!==n||(o.left=s.left-this.offset.parent.left-this.margins.left+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollLeft)),n&&"y"!==n||(o.top=s.top-this.offset.parent.top-this.margins.top+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollTop)),this.reverting=!0,V(this.helper).animate(o,parseInt(this.options.revert,10)||500,function(){i._clear(t)})):this._clear(t,e),!1},cancel:function(){if(this.dragging){this._mouseUp(new V.Event("mouseup",{target:null})),"original"===this.options.helper?(this.currentItem.css(this._storedCSS),this._removeClass(this.currentItem,"ui-sortable-helper")):this.currentItem.show();for(var t=this.containers.length-1;0<=t;t--)this.containers[t]._trigger("deactivate",null,this._uiHash(this)),this.containers[t].containerCache.over&&(this.containers[t]._trigger("out",null,this._uiHash(this)),this.containers[t].containerCache.over=0)}return this.placeholder&&(this.placeholder[0].parentNode&&this.placeholder[0].parentNode.removeChild(this.placeholder[0]),"original"!==this.options.helper&&this.helper&&this.helper[0].parentNode&&this.helper.remove(),V.extend(this,{helper:null,dragging:!1,reverting:!1,_noFinalSort:null}),this.domPosition.prev?V(this.domPosition.prev).after(this.currentItem):V(this.domPosition.parent).prepend(this.currentItem)),this},serialize:function(e){var t=this._getItemsAsjQuery(e&&e.connected),i=[];return e=e||{},V(t).each(function(){var t=(V(e.item||this).attr(e.attribute||"id")||"").match(e.expression||/(.+)[\-=_](.+)/);t&&i.push((e.key||t[1]+"[]")+"="+(e.key&&e.expression?t[1]:t[2]))}),!i.length&&e.key&&i.push(e.key+"="),i.join("&")},toArray:function(t){var e=this._getItemsAsjQuery(t&&t.connected),i=[];return t=t||{},e.each(function(){i.push(V(t.item||this).attr(t.attribute||"id")||"")}),i},_intersectsWith:function(t){var e=this.positionAbs.left,i=e+this.helperProportions.width,s=this.positionAbs.top,n=s+this.helperProportions.height,o=t.left,a=o+t.width,r=t.top,l=r+t.height,h=this.offset.click.top,c=this.offset.click.left,h="x"===this.options.axis||r<s+h&&s+h<l,c="y"===this.options.axis||o<e+c&&e+c<a;return"pointer"===this.options.tolerance||this.options.forcePointerForContainers||"pointer"!==this.options.tolerance&&this.helperProportions[this.floating?"width":"height"]>t[this.floating?"width":"height"]?h&&c:o<e+this.helperProportions.width/2&&i-this.helperProportions.width/2<a&&r<s+this.helperProportions.height/2&&n-this.helperProportions.height/2<l},_intersectsWithPointer:function(t){var e="x"===this.options.axis||this._isOverAxis(this.positionAbs.top+this.offset.click.top,t.top,t.height),t="y"===this.options.axis||this._isOverAxis(this.positionAbs.left+this.offset.click.left,t.left,t.width);return!(!e||!t)&&(e=this.dragDirection.vertical,t=this.dragDirection.horizontal,this.floating?"right"===t||"down"===e?2:1:e&&("down"===e?2:1))},_intersectsWithSides:function(t){var e=this._isOverAxis(this.positionAbs.top+this.offset.click.top,t.top+t.height/2,t.height),i=this._isOverAxis(this.positionAbs.left+this.offset.click.left,t.left+t.width/2,t.width),s=this.dragDirection.vertical,t=this.dragDirection.horizontal;return this.floating&&t?"right"===t&&i||"left"===t&&!i:s&&("down"===s&&e||"up"===s&&!e)},_getDragVerticalDirection:function(){var t=this.positionAbs.top-this.lastPositionAbs.top;return 0!=t&&(0<t?"down":"up")},_getDragHorizontalDirection:function(){var t=this.positionAbs.left-this.lastPositionAbs.left;return 0!=t&&(0<t?"right":"left")},refresh:function(t){return this._refreshItems(t),this._setHandleClassName(),this.refreshPositions(),this},_connectWith:function(){var t=this.options;return t.connectWith.constructor===String?[t.connectWith]:t.connectWith},_getItemsAsjQuery:function(t){var e,i,s,n,o=[],a=[],r=this._connectWith();if(r&&t)for(e=r.length-1;0<=e;e--)for(i=(s=V(r[e],this.document[0])).length-1;0<=i;i--)(n=V.data(s[i],this.widgetFullName))&&n!==this&&!n.options.disabled&&a.push(["function"==typeof n.options.items?n.options.items.call(n.element):V(n.options.items,n.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),n]);function l(){o.push(this)}for(a.push(["function"==typeof this.options.items?this.options.items.call(this.element,null,{options:this.options,item:this.currentItem}):V(this.options.items,this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),this]),e=a.length-1;0<=e;e--)a[e][0].each(l);return V(o)},_removeCurrentsFromItems:function(){var i=this.currentItem.find(":data("+this.widgetName+"-item)");this.items=V.grep(this.items,function(t){for(var e=0;e<i.length;e++)if(i[e]===t.item[0])return!1;return!0})},_refreshItems:function(t){this.items=[],this.containers=[this];var e,i,s,n,o,a,r,l,h=this.items,c=[["function"==typeof this.options.items?this.options.items.call(this.element[0],t,{item:this.currentItem}):V(this.options.items,this.element),this]],u=this._connectWith();if(u&&this.ready)for(e=u.length-1;0<=e;e--)for(i=(s=V(u[e],this.document[0])).length-1;0<=i;i--)(n=V.data(s[i],this.widgetFullName))&&n!==this&&!n.options.disabled&&(c.push(["function"==typeof n.options.items?n.options.items.call(n.element[0],t,{item:this.currentItem}):V(n.options.items,n.element),n]),this.containers.push(n));for(e=c.length-1;0<=e;e--)for(o=c[e][1],l=(a=c[e][i=0]).length;i<l;i++)(r=V(a[i])).data(this.widgetName+"-item",o),h.push({item:r,instance:o,width:0,height:0,left:0,top:0})},_refreshItemPositions:function(t){for(var e,i,s=this.items.length-1;0<=s;s--)e=this.items[s],this.currentContainer&&e.instance!==this.currentContainer&&e.item[0]!==this.currentItem[0]||(i=this.options.toleranceElement?V(this.options.toleranceElement,e.item):e.item,t||(e.width=i.outerWidth(),e.height=i.outerHeight()),i=i.offset(),e.left=i.left,e.top=i.top)},refreshPositions:function(t){var e,i;if(this.floating=!!this.items.length&&("x"===this.options.axis||this._isFloating(this.items[0].item)),this.offsetParent&&this.helper&&(this.offset.parent=this._getParentOffset()),this._refreshItemPositions(t),this.options.custom&&this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this);else for(e=this.containers.length-1;0<=e;e--)i=this.containers[e].element.offset(),this.containers[e].containerCache.left=i.left,this.containers[e].containerCache.top=i.top,this.containers[e].containerCache.width=this.containers[e].element.outerWidth(),this.containers[e].containerCache.height=this.containers[e].element.outerHeight();return this},_createPlaceholder:function(i){var s,n,o=(i=i||this).options;o.placeholder&&o.placeholder.constructor!==String||(s=o.placeholder,n=i.currentItem[0].nodeName.toLowerCase(),o.placeholder={element:function(){var t=V("<"+n+">",i.document[0]);return i._addClass(t,"ui-sortable-placeholder",s||i.currentItem[0].className)._removeClass(t,"ui-sortable-helper"),"tbody"===n?i._createTrPlaceholder(i.currentItem.find("tr").eq(0),V("<tr>",i.document[0]).appendTo(t)):"tr"===n?i._createTrPlaceholder(i.currentItem,t):"img"===n&&t.attr("src",i.currentItem.attr("src")),s||t.css("visibility","hidden"),t},update:function(t,e){s&&!o.forcePlaceholderSize||(e.height()&&(!o.forcePlaceholderSize||"tbody"!==n&&"tr"!==n)||e.height(i.currentItem.innerHeight()-parseInt(i.currentItem.css("paddingTop")||0,10)-parseInt(i.currentItem.css("paddingBottom")||0,10)),e.width()||e.width(i.currentItem.innerWidth()-parseInt(i.currentItem.css("paddingLeft")||0,10)-parseInt(i.currentItem.css("paddingRight")||0,10)))}}),i.placeholder=V(o.placeholder.element.call(i.element,i.currentItem)),i.currentItem.after(i.placeholder),o.placeholder.update(i,i.placeholder)},_createTrPlaceholder:function(t,e){var i=this;t.children().each(function(){V("<td>&#160;</td>",i.document[0]).attr("colspan",V(this).attr("colspan")||1).appendTo(e)})},_contactContainers:function(t){for(var e,i,s,n,o,a,r,l,h,c=null,u=null,d=this.containers.length-1;0<=d;d--)V.contains(this.currentItem[0],this.containers[d].element[0])||(this._intersectsWith(this.containers[d].containerCache)?c&&V.contains(this.containers[d].element[0],c.element[0])||(c=this.containers[d],u=d):this.containers[d].containerCache.over&&(this.containers[d]._trigger("out",t,this._uiHash(this)),this.containers[d].containerCache.over=0));if(c)if(1===this.containers.length)this.containers[u].containerCache.over||(this.containers[u]._trigger("over",t,this._uiHash(this)),this.containers[u].containerCache.over=1);else{for(i=1e4,s=null,n=(l=c.floating||this._isFloating(this.currentItem))?"left":"top",o=l?"width":"height",h=l?"pageX":"pageY",e=this.items.length-1;0<=e;e--)V.contains(this.containers[u].element[0],this.items[e].item[0])&&this.items[e].item[0]!==this.currentItem[0]&&(a=this.items[e].item.offset()[n],r=!1,t[h]-a>this.items[e][o]/2&&(r=!0),Math.abs(t[h]-a)<i&&(i=Math.abs(t[h]-a),s=this.items[e],this.direction=r?"up":"down"));(s||this.options.dropOnEmpty)&&(this.currentContainer!==this.containers[u]?(s?this._rearrange(t,s,null,!0):this._rearrange(t,null,this.containers[u].element,!0),this._trigger("change",t,this._uiHash()),this.containers[u]._trigger("change",t,this._uiHash(this)),this.currentContainer=this.containers[u],this.options.placeholder.update(this.currentContainer,this.placeholder),this.scrollParent=this.placeholder.scrollParent(),this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName&&(this.overflowOffset=this.scrollParent.offset()),this.containers[u]._trigger("over",t,this._uiHash(this)),this.containers[u].containerCache.over=1):this.currentContainer.containerCache.over||(this.containers[u]._trigger("over",t,this._uiHash()),this.currentContainer.containerCache.over=1))}},_createHelper:function(t){var e=this.options,t="function"==typeof e.helper?V(e.helper.apply(this.element[0],[t,this.currentItem])):"clone"===e.helper?this.currentItem.clone():this.currentItem;return t.parents("body").length||this.appendTo[0].appendChild(t[0]),t[0]===this.currentItem[0]&&(this._storedCSS={width:this.currentItem[0].style.width,height:this.currentItem[0].style.height,position:this.currentItem.css("position"),top:this.currentItem.css("top"),left:this.currentItem.css("left")}),t[0].style.width&&!e.forceHelperSize||t.width(this.currentItem.width()),t[0].style.height&&!e.forceHelperSize||t.height(this.currentItem.height()),t},_adjustOffsetFromHelper:function(t){"string"==typeof t&&(t=t.split(" ")),"left"in(t=Array.isArray(t)?{left:+t[0],top:+t[1]||0}:t)&&(this.offset.click.left=t.left+this.margins.left),"right"in t&&(this.offset.click.left=this.helperProportions.width-t.right+this.margins.left),"top"in t&&(this.offset.click.top=t.top+this.margins.top),"bottom"in t&&(this.offset.click.top=this.helperProportions.height-t.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var t=this.offsetParent.offset();return"absolute"===this.cssPosition&&this.scrollParent[0]!==this.document[0]&&V.contains(this.scrollParent[0],this.offsetParent[0])&&(t.left+=this.scrollParent.scrollLeft(),t.top+=this.scrollParent.scrollTop()),{top:(t=this.offsetParent[0]===this.document[0].body||this.offsetParent[0].tagName&&"html"===this.offsetParent[0].tagName.toLowerCase()&&V.ui.ie?{top:0,left:0}:t).top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:t.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"!==this.cssPosition)return{top:0,left:0};var t=this.currentItem.position();return{top:t.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:t.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}},_cacheMargins:function(){this.margins={left:parseInt(this.currentItem.css("marginLeft"),10)||0,top:parseInt(this.currentItem.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var t,e,i=this.options;"parent"===i.containment&&(i.containment=this.helper[0].parentNode),"document"!==i.containment&&"window"!==i.containment||(this.containment=[0-this.offset.relative.left-this.offset.parent.left,0-this.offset.relative.top-this.offset.parent.top,"document"===i.containment?this.document.width():this.window.width()-this.helperProportions.width-this.margins.left,("document"===i.containment?this.document.height()||document.body.parentNode.scrollHeight:this.window.height()||this.document[0].body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]),/^(document|window|parent)$/.test(i.containment)||(t=V(i.containment)[0],e=V(i.containment).offset(),i="hidden"!==V(t).css("overflow"),this.containment=[e.left+(parseInt(V(t).css("borderLeftWidth"),10)||0)+(parseInt(V(t).css("paddingLeft"),10)||0)-this.margins.left,e.top+(parseInt(V(t).css("borderTopWidth"),10)||0)+(parseInt(V(t).css("paddingTop"),10)||0)-this.margins.top,e.left+(i?Math.max(t.scrollWidth,t.offsetWidth):t.offsetWidth)-(parseInt(V(t).css("borderLeftWidth"),10)||0)-(parseInt(V(t).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,e.top+(i?Math.max(t.scrollHeight,t.offsetHeight):t.offsetHeight)-(parseInt(V(t).css("borderTopWidth"),10)||0)-(parseInt(V(t).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top])},_convertPositionTo:function(t,e){e=e||this.position;var i="absolute"===t?1:-1,s="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&V.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,t=/(html|body)/i.test(s[0].tagName);return{top:e.top+this.offset.relative.top*i+this.offset.parent.top*i-("fixed"===this.cssPosition?-this.scrollParent.scrollTop():t?0:s.scrollTop())*i,left:e.left+this.offset.relative.left*i+this.offset.parent.left*i-("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():t?0:s.scrollLeft())*i}},_generatePosition:function(t){var e=this.options,i=t.pageX,s=t.pageY,n="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&V.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,o=/(html|body)/i.test(n[0].tagName);return"relative"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&this.scrollParent[0]!==this.offsetParent[0]||(this.offset.relative=this._getRelativeOffset()),this.originalPosition&&(this.containment&&(t.pageX-this.offset.click.left<this.containment[0]&&(i=this.containment[0]+this.offset.click.left),t.pageY-this.offset.click.top<this.containment[1]&&(s=this.containment[1]+this.offset.click.top),t.pageX-this.offset.click.left>this.containment[2]&&(i=this.containment[2]+this.offset.click.left),t.pageY-this.offset.click.top>this.containment[3]&&(s=this.containment[3]+this.offset.click.top)),e.grid&&(t=this.originalPageY+Math.round((s-this.originalPageY)/e.grid[1])*e.grid[1],s=!this.containment||t-this.offset.click.top>=this.containment[1]&&t-this.offset.click.top<=this.containment[3]?t:t-this.offset.click.top>=this.containment[1]?t-e.grid[1]:t+e.grid[1],t=this.originalPageX+Math.round((i-this.originalPageX)/e.grid[0])*e.grid[0],i=!this.containment||t-this.offset.click.left>=this.containment[0]&&t-this.offset.click.left<=this.containment[2]?t:t-this.offset.click.left>=this.containment[0]?t-e.grid[0]:t+e.grid[0])),{top:s-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.scrollParent.scrollTop():o?0:n.scrollTop()),left:i-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():o?0:n.scrollLeft())}},_rearrange:function(t,e,i,s){i?i[0].appendChild(this.placeholder[0]):e.item[0].parentNode.insertBefore(this.placeholder[0],"down"===this.direction?e.item[0]:e.item[0].nextSibling),this.counter=this.counter?++this.counter:1;var n=this.counter;this._delay(function(){n===this.counter&&this.refreshPositions(!s)})},_clear:function(t,e){this.reverting=!1;var i,s=[];if(!this._noFinalSort&&this.currentItem.parent().length&&this.placeholder.before(this.currentItem),this._noFinalSort=null,this.helper[0]===this.currentItem[0]){for(i in this._storedCSS)"auto"!==this._storedCSS[i]&&"static"!==this._storedCSS[i]||(this._storedCSS[i]="");this.currentItem.css(this._storedCSS),this._removeClass(this.currentItem,"ui-sortable-helper")}else this.currentItem.show();function n(e,i,s){return function(t){s._trigger(e,t,i._uiHash(i))}}for(this.fromOutside&&!e&&s.push(function(t){this._trigger("receive",t,this._uiHash(this.fromOutside))}),!this.fromOutside&&this.domPosition.prev===this.currentItem.prev().not(".ui-sortable-helper")[0]&&this.domPosition.parent===this.currentItem.parent()[0]||e||s.push(function(t){this._trigger("update",t,this._uiHash())}),this!==this.currentContainer&&(e||(s.push(function(t){this._trigger("remove",t,this._uiHash())}),s.push(function(e){return function(t){e._trigger("receive",t,this._uiHash(this))}}.call(this,this.currentContainer)),s.push(function(e){return function(t){e._trigger("update",t,this._uiHash(this))}}.call(this,this.currentContainer)))),i=this.containers.length-1;0<=i;i--)e||s.push(n("deactivate",this,this.containers[i])),this.containers[i].containerCache.over&&(s.push(n("out",this,this.containers[i])),this.containers[i].containerCache.over=0);if(this.storedCursor&&(this.document.find("body").css("cursor",this.storedCursor),this.storedStylesheet.remove()),this._storedOpacity&&this.helper.css("opacity",this._storedOpacity),this._storedZIndex&&this.helper.css("zIndex","auto"===this._storedZIndex?"":this._storedZIndex),this.dragging=!1,e||this._trigger("beforeStop",t,this._uiHash()),this.placeholder[0].parentNode.removeChild(this.placeholder[0]),this.cancelHelperRemoval||(this.helper[0]!==this.currentItem[0]&&this.helper.remove(),this.helper=null),!e){for(i=0;i<s.length;i++)s[i].call(this,t);this._trigger("stop",t,this._uiHash())}return this.fromOutside=!1,!this.cancelHelperRemoval},_trigger:function(){!1===V.Widget.prototype._trigger.apply(this,arguments)&&this.cancel()},_uiHash:function(t){var e=t||this;return{helper:e.helper,placeholder:e.placeholder||V([]),position:e.position,originalPosition:e.originalPosition,offset:e.positionAbs,item:e.currentItem,sender:t?t.element:null}}});function ht(e){return function(){var t=this.element.val();e.apply(this,arguments),this._refresh(),t!==this.element.val()&&this._trigger("change")}}V.widget("ui.spinner",{version:"1.13.2",defaultElement:"<input>",widgetEventPrefix:"spin",options:{classes:{"ui-spinner":"ui-corner-all","ui-spinner-down":"ui-corner-br","ui-spinner-up":"ui-corner-tr"},culture:null,icons:{down:"ui-icon-triangle-1-s",up:"ui-icon-triangle-1-n"},incremental:!0,max:null,min:null,numberFormat:null,page:10,step:1,change:null,spin:null,start:null,stop:null},_create:function(){this._setOption("max",this.options.max),this._setOption("min",this.options.min),this._setOption("step",this.options.step),""!==this.value()&&this._value(this.element.val(),!0),this._draw(),this._on(this._events),this._refresh(),this._on(this.window,{beforeunload:function(){this.element.removeAttr("autocomplete")}})},_getCreateOptions:function(){var s=this._super(),n=this.element;return V.each(["min","max","step"],function(t,e){var i=n.attr(e);null!=i&&i.length&&(s[e]=i)}),s},_events:{keydown:function(t){this._start(t)&&this._keydown(t)&&t.preventDefault()},keyup:"_stop",focus:function(){this.previous=this.element.val()},blur:function(t){this.cancelBlur?delete this.cancelBlur:(this._stop(),this._refresh(),this.previous!==this.element.val()&&this._trigger("change",t))},mousewheel:function(t,e){var i=V.ui.safeActiveElement(this.document[0]);if(this.element[0]===i&&e){if(!this.spinning&&!this._start(t))return!1;this._spin((0<e?1:-1)*this.options.step,t),clearTimeout(this.mousewheelTimer),this.mousewheelTimer=this._delay(function(){this.spinning&&this._stop(t)},100),t.preventDefault()}},"mousedown .ui-spinner-button":function(t){var e;function i(){this.element[0]===V.ui.safeActiveElement(this.document[0])||(this.element.trigger("focus"),this.previous=e,this._delay(function(){this.previous=e}))}e=this.element[0]===V.ui.safeActiveElement(this.document[0])?this.previous:this.element.val(),t.preventDefault(),i.call(this),this.cancelBlur=!0,this._delay(function(){delete this.cancelBlur,i.call(this)}),!1!==this._start(t)&&this._repeat(null,V(t.currentTarget).hasClass("ui-spinner-up")?1:-1,t)},"mouseup .ui-spinner-button":"_stop","mouseenter .ui-spinner-button":function(t){if(V(t.currentTarget).hasClass("ui-state-active"))return!1!==this._start(t)&&void this._repeat(null,V(t.currentTarget).hasClass("ui-spinner-up")?1:-1,t)},"mouseleave .ui-spinner-button":"_stop"},_enhance:function(){this.uiSpinner=this.element.attr("autocomplete","off").wrap("<span>").parent().append("<a></a><a></a>")},_draw:function(){this._enhance(),this._addClass(this.uiSpinner,"ui-spinner","ui-widget ui-widget-content"),this._addClass("ui-spinner-input"),this.element.attr("role","spinbutton"),this.buttons=this.uiSpinner.children("a").attr("tabIndex",-1).attr("aria-hidden",!0).button({classes:{"ui-button":""}}),this._removeClass(this.buttons,"ui-corner-all"),this._addClass(this.buttons.first(),"ui-spinner-button ui-spinner-up"),this._addClass(this.buttons.last(),"ui-spinner-button ui-spinner-down"),this.buttons.first().button({icon:this.options.icons.up,showLabel:!1}),this.buttons.last().button({icon:this.options.icons.down,showLabel:!1}),this.buttons.height()>Math.ceil(.5*this.uiSpinner.height())&&0<this.uiSpinner.height()&&this.uiSpinner.height(this.uiSpinner.height())},_keydown:function(t){var e=this.options,i=V.ui.keyCode;switch(t.keyCode){case i.UP:return this._repeat(null,1,t),!0;case i.DOWN:return this._repeat(null,-1,t),!0;case i.PAGE_UP:return this._repeat(null,e.page,t),!0;case i.PAGE_DOWN:return this._repeat(null,-e.page,t),!0}return!1},_start:function(t){return!(!this.spinning&&!1===this._trigger("start",t))&&(this.counter||(this.counter=1),this.spinning=!0)},_repeat:function(t,e,i){t=t||500,clearTimeout(this.timer),this.timer=this._delay(function(){this._repeat(40,e,i)},t),this._spin(e*this.options.step,i)},_spin:function(t,e){var i=this.value()||0;this.counter||(this.counter=1),i=this._adjustValue(i+t*this._increment(this.counter)),this.spinning&&!1===this._trigger("spin",e,{value:i})||(this._value(i),this.counter++)},_increment:function(t){var e=this.options.incremental;return e?"function"==typeof e?e(t):Math.floor(t*t*t/5e4-t*t/500+17*t/200+1):1},_precision:function(){var t=this._precisionOf(this.options.step);return t=null!==this.options.min?Math.max(t,this._precisionOf(this.options.min)):t},_precisionOf:function(t){var e=t.toString(),t=e.indexOf(".");return-1===t?0:e.length-t-1},_adjustValue:function(t){var e=this.options,i=null!==e.min?e.min:0,s=t-i;return t=i+Math.round(s/e.step)*e.step,t=parseFloat(t.toFixed(this._precision())),null!==e.max&&t>e.max?e.max:null!==e.min&&t<e.min?e.min:t},_stop:function(t){this.spinning&&(clearTimeout(this.timer),clearTimeout(this.mousewheelTimer),this.counter=0,this.spinning=!1,this._trigger("stop",t))},_setOption:function(t,e){var i;if("culture"===t||"numberFormat"===t)return i=this._parse(this.element.val()),this.options[t]=e,void this.element.val(this._format(i));"max"!==t&&"min"!==t&&"step"!==t||"string"==typeof e&&(e=this._parse(e)),"icons"===t&&(i=this.buttons.first().find(".ui-icon"),this._removeClass(i,null,this.options.icons.up),this._addClass(i,null,e.up),i=this.buttons.last().find(".ui-icon"),this._removeClass(i,null,this.options.icons.down),this._addClass(i,null,e.down)),this._super(t,e)},_setOptionDisabled:function(t){this._super(t),this._toggleClass(this.uiSpinner,null,"ui-state-disabled",!!t),this.element.prop("disabled",!!t),this.buttons.button(t?"disable":"enable")},_setOptions:ht(function(t){this._super(t)}),_parse:function(t){return""===(t="string"==typeof t&&""!==t?window.Globalize&&this.options.numberFormat?Globalize.parseFloat(t,10,this.options.culture):+t:t)||isNaN(t)?null:t},_format:function(t){return""===t?"":window.Globalize&&this.options.numberFormat?Globalize.format(t,this.options.numberFormat,this.options.culture):t},_refresh:function(){this.element.attr({"aria-valuemin":this.options.min,"aria-valuemax":this.options.max,"aria-valuenow":this._parse(this.element.val())})},isValid:function(){var t=this.value();return null!==t&&t===this._adjustValue(t)},_value:function(t,e){var i;""!==t&&null!==(i=this._parse(t))&&(e||(i=this._adjustValue(i)),t=this._format(i)),this.element.val(t),this._refresh()},_destroy:function(){this.element.prop("disabled",!1).removeAttr("autocomplete role aria-valuemin aria-valuemax aria-valuenow"),this.uiSpinner.replaceWith(this.element)},stepUp:ht(function(t){this._stepUp(t)}),_stepUp:function(t){this._start()&&(this._spin((t||1)*this.options.step),this._stop())},stepDown:ht(function(t){this._stepDown(t)}),_stepDown:function(t){this._start()&&(this._spin((t||1)*-this.options.step),this._stop())},pageUp:ht(function(t){this._stepUp((t||1)*this.options.page)}),pageDown:ht(function(t){this._stepDown((t||1)*this.options.page)}),value:function(t){if(!arguments.length)return this._parse(this.element.val());ht(this._value).call(this,t)},widget:function(){return this.uiSpinner}}),!1!==V.uiBackCompat&&V.widget("ui.spinner",V.ui.spinner,{_enhance:function(){this.uiSpinner=this.element.attr("autocomplete","off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml())},_uiSpinnerHtml:function(){return"<span>"},_buttonHtml:function(){return"<a></a><a></a>"}});var ct;V.ui.spinner;V.widget("ui.tabs",{version:"1.13.2",delay:300,options:{active:null,classes:{"ui-tabs":"ui-corner-all","ui-tabs-nav":"ui-corner-all","ui-tabs-panel":"ui-corner-bottom","ui-tabs-tab":"ui-corner-top"},collapsible:!1,event:"click",heightStyle:"content",hide:null,show:null,activate:null,beforeActivate:null,beforeLoad:null,load:null},_isLocal:(ct=/#.*$/,function(t){var e=t.href.replace(ct,""),i=location.href.replace(ct,"");try{e=decodeURIComponent(e)}catch(t){}try{i=decodeURIComponent(i)}catch(t){}return 1<t.hash.length&&e===i}),_create:function(){var e=this,t=this.options;this.running=!1,this._addClass("ui-tabs","ui-widget ui-widget-content"),this._toggleClass("ui-tabs-collapsible",null,t.collapsible),this._processTabs(),t.active=this._initialActive(),Array.isArray(t.disabled)&&(t.disabled=V.uniqueSort(t.disabled.concat(V.map(this.tabs.filter(".ui-state-disabled"),function(t){return e.tabs.index(t)}))).sort()),!1!==this.options.active&&this.anchors.length?this.active=this._findActive(t.active):this.active=V(),this._refresh(),this.active.length&&this.load(t.active)},_initialActive:function(){var i=this.options.active,t=this.options.collapsible,s=location.hash.substring(1);return null===i&&(s&&this.tabs.each(function(t,e){if(V(e).attr("aria-controls")===s)return i=t,!1}),null!==(i=null===i?this.tabs.index(this.tabs.filter(".ui-tabs-active")):i)&&-1!==i||(i=!!this.tabs.length&&0)),!1!==i&&-1===(i=this.tabs.index(this.tabs.eq(i)))&&(i=!t&&0),i=!t&&!1===i&&this.anchors.length?0:i},_getCreateEventData:function(){return{tab:this.active,panel:this.active.length?this._getPanelForTab(this.active):V()}},_tabKeydown:function(t){var e=V(V.ui.safeActiveElement(this.document[0])).closest("li"),i=this.tabs.index(e),s=!0;if(!this._handlePageNav(t)){switch(t.keyCode){case V.ui.keyCode.RIGHT:case V.ui.keyCode.DOWN:i++;break;case V.ui.keyCode.UP:case V.ui.keyCode.LEFT:s=!1,i--;break;case V.ui.keyCode.END:i=this.anchors.length-1;break;case V.ui.keyCode.HOME:i=0;break;case V.ui.keyCode.SPACE:return t.preventDefault(),clearTimeout(this.activating),void this._activate(i);case V.ui.keyCode.ENTER:return t.preventDefault(),clearTimeout(this.activating),void this._activate(i!==this.options.active&&i);default:return}t.preventDefault(),clearTimeout(this.activating),i=this._focusNextTab(i,s),t.ctrlKey||t.metaKey||(e.attr("aria-selected","false"),this.tabs.eq(i).attr("aria-selected","true"),this.activating=this._delay(function(){this.option("active",i)},this.delay))}},_panelKeydown:function(t){this._handlePageNav(t)||t.ctrlKey&&t.keyCode===V.ui.keyCode.UP&&(t.preventDefault(),this.active.trigger("focus"))},_handlePageNav:function(t){return t.altKey&&t.keyCode===V.ui.keyCode.PAGE_UP?(this._activate(this._focusNextTab(this.options.active-1,!1)),!0):t.altKey&&t.keyCode===V.ui.keyCode.PAGE_DOWN?(this._activate(this._focusNextTab(this.options.active+1,!0)),!0):void 0},_findNextTab:function(t,e){var i=this.tabs.length-1;for(;-1!==V.inArray(t=(t=i<t?0:t)<0?i:t,this.options.disabled);)t=e?t+1:t-1;return t},_focusNextTab:function(t,e){return t=this._findNextTab(t,e),this.tabs.eq(t).trigger("focus"),t},_setOption:function(t,e){"active"!==t?(this._super(t,e),"collapsible"===t&&(this._toggleClass("ui-tabs-collapsible",null,e),e||!1!==this.options.active||this._activate(0)),"event"===t&&this._setupEvents(e),"heightStyle"===t&&this._setupHeightStyle(e)):this._activate(e)},_sanitizeSelector:function(t){return t?t.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g,"\\$&"):""},refresh:function(){var t=this.options,e=this.tablist.children(":has(a[href])");t.disabled=V.map(e.filter(".ui-state-disabled"),function(t){return e.index(t)}),this._processTabs(),!1!==t.active&&this.anchors.length?this.active.length&&!V.contains(this.tablist[0],this.active[0])?this.tabs.length===t.disabled.length?(t.active=!1,this.active=V()):this._activate(this._findNextTab(Math.max(0,t.active-1),!1)):t.active=this.tabs.index(this.active):(t.active=!1,this.active=V()),this._refresh()},_refresh:function(){this._setOptionDisabled(this.options.disabled),this._setupEvents(this.options.event),this._setupHeightStyle(this.options.heightStyle),this.tabs.not(this.active).attr({"aria-selected":"false","aria-expanded":"false",tabIndex:-1}),this.panels.not(this._getPanelForTab(this.active)).hide().attr({"aria-hidden":"true"}),this.active.length?(this.active.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0}),this._addClass(this.active,"ui-tabs-active","ui-state-active"),this._getPanelForTab(this.active).show().attr({"aria-hidden":"false"})):this.tabs.eq(0).attr("tabIndex",0)},_processTabs:function(){var l=this,t=this.tabs,e=this.anchors,i=this.panels;this.tablist=this._getList().attr("role","tablist"),this._addClass(this.tablist,"ui-tabs-nav","ui-helper-reset ui-helper-clearfix ui-widget-header"),this.tablist.on("mousedown"+this.eventNamespace,"> li",function(t){V(this).is(".ui-state-disabled")&&t.preventDefault()}).on("focus"+this.eventNamespace,".ui-tabs-anchor",function(){V(this).closest("li").is(".ui-state-disabled")&&this.blur()}),this.tabs=this.tablist.find("> li:has(a[href])").attr({role:"tab",tabIndex:-1}),this._addClass(this.tabs,"ui-tabs-tab","ui-state-default"),this.anchors=this.tabs.map(function(){return V("a",this)[0]}).attr({tabIndex:-1}),this._addClass(this.anchors,"ui-tabs-anchor"),this.panels=V(),this.anchors.each(function(t,e){var i,s,n,o=V(e).uniqueId().attr("id"),a=V(e).closest("li"),r=a.attr("aria-controls");l._isLocal(e)?(n=(i=e.hash).substring(1),s=l.element.find(l._sanitizeSelector(i))):(n=a.attr("aria-controls")||V({}).uniqueId()[0].id,(s=l.element.find(i="#"+n)).length||(s=l._createPanel(n)).insertAfter(l.panels[t-1]||l.tablist),s.attr("aria-live","polite")),s.length&&(l.panels=l.panels.add(s)),r&&a.data("ui-tabs-aria-controls",r),a.attr({"aria-controls":n,"aria-labelledby":o}),s.attr("aria-labelledby",o)}),this.panels.attr("role","tabpanel"),this._addClass(this.panels,"ui-tabs-panel","ui-widget-content"),t&&(this._off(t.not(this.tabs)),this._off(e.not(this.anchors)),this._off(i.not(this.panels)))},_getList:function(){return this.tablist||this.element.find("ol, ul").eq(0)},_createPanel:function(t){return V("<div>").attr("id",t).data("ui-tabs-destroy",!0)},_setOptionDisabled:function(t){var e,i;for(Array.isArray(t)&&(t.length?t.length===this.anchors.length&&(t=!0):t=!1),i=0;e=this.tabs[i];i++)e=V(e),!0===t||-1!==V.inArray(i,t)?(e.attr("aria-disabled","true"),this._addClass(e,null,"ui-state-disabled")):(e.removeAttr("aria-disabled"),this._removeClass(e,null,"ui-state-disabled"));this.options.disabled=t,this._toggleClass(this.widget(),this.widgetFullName+"-disabled",null,!0===t)},_setupEvents:function(t){var i={};t&&V.each(t.split(" "),function(t,e){i[e]="_eventHandler"}),this._off(this.anchors.add(this.tabs).add(this.panels)),this._on(!0,this.anchors,{click:function(t){t.preventDefault()}}),this._on(this.anchors,i),this._on(this.tabs,{keydown:"_tabKeydown"}),this._on(this.panels,{keydown:"_panelKeydown"}),this._focusable(this.tabs),this._hoverable(this.tabs)},_setupHeightStyle:function(t){var i,e=this.element.parent();"fill"===t?(i=e.height(),i-=this.element.outerHeight()-this.element.height(),this.element.siblings(":visible").each(function(){var t=V(this),e=t.css("position");"absolute"!==e&&"fixed"!==e&&(i-=t.outerHeight(!0))}),this.element.children().not(this.panels).each(function(){i-=V(this).outerHeight(!0)}),this.panels.each(function(){V(this).height(Math.max(0,i-V(this).innerHeight()+V(this).height()))}).css("overflow","auto")):"auto"===t&&(i=0,this.panels.each(function(){i=Math.max(i,V(this).height("").height())}).height(i))},_eventHandler:function(t){var e=this.options,i=this.active,s=V(t.currentTarget).closest("li"),n=s[0]===i[0],o=n&&e.collapsible,a=o?V():this._getPanelForTab(s),r=i.length?this._getPanelForTab(i):V(),i={oldTab:i,oldPanel:r,newTab:o?V():s,newPanel:a};t.preventDefault(),s.hasClass("ui-state-disabled")||s.hasClass("ui-tabs-loading")||this.running||n&&!e.collapsible||!1===this._trigger("beforeActivate",t,i)||(e.active=!o&&this.tabs.index(s),this.active=n?V():s,this.xhr&&this.xhr.abort(),r.length||a.length||V.error("jQuery UI Tabs: Mismatching fragment identifier."),a.length&&this.load(this.tabs.index(s),t),this._toggle(t,i))},_toggle:function(t,e){var i=this,s=e.newPanel,n=e.oldPanel;function o(){i.running=!1,i._trigger("activate",t,e)}function a(){i._addClass(e.newTab.closest("li"),"ui-tabs-active","ui-state-active"),s.length&&i.options.show?i._show(s,i.options.show,o):(s.show(),o())}this.running=!0,n.length&&this.options.hide?this._hide(n,this.options.hide,function(){i._removeClass(e.oldTab.closest("li"),"ui-tabs-active","ui-state-active"),a()}):(this._removeClass(e.oldTab.closest("li"),"ui-tabs-active","ui-state-active"),n.hide(),a()),n.attr("aria-hidden","true"),e.oldTab.attr({"aria-selected":"false","aria-expanded":"false"}),s.length&&n.length?e.oldTab.attr("tabIndex",-1):s.length&&this.tabs.filter(function(){return 0===V(this).attr("tabIndex")}).attr("tabIndex",-1),s.attr("aria-hidden","false"),e.newTab.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0})},_activate:function(t){var t=this._findActive(t);t[0]!==this.active[0]&&(t=(t=!t.length?this.active:t).find(".ui-tabs-anchor")[0],this._eventHandler({target:t,currentTarget:t,preventDefault:V.noop}))},_findActive:function(t){return!1===t?V():this.tabs.eq(t)},_getIndex:function(t){return t="string"==typeof t?this.anchors.index(this.anchors.filter("[href$='"+V.escapeSelector(t)+"']")):t},_destroy:function(){this.xhr&&this.xhr.abort(),this.tablist.removeAttr("role").off(this.eventNamespace),this.anchors.removeAttr("role tabIndex").removeUniqueId(),this.tabs.add(this.panels).each(function(){V.data(this,"ui-tabs-destroy")?V(this).remove():V(this).removeAttr("role tabIndex aria-live aria-busy aria-selected aria-labelledby aria-hidden aria-expanded")}),this.tabs.each(function(){var t=V(this),e=t.data("ui-tabs-aria-controls");e?t.attr("aria-controls",e).removeData("ui-tabs-aria-controls"):t.removeAttr("aria-controls")}),this.panels.show(),"content"!==this.options.heightStyle&&this.panels.css("height","")},enable:function(i){var t=this.options.disabled;!1!==t&&(t=void 0!==i&&(i=this._getIndex(i),Array.isArray(t)?V.map(t,function(t){return t!==i?t:null}):V.map(this.tabs,function(t,e){return e!==i?e:null})),this._setOptionDisabled(t))},disable:function(t){var e=this.options.disabled;if(!0!==e){if(void 0===t)e=!0;else{if(t=this._getIndex(t),-1!==V.inArray(t,e))return;e=Array.isArray(e)?V.merge([t],e).sort():[t]}this._setOptionDisabled(e)}},load:function(t,s){t=this._getIndex(t);function n(t,e){"abort"===e&&o.panels.stop(!1,!0),o._removeClass(i,"ui-tabs-loading"),a.removeAttr("aria-busy"),t===o.xhr&&delete o.xhr}var o=this,i=this.tabs.eq(t),t=i.find(".ui-tabs-anchor"),a=this._getPanelForTab(i),r={tab:i,panel:a};this._isLocal(t[0])||(this.xhr=V.ajax(this._ajaxSettings(t,s,r)),this.xhr&&"canceled"!==this.xhr.statusText&&(this._addClass(i,"ui-tabs-loading"),a.attr("aria-busy","true"),this.xhr.done(function(t,e,i){setTimeout(function(){a.html(t),o._trigger("load",s,r),n(i,e)},1)}).fail(function(t,e){setTimeout(function(){n(t,e)},1)})))},_ajaxSettings:function(t,i,s){var n=this;return{url:t.attr("href").replace(/#.*$/,""),beforeSend:function(t,e){return n._trigger("beforeLoad",i,V.extend({jqXHR:t,ajaxSettings:e},s))}}},_getPanelForTab:function(t){t=V(t).attr("aria-controls");return this.element.find(this._sanitizeSelector("#"+t))}}),!1!==V.uiBackCompat&&V.widget("ui.tabs",V.ui.tabs,{_processTabs:function(){this._superApply(arguments),this._addClass(this.tabs,"ui-tab")}});V.ui.tabs;V.widget("ui.tooltip",{version:"1.13.2",options:{classes:{"ui-tooltip":"ui-corner-all ui-widget-shadow"},content:function(){var t=V(this).attr("title");return V("<a>").text(t).html()},hide:!0,items:"[title]:not([disabled])",position:{my:"left top+15",at:"left bottom",collision:"flipfit flip"},show:!0,track:!1,close:null,open:null},_addDescribedBy:function(t,e){var i=(t.attr("aria-describedby")||"").split(/\s+/);i.push(e),t.data("ui-tooltip-id",e).attr("aria-describedby",String.prototype.trim.call(i.join(" ")))},_removeDescribedBy:function(t){var e=t.data("ui-tooltip-id"),i=(t.attr("aria-describedby")||"").split(/\s+/),e=V.inArray(e,i);-1!==e&&i.splice(e,1),t.removeData("ui-tooltip-id"),(i=String.prototype.trim.call(i.join(" ")))?t.attr("aria-describedby",i):t.removeAttr("aria-describedby")},_create:function(){this._on({mouseover:"open",focusin:"open"}),this.tooltips={},this.parents={},this.liveRegion=V("<div>").attr({role:"log","aria-live":"assertive","aria-relevant":"additions"}).appendTo(this.document[0].body),this._addClass(this.liveRegion,null,"ui-helper-hidden-accessible"),this.disabledTitles=V([])},_setOption:function(t,e){var i=this;this._super(t,e),"content"===t&&V.each(this.tooltips,function(t,e){i._updateContent(e.element)})},_setOptionDisabled:function(t){this[t?"_disable":"_enable"]()},_disable:function(){var s=this;V.each(this.tooltips,function(t,e){var i=V.Event("blur");i.target=i.currentTarget=e.element[0],s.close(i,!0)}),this.disabledTitles=this.disabledTitles.add(this.element.find(this.options.items).addBack().filter(function(){var t=V(this);if(t.is("[title]"))return t.data("ui-tooltip-title",t.attr("title")).removeAttr("title")}))},_enable:function(){this.disabledTitles.each(function(){var t=V(this);t.data("ui-tooltip-title")&&t.attr("title",t.data("ui-tooltip-title"))}),this.disabledTitles=V([])},open:function(t){var i=this,e=V(t?t.target:this.element).closest(this.options.items);e.length&&!e.data("ui-tooltip-id")&&(e.attr("title")&&e.data("ui-tooltip-title",e.attr("title")),e.data("ui-tooltip-open",!0),t&&"mouseover"===t.type&&e.parents().each(function(){var t,e=V(this);e.data("ui-tooltip-open")&&((t=V.Event("blur")).target=t.currentTarget=this,i.close(t,!0)),e.attr("title")&&(e.uniqueId(),i.parents[this.id]={element:this,title:e.attr("title")},e.attr("title",""))}),this._registerCloseHandlers(t,e),this._updateContent(e,t))},_updateContent:function(e,i){var t=this.options.content,s=this,n=i?i.type:null;if("string"==typeof t||t.nodeType||t.jquery)return this._open(i,e,t);(t=t.call(e[0],function(t){s._delay(function(){e.data("ui-tooltip-open")&&(i&&(i.type=n),this._open(i,e,t))})}))&&this._open(i,e,t)},_open:function(t,e,i){var s,n,o,a=V.extend({},this.options.position);function r(t){a.of=t,n.is(":hidden")||n.position(a)}i&&((s=this._find(e))?s.tooltip.find(".ui-tooltip-content").html(i):(e.is("[title]")&&(t&&"mouseover"===t.type?e.attr("title",""):e.removeAttr("title")),s=this._tooltip(e),n=s.tooltip,this._addDescribedBy(e,n.attr("id")),n.find(".ui-tooltip-content").html(i),this.liveRegion.children().hide(),(i=V("<div>").html(n.find(".ui-tooltip-content").html())).removeAttr("name").find("[name]").removeAttr("name"),i.removeAttr("id").find("[id]").removeAttr("id"),i.appendTo(this.liveRegion),this.options.track&&t&&/^mouse/.test(t.type)?(this._on(this.document,{mousemove:r}),r(t)):n.position(V.extend({of:e},this.options.position)),n.hide(),this._show(n,this.options.show),this.options.track&&this.options.show&&this.options.show.delay&&(o=this.delayedShow=setInterval(function(){n.is(":visible")&&(r(a.of),clearInterval(o))},13)),this._trigger("open",t,{tooltip:n})))},_registerCloseHandlers:function(t,e){var i={keyup:function(t){t.keyCode===V.ui.keyCode.ESCAPE&&((t=V.Event(t)).currentTarget=e[0],this.close(t,!0))}};e[0]!==this.element[0]&&(i.remove=function(){var t=this._find(e);t&&this._removeTooltip(t.tooltip)}),t&&"mouseover"!==t.type||(i.mouseleave="close"),t&&"focusin"!==t.type||(i.focusout="close"),this._on(!0,e,i)},close:function(t){var e,i=this,s=V(t?t.currentTarget:this.element),n=this._find(s);n?(e=n.tooltip,n.closing||(clearInterval(this.delayedShow),s.data("ui-tooltip-title")&&!s.attr("title")&&s.attr("title",s.data("ui-tooltip-title")),this._removeDescribedBy(s),n.hiding=!0,e.stop(!0),this._hide(e,this.options.hide,function(){i._removeTooltip(V(this))}),s.removeData("ui-tooltip-open"),this._off(s,"mouseleave focusout keyup"),s[0]!==this.element[0]&&this._off(s,"remove"),this._off(this.document,"mousemove"),t&&"mouseleave"===t.type&&V.each(this.parents,function(t,e){V(e.element).attr("title",e.title),delete i.parents[t]}),n.closing=!0,this._trigger("close",t,{tooltip:e}),n.hiding||(n.closing=!1))):s.removeData("ui-tooltip-open")},_tooltip:function(t){var e=V("<div>").attr("role","tooltip"),i=V("<div>").appendTo(e),s=e.uniqueId().attr("id");return this._addClass(i,"ui-tooltip-content"),this._addClass(e,"ui-tooltip","ui-widget ui-widget-content"),e.appendTo(this._appendTo(t)),this.tooltips[s]={element:t,tooltip:e}},_find:function(t){t=t.data("ui-tooltip-id");return t?this.tooltips[t]:null},_removeTooltip:function(t){clearInterval(this.delayedShow),t.remove(),delete this.tooltips[t.attr("id")]},_appendTo:function(t){t=t.closest(".ui-front, dialog");return t=!t.length?this.document[0].body:t},_destroy:function(){var s=this;V.each(this.tooltips,function(t,e){var i=V.Event("blur"),e=e.element;i.target=i.currentTarget=e[0],s.close(i,!0),V("#"+t).remove(),e.data("ui-tooltip-title")&&(e.attr("title")||e.attr("title",e.data("ui-tooltip-title")),e.removeData("ui-tooltip-title"))}),this.liveRegion.remove()}}),!1!==V.uiBackCompat&&V.widget("ui.tooltip",V.ui.tooltip,{options:{tooltipClass:null},_tooltip:function(){var t=this._superApply(arguments);return this.options.tooltipClass&&t.tooltip.addClass(this.options.tooltipClass),t}});V.ui.tooltip});</script>
<style type="text/css">

.tocify {
width: 20%;
max-height: 90%;
overflow: auto;
margin-left: 2%;
position: fixed;
border: 1px solid #ccc;
border-radius: 6px;
}

.tocify ul, .tocify li {
list-style: none;
margin: 0;
padding: 0;
border: none;
line-height: 30px;
}

.tocify-header {
text-indent: 10px;
}

.tocify-subheader {
text-indent: 20px;
display: none;
}

.tocify-subheader li {
font-size: 12px;
}

.tocify-subheader .tocify-subheader {
text-indent: 30px;
}
.tocify-subheader .tocify-subheader .tocify-subheader {
text-indent: 40px;
}
.tocify-subheader .tocify-subheader .tocify-subheader .tocify-subheader {
text-indent: 50px;
}
.tocify-subheader .tocify-subheader .tocify-subheader .tocify-subheader .tocify-subheader {
text-indent: 60px;
}

.tocify .tocify-item > a, .tocify .nav-list .nav-header {
margin: 0px;
}

.tocify .tocify-item a, .tocify .list-group-item {
padding: 5px;
}
.tocify .nav-pills > li {
float: none;
}


</style>
<script>/* jquery Tocify - v1.9.1 - 2013-10-22
 * http://www.gregfranko.com/jquery.tocify.js/
 * Copyright (c) 2013 Greg Franko; Licensed MIT */

// Immediately-Invoked Function Expression (IIFE) [Ben Alman Blog Post](http://benalman.com/news/2010/11/immediately-invoked-function-expression/) that calls another IIFE that contains all of the plugin logic.  I used this pattern so that anyone viewing this code would not have to scroll to the bottom of the page to view the local parameters that were passed to the main IIFE.
(function(tocify) {

    // ECMAScript 5 Strict Mode: [John Resig Blog Post](http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/)
    "use strict";

    // Calls the second IIFE and locally passes in the global jQuery, window, and document objects
    tocify(window.jQuery, window, document);

  }

  // Locally passes in `jQuery`, the `window` object, the `document` object, and an `undefined` variable.  The `jQuery`, `window` and `document` objects are passed in locally, to improve performance, since javascript first searches for a variable match within the local variables set before searching the global variables set.  All of the global variables are also passed in locally to be minifier friendly. `undefined` can be passed in locally, because it is not a reserved word in JavaScript.
  (function($, window, document, undefined) {

    // ECMAScript 5 Strict Mode: [John Resig Blog Post](http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/)
    "use strict";

    var tocClassName = "tocify",
      tocClass = "." + tocClassName,
      tocFocusClassName = "tocify-focus",
      tocHoverClassName = "tocify-hover",
      hideTocClassName = "tocify-hide",
      hideTocClass = "." + hideTocClassName,
      headerClassName = "tocify-header",
      headerClass = "." + headerClassName,
      subheaderClassName = "tocify-subheader",
      subheaderClass = "." + subheaderClassName,
      itemClassName = "tocify-item",
      itemClass = "." + itemClassName,
      extendPageClassName = "tocify-extend-page",
      extendPageClass = "." + extendPageClassName;

    // Calling the jQueryUI Widget Factory Method
    $.widget("toc.tocify", {

      //Plugin version
      version: "1.9.1",

      // These options will be used as defaults
      options: {

        // **context**: Accepts String: Any jQuery selector
        // The container element that holds all of the elements used to generate the table of contents
        context: "body",

        // **ignoreSelector**: Accepts String: Any jQuery selector
        // A selector to any element that would be matched by selectors that you wish to be ignored
        ignoreSelector: null,

        // **selectors**: Accepts an Array of Strings: Any jQuery selectors
        // The element's used to generate the table of contents.  The order is very important since it will determine the table of content's nesting structure
        selectors: "h1, h2, h3",

        // **showAndHide**: Accepts a boolean: true or false
        // Used to determine if elements should be shown and hidden
        showAndHide: true,

        // **showEffect**: Accepts String: "none", "fadeIn", "show", or "slideDown"
        // Used to display any of the table of contents nested items
        showEffect: "slideDown",

        // **showEffectSpeed**: Accepts Number (milliseconds) or String: "slow", "medium", or "fast"
        // The time duration of the show animation
        showEffectSpeed: "medium",

        // **hideEffect**: Accepts String: "none", "fadeOut", "hide", or "slideUp"
        // Used to hide any of the table of contents nested items
        hideEffect: "slideUp",

        // **hideEffectSpeed**: Accepts Number (milliseconds) or String: "slow", "medium", or "fast"
        // The time duration of the hide animation
        hideEffectSpeed: "medium",

        // **smoothScroll**: Accepts a boolean: true or false
        // Determines if a jQuery animation should be used to scroll to specific table of contents items on the page
        smoothScroll: true,

        // **smoothScrollSpeed**: Accepts Number (milliseconds) or String: "slow", "medium", or "fast"
        // The time duration of the smoothScroll animation
        smoothScrollSpeed: "medium",

        // **scrollTo**: Accepts Number (pixels)
        // The amount of space between the top of page and the selected table of contents item after the page has been scrolled
        scrollTo: 0,

        // **showAndHideOnScroll**: Accepts a boolean: true or false
        // Determines if table of contents nested items should be shown and hidden while scrolling
        showAndHideOnScroll: true,

        // **highlightOnScroll**: Accepts a boolean: true or false
        // Determines if table of contents nested items should be highlighted (set to a different color) while scrolling
        highlightOnScroll: true,

        // **highlightOffset**: Accepts a number
        // The offset distance in pixels to trigger the next active table of contents item
        highlightOffset: 40,

        // **theme**: Accepts a string: "bootstrap", "jqueryui", or "none"
        // Determines if Twitter Bootstrap, jQueryUI, or Tocify classes should be added to the table of contents
        theme: "bootstrap",

        // **extendPage**: Accepts a boolean: true or false
        // If a user scrolls to the bottom of the page and the page is not tall enough to scroll to the last table of contents item, then the page height is increased
        extendPage: true,

        // **extendPageOffset**: Accepts a number: pixels
        // How close to the bottom of the page a user must scroll before the page is extended
        extendPageOffset: 100,

        // **history**: Accepts a boolean: true or false
        // Adds a hash to the page url to maintain history
        history: true,

        // **scrollHistory**: Accepts a boolean: true or false
        // Adds a hash to the page url, to maintain history, when scrolling to a TOC item
        scrollHistory: false,

        // **hashGenerator**: How the hash value (the anchor segment of the URL, following the
        // # character) will be generated.
        //
        // "compact" (default) - #CompressesEverythingTogether
        // "pretty" - #looks-like-a-nice-url-and-is-easily-readable
        // function(text, element){} - Your own hash generation function that accepts the text as an
        // argument, and returns the hash value.
        hashGenerator: "compact",

        // **highlightDefault**: Accepts a boolean: true or false
        // Set's the first TOC item as active if no other TOC item is active.
        highlightDefault: true

      },

      // _Create
      // -------
      //      Constructs the plugin.  Only called once.
      _create: function() {

        var self = this;

        self.extendPageScroll = true;

        // Internal array that keeps track of all TOC items (Helps to recognize if there are duplicate TOC item strings)
        self.items = [];

        // Generates the HTML for the dynamic table of contents
        self._generateToc();

        // Adds CSS classes to the newly generated table of contents HTML
        self._addCSSClasses();

        self.webkit = (function() {

          for (var prop in window) {

            if (prop) {

              if (prop.toLowerCase().indexOf("webkit") !== -1) {

                return true;

              }

            }

          }

          return false;

        }());

        // Adds jQuery event handlers to the newly generated table of contents
        self._setEventHandlers();

        // Binding to the Window load event to make sure the correct scrollTop is calculated
        $(window).on("load", function() {

          // Sets the active TOC item
          self._setActiveElement(true);

          // Once all animations on the page are complete, this callback function will be called
          $("html, body").promise().done(function() {

            setTimeout(function() {

              self.extendPageScroll = false;

            }, 0);

          });

        });

      },

      // _generateToc
      // ------------
      //      Generates the HTML for the dynamic table of contents
      _generateToc: function() {

        // _Local variables_

        // Stores the plugin context in the self variable
        var self = this,

          // All of the HTML tags found within the context provided (i.e. body) that match the top level jQuery selector above
          firstElem,

          // Instantiated variable that will store the top level newly created unordered list DOM element
          ul,
          ignoreSelector = self.options.ignoreSelector;


        // Determine the element to start the toc with
        // get all the top level selectors
        firstElem = [];
        var selectors = this.options.selectors.replace(/ /g, "").split(",");
        // find the first set that have at least one non-ignored element
        for(var i = 0; i < selectors.length; i++) {
          var foundSelectors = $(this.options.context).find(selectors[i]);
          for (var s = 0; s < foundSelectors.length; s++) {
            if (!$(foundSelectors[s]).is(ignoreSelector)) {
              firstElem = foundSelectors;
              break;
            }
          }
          if (firstElem.length> 0)
            break;
        }

        if (!firstElem.length) {

          self.element.addClass(hideTocClassName);

          return;

        }

        self.element.addClass(tocClassName);

        // Loops through each top level selector
        firstElem.each(function(index) {

          //If the element matches the ignoreSelector then we skip it
          if ($(this).is(ignoreSelector)) {
            return;
          }

          // Creates an unordered list HTML element and adds a dynamic ID and standard class name
          ul = $("<ul/>", {
            "id": headerClassName + index,
            "class": headerClassName
          }).

          // Appends a top level list item HTML element to the previously created HTML header
          append(self._nestElements($(this), index));

          // Add the created unordered list element to the HTML element calling the plugin
          self.element.append(ul);

          // Finds all of the HTML tags between the header and subheader elements
          $(this).nextUntil(this.nodeName.toLowerCase()).each(function() {

            // If there are no nested subheader elemements
            if ($(this).find(self.options.selectors).length === 0) {

              // Loops through all of the subheader elements
              $(this).filter(self.options.selectors).each(function() {

                //If the element matches the ignoreSelector then we skip it
                if ($(this).is(ignoreSelector)) {
                  return;
                }

                self._appendSubheaders.call(this, self, ul);

              });

            }

            // If there are nested subheader elements
            else {

              // Loops through all of the subheader elements
              $(this).find(self.options.selectors).each(function() {

                //If the element matches the ignoreSelector then we skip it
                if ($(this).is(ignoreSelector)) {
                  return;
                }

                self._appendSubheaders.call(this, self, ul);

              });

            }

          });

        });

      },

      _setActiveElement: function(pageload) {

        var self = this,

          hash = window.location.hash.substring(1),

          elem = self.element.find('li[data-unique="' + hash + '"]');

        if (hash.length) {

          // Removes highlighting from all of the list item's
          self.element.find("." + self.focusClass).removeClass(self.focusClass);

          // Highlights the current list item that was clicked
          elem.addClass(self.focusClass);

          // Triggers the click event on the currently focused TOC item
          elem.click();

        } else {

          // Removes highlighting from all of the list item's
          self.element.find("." + self.focusClass).removeClass(self.focusClass);

          if (!hash.length && pageload && self.options.highlightDefault) {

            // Highlights the first TOC item if no other items are highlighted
            self.element.find(itemClass).first().addClass(self.focusClass);

          }

        }

        return self;

      },

      // _nestElements
      // -------------
      //      Helps create the table of contents list by appending nested list items
      _nestElements: function(self, index) {

        var arr, item, hashValue;

        arr = $.grep(this.items, function(item) {

          return item === self.text();

        });

        // If there is already a duplicate TOC item
        if (arr.length) {

          // Adds the current TOC item text and index (for slight randomization) to the internal array
          this.items.push(self.text() + index);

        }

        // If there not a duplicate TOC item
        else {

          // Adds the current TOC item text to the internal array
          this.items.push(self.text());

        }

        hashValue = this._generateHashValue(arr, self, index);

        // Appends a list item HTML element to the last unordered list HTML element found within the HTML element calling the plugin
        item = $("<li/>", {

          // Sets a common class name to the list item
          "class": itemClassName,

          "data-unique": hashValue

        });

        if (this.options.theme !== "bootstrap3") {

          item.append($("<a/>", {

            "html": self.html()

          }));

        } else {

          item.html(self.html());

        }

        // Adds an HTML anchor tag before the currently traversed HTML element
        self.before($("<div/>", {

          // Sets a name attribute on the anchor tag to the text of the currently traversed HTML element (also making sure that all whitespace is replaced with an underscore)
          "name": hashValue,

          "data-unique": hashValue

        }));

        return item;

      },

      // _generateHashValue
      // ------------------
      //      Generates the hash value that will be used to refer to each item.
      _generateHashValue: function(arr, self, index) {

        var hashValue = "",
          hashGeneratorOption = this.options.hashGenerator;

        if (hashGeneratorOption === "pretty") {

          // prettify the text
          hashValue = self.text().toLowerCase().replace(/\s/g, "-");

          // fix double hyphens
          while (hashValue.indexOf("--") > -1) {
            hashValue = hashValue.replace(/--/g, "-");
          }

          // fix colon-space instances
          while (hashValue.indexOf(":-") > -1) {
            hashValue = hashValue.replace(/:-/g, "-");
          }

        } else if (typeof hashGeneratorOption === "function") {

          // call the function
          hashValue = hashGeneratorOption(self.text(), self);

        } else {

          // compact - the default
          hashValue = self.text().replace(/\s/g, "");

        }

        // add the index if we need to
        if (arr.length) {
          hashValue += "" + index;
        }

        // return the value
        return hashValue;

      },

      // _appendElements
      // ---------------
      //      Helps create the table of contents list by appending subheader elements

      _appendSubheaders: function(self, ul) {

        // The current element index
        var index = $(this).index(self.options.selectors),

          // Finds the previous header DOM element
          previousHeader = $(self.options.selectors).eq(index - 1),

          currentTagName = +$(this).prop("tagName").charAt(1),

          previousTagName = +previousHeader.prop("tagName").charAt(1),

          lastSubheader;

        // If the current header DOM element is smaller than the previous header DOM element or the first subheader
        if (currentTagName < previousTagName) {

          // Selects the last unordered list HTML found within the HTML element calling the plugin
          self.element.find(subheaderClass + "[data-tag=" + currentTagName + "]").last().append(self._nestElements($(this), index));

        }

        // If the current header DOM element is the same type of header(eg. h4) as the previous header DOM element
        else if (currentTagName === previousTagName) {

          ul.find(itemClass).last().after(self._nestElements($(this), index));

        } else {

          // Selects the last unordered list HTML found within the HTML element calling the plugin
          ul.find(itemClass).last().

          // Appends an unorderedList HTML element to the dynamic `unorderedList` variable and sets a common class name
          after($("<ul/>", {

            "class": subheaderClassName,

            "data-tag": currentTagName

          })).next(subheaderClass).

          // Appends a list item HTML element to the last unordered list HTML element found within the HTML element calling the plugin
          append(self._nestElements($(this), index));
        }

      },

      // _setEventHandlers
      // ----------------
      //      Adds jQuery event handlers to the newly generated table of contents
      _setEventHandlers: function() {

        // _Local variables_

        // Stores the plugin context in the self variable
        var self = this,

          // Instantiates a new variable that will be used to hold a specific element's context
          $self,

          // Instantiates a new variable that will be used to determine the smoothScroll animation time duration
          duration;

        // Event delegation that looks for any clicks on list item elements inside of the HTML element calling the plugin
        this.element.on("click.tocify", "li", function(event) {

          if (self.options.history) {

            window.location.hash = $(this).attr("data-unique");

          }

          // Removes highlighting from all of the list item's
          self.element.find("." + self.focusClass).removeClass(self.focusClass);

          // Highlights the current list item that was clicked
          $(this).addClass(self.focusClass);

          // If the showAndHide option is true
          if (self.options.showAndHide) {

            var elem = $('li[data-unique="' + $(this).attr("data-unique") + '"]');

            self._triggerShow(elem);

          }

          self._scrollTo($(this));

        });

        // Mouseenter and Mouseleave event handlers for the list item's within the HTML element calling the plugin
        this.element.find("li").on({

          // Mouseenter event handler
          "mouseenter.tocify": function() {

            // Adds a hover CSS class to the current list item
            $(this).addClass(self.hoverClass);

            // Makes sure the cursor is set to the pointer icon
            $(this).css("cursor", "pointer");

          },

          // Mouseleave event handler
          "mouseleave.tocify": function() {

            if (self.options.theme !== "bootstrap") {

              // Removes the hover CSS class from the current list item
              $(this).removeClass(self.hoverClass);

            }

          }
        });

        // only attach handler if needed (expensive in IE)
        if (self.options.extendPage || self.options.highlightOnScroll || self.options.scrollHistory || self.options.showAndHideOnScroll) {
          // Window scroll event handler
          $(window).on("scroll.tocify", function() {

            // Once all animations on the page are complete, this callback function will be called
            $("html, body").promise().done(function() {

              // Local variables

              // Stores how far the user has scrolled
              var winScrollTop = $(window).scrollTop(),

                // Stores the height of the window
                winHeight = $(window).height(),

                // Stores the height of the document
                docHeight = $(document).height(),

                scrollHeight = $("body")[0].scrollHeight,

                // Instantiates a variable that will be used to hold a selected HTML element
                elem,

                lastElem,

                lastElemOffset,

                currentElem;

              if (self.options.extendPage) {

                // If the user has scrolled to the bottom of the page and the last toc item is not focused
                if ((self.webkit && winScrollTop >= scrollHeight - winHeight - self.options.extendPageOffset) || (!self.webkit && winHeight + winScrollTop > docHeight - self.options.extendPageOffset)) {

                  if (!$(extendPageClass).length) {

                    lastElem = $('div[data-unique="' + $(itemClass).last().attr("data-unique") + '"]');

                    if (!lastElem.length) return;

                    // Gets the top offset of the page header that is linked to the last toc item
                    lastElemOffset = lastElem.offset().top;

                    // Appends a div to the bottom of the page and sets the height to the difference of the window scrollTop and the last element's position top offset
                    $(self.options.context).append($("<div/>", {

                      "class": extendPageClassName,

                      "height": Math.abs(lastElemOffset - winScrollTop) + "px",

                      "data-unique": extendPageClassName

                    }));

                    if (self.extendPageScroll) {

                      currentElem = self.element.find('li.' + self.focusClass);

                      self._scrollTo($('div[data-unique="' + currentElem.attr("data-unique") + '"]'));

                    }

                  }

                }

              }

              // The zero timeout ensures the following code is run after the scroll events
              setTimeout(function() {

                // _Local variables_

                // Stores the distance to the closest anchor
                var closestAnchorDistance = null,

                  // Stores the index of the closest anchor
                  closestAnchorIdx = null,

                  // Keeps a reference to all anchors
                  anchors = $(self.options.context).find("div[data-unique]"),

                  anchorText;

                // Determines the index of the closest anchor
                anchors.each(function(idx) {
                  var distance = Math.abs(($(this).next().length ? $(this).next() : $(this)).offset().top - winScrollTop - self.options.highlightOffset);
                  if (closestAnchorDistance == null || distance < closestAnchorDistance) {
                    closestAnchorDistance = distance;
                    closestAnchorIdx = idx;
                  } else {
                    return false;
                  }
                });

                anchorText = $(anchors[closestAnchorIdx]).attr("data-unique");

                // Stores the list item HTML element that corresponds to the currently traversed anchor tag
                elem = $('li[data-unique="' + anchorText + '"]');

                // If the `highlightOnScroll` option is true and a next element is found
                if (self.options.highlightOnScroll && elem.length) {

                  // Removes highlighting from all of the list item's
                  self.element.find("." + self.focusClass).removeClass(self.focusClass);

                  // Highlights the corresponding list item
                  elem.addClass(self.focusClass);

                }

                if (self.options.scrollHistory) {

                  if (window.location.hash !== "#" + anchorText) {

                    window.location.replace("#" + anchorText);

                  }
                }

                // If the `showAndHideOnScroll` option is true
                if (self.options.showAndHideOnScroll && self.options.showAndHide) {

                  self._triggerShow(elem, true);

                }

              }, 0);

            });

          });
        }

      },

      // Show
      // ----
      //      Opens the current sub-header
      show: function(elem, scroll) {

        // Stores the plugin context in the `self` variable
        var self = this,
          element = elem;

        // If the sub-header is not already visible
        if (!elem.is(":visible")) {

          // If the current element does not have any nested subheaders, is not a header, and its parent is not visible
          if (!elem.find(subheaderClass).length && !elem.parent().is(headerClass) && !elem.parent().is(":visible")) {

            // Sets the current element to all of the subheaders within the current header
            elem = elem.parents(subheaderClass).add(elem);

          }

          // If the current element does not have any nested subheaders and is not a header
          else if (!elem.children(subheaderClass).length && !elem.parent().is(headerClass)) {

            // Sets the current element to the closest subheader
            elem = elem.closest(subheaderClass);

          }

          //Determines what jQuery effect to use
          switch (self.options.showEffect) {

            //Uses `no effect`
            case "none":

              elem.show();

              break;

              //Uses the jQuery `show` special effect
            case "show":

              elem.show(self.options.showEffectSpeed);

              break;

              //Uses the jQuery `slideDown` special effect
            case "slideDown":

              elem.slideDown(self.options.showEffectSpeed);

              break;

              //Uses the jQuery `fadeIn` special effect
            case "fadeIn":

              elem.fadeIn(self.options.showEffectSpeed);

              break;

              //If none of the above options were passed, then a `jQueryUI show effect` is expected
            default:

              elem.show();

              break;

          }

        }

        // If the current subheader parent element is a header
        if (elem.parent().is(headerClass)) {

          // Hides all non-active sub-headers
          self.hide($(subheaderClass).not(elem));

        }

        // If the current subheader parent element is not a header
        else {

          // Hides all non-active sub-headers
          self.hide($(subheaderClass).not(elem.closest(headerClass).find(subheaderClass).not(elem.siblings())));

        }

        // Maintains chainablity
        return self;

      },

      // Hide
      // ----
      //      Closes the current sub-header
      hide: function(elem) {

        // Stores the plugin context in the `self` variable
        var self = this;

        //Determines what jQuery effect to use
        switch (self.options.hideEffect) {

          // Uses `no effect`
          case "none":

            elem.hide();

            break;

            // Uses the jQuery `hide` special effect
          case "hide":

            elem.hide(self.options.hideEffectSpeed);

            break;

            // Uses the jQuery `slideUp` special effect
          case "slideUp":

            elem.slideUp(self.options.hideEffectSpeed);

            break;

            // Uses the jQuery `fadeOut` special effect
          case "fadeOut":

            elem.fadeOut(self.options.hideEffectSpeed);

            break;

            // If none of the above options were passed, then a `jqueryUI hide effect` is expected
          default:

            elem.hide();

            break;

        }

        // Maintains chainablity
        return self;
      },

      // _triggerShow
      // ------------
      //      Determines what elements get shown on scroll and click
      _triggerShow: function(elem, scroll) {

        var self = this;

        // If the current element's parent is a header element or the next element is a nested subheader element
        if (elem.parent().is(headerClass) || elem.next().is(subheaderClass)) {

          // Shows the next sub-header element
          self.show(elem.next(subheaderClass), scroll);

        }

        // If the current element's parent is a subheader element
        else if (elem.parent().is(subheaderClass)) {

          // Shows the parent sub-header element
          self.show(elem.parent(), scroll);

        }

        // Maintains chainability
        return self;

      },

      // _addCSSClasses
      // --------------
      //      Adds CSS classes to the newly generated table of contents HTML
      _addCSSClasses: function() {

        // If the user wants a jqueryUI theme
        if (this.options.theme === "jqueryui") {

          this.focusClass = "ui-state-default";

          this.hoverClass = "ui-state-hover";

          //Adds the default styling to the dropdown list
          this.element.addClass("ui-widget").find(".toc-title").addClass("ui-widget-header").end().find("li").addClass("ui-widget-content");

        }

        // If the user wants a twitterBootstrap theme
        else if (this.options.theme === "bootstrap") {

          this.element.find(headerClass + "," + subheaderClass).addClass("nav nav-list");

          this.focusClass = "active";

        }

        // If the user wants a twitterBootstrap theme
        else if (this.options.theme === "bootstrap3") {

          this.element.find(headerClass + "," + subheaderClass).addClass("list-group");

          this.element.find(itemClass).addClass("list-group-item");

          this.focusClass = "active";

        }

        // If a user does not want a prebuilt theme
        else {

          // Adds more neutral classes (instead of jqueryui)

          this.focusClass = tocFocusClassName;

          this.hoverClass = tocHoverClassName;

        }

        //Maintains chainability
        return this;

      },

      // setOption
      // ---------
      //      Sets a single Tocify option after the plugin is invoked
      setOption: function() {

        // Calls the jQueryUI Widget Factory setOption method
        $.Widget.prototype._setOption.apply(this, arguments);

      },

      // setOptions
      // ----------
      //      Sets a single or multiple Tocify options after the plugin is invoked
      setOptions: function() {

        // Calls the jQueryUI Widget Factory setOptions method
        $.Widget.prototype._setOptions.apply(this, arguments);

      },

      // _scrollTo
      // ---------
      //      Scrolls to a specific element
      _scrollTo: function(elem) {

        var self = this,
          duration = self.options.smoothScroll || 0,
          scrollTo = self.options.scrollTo,
          currentDiv = $('div[data-unique="' + elem.attr("data-unique") + '"]');

        if (!currentDiv.length) {

          return self;

        }

        // Once all animations on the page are complete, this callback function will be called
        $("html, body").promise().done(function() {

          // Animates the html and body element scrolltops
          $("html, body").animate({

            // Sets the jQuery `scrollTop` to the top offset of the HTML div tag that matches the current list item's `data-unique` tag
            "scrollTop": currentDiv.offset().top - ($.isFunction(scrollTo) ? scrollTo.call() : scrollTo) + "px"

          }, {

            // Sets the smoothScroll animation time duration to the smoothScrollSpeed option
            "duration": duration

          });

        });

        // Maintains chainability
        return self;

      }

    });

  })); //end of plugin
</script>
<script>

/**
 * jQuery Plugin: Sticky Tabs
 *
 * @author Aidan Lister <aidan@php.net>
 * adapted by Ruben Arslan to activate parent tabs too
 * http://www.aidanlister.com/2014/03/persisting-the-tab-state-in-bootstrap/
 */
(function($) {
  "use strict";
  $.fn.rmarkdownStickyTabs = function() {
    var context = this;
    // Show the tab corresponding with the hash in the URL, or the first tab
    var showStuffFromHash = function() {
      var hash = window.location.hash;
      var selector = hash ? 'a[href="' + hash + '"]' : 'li.active > a';
      var $selector = $(selector, context);
      if($selector.data('toggle') === "tab") {
        $selector.tab('show');
        // walk up the ancestors of this element, show any hidden tabs
        $selector.parents('.section.tabset').each(function(i, elm) {
          var link = $('a[href="#' + $(elm).attr('id') + '"]');
          if(link.data('toggle') === "tab") {
            link.tab("show");
          }
        });
      }
    };


    // Set the correct tab when the page loads
    showStuffFromHash(context);

    // Set the correct tab when a user uses their back/forward button
    $(window).on('hashchange', function() {
      showStuffFromHash(context);
    });

    // Change the URL when tabs are clicked
    $('a', context).on('click', function(e) {
      history.pushState(null, null, this.href);
      showStuffFromHash(context);
    });

    return this;
  };
}(jQuery));

window.buildTabsets = function(tocID) {

  // build a tabset from a section div with the .tabset class
  function buildTabset(tabset) {

    // check for fade and pills options
    var fade = tabset.hasClass("tabset-fade");
    var pills = tabset.hasClass("tabset-pills");
    var navClass = pills ? "nav-pills" : "nav-tabs";

    // determine the heading level of the tabset and tabs
    var match = tabset.attr('class').match(/level(\d) /);
    if (match === null)
      return;
    var tabsetLevel = Number(match[1]);
    var tabLevel = tabsetLevel + 1;

    // find all subheadings immediately below
    var tabs = tabset.find("div.section.level" + tabLevel);
    if (!tabs.length)
      return;

    // create tablist and tab-content elements
    var tabList = $('<ul class="nav ' + navClass + '" role="tablist"></ul>');
    $(tabs[0]).before(tabList);
    var tabContent = $('<div class="tab-content"></div>');
    $(tabs[0]).before(tabContent);

    // build the tabset
    var activeTab = 0;
    tabs.each(function(i) {

      // get the tab div
      var tab = $(tabs[i]);

      // get the id then sanitize it for use with bootstrap tabs
      var id = tab.attr('id');

      // see if this is marked as the active tab
      if (tab.hasClass('active'))
        activeTab = i;

      // remove any table of contents entries associated with
      // this ID (since we'll be removing the heading element)
      $("div#" + tocID + " li a[href='#" + id + "']").parent().remove();

      // sanitize the id for use with bootstrap tabs
      id = id.replace(/[.\/?&!#<>]/g, '').replace(/\s/g, '_');
      tab.attr('id', id);

      // get the heading element within it, grab it's text, then remove it
      var heading = tab.find('h' + tabLevel + ':first');
      var headingText = heading.html();
      heading.remove();

      // build and append the tab list item
      var a = $('<a role="tab" data-toggle="tab">' + headingText + '</a>');
      a.attr('href', '#' + id);
      a.attr('aria-controls', id);
      var li = $('<li role="presentation"></li>');
      li.append(a);
      tabList.append(li);

      // set it's attributes
      tab.attr('role', 'tabpanel');
      tab.addClass('tab-pane');
      tab.addClass('tabbed-pane');
      if (fade)
        tab.addClass('fade');

      // move it into the tab content div
      tab.detach().appendTo(tabContent);
    });

    // set active tab
    $(tabList.children('li')[activeTab]).addClass('active');
    var active = $(tabContent.children('div.section')[activeTab]);
    active.addClass('active');
    if (fade)
      active.addClass('in');

    if (tabset.hasClass("tabset-sticky"))
      tabset.rmarkdownStickyTabs();
  }

  // convert section divs with the .tabset class to tabsets
  var tabsets = $("div.section.tabset");
  tabsets.each(function(i) {
    buildTabset($(tabsets[i]));
  });
};

</script>
<script>
window.initializeCodeFolding = function(show) {

  // handlers for show-all and hide all
  $("#rmd-show-all-code").click(function() {
    $('div.r-code-collapse').each(function() {
      $(this).collapse('show');
    });
  });
  $("#rmd-hide-all-code").click(function() {
    $('div.r-code-collapse').each(function() {
      $(this).collapse('hide');
    });
  });

  // index for unique code element ids
  var currentIndex = 1;

  // select all R code blocks
  var rCodeBlocks = $('pre.r, pre.python, pre.bash, pre.sql, pre.cpp, pre.stan, pre.julia, pre.foldable');
  rCodeBlocks.each(function() {
    // skip if the block has fold-none class
    if ($(this).hasClass('fold-none')) return;

    // create a collapsable div to wrap the code in
    var div = $('<div class="collapse r-code-collapse"></div>');
    var showThis = (show || $(this).hasClass('fold-show')) && !$(this).hasClass('fold-hide');
    var id = 'rcode-643E0F36' + currentIndex++;
    div.attr('id', id);
    $(this).before(div);
    $(this).detach().appendTo(div);

    // add a show code button right above
    var showCodeText = $('<span>' + (showThis ? 'Hide' : 'Show') + '</span>');
    var showCodeButton = $('<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm code-folding-btn pull-right float-right"></button>');
    showCodeButton.append(showCodeText);
    showCodeButton
        .attr('data-toggle', 'collapse')
        .attr('data-bs-toggle', 'collapse') // BS5
        .attr('data-target', '#' + id)
        .attr('data-bs-target', '#' + id)   // BS5
        .attr('aria-expanded', showThis)
        .attr('aria-controls', id);

    var buttonRow = $('<div class="row"></div>');
    var buttonCol = $('<div class="col-md-12"></div>');

    buttonCol.append(showCodeButton);
    buttonRow.append(buttonCol);

    div.before(buttonRow);

    // show the div if necessary
    if (showThis) div.collapse('show');

    // update state of button on show/hide
    //   * Change text
    //   * add a class for intermediate states styling
    div.on('hide.bs.collapse', function () {
      showCodeText.text('Show');
      showCodeButton.addClass('btn-collapsing');
    });
    div.on('hidden.bs.collapse', function () {
      showCodeButton.removeClass('btn-collapsing');
    });
    div.on('show.bs.collapse', function () {
      showCodeText.text('Hide');
      showCodeButton.addClass('btn-expanding');
    });
    div.on('shown.bs.collapse', function () {
      showCodeButton.removeClass('btn-expanding');
    });

  });

}
</script>
<style type="text/css">.hljs-literal {
color: #990073;
}
.hljs-number {
color: #099;
}
.hljs-comment {
color: #998;
font-style: italic;
}
.hljs-keyword {
color: #900;
font-weight: bold;
}
.hljs-string {
color: #d14;
}
</style>
<script src="data:application/javascript;base64,LyohIGhpZ2hsaWdodC5qcyB2OS4xMi4wIHwgQlNEMyBMaWNlbnNlIHwgZ2l0LmlvL2hsanNsaWNlbnNlICovCiFmdW5jdGlvbihlKXt2YXIgbj0ib2JqZWN0Ij09dHlwZW9mIHdpbmRvdyYmd2luZG93fHwib2JqZWN0Ij09dHlwZW9mIHNlbGYmJnNlbGY7InVuZGVmaW5lZCIhPXR5cGVvZiBleHBvcnRzP2UoZXhwb3J0cyk6biYmKG4uaGxqcz1lKHt9KSwiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kJiZkZWZpbmUoW10sZnVuY3Rpb24oKXtyZXR1cm4gbi5obGpzfSkpfShmdW5jdGlvbihlKXtmdW5jdGlvbiBuKGUpe3JldHVybiBlLnJlcGxhY2UoLyYvZywiJmFtcDsiKS5yZXBsYWNlKC88L2csIiZsdDsiKS5yZXBsYWNlKC8+L2csIiZndDsiKX1mdW5jdGlvbiB0KGUpe3JldHVybiBlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCl9ZnVuY3Rpb24gcihlLG4pe3ZhciB0PWUmJmUuZXhlYyhuKTtyZXR1cm4gdCYmMD09PXQuaW5kZXh9ZnVuY3Rpb24gYShlKXtyZXR1cm4gay50ZXN0KGUpfWZ1bmN0aW9uIGkoZSl7dmFyIG4sdCxyLGksbz1lLmNsYXNzTmFtZSsiICI7aWYobys9ZS5wYXJlbnROb2RlP2UucGFyZW50Tm9kZS5jbGFzc05hbWU6IiIsdD1CLmV4ZWMobykpcmV0dXJuIHcodFsxXSk/dFsxXToibm8taGlnaGxpZ2h0Ijtmb3Iobz1vLnNwbGl0KC9ccysvKSxuPTAscj1vLmxlbmd0aDtyPm47bisrKWlmKGk9b1tuXSxhKGkpfHx3KGkpKXJldHVybiBpfWZ1bmN0aW9uIG8oZSl7dmFyIG4sdD17fSxyPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKTtmb3IobiBpbiBlKXRbbl09ZVtuXTtyZXR1cm4gci5mb3JFYWNoKGZ1bmN0aW9uKGUpe2ZvcihuIGluIGUpdFtuXT1lW25dfSksdH1mdW5jdGlvbiB1KGUpe3ZhciBuPVtdO3JldHVybiBmdW5jdGlvbiByKGUsYSl7Zm9yKHZhciBpPWUuZmlyc3RDaGlsZDtpO2k9aS5uZXh0U2libGluZykzPT09aS5ub2RlVHlwZT9hKz1pLm5vZGVWYWx1ZS5sZW5ndGg6MT09PWkubm9kZVR5cGUmJihuLnB1c2goe2V2ZW50OiJzdGFydCIsb2Zmc2V0OmEsbm9kZTppfSksYT1yKGksYSksdChpKS5tYXRjaCgvYnJ8aHJ8aW1nfGlucHV0Lyl8fG4ucHVzaCh7ZXZlbnQ6InN0b3AiLG9mZnNldDphLG5vZGU6aX0pKTtyZXR1cm4gYX0oZSwwKSxufWZ1bmN0aW9uIGMoZSxyLGEpe2Z1bmN0aW9uIGkoKXtyZXR1cm4gZS5sZW5ndGgmJnIubGVuZ3RoP2VbMF0ub2Zmc2V0IT09clswXS5vZmZzZXQ/ZVswXS5vZmZzZXQ8clswXS5vZmZzZXQ/ZTpyOiJzdGFydCI9PT1yWzBdLmV2ZW50P2U6cjplLmxlbmd0aD9lOnJ9ZnVuY3Rpb24gbyhlKXtmdW5jdGlvbiByKGUpe3JldHVybiIgIitlLm5vZGVOYW1lKyc9IicrbihlLnZhbHVlKS5yZXBsYWNlKCciJywiJnF1b3Q7IikrJyInfXMrPSI8Iit0KGUpK0UubWFwLmNhbGwoZS5hdHRyaWJ1dGVzLHIpLmpvaW4oIiIpKyI+In1mdW5jdGlvbiB1KGUpe3MrPSI8LyIrdChlKSsiPiJ9ZnVuY3Rpb24gYyhlKXsoInN0YXJ0Ij09PWUuZXZlbnQ/bzp1KShlLm5vZGUpfWZvcih2YXIgbD0wLHM9IiIsZj1bXTtlLmxlbmd0aHx8ci5sZW5ndGg7KXt2YXIgZz1pKCk7aWYocys9bihhLnN1YnN0cmluZyhsLGdbMF0ub2Zmc2V0KSksbD1nWzBdLm9mZnNldCxnPT09ZSl7Zi5yZXZlcnNlKCkuZm9yRWFjaCh1KTtkbyBjKGcuc3BsaWNlKDAsMSlbMF0pLGc9aSgpO3doaWxlKGc9PT1lJiZnLmxlbmd0aCYmZ1swXS5vZmZzZXQ9PT1sKTtmLnJldmVyc2UoKS5mb3JFYWNoKG8pfWVsc2Uic3RhcnQiPT09Z1swXS5ldmVudD9mLnB1c2goZ1swXS5ub2RlKTpmLnBvcCgpLGMoZy5zcGxpY2UoMCwxKVswXSl9cmV0dXJuIHMrbihhLnN1YnN0cihsKSl9ZnVuY3Rpb24gbChlKXtyZXR1cm4gZS52JiYhZS5jYWNoZWRfdmFyaWFudHMmJihlLmNhY2hlZF92YXJpYW50cz1lLnYubWFwKGZ1bmN0aW9uKG4pe3JldHVybiBvKGUse3Y6bnVsbH0sbil9KSksZS5jYWNoZWRfdmFyaWFudHN8fGUuZVcmJltvKGUpXXx8W2VdfWZ1bmN0aW9uIHMoZSl7ZnVuY3Rpb24gbihlKXtyZXR1cm4gZSYmZS5zb3VyY2V8fGV9ZnVuY3Rpb24gdCh0LHIpe3JldHVybiBuZXcgUmVnRXhwKG4odCksIm0iKyhlLmNJPyJpIjoiIikrKHI/ImciOiIiKSl9ZnVuY3Rpb24gcihhLGkpe2lmKCFhLmNvbXBpbGVkKXtpZihhLmNvbXBpbGVkPSEwLGEuaz1hLmt8fGEuYkssYS5rKXt2YXIgbz17fSx1PWZ1bmN0aW9uKG4sdCl7ZS5jSSYmKHQ9dC50b0xvd2VyQ2FzZSgpKSx0LnNwbGl0KCIgIikuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1lLnNwbGl0KCJ8Iik7b1t0WzBdXT1bbix0WzFdP051bWJlcih0WzFdKToxXX0pfTsic3RyaW5nIj09dHlwZW9mIGEuaz91KCJrZXl3b3JkIixhLmspOngoYS5rKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3UoZSxhLmtbZV0pfSksYS5rPW99YS5sUj10KGEubHx8L1x3Ky8sITApLGkmJihhLmJLJiYoYS5iPSJcXGIoIithLmJLLnNwbGl0KCIgIikuam9pbigifCIpKyIpXFxiIiksYS5ifHwoYS5iPS9cQnxcYi8pLGEuYlI9dChhLmIpLGEuZXx8YS5lV3x8KGEuZT0vXEJ8XGIvKSxhLmUmJihhLmVSPXQoYS5lKSksYS50RT1uKGEuZSl8fCIiLGEuZVcmJmkudEUmJihhLnRFKz0oYS5lPyJ8IjoiIikraS50RSkpLGEuaSYmKGEuaVI9dChhLmkpKSxudWxsPT1hLnImJihhLnI9MSksYS5jfHwoYS5jPVtdKSxhLmM9QXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSxhLmMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBsKCJzZWxmIj09PWU/YTplKX0pKSxhLmMuZm9yRWFjaChmdW5jdGlvbihlKXtyKGUsYSl9KSxhLnN0YXJ0cyYmcihhLnN0YXJ0cyxpKTt2YXIgYz1hLmMubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLmJLPyJcXC4/KCIrZS5iKyIpXFwuPyI6ZS5ifSkuY29uY2F0KFthLnRFLGEuaV0pLm1hcChuKS5maWx0ZXIoQm9vbGVhbik7YS50PWMubGVuZ3RoP3QoYy5qb2luKCJ8IiksITApOntleGVjOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9fX19cihlKX1mdW5jdGlvbiBmKGUsdCxhLGkpe2Z1bmN0aW9uIG8oZSxuKXt2YXIgdCxhO2Zvcih0PTAsYT1uLmMubGVuZ3RoO2E+dDt0KyspaWYocihuLmNbdF0uYlIsZSkpcmV0dXJuIG4uY1t0XX1mdW5jdGlvbiB1KGUsbil7aWYocihlLmVSLG4pKXtmb3IoO2UuZW5kc1BhcmVudCYmZS5wYXJlbnQ7KWU9ZS5wYXJlbnQ7cmV0dXJuIGV9cmV0dXJuIGUuZVc/dShlLnBhcmVudCxuKTp2b2lkIDB9ZnVuY3Rpb24gYyhlLG4pe3JldHVybiFhJiZyKG4uaVIsZSl9ZnVuY3Rpb24gbChlLG4pe3ZhciB0PU4uY0k/blswXS50b0xvd2VyQ2FzZSgpOm5bMF07cmV0dXJuIGUuay5oYXNPd25Qcm9wZXJ0eSh0KSYmZS5rW3RdfWZ1bmN0aW9uIHAoZSxuLHQscil7dmFyIGE9cj8iIjpJLmNsYXNzUHJlZml4LGk9JzxzcGFuIGNsYXNzPSInK2Esbz10PyIiOkM7cmV0dXJuIGkrPWUrJyI+JyxpK24rb31mdW5jdGlvbiBoKCl7dmFyIGUsdCxyLGE7aWYoIUUuaylyZXR1cm4gbihrKTtmb3IoYT0iIix0PTAsRS5sUi5sYXN0SW5kZXg9MCxyPUUubFIuZXhlYyhrKTtyOylhKz1uKGsuc3Vic3RyaW5nKHQsci5pbmRleCkpLGU9bChFLHIpLGU/KEIrPWVbMV0sYSs9cChlWzBdLG4oclswXSkpKTphKz1uKHJbMF0pLHQ9RS5sUi5sYXN0SW5kZXgscj1FLmxSLmV4ZWMoayk7cmV0dXJuIGErbihrLnN1YnN0cih0KSl9ZnVuY3Rpb24gZCgpe3ZhciBlPSJzdHJpbmciPT10eXBlb2YgRS5zTDtpZihlJiYheVtFLnNMXSlyZXR1cm4gbihrKTt2YXIgdD1lP2YoRS5zTCxrLCEwLHhbRS5zTF0pOmcoayxFLnNMLmxlbmd0aD9FLnNMOnZvaWQgMCk7cmV0dXJuIEUucj4wJiYoQis9dC5yKSxlJiYoeFtFLnNMXT10LnRvcCkscCh0Lmxhbmd1YWdlLHQudmFsdWUsITEsITApfWZ1bmN0aW9uIGIoKXtMKz1udWxsIT1FLnNMP2QoKTpoKCksaz0iIn1mdW5jdGlvbiB2KGUpe0wrPWUuY04/cChlLmNOLCIiLCEwKToiIixFPU9iamVjdC5jcmVhdGUoZSx7cGFyZW50Ont2YWx1ZTpFfX0pfWZ1bmN0aW9uIG0oZSxuKXtpZihrKz1lLG51bGw9PW4pcmV0dXJuIGIoKSwwO3ZhciB0PW8obixFKTtpZih0KXJldHVybiB0LnNraXA/ays9bjoodC5lQiYmKGsrPW4pLGIoKSx0LnJCfHx0LmVCfHwoaz1uKSksdih0LG4pLHQuckI/MDpuLmxlbmd0aDt2YXIgcj11KEUsbik7aWYocil7dmFyIGE9RTthLnNraXA/ays9bjooYS5yRXx8YS5lRXx8KGsrPW4pLGIoKSxhLmVFJiYoaz1uKSk7ZG8gRS5jTiYmKEwrPUMpLEUuc2tpcHx8KEIrPUUuciksRT1FLnBhcmVudDt3aGlsZShFIT09ci5wYXJlbnQpO3JldHVybiByLnN0YXJ0cyYmdihyLnN0YXJ0cywiIiksYS5yRT8wOm4ubGVuZ3RofWlmKGMobixFKSl0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgbGV4ZW1lICInK24rJyIgZm9yIG1vZGUgIicrKEUuY058fCI8dW5uYW1lZD4iKSsnIicpO3JldHVybiBrKz1uLG4ubGVuZ3RofHwxfXZhciBOPXcoZSk7aWYoIU4pdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGxhbmd1YWdlOiAiJytlKyciJyk7cyhOKTt2YXIgUixFPWl8fE4seD17fSxMPSIiO2ZvcihSPUU7UiE9PU47Uj1SLnBhcmVudClSLmNOJiYoTD1wKFIuY04sIiIsITApK0wpO3ZhciBrPSIiLEI9MDt0cnl7Zm9yKHZhciBNLGosTz0wOzspe2lmKEUudC5sYXN0SW5kZXg9TyxNPUUudC5leGVjKHQpLCFNKWJyZWFrO2o9bSh0LnN1YnN0cmluZyhPLE0uaW5kZXgpLE1bMF0pLE89TS5pbmRleCtqfWZvcihtKHQuc3Vic3RyKE8pKSxSPUU7Ui5wYXJlbnQ7Uj1SLnBhcmVudClSLmNOJiYoTCs9Qyk7cmV0dXJue3I6Qix2YWx1ZTpMLGxhbmd1YWdlOmUsdG9wOkV9fWNhdGNoKFQpe2lmKFQubWVzc2FnZSYmLTEhPT1ULm1lc3NhZ2UuaW5kZXhPZigiSWxsZWdhbCIpKXJldHVybntyOjAsdmFsdWU6bih0KX07dGhyb3cgVH19ZnVuY3Rpb24gZyhlLHQpe3Q9dHx8SS5sYW5ndWFnZXN8fHgoeSk7dmFyIHI9e3I6MCx2YWx1ZTpuKGUpfSxhPXI7cmV0dXJuIHQuZmlsdGVyKHcpLmZvckVhY2goZnVuY3Rpb24obil7dmFyIHQ9ZihuLGUsITEpO3QubGFuZ3VhZ2U9bix0LnI+YS5yJiYoYT10KSx0LnI+ci5yJiYoYT1yLHI9dCl9KSxhLmxhbmd1YWdlJiYoci5zZWNvbmRfYmVzdD1hKSxyfWZ1bmN0aW9uIHAoZSl7cmV0dXJuIEkudGFiUmVwbGFjZXx8SS51c2VCUj9lLnJlcGxhY2UoTSxmdW5jdGlvbihlLG4pe3JldHVybiBJLnVzZUJSJiYiXG4iPT09ZT8iPGJyPiI6SS50YWJSZXBsYWNlP24ucmVwbGFjZSgvXHQvZyxJLnRhYlJlcGxhY2UpOiIifSk6ZX1mdW5jdGlvbiBoKGUsbix0KXt2YXIgcj1uP0xbbl06dCxhPVtlLnRyaW0oKV07cmV0dXJuIGUubWF0Y2goL1xiaGxqc1xiLyl8fGEucHVzaCgiaGxqcyIpLC0xPT09ZS5pbmRleE9mKHIpJiZhLnB1c2gociksYS5qb2luKCIgIikudHJpbSgpfWZ1bmN0aW9uIGQoZSl7dmFyIG4sdCxyLG8sbCxzPWkoZSk7YShzKXx8KEkudXNlQlI/KG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiwiZGl2Iiksbi5pbm5lckhUTUw9ZS5pbm5lckhUTUwucmVwbGFjZSgvXG4vZywiIikucmVwbGFjZSgvPGJyWyBcL10qPi9nLCJcbiIpKTpuPWUsbD1uLnRleHRDb250ZW50LHI9cz9mKHMsbCwhMCk6ZyhsKSx0PXUobiksdC5sZW5ndGgmJihvPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIsImRpdiIpLG8uaW5uZXJIVE1MPXIudmFsdWUsci52YWx1ZT1jKHQsdShvKSxsKSksci52YWx1ZT1wKHIudmFsdWUpLGUuaW5uZXJIVE1MPXIudmFsdWUsZS5jbGFzc05hbWU9aChlLmNsYXNzTmFtZSxzLHIubGFuZ3VhZ2UpLGUucmVzdWx0PXtsYW5ndWFnZTpyLmxhbmd1YWdlLHJlOnIucn0sci5zZWNvbmRfYmVzdCYmKGUuc2Vjb25kX2Jlc3Q9e2xhbmd1YWdlOnIuc2Vjb25kX2Jlc3QubGFuZ3VhZ2UscmU6ci5zZWNvbmRfYmVzdC5yfSkpfWZ1bmN0aW9uIGIoZSl7ST1vKEksZSl9ZnVuY3Rpb24gdigpe2lmKCF2LmNhbGxlZCl7di5jYWxsZWQ9ITA7dmFyIGU9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgicHJlIGNvZGUiKTtFLmZvckVhY2guY2FsbChlLGQpfX1mdW5jdGlvbiBtKCl7YWRkRXZlbnRMaXN0ZW5lcigiRE9NQ29udGVudExvYWRlZCIsdiwhMSksYWRkRXZlbnRMaXN0ZW5lcigibG9hZCIsdiwhMSl9ZnVuY3Rpb24gTihuLHQpe3ZhciByPXlbbl09dChlKTtyLmFsaWFzZXMmJnIuYWxpYXNlcy5mb3JFYWNoKGZ1bmN0aW9uKGUpe0xbZV09bn0pfWZ1bmN0aW9uIFIoKXtyZXR1cm4geCh5KX1mdW5jdGlvbiB3KGUpe3JldHVybiBlPShlfHwiIikudG9Mb3dlckNhc2UoKSx5W2VdfHx5W0xbZV1dfXZhciBFPVtdLHg9T2JqZWN0LmtleXMseT17fSxMPXt9LGs9L14obm8tP2hpZ2hsaWdodHxwbGFpbnx0ZXh0KSQvaSxCPS9cYmxhbmcoPzp1YWdlKT8tKFtcdy1dKylcYi9pLE09LygoXig8W14+XSs+fFx0fCkrfCg/OlxuKSkpL2dtLEM9Ijwvc3Bhbj4iLEk9e2NsYXNzUHJlZml4OiJobGpzLSIsdGFiUmVwbGFjZTpudWxsLHVzZUJSOiExLGxhbmd1YWdlczp2b2lkIDB9O3JldHVybiBlLmhpZ2hsaWdodD1mLGUuaGlnaGxpZ2h0QXV0bz1nLGUuZml4TWFya3VwPXAsZS5oaWdobGlnaHRCbG9jaz1kLGUuY29uZmlndXJlPWIsZS5pbml0SGlnaGxpZ2h0aW5nPXYsZS5pbml0SGlnaGxpZ2h0aW5nT25Mb2FkPW0sZS5yZWdpc3Rlckxhbmd1YWdlPU4sZS5saXN0TGFuZ3VhZ2VzPVIsZS5nZXRMYW5ndWFnZT13LGUuaW5oZXJpdD1vLGUuSVI9IlthLXpBLVpdXFx3KiIsZS5VSVI9IlthLXpBLVpfXVxcdyoiLGUuTlI9IlxcYlxcZCsoXFwuXFxkKyk/IixlLkNOUj0iKC0/KShcXGIwW3hYXVthLWZBLUYwLTldK3woXFxiXFxkKyhcXC5cXGQqKT98XFwuXFxkKykoW2VFXVstK10/XFxkKyk/KSIsZS5CTlI9IlxcYigwYlswMV0rKSIsZS5SU1I9IiF8IT18IT09fCV8JT18JnwmJnwmPXxcXCp8XFwqPXxcXCt8XFwrPXwsfC18LT18Lz18L3w6fDt8PDx8PDw9fDw9fDx8PT09fD09fD18Pj4+PXw+Pj18Pj18Pj4+fD4+fD58XFw/fFxcW3xcXHt8XFwofFxcXnxcXF49fFxcfHxcXHw9fFxcfFxcfHx+IixlLkJFPXtiOiJcXFxcW1xcc1xcU10iLHI6MH0sZS5BU009e2NOOiJzdHJpbmciLGI6IiciLGU6IiciLGk6IlxcbiIsYzpbZS5CRV19LGUuUVNNPXtjTjoic3RyaW5nIixiOiciJyxlOiciJyxpOiJcXG4iLGM6W2UuQkVdfSxlLlBXTT17YjovXGIoYXxhbnx0aGV8YXJlfEknbXxpc24ndHxkb24ndHxkb2Vzbid0fHdvbid0fGJ1dHxqdXN0fHNob3VsZHxwcmV0dHl8c2ltcGx5fGVub3VnaHxnb25uYXxnb2luZ3x3dGZ8c298c3VjaHx3aWxsfHlvdXx5b3VyfHRoZXl8bGlrZXxtb3JlKVxiL30sZS5DPWZ1bmN0aW9uKG4sdCxyKXt2YXIgYT1lLmluaGVyaXQoe2NOOiJjb21tZW50IixiOm4sZTp0LGM6W119LHJ8fHt9KTtyZXR1cm4gYS5jLnB1c2goZS5QV00pLGEuYy5wdXNoKHtjTjoiZG9jdGFnIixiOiIoPzpUT0RPfEZJWE1FfE5PVEV8QlVHfFhYWCk6IixyOjB9KSxhfSxlLkNMQ009ZS5DKCIvLyIsIiQiKSxlLkNCQ009ZS5DKCIvXFwqIiwiXFwqLyIpLGUuSENNPWUuQygiIyIsIiQiKSxlLk5NPXtjTjoibnVtYmVyIixiOmUuTlIscjowfSxlLkNOTT17Y046Im51bWJlciIsYjplLkNOUixyOjB9LGUuQk5NPXtjTjoibnVtYmVyIixiOmUuQk5SLHI6MH0sZS5DU1NOTT17Y046Im51bWJlciIsYjplLk5SKyIoJXxlbXxleHxjaHxyZW18dnd8dmh8dm1pbnx2bWF4fGNtfG1tfGlufHB0fHBjfHB4fGRlZ3xncmFkfHJhZHx0dXJufHN8bXN8SHp8a0h6fGRwaXxkcGNtfGRwcHgpPyIscjowfSxlLlJNPXtjTjoicmVnZXhwIixiOi9cLy8sZTovXC9bZ2ltdXldKi8saTovXG4vLGM6W2UuQkUse2I6L1xbLyxlOi9cXS8scjowLGM6W2UuQkVdfV19LGUuVE09e2NOOiJ0aXRsZSIsYjplLklSLHI6MH0sZS5VVE09e2NOOiJ0aXRsZSIsYjplLlVJUixyOjB9LGUuTUVUSE9EX0dVQVJEPXtiOiJcXC5cXHMqIitlLlVJUixyOjB9LGV9KTtobGpzLnJlZ2lzdGVyTGFuZ3VhZ2UoInNxbCIsZnVuY3Rpb24oZSl7dmFyIHQ9ZS5DKCItLSIsIiQiKTtyZXR1cm57Y0k6ITAsaTovWzw+e30qI10vLGM6W3tiSzoiYmVnaW4gZW5kIHN0YXJ0IGNvbW1pdCByb2xsYmFjayBzYXZlcG9pbnQgbG9jayBhbHRlciBjcmVhdGUgZHJvcCByZW5hbWUgY2FsbCBkZWxldGUgZG8gaGFuZGxlciBpbnNlcnQgbG9hZCByZXBsYWNlIHNlbGVjdCB0cnVuY2F0ZSB1cGRhdGUgc2V0IHNob3cgcHJhZ21hIGdyYW50IG1lcmdlIGRlc2NyaWJlIHVzZSBleHBsYWluIGhlbHAgZGVjbGFyZSBwcmVwYXJlIGV4ZWN1dGUgZGVhbGxvY2F0ZSByZWxlYXNlIHVubG9jayBwdXJnZSByZXNldCBjaGFuZ2Ugc3RvcCBhbmFseXplIGNhY2hlIGZsdXNoIG9wdGltaXplIHJlcGFpciBraWxsIGluc3RhbGwgdW5pbnN0YWxsIGNoZWNrc3VtIHJlc3RvcmUgY2hlY2sgYmFja3VwIHJldm9rZSBjb21tZW50IixlOi87LyxlVzohMCxsOi9bXHdcLl0rLyxrOntrZXl3b3JkOiJhYm9ydCBhYnMgYWJzb2x1dGUgYWNjIGFjY2UgYWNjZXAgYWNjZXB0IGFjY2VzcyBhY2Nlc3NlZCBhY2Nlc3NpYmxlIGFjY291bnQgYWNvcyBhY3Rpb24gYWN0aXZhdGUgYWRkIGFkZHRpbWUgYWRtaW4gYWRtaW5pc3RlciBhZHZhbmNlZCBhZHZpc2UgYWVzX2RlY3J5cHQgYWVzX2VuY3J5cHQgYWZ0ZXIgYWdlbnQgYWdncmVnYXRlIGFsaSBhbGlhIGFsaWFzIGFsbG9jYXRlIGFsbG93IGFsdGVyIGFsd2F5cyBhbmFseXplIGFuY2lsbGFyeSBhbmQgYW55IGFueWRhdGEgYW55ZGF0YXNldCBhbnlzY2hlbWEgYW55dHlwZSBhcHBseSBhcmNoaXZlIGFyY2hpdmVkIGFyY2hpdmVsb2cgYXJlIGFzIGFzYyBhc2NpaSBhc2luIGFzc2VtYmx5IGFzc2VydGlvbiBhc3NvY2lhdGUgYXN5bmNocm9ub3VzIGF0IGF0YW4gYXRuMiBhdHRyIGF0dHJpIGF0dHJpYiBhdHRyaWJ1IGF0dHJpYnV0IGF0dHJpYnV0ZSBhdHRyaWJ1dGVzIGF1ZGl0IGF1dGhlbnRpY2F0ZWQgYXV0aGVudGljYXRpb24gYXV0aGlkIGF1dGhvcnMgYXV0byBhdXRvYWxsb2NhdGUgYXV0b2RibGluayBhdXRvZXh0ZW5kIGF1dG9tYXRpYyBhdmFpbGFiaWxpdHkgYXZnIGJhY2t1cCBiYWRmaWxlIGJhc2ljZmlsZSBiZWZvcmUgYmVnaW4gYmVnaW5uaW5nIGJlbmNobWFyayBiZXR3ZWVuIGJmaWxlIGJmaWxlX2Jhc2UgYmlnIGJpZ2ZpbGUgYmluIGJpbmFyeV9kb3VibGUgYmluYXJ5X2Zsb2F0IGJpbmxvZyBiaXRfYW5kIGJpdF9jb3VudCBiaXRfbGVuZ3RoIGJpdF9vciBiaXRfeG9yIGJpdG1hcCBibG9iX2Jhc2UgYmxvY2sgYmxvY2tzaXplIGJvZHkgYm90aCBib3VuZCBidWZmZXJfY2FjaGUgYnVmZmVyX3Bvb2wgYnVpbGQgYnVsayBieSBieXRlIGJ5dGVvcmRlcm1hcmsgYnl0ZXMgY2FjaGUgY2FjaGluZyBjYWxsIGNhbGxpbmcgY2FuY2VsIGNhcGFjaXR5IGNhc2NhZGUgY2FzY2FkZWQgY2FzZSBjYXN0IGNhdGFsb2cgY2F0ZWdvcnkgY2VpbCBjZWlsaW5nIGNoYWluIGNoYW5nZSBjaGFuZ2VkIGNoYXJfYmFzZSBjaGFyX2xlbmd0aCBjaGFyYWN0ZXJfbGVuZ3RoIGNoYXJhY3RlcnMgY2hhcmFjdGVyc2V0IGNoYXJpbmRleCBjaGFyc2V0IGNoYXJzZXRmb3JtIGNoYXJzZXRpZCBjaGVjayBjaGVja3N1bSBjaGVja3N1bV9hZ2cgY2hpbGQgY2hvb3NlIGNociBjaHVuayBjbGFzcyBjbGVhbnVwIGNsZWFyIGNsaWVudCBjbG9iIGNsb2JfYmFzZSBjbG9uZSBjbG9zZSBjbHVzdGVyX2lkIGNsdXN0ZXJfcHJvYmFiaWxpdHkgY2x1c3Rlcl9zZXQgY2x1c3RlcmluZyBjb2FsZXNjZSBjb2VyY2liaWxpdHkgY29sIGNvbGxhdGUgY29sbGF0aW9uIGNvbGxlY3QgY29sdSBjb2x1bSBjb2x1bW4gY29sdW1uX3ZhbHVlIGNvbHVtbnMgY29sdW1uc191cGRhdGVkIGNvbW1lbnQgY29tbWl0IGNvbXBhY3QgY29tcGF0aWJpbGl0eSBjb21waWxlZCBjb21wbGV0ZSBjb21wb3NpdGVfbGltaXQgY29tcG91bmQgY29tcHJlc3MgY29tcHV0ZSBjb25jYXQgY29uY2F0X3dzIGNvbmN1cnJlbnQgY29uZmlybSBjb25uIGNvbm5lYyBjb25uZWN0IGNvbm5lY3RfYnlfaXNjeWNsZSBjb25uZWN0X2J5X2lzbGVhZiBjb25uZWN0X2J5X3Jvb3QgY29ubmVjdF90aW1lIGNvbm5lY3Rpb24gY29uc2lkZXIgY29uc2lzdGVudCBjb25zdGFudCBjb25zdHJhaW50IGNvbnN0cmFpbnRzIGNvbnN0cnVjdG9yIGNvbnRhaW5lciBjb250ZW50IGNvbnRlbnRzIGNvbnRleHQgY29udHJpYnV0b3JzIGNvbnRyb2xmaWxlIGNvbnYgY29udmVydCBjb252ZXJ0X3R6IGNvcnIgY29ycl9rIGNvcnJfcyBjb3JyZXNwb25kaW5nIGNvcnJ1cHRpb24gY29zIGNvc3QgY291bnQgY291bnRfYmlnIGNvdW50ZWQgY292YXJfcG9wIGNvdmFyX3NhbXAgY3B1X3Blcl9jYWxsIGNwdV9wZXJfc2Vzc2lvbiBjcmMzMiBjcmVhdGUgY3JlYXRpb24gY3JpdGljYWwgY3Jvc3MgY3ViZSBjdW1lX2Rpc3QgY3VyZGF0ZSBjdXJyZW50IGN1cnJlbnRfZGF0ZSBjdXJyZW50X3RpbWUgY3VycmVudF90aW1lc3RhbXAgY3VycmVudF91c2VyIGN1cnNvciBjdXJ0aW1lIGN1c3RvbWRhdHVtIGN5Y2xlIGRhdGEgZGF0YWJhc2UgZGF0YWJhc2VzIGRhdGFmaWxlIGRhdGFmaWxlcyBkYXRhbGVuZ3RoIGRhdGVfYWRkIGRhdGVfY2FjaGUgZGF0ZV9mb3JtYXQgZGF0ZV9zdWIgZGF0ZWFkZCBkYXRlZGlmZiBkYXRlZnJvbXBhcnRzIGRhdGVuYW1lIGRhdGVwYXJ0IGRhdGV0aW1lMmZyb21wYXJ0cyBkYXkgZGF5X3RvX3NlY29uZCBkYXluYW1lIGRheW9mbW9udGggZGF5b2Z3ZWVrIGRheW9meWVhciBkYXlzIGRiX3JvbGVfY2hhbmdlIGRidGltZXpvbmUgZGRsIGRlYWxsb2NhdGUgZGVjbGFyZSBkZWNvZGUgZGVjb21wb3NlIGRlY3JlbWVudCBkZWNyeXB0IGRlZHVwbGljYXRlIGRlZiBkZWZhIGRlZmF1IGRlZmF1bCBkZWZhdWx0IGRlZmF1bHRzIGRlZmVycmVkIGRlZmkgZGVmaW4gZGVmaW5lIGRlZ3JlZXMgZGVsYXllZCBkZWxlZ2F0ZSBkZWxldGUgZGVsZXRlX2FsbCBkZWxpbWl0ZWQgZGVtYW5kIGRlbnNlX3JhbmsgZGVwdGggZGVxdWV1ZSBkZXNfZGVjcnlwdCBkZXNfZW5jcnlwdCBkZXNfa2V5X2ZpbGUgZGVzYyBkZXNjciBkZXNjcmkgZGVzY3JpYiBkZXNjcmliZSBkZXNjcmlwdG9yIGRldGVybWluaXN0aWMgZGlhZ25vc3RpY3MgZGlmZmVyZW5jZSBkaW1lbnNpb24gZGlyZWN0X2xvYWQgZGlyZWN0b3J5IGRpc2FibGUgZGlzYWJsZV9hbGwgZGlzYWxsb3cgZGlzYXNzb2NpYXRlIGRpc2NhcmRmaWxlIGRpc2Nvbm5lY3QgZGlza2dyb3VwIGRpc3RpbmN0IGRpc3RpbmN0cm93IGRpc3RyaWJ1dGUgZGlzdHJpYnV0ZWQgZGl2IGRvIGRvY3VtZW50IGRvbWFpbiBkb3RuZXQgZG91YmxlIGRvd25ncmFkZSBkcm9wIGR1bXBmaWxlIGR1cGxpY2F0ZSBkdXJhdGlvbiBlYWNoIGVkaXRpb24gZWRpdGlvbmFibGUgZWRpdGlvbnMgZWxlbWVudCBlbGxpcHNpcyBlbHNlIGVsc2lmIGVsdCBlbXB0eSBlbmFibGUgZW5hYmxlX2FsbCBlbmNsb3NlZCBlbmNvZGUgZW5jb2RpbmcgZW5jcnlwdCBlbmQgZW5kLWV4ZWMgZW5kaWFuIGVuZm9yY2VkIGVuZ2luZSBlbmdpbmVzIGVucXVldWUgZW50ZXJwcmlzZSBlbnRpdHllc2NhcGluZyBlb21vbnRoIGVycm9yIGVycm9ycyBlc2NhcGVkIGV2YWxuYW1lIGV2YWx1YXRlIGV2ZW50IGV2ZW50ZGF0YSBldmVudHMgZXhjZXB0IGV4Y2VwdGlvbiBleGNlcHRpb25zIGV4Y2hhbmdlIGV4Y2x1ZGUgZXhjbHVkaW5nIGV4ZWN1IGV4ZWN1dCBleGVjdXRlIGV4ZW1wdCBleGlzdHMgZXhpdCBleHAgZXhwaXJlIGV4cGxhaW4gZXhwb3J0IGV4cG9ydF9zZXQgZXh0ZW5kZWQgZXh0ZW50IGV4dGVybmFsIGV4dGVybmFsXzEgZXh0ZXJuYWxfMiBleHRlcm5hbGx5IGV4dHJhY3QgZmFpbGVkIGZhaWxlZF9sb2dpbl9hdHRlbXB0cyBmYWlsb3ZlciBmYWlsdXJlIGZhciBmYXN0IGZlYXR1cmVfc2V0IGZlYXR1cmVfdmFsdWUgZmV0Y2ggZmllbGQgZmllbGRzIGZpbGUgZmlsZV9uYW1lX2NvbnZlcnQgZmlsZXN5c3RlbV9saWtlX2xvZ2dpbmcgZmluYWwgZmluaXNoIGZpcnN0IGZpcnN0X3ZhbHVlIGZpeGVkIGZsYXNoX2NhY2hlIGZsYXNoYmFjayBmbG9vciBmbHVzaCBmb2xsb3dpbmcgZm9sbG93cyBmb3IgZm9yYWxsIGZvcmNlIGZvcm0gZm9ybWEgZm9ybWF0IGZvdW5kIGZvdW5kX3Jvd3MgZnJlZWxpc3QgZnJlZWxpc3RzIGZyZWVwb29scyBmcmVzaCBmcm9tIGZyb21fYmFzZTY0IGZyb21fZGF5cyBmdHAgZnVsbCBmdW5jdGlvbiBnZW5lcmFsIGdlbmVyYXRlZCBnZXQgZ2V0X2Zvcm1hdCBnZXRfbG9jayBnZXRkYXRlIGdldHV0Y2RhdGUgZ2xvYmFsIGdsb2JhbF9uYW1lIGdsb2JhbGx5IGdvIGdvdG8gZ3JhbnQgZ3JhbnRzIGdyZWF0ZXN0IGdyb3VwIGdyb3VwX2NvbmNhdCBncm91cF9pZCBncm91cGluZyBncm91cGluZ19pZCBncm91cHMgZ3RpZF9zdWJ0cmFjdCBndWFyYW50ZWUgZ3VhcmQgaGFuZGxlciBoYXNoIGhhc2hrZXlzIGhhdmluZyBoZWEgaGVhZCBoZWFkaSBoZWFkaW4gaGVhZGluZyBoZWFwIGhlbHAgaGV4IGhpZXJhcmNoeSBoaWdoIGhpZ2hfcHJpb3JpdHkgaG9zdHMgaG91ciBodHRwIGlkIGlkZW50X2N1cnJlbnQgaWRlbnRfaW5jciBpZGVudF9zZWVkIGlkZW50aWZpZWQgaWRlbnRpdHkgaWRsZV90aW1lIGlmIGlmbnVsbCBpZ25vcmUgaWlmIGlsaWtlIGlsbSBpbW1lZGlhdGUgaW1wb3J0IGluIGluY2x1ZGUgaW5jbHVkaW5nIGluY3JlbWVudCBpbmRleCBpbmRleGVzIGluZGV4aW5nIGluZGV4dHlwZSBpbmRpY2F0b3IgaW5kaWNlcyBpbmV0Nl9hdG9uIGluZXQ2X250b2EgaW5ldF9hdG9uIGluZXRfbnRvYSBpbmZpbGUgaW5pdGlhbCBpbml0aWFsaXplZCBpbml0aWFsbHkgaW5pdHJhbnMgaW5tZW1vcnkgaW5uZXIgaW5ub2RiIGlucHV0IGluc2VydCBpbnN0YWxsIGluc3RhbmNlIGluc3RhbnRpYWJsZSBpbnN0ciBpbnRlcmZhY2UgaW50ZXJsZWF2ZWQgaW50ZXJzZWN0IGludG8gaW52YWxpZGF0ZSBpbnZpc2libGUgaXMgaXNfZnJlZV9sb2NrIGlzX2lwdjQgaXNfaXB2NF9jb21wYXQgaXNfbm90IGlzX25vdF9udWxsIGlzX3VzZWRfbG9jayBpc2RhdGUgaXNudWxsIGlzb2xhdGlvbiBpdGVyYXRlIGphdmEgam9pbiBqc29uIGpzb25fZXhpc3RzIGtlZXAga2VlcF9kdXBsaWNhdGVzIGtleSBrZXlzIGtpbGwgbGFuZ3VhZ2UgbGFyZ2UgbGFzdCBsYXN0X2RheSBsYXN0X2luc2VydF9pZCBsYXN0X3ZhbHVlIGxheCBsY2FzZSBsZWFkIGxlYWRpbmcgbGVhc3QgbGVhdmVzIGxlZnQgbGVuIGxlbmdodCBsZW5ndGggbGVzcyBsZXZlbCBsZXZlbHMgbGlicmFyeSBsaWtlIGxpa2UyIGxpa2U0IGxpa2VjIGxpbWl0IGxpbmVzIGxpbmsgbGlzdCBsaXN0YWdnIGxpdHRsZSBsbiBsb2FkIGxvYWRfZmlsZSBsb2IgbG9icyBsb2NhbCBsb2NhbHRpbWUgbG9jYWx0aW1lc3RhbXAgbG9jYXRlIGxvY2F0b3IgbG9jayBsb2NrZWQgbG9nIGxvZzEwIGxvZzIgbG9nZmlsZSBsb2dmaWxlcyBsb2dnaW5nIGxvZ2ljYWwgbG9naWNhbF9yZWFkc19wZXJfY2FsbCBsb2dvZmYgbG9nb24gbG9ncyBsb25nIGxvb3AgbG93IGxvd19wcmlvcml0eSBsb3dlciBscGFkIGxydHJpbSBsdHJpbSBtYWluIG1ha2Vfc2V0IG1ha2VkYXRlIG1ha2V0aW1lIG1hbmFnZWQgbWFuYWdlbWVudCBtYW51YWwgbWFwIG1hcHBpbmcgbWFzayBtYXN0ZXIgbWFzdGVyX3Bvc193YWl0IG1hdGNoIG1hdGNoZWQgbWF0ZXJpYWxpemVkIG1heCBtYXhleHRlbnRzIG1heGltaXplIG1heGluc3RhbmNlcyBtYXhsZW4gbWF4bG9nZmlsZXMgbWF4bG9naGlzdG9yeSBtYXhsb2dtZW1iZXJzIG1heHNpemUgbWF4dHJhbnMgbWQ1IG1lYXN1cmVzIG1lZGlhbiBtZWRpdW0gbWVtYmVyIG1lbWNvbXByZXNzIG1lbW9yeSBtZXJnZSBtaWNyb3NlY29uZCBtaWQgbWlncmF0aW9uIG1pbiBtaW5leHRlbnRzIG1pbmltdW0gbWluaW5nIG1pbnVzIG1pbnV0ZSBtaW52YWx1ZSBtaXNzaW5nIG1vZCBtb2RlIG1vZGVsIG1vZGlmaWNhdGlvbiBtb2RpZnkgbW9kdWxlIG1vbml0b3JpbmcgbW9udGggbW9udGhzIG1vdW50IG1vdmUgbW92ZW1lbnQgbXVsdGlzZXQgbXV0ZXggbmFtZSBuYW1lX2NvbnN0IG5hbWVzIG5hbiBuYXRpb25hbCBuYXRpdmUgbmF0dXJhbCBuYXYgbmNoYXIgbmNsb2IgbmVzdGVkIG5ldmVyIG5ldyBuZXdsaW5lIG5leHQgbmV4dHZhbCBubyBub193cml0ZV90b19iaW5sb2cgbm9hcmNoaXZlbG9nIG5vYXVkaXQgbm9iYWRmaWxlIG5vY2hlY2sgbm9jb21wcmVzcyBub2NvcHkgbm9jeWNsZSBub2RlbGF5IG5vZGlzY2FyZGZpbGUgbm9lbnRpdHllc2NhcGluZyBub2d1YXJhbnRlZSBub2tlZXAgbm9sb2dmaWxlIG5vbWFwcGluZyBub21heHZhbHVlIG5vbWluaW1pemUgbm9taW52YWx1ZSBub21vbml0b3Jpbmcgbm9uZSBub25lZGl0aW9uYWJsZSBub25zY2hlbWEgbm9vcmRlciBub3ByIG5vcHJvIG5vcHJvbSBub3Byb21wIG5vcHJvbXB0IG5vcmVseSBub3Jlc2V0bG9ncyBub3JldmVyc2Ugbm9ybWFsIG5vcm93ZGVwZW5kZW5jaWVzIG5vc2NoZW1hY2hlY2sgbm9zd2l0Y2ggbm90IG5vdGhpbmcgbm90aWNlIG5vdHJpbSBub3ZhbGlkYXRlIG5vdyBub3dhaXQgbnRoX3ZhbHVlIG51bGxpZiBudWxscyBudW0gbnVtYiBudW1iZSBudmFyY2hhciBudmFyY2hhcjIgb2JqZWN0IG9jaWNvbGwgb2NpZGF0ZSBvY2lkYXRldGltZSBvY2lkdXJhdGlvbiBvY2lpbnRlcnZhbCBvY2lsb2Jsb2NhdG9yIG9jaW51bWJlciBvY2lyZWYgb2NpcmVmY3Vyc29yIG9jaXJvd2lkIG9jaXN0cmluZyBvY2l0eXBlIG9jdCBvY3RldF9sZW5ndGggb2Ygb2ZmIG9mZmxpbmUgb2Zmc2V0IG9pZCBvaWRpbmRleCBvbGQgb24gb25saW5lIG9ubHkgb3BhcXVlIG9wZW4gb3BlcmF0aW9ucyBvcGVyYXRvciBvcHRpbWFsIG9wdGltaXplIG9wdGlvbiBvcHRpb25hbGx5IG9yIG9yYWNsZSBvcmFjbGVfZGF0ZSBvcmFkYXRhIG9yZCBvcmRhdWRpbyBvcmRkaWNvbSBvcmRkb2Mgb3JkZXIgb3JkaW1hZ2Ugb3JkaW5hbGl0eSBvcmR2aWRlbyBvcmdhbml6YXRpb24gb3JsYW55IG9ybHZhcnkgb3V0IG91dGVyIG91dGZpbGUgb3V0bGluZSBvdXRwdXQgb3ZlciBvdmVyZmxvdyBvdmVycmlkaW5nIHBhY2thZ2UgcGFkIHBhcmFsbGVsIHBhcmFsbGVsX2VuYWJsZSBwYXJhbWV0ZXJzIHBhcmVudCBwYXJzZSBwYXJ0aWFsIHBhcnRpdGlvbiBwYXJ0aXRpb25zIHBhc2NhbCBwYXNzaW5nIHBhc3N3b3JkIHBhc3N3b3JkX2dyYWNlX3RpbWUgcGFzc3dvcmRfbG9ja190aW1lIHBhc3N3b3JkX3JldXNlX21heCBwYXNzd29yZF9yZXVzZV90aW1lIHBhc3N3b3JkX3ZlcmlmeV9mdW5jdGlvbiBwYXRjaCBwYXRoIHBhdGluZGV4IHBjdGluY3JlYXNlIHBjdHRocmVzaG9sZCBwY3R1c2VkIHBjdHZlcnNpb24gcGVyY2VudCBwZXJjZW50X3JhbmsgcGVyY2VudGlsZV9jb250IHBlcmNlbnRpbGVfZGlzYyBwZXJmb3JtYW5jZSBwZXJpb2QgcGVyaW9kX2FkZCBwZXJpb2RfZGlmZiBwZXJtYW5lbnQgcGh5c2ljYWwgcGkgcGlwZSBwaXBlbGluZWQgcGl2b3QgcGx1Z2dhYmxlIHBsdWdpbiBwb2xpY3kgcG9zaXRpb24gcG9zdF90cmFuc2FjdGlvbiBwb3cgcG93ZXIgcHJhZ21hIHByZWJ1aWx0IHByZWNlZGVzIHByZWNlZGluZyBwcmVjaXNpb24gcHJlZGljdGlvbiBwcmVkaWN0aW9uX2Nvc3QgcHJlZGljdGlvbl9kZXRhaWxzIHByZWRpY3Rpb25fcHJvYmFiaWxpdHkgcHJlZGljdGlvbl9zZXQgcHJlcGFyZSBwcmVzZW50IHByZXNlcnZlIHByaW9yIHByaW9yaXR5IHByaXZhdGUgcHJpdmF0ZV9zZ2EgcHJpdmlsZWdlcyBwcm9jZWR1cmFsIHByb2NlZHVyZSBwcm9jZWR1cmVfYW5hbHl6ZSBwcm9jZXNzbGlzdCBwcm9maWxlcyBwcm9qZWN0IHByb21wdCBwcm90ZWN0aW9uIHB1YmxpYyBwdWJsaXNoaW5nc2VydmVybmFtZSBwdXJnZSBxdWFydGVyIHF1ZXJ5IHF1aWNrIHF1aWVzY2UgcXVvdGEgcXVvdGVuYW1lIHJhZGlhbnMgcmFpc2UgcmFuZCByYW5nZSByYW5rIHJhdyByZWFkIHJlYWRzIHJlYWRzaXplIHJlYnVpbGQgcmVjb3JkIHJlY29yZHMgcmVjb3ZlciByZWNvdmVyeSByZWN1cnNpdmUgcmVjeWNsZSByZWRvIHJlZHVjZWQgcmVmIHJlZmVyZW5jZSByZWZlcmVuY2VkIHJlZmVyZW5jZXMgcmVmZXJlbmNpbmcgcmVmcmVzaCByZWdleHBfbGlrZSByZWdpc3RlciByZWdyX2F2Z3ggcmVncl9hdmd5IHJlZ3JfY291bnQgcmVncl9pbnRlcmNlcHQgcmVncl9yMiByZWdyX3Nsb3BlIHJlZ3Jfc3h4IHJlZ3Jfc3h5IHJlamVjdCByZWtleSByZWxhdGlvbmFsIHJlbGF0aXZlIHJlbGF5bG9nIHJlbGVhc2UgcmVsZWFzZV9sb2NrIHJlbGllc19vbiByZWxvY2F0ZSByZWx5IHJlbSByZW1haW5kZXIgcmVuYW1lIHJlcGFpciByZXBlYXQgcmVwbGFjZSByZXBsaWNhdGUgcmVwbGljYXRpb24gcmVxdWlyZWQgcmVzZXQgcmVzZXRsb2dzIHJlc2l6ZSByZXNvdXJjZSByZXNwZWN0IHJlc3RvcmUgcmVzdHJpY3RlZCByZXN1bHQgcmVzdWx0X2NhY2hlIHJlc3VtYWJsZSByZXN1bWUgcmV0ZW50aW9uIHJldHVybiByZXR1cm5pbmcgcmV0dXJucyByZXVzZSByZXZlcnNlIHJldm9rZSByaWdodCBybGlrZSByb2xlIHJvbGVzIHJvbGxiYWNrIHJvbGxpbmcgcm9sbHVwIHJvdW5kIHJvdyByb3dfY291bnQgcm93ZGVwZW5kZW5jaWVzIHJvd2lkIHJvd251bSByb3dzIHJ0cmltIHJ1bGVzIHNhZmUgc2FsdCBzYW1wbGUgc2F2ZSBzYXZlcG9pbnQgc2IxIHNiMiBzYjQgc2NhbiBzY2hlbWEgc2NoZW1hY2hlY2sgc2NuIHNjb3BlIHNjcm9sbCBzZG9fZ2VvcmFzdGVyIHNkb190b3BvX2dlb21ldHJ5IHNlYXJjaCBzZWNfdG9fdGltZSBzZWNvbmQgc2VjdGlvbiBzZWN1cmVmaWxlIHNlY3VyaXR5IHNlZWQgc2VnbWVudCBzZWxlY3Qgc2VsZiBzZXF1ZW5jZSBzZXF1ZW50aWFsIHNlcmlhbGl6YWJsZSBzZXJ2ZXIgc2VydmVyZXJyb3Igc2Vzc2lvbiBzZXNzaW9uX3VzZXIgc2Vzc2lvbnNfcGVyX3VzZXIgc2V0IHNldHMgc2V0dGluZ3Mgc2hhIHNoYTEgc2hhMiBzaGFyZSBzaGFyZWQgc2hhcmVkX3Bvb2wgc2hvcnQgc2hvdyBzaHJpbmsgc2h1dGRvd24gc2lfYXZlcmFnZWNvbG9yIHNpX2NvbG9yaGlzdG9ncmFtIHNpX2ZlYXR1cmVsaXN0IHNpX3Bvc2l0aW9uYWxjb2xvciBzaV9zdGlsbGltYWdlIHNpX3RleHR1cmUgc2libGluZ3Mgc2lkIHNpZ24gc2luIHNpemUgc2l6ZV90IHNpemVzIHNraXAgc2xhdmUgc2xlZXAgc21hbGxkYXRldGltZWZyb21wYXJ0cyBzbWFsbGZpbGUgc25hcHNob3Qgc29tZSBzb25hbWUgc29ydCBzb3VuZGV4IHNvdXJjZSBzcGFjZSBzcGFyc2Ugc3BmaWxlIHNwbGl0IHNxbCBzcWxfYmlnX3Jlc3VsdCBzcWxfYnVmZmVyX3Jlc3VsdCBzcWxfY2FjaGUgc3FsX2NhbGNfZm91bmRfcm93cyBzcWxfc21hbGxfcmVzdWx0IHNxbF92YXJpYW50X3Byb3BlcnR5IHNxbGNvZGUgc3FsZGF0YSBzcWxlcnJvciBzcWxuYW1lIHNxbHN0YXRlIHNxcnQgc3F1YXJlIHN0YW5kYWxvbmUgc3RhbmRieSBzdGFydCBzdGFydGluZyBzdGFydHVwIHN0YXRlbWVudCBzdGF0aWMgc3RhdGlzdGljcyBzdGF0c19iaW5vbWlhbF90ZXN0IHN0YXRzX2Nyb3NzdGFiIHN0YXRzX2tzX3Rlc3Qgc3RhdHNfbW9kZSBzdGF0c19td190ZXN0IHN0YXRzX29uZV93YXlfYW5vdmEgc3RhdHNfdF90ZXN0XyBzdGF0c190X3Rlc3RfaW5kZXAgc3RhdHNfdF90ZXN0X29uZSBzdGF0c190X3Rlc3RfcGFpcmVkIHN0YXRzX3dzcl90ZXN0IHN0YXR1cyBzdGQgc3RkZGV2IHN0ZGRldl9wb3Agc3RkZGV2X3NhbXAgc3RkZXYgc3RvcCBzdG9yYWdlIHN0b3JlIHN0b3JlZCBzdHIgc3RyX3RvX2RhdGUgc3RyYWlnaHRfam9pbiBzdHJjbXAgc3RyaWN0IHN0cmluZyBzdHJ1Y3Qgc3R1ZmYgc3R5bGUgc3ViZGF0ZSBzdWJwYXJ0aXRpb24gc3VicGFydGl0aW9ucyBzdWJzdGl0dXRhYmxlIHN1YnN0ciBzdWJzdHJpbmcgc3VidGltZSBzdWJ0cmluZ19pbmRleCBzdWJ0eXBlIHN1Y2Nlc3Mgc3VtIHN1c3BlbmQgc3dpdGNoIHN3aXRjaG9mZnNldCBzd2l0Y2hvdmVyIHN5bmMgc3luY2hyb25vdXMgc3lub255bSBzeXMgc3lzX3htbGFnZyBzeXNhc20gc3lzYXV4IHN5c2RhdGUgc3lzZGF0ZXRpbWVvZmZzZXQgc3lzZGJhIHN5c29wZXIgc3lzdGVtIHN5c3RlbV91c2VyIHN5c3V0Y2RhdGV0aW1lIHRhYmxlIHRhYmxlcyB0YWJsZXNwYWNlIHRhbiB0ZG8gdGVtcGxhdGUgdGVtcG9yYXJ5IHRlcm1pbmF0ZWQgdGVydGlhcnlfd2VpZ2h0cyB0ZXN0IHRoYW4gdGhlbiB0aHJlYWQgdGhyb3VnaCB0aWVyIHRpZXMgdGltZSB0aW1lX2Zvcm1hdCB0aW1lX3pvbmUgdGltZWRpZmYgdGltZWZyb21wYXJ0cyB0aW1lb3V0IHRpbWVzdGFtcCB0aW1lc3RhbXBhZGQgdGltZXN0YW1wZGlmZiB0aW1lem9uZV9hYmJyIHRpbWV6b25lX21pbnV0ZSB0aW1lem9uZV9yZWdpb24gdG8gdG9fYmFzZTY0IHRvX2RhdGUgdG9fZGF5cyB0b19zZWNvbmRzIHRvZGF0ZXRpbWVvZmZzZXQgdHJhY2UgdHJhY2tpbmcgdHJhbnNhY3Rpb24gdHJhbnNhY3Rpb25hbCB0cmFuc2xhdGUgdHJhbnNsYXRpb24gdHJlYXQgdHJpZ2dlciB0cmlnZ2VyX25lc3RsZXZlbCB0cmlnZ2VycyB0cmltIHRydW5jYXRlIHRyeV9jYXN0IHRyeV9jb252ZXJ0IHRyeV9wYXJzZSB0eXBlIHViMSB1YjIgdWI0IHVjYXNlIHVuYXJjaGl2ZWQgdW5ib3VuZGVkIHVuY29tcHJlc3MgdW5kZXIgdW5kbyB1bmhleCB1bmljb2RlIHVuaWZvcm0gdW5pbnN0YWxsIHVuaW9uIHVuaXF1ZSB1bml4X3RpbWVzdGFtcCB1bmtub3duIHVubGltaXRlZCB1bmxvY2sgdW5waXZvdCB1bnJlY292ZXJhYmxlIHVuc2FmZSB1bnNpZ25lZCB1bnRpbCB1bnRydXN0ZWQgdW51c2FibGUgdW51c2VkIHVwZGF0ZSB1cGRhdGVkIHVwZ3JhZGUgdXBwZWQgdXBwZXIgdXBzZXJ0IHVybCB1cm93aWQgdXNhYmxlIHVzYWdlIHVzZSB1c2Vfc3RvcmVkX291dGxpbmVzIHVzZXIgdXNlcl9kYXRhIHVzZXJfcmVzb3VyY2VzIHVzZXJzIHVzaW5nIHV0Y19kYXRlIHV0Y190aW1lc3RhbXAgdXVpZCB1dWlkX3Nob3J0IHZhbGlkYXRlIHZhbGlkYXRlX3Bhc3N3b3JkX3N0cmVuZ3RoIHZhbGlkYXRpb24gdmFsaXN0IHZhbHVlIHZhbHVlcyB2YXIgdmFyX3NhbXAgdmFyY2hhcmMgdmFyaSB2YXJpYSB2YXJpYWIgdmFyaWFibCB2YXJpYWJsZSB2YXJpYWJsZXMgdmFyaWFuY2UgdmFycCB2YXJyYXcgdmFycmF3YyB2YXJyYXkgdmVyaWZ5IHZlcnNpb24gdmVyc2lvbnMgdmlldyB2aXJ0dWFsIHZpc2libGUgdm9pZCB3YWl0IHdhbGxldCB3YXJuaW5nIHdhcm5pbmdzIHdlZWsgd2Vla2RheSB3ZWVrb2Z5ZWFyIHdlbGxmb3JtZWQgd2hlbiB3aGVuZSB3aGVuZXYgd2hlbmV2ZSB3aGVuZXZlciB3aGVyZSB3aGlsZSB3aGl0ZXNwYWNlIHdpdGggd2l0aGluIHdpdGhvdXQgd29yayB3cmFwcGVkIHhkYiB4bWwgeG1sYWdnIHhtbGF0dHJpYnV0ZXMgeG1sY2FzdCB4bWxjb2xhdHR2YWwgeG1sZWxlbWVudCB4bWxleGlzdHMgeG1sZm9yZXN0IHhtbGluZGV4IHhtbG5hbWVzcGFjZXMgeG1scGkgeG1scXVlcnkgeG1scm9vdCB4bWxzY2hlbWEgeG1sc2VyaWFsaXplIHhtbHRhYmxlIHhtbHR5cGUgeG9yIHllYXIgeWVhcl90b19tb250aCB5ZWFycyB5ZWFyd2VlayIsbGl0ZXJhbDoidHJ1ZSBmYWxzZSBudWxsIixidWlsdF9pbjoiYXJyYXkgYmlnaW50IGJpbmFyeSBiaXQgYmxvYiBib29sZWFuIGNoYXIgY2hhcmFjdGVyIGRhdGUgZGVjIGRlY2ltYWwgZmxvYXQgaW50IGludDggaW50ZWdlciBpbnRlcnZhbCBudW1iZXIgbnVtZXJpYyByZWFsIHJlY29yZCBzZXJpYWwgc2VyaWFsOCBzbWFsbGludCB0ZXh0IHZhcmNoYXIgdmFyeWluZyB2b2lkIn0sYzpbe2NOOiJzdHJpbmciLGI6IiciLGU6IiciLGM6W2UuQkUse2I6IicnIn1dfSx7Y046InN0cmluZyIsYjonIicsZTonIicsYzpbZS5CRSx7YjonIiInfV19LHtjTjoic3RyaW5nIixiOiJgIixlOiJgIixjOltlLkJFXX0sZS5DTk0sZS5DQkNNLHRdfSxlLkNCQ00sdF19fSk7aGxqcy5yZWdpc3Rlckxhbmd1YWdlKCJyIixmdW5jdGlvbihlKXt2YXIgcj0iKFthLXpBLVpdfFxcLlthLXpBLVouXSlbYS16QS1aMC05Ll9dKiI7cmV0dXJue2M6W2UuSENNLHtiOnIsbDpyLGs6e2tleXdvcmQ6ImZ1bmN0aW9uIGlmIGluIGJyZWFrIG5leHQgcmVwZWF0IGVsc2UgZm9yIHJldHVybiBzd2l0Y2ggd2hpbGUgdHJ5IHRyeUNhdGNoIHN0b3Agd2FybmluZyByZXF1aXJlIGxpYnJhcnkgYXR0YWNoIGRldGFjaCBzb3VyY2Ugc2V0TWV0aG9kIHNldEdlbmVyaWMgc2V0R3JvdXBHZW5lcmljIHNldENsYXNzIC4uLiIsbGl0ZXJhbDoiTlVMTCBOQSBUUlVFIEZBTFNFIFQgRiBJbmYgTmFOIE5BX2ludGVnZXJffDEwIE5BX3JlYWxffDEwIE5BX2NoYXJhY3Rlcl98MTAgTkFfY29tcGxleF98MTAifSxyOjB9LHtjTjoibnVtYmVyIixiOiIwW3hYXVswLTlhLWZBLUZdK1tMaV0/XFxiIixyOjB9LHtjTjoibnVtYmVyIixiOiJcXGQrKD86W2VFXVsrXFwtXT9cXGQqKT9MXFxiIixyOjB9LHtjTjoibnVtYmVyIixiOiJcXGQrXFwuKD8hXFxkKSg/OmlcXGIpPyIscjowfSx7Y046Im51bWJlciIsYjoiXFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKik/aT9cXGIiLHI6MH0se2NOOiJudW1iZXIiLGI6IlxcLlxcZCsoPzpbZUVdWytcXC1dP1xcZCopP2k/XFxiIixyOjB9LHtiOiJgIixlOiJgIixyOjB9LHtjTjoic3RyaW5nIixjOltlLkJFXSx2Olt7YjonIicsZTonIid9LHtiOiInIixlOiInIn1dfV19fSk7aGxqcy5yZWdpc3Rlckxhbmd1YWdlKCJwZXJsIixmdW5jdGlvbihlKXt2YXIgdD0iZ2V0cHdlbnQgZ2V0c2VydmVudCBxdW90ZW1ldGEgbXNncmN2IHNjYWxhciBraWxsIGRibWNsb3NlIHVuZGVmIGxjIG1hIHN5c3dyaXRlIHRyIHNlbmQgdW1hc2sgc3lzb3BlbiBzaG13cml0ZSB2ZWMgcXggdXRpbWUgbG9jYWwgb2N0IHNlbWN0bCBsb2NhbHRpbWUgcmVhZHBpcGUgZG8gcmV0dXJuIGZvcm1hdCByZWFkIHNwcmludGYgZGJtb3BlbiBwb3AgZ2V0cGdycCBub3QgZ2V0cHduYW0gcmV3aW5kZGlyIHFxZmlsZW5vIHF3IGVuZHByb3RvZW50IHdhaXQgc2V0aG9zdGVudCBibGVzcyBzfDAgb3BlbmRpciBjb250aW51ZSBlYWNoIHNsZWVwIGVuZGdyZW50IHNodXRkb3duIGR1bXAgY2hvbXAgY29ubmVjdCBnZXRzb2NrbmFtZSBkaWUgc29ja2V0cGFpciBjbG9zZSBmbG9jayBleGlzdHMgaW5kZXggc2htZ2V0c3ViIGZvciBlbmRwd2VudCByZWRvIGxzdGF0IG1zZ2N0bCBzZXRwZ3JwIGFicyBleGl0IHNlbGVjdCBwcmludCByZWYgZ2V0aG9zdGJ5YWRkciB1bnNoaWZ0IGZjbnRsIHN5c2NhbGwgZ290byBnZXRuZXRieWFkZHIgam9pbiBnbXRpbWUgc3ltbGluayBzZW1nZXQgc3BsaWNlIHh8MCBnZXRwZWVybmFtZSByZWN2IGxvZyBzZXRzb2Nrb3B0IGNvcyBsYXN0IHJldmVyc2UgZ2V0aG9zdGJ5bmFtZSBnZXRncm5hbSBzdHVkeSBmb3JtbGluZSBlbmRob3N0ZW50IHRpbWVzIGNob3AgbGVuZ3RoIGdldGhvc3RlbnQgZ2V0bmV0ZW50IHBhY2sgZ2V0cHJvdG9lbnQgZ2V0c2VydmJ5bmFtZSByYW5kIG1rZGlyIHBvcyBjaG1vZCB5fDAgc3Vic3RyIGVuZG5ldGVudCBwcmludGYgbmV4dCBvcGVuIG1zZ3NuZCByZWFkZGlyIHVzZSB1bmxpbmsgZ2V0c29ja29wdCBnZXRwcmlvcml0eSByaW5kZXggd2FudGFycmF5IGhleCBzeXN0ZW0gZ2V0c2VydmJ5cG9ydCBlbmRzZXJ2ZW50IGludCBjaHIgdW50aWUgcm1kaXIgcHJvdG90eXBlIHRlbGwgbGlzdGVuIGZvcmsgc2htcmVhZCB1Y2ZpcnN0IHNldHByb3RvZW50IGVsc2Ugc3lzc2VlayBsaW5rIGdldGdyZ2lkIHNobWN0bCB3YWl0cGlkIHVucGFjayBnZXRuZXRieW5hbWUgcmVzZXQgY2hkaXIgZ3JlcCBzcGxpdCByZXF1aXJlIGNhbGxlciBsY2ZpcnN0IHVudGlsIHdhcm4gd2hpbGUgdmFsdWVzIHNoaWZ0IHRlbGxkaXIgZ2V0cHd1aWQgbXkgZ2V0cHJvdG9ieW51bWJlciBkZWxldGUgYW5kIHNvcnQgdWMgZGVmaW5lZCBzcmFuZCBhY2NlcHQgcGFja2FnZSBzZWVrZGlyIGdldHByb3RvYnluYW1lIHNlbW9wIG91ciByZW5hbWUgc2VlayBpZiBxfDAgY2hyb290IHN5c3JlYWQgc2V0cHdlbnQgbm8gY3J5cHQgZ2V0YyBjaG93biBzcXJ0IHdyaXRlIHNldG5ldGVudCBzZXRwcmlvcml0eSBmb3JlYWNoIHRpZSBzaW4gbXNnZ2V0IG1hcCBzdGF0IGdldGxvZ2luIHVubGVzcyBlbHNpZiB0cnVuY2F0ZSBleGVjIGtleXMgZ2xvYiB0aWVkIGNsb3NlZGlyaW9jdGwgc29ja2V0IHJlYWRsaW5rIGV2YWwgeG9yIHJlYWRsaW5lIGJpbm1vZGUgc2V0c2VydmVudCBlb2Ygb3JkIGJpbmQgYWxhcm0gcGlwZSBhdGFuMiBnZXRncmVudCBleHAgdGltZSBwdXNoIHNldGdyZW50IGd0IGx0IG9yIG5lIG18MCBicmVhayBnaXZlbiBzYXkgc3RhdGUgd2hlbiIscj17Y046InN1YnN0IixiOiJbJEBdXFx7IixlOiJcXH0iLGs6dH0scz17YjoiLT57IixlOiJ9In0sbj17djpbe2I6L1wkXGQvfSx7YjovW1wkJUBdKFxeXHdcYnwjXHcrKDo6XHcrKSp8e1x3K318XHcrKDo6XHcqKSopL30se2I6L1tcJCVAXVteXHNcd3tdLyxyOjB9XX0saT1bZS5CRSxyLG5dLG89W24sZS5IQ00sZS5DKCJeXFw9XFx3IiwiXFw9Y3V0Iix7ZVc6ITB9KSxzLHtjTjoic3RyaW5nIixjOmksdjpbe2I6InFbcXd4cl0/XFxzKlxcKCIsZToiXFwpIixyOjV9LHtiOiJxW3F3eHJdP1xccypcXFsiLGU6IlxcXSIscjo1fSx7YjoicVtxd3hyXT9cXHMqXFx7IixlOiJcXH0iLHI6NX0se2I6InFbcXd4cl0/XFxzKlxcfCIsZToiXFx8IixyOjV9LHtiOiJxW3F3eHJdP1xccypcXDwiLGU6IlxcPiIscjo1fSx7YjoicXdcXHMrcSIsZToicSIscjo1fSx7YjoiJyIsZToiJyIsYzpbZS5CRV19LHtiOiciJyxlOiciJ30se2I6ImAiLGU6ImAiLGM6W2UuQkVdfSx7Yjoie1xcdyt9IixjOltdLHI6MH0se2I6Ii0/XFx3K1xccypcXD1cXD4iLGM6W10scjowfV19LHtjTjoibnVtYmVyIixiOiIoXFxiMFswLTdfXSspfChcXGIweFswLTlhLWZBLUZfXSspfChcXGJbMS05XVswLTlfXSooXFwuWzAtOV9dKyk/KXxbMF9dXFxiIixyOjB9LHtiOiIoXFwvXFwvfCIrZS5SU1IrInxcXGIoc3BsaXR8cmV0dXJufHByaW50fHJldmVyc2V8Z3JlcClcXGIpXFxzKiIsazoic3BsaXQgcmV0dXJuIHByaW50IHJldmVyc2UgZ3JlcCIscjowLGM6W2UuSENNLHtjTjoicmVnZXhwIixiOiIoc3x0cnx5KS8oXFxcXC58W14vXSkqLyhcXFxcLnxbXi9dKSovW2Etel0qIixyOjEwfSx7Y046InJlZ2V4cCIsYjoiKG18cXIpPy8iLGU6Ii9bYS16XSoiLGM6W2UuQkVdLHI6MH1dfSx7Y046ImZ1bmN0aW9uIixiSzoic3ViIixlOiIoXFxzKlxcKC4qP1xcKSk/Wzt7XSIsZUU6ITAscjo1LGM6W2UuVE1dfSx7YjoiLVxcd1xcYiIscjowfSx7YjoiXl9fREFUQV9fJCIsZToiXl9fRU5EX18kIixzTDoibW9qb2xpY2lvdXMiLGM6W3tiOiJeQEAuKiIsZToiJCIsY046ImNvbW1lbnQifV19XTtyZXR1cm4gci5jPW8scy5jPW8se2FsaWFzZXM6WyJwbCIsInBtIl0sbDovW1x3XC5dKy8sazp0LGM6b319KTtobGpzLnJlZ2lzdGVyTGFuZ3VhZ2UoImluaSIsZnVuY3Rpb24oZSl7dmFyIGI9e2NOOiJzdHJpbmciLGM6W2UuQkVdLHY6W3tiOiInJyciLGU6IicnJyIscjoxMH0se2I6JyIiIicsZTonIiIiJyxyOjEwfSx7YjonIicsZTonIid9LHtiOiInIixlOiInIn1dfTtyZXR1cm57YWxpYXNlczpbInRvbWwiXSxjSTohMCxpOi9cUy8sYzpbZS5DKCI7IiwiJCIpLGUuSENNLHtjTjoic2VjdGlvbiIsYjovXlxzKlxbKy8sZTovXF0rL30se2I6L15bYS16MC05XFtcXV8tXStccyo9XHMqLyxlOiIkIixyQjohMCxjOlt7Y046ImF0dHIiLGI6L1thLXowLTlcW1xdXy1dKy99LHtiOi89LyxlVzohMCxyOjAsYzpbe2NOOiJsaXRlcmFsIixiOi9cYm9ufG9mZnx0cnVlfGZhbHNlfHllc3xub1xiL30se2NOOiJ2YXJpYWJsZSIsdjpbe2I6L1wkW1x3XGQiXVtcd1xkX10qL30se2I6L1wkXHsoLio/KX0vfV19LGIse2NOOiJudW1iZXIiLGI6LyhbXCtcLV0rKT9bXGRdK19bXGRfXSsvfSxlLk5NXX1dfV19fSk7aGxqcy5yZWdpc3Rlckxhbmd1YWdlKCJkaWZmIixmdW5jdGlvbihlKXtyZXR1cm57YWxpYXNlczpbInBhdGNoIl0sYzpbe2NOOiJtZXRhIixyOjEwLHY6W3tiOi9eQEAgK1wtXGQrLFxkKyArXCtcZCssXGQrICtAQCQvfSx7YjovXlwqXCpcKiArXGQrLFxkKyArXCpcKlwqXCokL30se2I6L15cLVwtXC0gK1xkKyxcZCsgK1wtXC1cLVwtJC99XX0se2NOOiJjb21tZW50Iix2Olt7YjovSW5kZXg6IC8sZTovJC99LHtiOi89ezMsfS8sZTovJC99LHtiOi9eXC17M30vLGU6LyQvfSx7YjovXlwqezN9IC8sZTovJC99LHtiOi9eXCt7M30vLGU6LyQvfSx7YjovXCp7NX0vLGU6L1wqezV9JC99XX0se2NOOiJhZGRpdGlvbiIsYjoiXlxcKyIsZToiJCJ9LHtjTjoiZGVsZXRpb24iLGI6Il5cXC0iLGU6IiQifSx7Y046ImFkZGl0aW9uIixiOiJeXFwhIixlOiIkIn1dfX0pO2hsanMucmVnaXN0ZXJMYW5ndWFnZSgiZ28iLGZ1bmN0aW9uKGUpe3ZhciB0PXtrZXl3b3JkOiJicmVhayBkZWZhdWx0IGZ1bmMgaW50ZXJmYWNlIHNlbGVjdCBjYXNlIG1hcCBzdHJ1Y3QgY2hhbiBlbHNlIGdvdG8gcGFja2FnZSBzd2l0Y2ggY29uc3QgZmFsbHRocm91Z2ggaWYgcmFuZ2UgdHlwZSBjb250aW51ZSBmb3IgaW1wb3J0IHJldHVybiB2YXIgZ28gZGVmZXIgYm9vbCBieXRlIGNvbXBsZXg2NCBjb21wbGV4MTI4IGZsb2F0MzIgZmxvYXQ2NCBpbnQ4IGludDE2IGludDMyIGludDY0IHN0cmluZyB1aW50OCB1aW50MTYgdWludDMyIHVpbnQ2NCBpbnQgdWludCB1aW50cHRyIHJ1bmUiLGxpdGVyYWw6InRydWUgZmFsc2UgaW90YSBuaWwiLGJ1aWx0X2luOiJhcHBlbmQgY2FwIGNsb3NlIGNvbXBsZXggY29weSBpbWFnIGxlbiBtYWtlIG5ldyBwYW5pYyBwcmludCBwcmludGxuIHJlYWwgcmVjb3ZlciBkZWxldGUifTtyZXR1cm57YWxpYXNlczpbImdvbGFuZyJdLGs6dCxpOiI8LyIsYzpbZS5DTENNLGUuQ0JDTSx7Y046InN0cmluZyIsdjpbZS5RU00se2I6IiciLGU6IlteXFxcXF0nIn0se2I6ImAiLGU6ImAifV19LHtjTjoibnVtYmVyIix2Olt7YjplLkNOUisiW2RmbHNpXSIscjoxfSxlLkNOTV19LHtiOi86PS99LHtjTjoiZnVuY3Rpb24iLGJLOiJmdW5jIixlOi9ccypcey8sZUU6ITAsYzpbZS5UTSx7Y046InBhcmFtcyIsYjovXCgvLGU6L1wpLyxrOnQsaTovWyInXS99XX1dfX0pO2hsanMucmVnaXN0ZXJMYW5ndWFnZSgiYmFzaCIsZnVuY3Rpb24oZSl7dmFyIHQ9e2NOOiJ2YXJpYWJsZSIsdjpbe2I6L1wkW1x3XGQjQF1bXHdcZF9dKi99LHtiOi9cJFx7KC4qPyl9L31dfSxzPXtjTjoic3RyaW5nIixiOi8iLyxlOi8iLyxjOltlLkJFLHQse2NOOiJ2YXJpYWJsZSIsYjovXCRcKC8sZTovXCkvLGM6W2UuQkVdfV19LGE9e2NOOiJzdHJpbmciLGI6LycvLGU6LycvfTtyZXR1cm57YWxpYXNlczpbInNoIiwienNoIl0sbDovXGItP1thLXpcLl9dK1xiLyxrOntrZXl3b3JkOiJpZiB0aGVuIGVsc2UgZWxpZiBmaSBmb3Igd2hpbGUgaW4gZG8gZG9uZSBjYXNlIGVzYWMgZnVuY3Rpb24iLGxpdGVyYWw6InRydWUgZmFsc2UiLGJ1aWx0X2luOiJicmVhayBjZCBjb250aW51ZSBldmFsIGV4ZWMgZXhpdCBleHBvcnQgZ2V0b3B0cyBoYXNoIHB3ZCByZWFkb25seSByZXR1cm4gc2hpZnQgdGVzdCB0aW1lcyB0cmFwIHVtYXNrIHVuc2V0IGFsaWFzIGJpbmQgYnVpbHRpbiBjYWxsZXIgY29tbWFuZCBkZWNsYXJlIGVjaG8gZW5hYmxlIGhlbHAgbGV0IGxvY2FsIGxvZ291dCBtYXBmaWxlIHByaW50ZiByZWFkIHJlYWRhcnJheSBzb3VyY2UgdHlwZSB0eXBlc2V0IHVsaW1pdCB1bmFsaWFzIHNldCBzaG9wdCBhdXRvbG9hZCBiZyBiaW5ka2V5IGJ5ZSBjYXAgY2hkaXIgY2xvbmUgY29tcGFyZ3VtZW50cyBjb21wY2FsbCBjb21wY3RsIGNvbXBkZXNjcmliZSBjb21wZmlsZXMgY29tcGdyb3VwcyBjb21wcXVvdGUgY29tcHRhZ3MgY29tcHRyeSBjb21wdmFsdWVzIGRpcnMgZGlzYWJsZSBkaXNvd24gZWNob3RjIGVjaG90aSBlbXVsYXRlIGZjIGZnIGZsb2F0IGZ1bmN0aW9ucyBnZXRjYXAgZ2V0bG4gaGlzdG9yeSBpbnRlZ2VyIGpvYnMga2lsbCBsaW1pdCBsb2cgbm9nbG9iIHBvcGQgcHJpbnQgcHVzaGQgcHVzaGxuIHJlaGFzaCBzY2hlZCBzZXRjYXAgc2V0b3B0IHN0YXQgc3VzcGVuZCB0dHljdGwgdW5mdW5jdGlvbiB1bmhhc2ggdW5saW1pdCB1bnNldG9wdCB2YXJlZCB3YWl0IHdoZW5jZSB3aGVyZSB3aGljaCB6Y29tcGlsZSB6Zm9ybWF0IHpmdHAgemxlIHptb2Rsb2FkIHpwYXJzZW9wdHMgenByb2YgenB0eSB6cmVnZXhwYXJzZSB6c29ja2V0IHpzdHlsZSB6dGNwIixfOiItbmUgLWVxIC1sdCAtZ3QgLWYgLWQgLWUgLXMgLWwgLWEifSxjOlt7Y046Im1ldGEiLGI6L14jIVteXG5dK3NoXHMqJC8scjoxMH0se2NOOiJmdW5jdGlvbiIsYjovXHdbXHdcZF9dKlxzKlwoXHMqXClccypcey8sckI6ITAsYzpbZS5pbmhlcml0KGUuVE0se2I6L1x3W1x3XGRfXSovfSldLHI6MH0sZS5IQ00scyxhLHRdfX0pO2hsanMucmVnaXN0ZXJMYW5ndWFnZSgicHl0aG9uIixmdW5jdGlvbihlKXt2YXIgcj17a2V5d29yZDoiYW5kIGVsaWYgaXMgZ2xvYmFsIGFzIGluIGlmIGZyb20gcmFpc2UgZm9yIGV4Y2VwdCBmaW5hbGx5IHByaW50IGltcG9ydCBwYXNzIHJldHVybiBleGVjIGVsc2UgYnJlYWsgbm90IHdpdGggY2xhc3MgYXNzZXJ0IHlpZWxkIHRyeSB3aGlsZSBjb250aW51ZSBkZWwgb3IgZGVmIGxhbWJkYSBhc3luYyBhd2FpdCBub25sb2NhbHwxMCBOb25lIFRydWUgRmFsc2UiLGJ1aWx0X2luOiJFbGxpcHNpcyBOb3RJbXBsZW1lbnRlZCJ9LGI9e2NOOiJtZXRhIixiOi9eKD4+PnxcLlwuXC4pIC99LGM9e2NOOiJzdWJzdCIsYjovXHsvLGU6L1x9LyxrOnIsaTovIy99LGE9e2NOOiJzdHJpbmciLGM6W2UuQkVdLHY6W3tiOi8odXxiKT9yPycnJy8sZTovJycnLyxjOltiXSxyOjEwfSx7YjovKHV8Yik/cj8iIiIvLGU6LyIiIi8sYzpbYl0scjoxMH0se2I6LyhmcnxyZnxmKScnJy8sZTovJycnLyxjOltiLGNdfSx7YjovKGZyfHJmfGYpIiIiLyxlOi8iIiIvLGM6W2IsY119LHtiOi8odXxyfHVyKScvLGU6LycvLHI6MTB9LHtiOi8odXxyfHVyKSIvLGU6LyIvLHI6MTB9LHtiOi8oYnxiciknLyxlOi8nL30se2I6LyhifGJyKSIvLGU6LyIvfSx7YjovKGZyfHJmfGYpJy8sZTovJy8sYzpbY119LHtiOi8oZnJ8cmZ8ZikiLyxlOi8iLyxjOltjXX0sZS5BU00sZS5RU01dfSxzPXtjTjoibnVtYmVyIixyOjAsdjpbe2I6ZS5CTlIrIltsTGpKXT8ifSx7YjoiXFxiKDBvWzAtN10rKVtsTGpKXT8ifSx7YjplLkNOUisiW2xMakpdPyJ9XX0saT17Y046InBhcmFtcyIsYjovXCgvLGU6L1wpLyxjOlsic2VsZiIsYixzLGFdfTtyZXR1cm4gYy5jPVthLHMsYl0se2FsaWFzZXM6WyJweSIsImd5cCJdLGs6cixpOi8oPFwvfC0+fFw/KXw9Pi8sYzpbYixzLGEsZS5IQ00se3Y6W3tjTjoiZnVuY3Rpb24iLGJLOiJkZWYifSx7Y046ImNsYXNzIixiSzoiY2xhc3MifV0sZTovOi8saTovWyR7PTtcbixdLyxjOltlLlVUTSxpLHtiOi8tPi8sZVc6ITAsazoiTm9uZSJ9XX0se2NOOiJtZXRhIixiOi9eW1x0IF0qQC8sZTovJC99LHtiOi9cYihwcmludHxleGVjKVwoL31dfX0pO2hsanMucmVnaXN0ZXJMYW5ndWFnZSgianVsaWEiLGZ1bmN0aW9uKGUpe3ZhciByPXtrZXl3b3JkOiJpbiBpc2Egd2hlcmUgYmFyZW1vZHVsZSBiZWdpbiBicmVhayBjYXRjaCBjY2FsbCBjb25zdCBjb250aW51ZSBkbyBlbHNlIGVsc2VpZiBlbmQgZXhwb3J0IGZhbHNlIGZpbmFsbHkgZm9yIGZ1bmN0aW9uIGdsb2JhbCBpZiBpbXBvcnQgaW1wb3J0YWxsIGxldCBsb2NhbCBtYWNybyBtb2R1bGUgcXVvdGUgcmV0dXJuIHRydWUgdHJ5IHVzaW5nIHdoaWxlIHR5cGUgaW1tdXRhYmxlIGFic3RyYWN0IGJpdHN0eXBlIHR5cGVhbGlhcyAiLGxpdGVyYWw6InRydWUgZmFsc2UgQVJHUyBDX05VTEwgRGV2TnVsbCBFTkRJQU5fQk9NIEVOViBJIEluZiBJbmYxNiBJbmYzMiBJbmY2NCBJbnNlcnRpb25Tb3J0IEpVTElBX0hPTUUgTE9BRF9QQVRIIE1lcmdlU29ydCBOYU4gTmFOMTYgTmFOMzIgTmFONjQgUFJPR1JBTV9GSUxFIFF1aWNrU29ydCBSb3VuZERvd24gUm91bmRGcm9tWmVybyBSb3VuZE5lYXJlc3QgUm91bmROZWFyZXN0VGllc0F3YXkgUm91bmROZWFyZXN0VGllc1VwIFJvdW5kVG9aZXJvIFJvdW5kVXAgU1RERVJSIFNURElOIFNURE9VVCBWRVJTSU9OIGNhdGFsYW4gZXwwIGV1fDAgZXVsZXJnYW1tYSBnb2xkZW4gaW0gbm90aGluZyBwaSDOsyDPgCDPhiAiLGJ1aWx0X2luOiJBTlkgQWJzdHJhY3RBcnJheSBBYnN0cmFjdENoYW5uZWwgQWJzdHJhY3RGbG9hdCBBYnN0cmFjdE1hdHJpeCBBYnN0cmFjdFJORyBBYnN0cmFjdFNlcmlhbGl6ZXIgQWJzdHJhY3RTZXQgQWJzdHJhY3RTcGFyc2VBcnJheSBBYnN0cmFjdFNwYXJzZU1hdHJpeCBBYnN0cmFjdFNwYXJzZVZlY3RvciBBYnN0cmFjdFN0cmluZyBBYnN0cmFjdFVuaXRSYW5nZSBBYnN0cmFjdFZlY09yTWF0IEFic3RyYWN0VmVjdG9yIEFueSBBcmd1bWVudEVycm9yIEFycmF5IEFzc2VydGlvbkVycm9yIEFzc29jaWF0aXZlIEJhc2U2NERlY29kZVBpcGUgQmFzZTY0RW5jb2RlUGlwZSBCaWRpYWdvbmFsIEJpZ0Zsb2F0IEJpZ0ludCBCaXRBcnJheSBCaXRNYXRyaXggQml0VmVjdG9yIEJvb2wgQm91bmRzRXJyb3IgQnVmZmVyU3RyZWFtIENhY2hpbmdQb29sIENhcHR1cmVkRXhjZXB0aW9uIENhcnRlc2lhbkluZGV4IENhcnRlc2lhblJhbmdlIENjaGFyIENkb3VibGUgQ2Zsb2F0IENoYW5uZWwgQ2hhciBDaW50IENpbnRtYXhfdCBDbG9uZyBDbG9uZ2xvbmcgQ2x1c3Rlck1hbmFnZXIgQ21kIENvZGVJbmZvIENvbG9uIENvbXBsZXggQ29tcGxleDEyOCBDb21wbGV4MzIgQ29tcGxleDY0IENvbXBvc2l0ZUV4Y2VwdGlvbiBDb25kaXRpb24gQ29uakFycmF5IENvbmpNYXRyaXggQ29ualZlY3RvciBDcHRyZGlmZl90IENzaG9ydCBDc2l6ZV90IENzc2l6ZV90IENzdHJpbmcgQ3VjaGFyIEN1aW50IEN1aW50bWF4X3QgQ3Vsb25nIEN1bG9uZ2xvbmcgQ3VzaG9ydCBDd2NoYXJfdCBDd3N0cmluZyBEYXRhVHlwZSBEYXRlIERhdGVGb3JtYXQgRGF0ZVRpbWUgRGVuc2VBcnJheSBEZW5zZU1hdHJpeCBEZW5zZVZlY09yTWF0IERlbnNlVmVjdG9yIERpYWdvbmFsIERpY3QgRGltZW5zaW9uTWlzbWF0Y2ggRGltcyBEaXJlY3RJbmRleFN0cmluZyBEaXNwbGF5IERpdmlkZUVycm9yIERvbWFpbkVycm9yIEVPRkVycm9yIEVhY2hMaW5lIEVudW0gRW51bWVyYXRlIEVycm9yRXhjZXB0aW9uIEV4Y2VwdGlvbiBFeHBvbmVudGlhbEJhY2tPZmYgRXhwciBGYWN0b3JpemF0aW9uIEZpbGVNb25pdG9yIEZsb2F0MTYgRmxvYXQzMiBGbG9hdDY0IEZ1bmN0aW9uIEZ1dHVyZSBHbG9iYWxSZWYgR290b05vZGUgSFRNTCBIZXJtaXRpYW4gSU8gSU9CdWZmZXIgSU9Db250ZXh0IElPU3RyZWFtIElQQWRkciBJUHY0IElQdjYgSW5kZXhDYXJ0ZXNpYW4gSW5kZXhMaW5lYXIgSW5kZXhTdHlsZSBJbmV4YWN0RXJyb3IgSW5pdEVycm9yIEludCBJbnQxMjggSW50MTYgSW50MzIgSW50NjQgSW50OCBJbnRTZXQgSW50ZWdlciBJbnRlcnJ1cHRFeGNlcHRpb24gSW52YWxpZFN0YXRlRXhjZXB0aW9uIElycmF0aW9uYWwgS2V5RXJyb3IgTGFiZWxOb2RlIExpblNwYWNlIExpbmVOdW1iZXJOb2RlIExvYWRFcnJvciBMb3dlclRyaWFuZ3VsYXIgTUlNRSBNYXRyaXggTWVyc2VubmVUd2lzdGVyIE1ldGhvZCBNZXRob2RFcnJvciBNZXRob2RUYWJsZSBNb2R1bGUgTlR1cGxlIE5ld3Zhck5vZGUgTnVsbEV4Y2VwdGlvbiBOdWxsYWJsZSBOdW1iZXIgT2JqZWN0SWREaWN0IE9yZGluYWxSYW5nZSBPdXRPZk1lbW9yeUVycm9yIE92ZXJmbG93RXJyb3IgUGFpciBQYXJzZUVycm9yIFBhcnRpYWxRdWlja1NvcnQgUGVybXV0ZWREaW1zQXJyYXkgUGlwZSBQb2xsaW5nRmlsZVdhdGNoZXIgUHJvY2Vzc0V4aXRlZEV4Y2VwdGlvbiBQdHIgUXVvdGVOb2RlIFJhbmRvbURldmljZSBSYW5nZSBSYW5nZUluZGV4IFJhdGlvbmFsIFJhd0ZEIFJlYWRPbmx5TWVtb3J5RXJyb3IgUmVhbCBSZWVudHJhbnRMb2NrIFJlZiBSZWdleCBSZWdleE1hdGNoIFJlbW90ZUNoYW5uZWwgUmVtb3RlRXhjZXB0aW9uIFJldlN0cmluZyBSb3VuZGluZ01vZGUgUm93VmVjdG9yIFNTQVZhbHVlIFNlZ21lbnRhdGlvbkZhdWx0IFNlcmlhbGl6YXRpb25TdGF0ZSBTZXQgU2hhcmVkQXJyYXkgU2hhcmVkTWF0cml4IFNoYXJlZFZlY3RvciBTaWduZWQgU2ltcGxlVmVjdG9yIFNsb3QgU2xvdE51bWJlciBTcGFyc2VNYXRyaXhDU0MgU3BhcnNlVmVjdG9yIFN0YWNrRnJhbWUgU3RhY2tPdmVyZmxvd0Vycm9yIFN0YWNrVHJhY2UgU3RlcFJhbmdlIFN0ZXBSYW5nZUxlbiBTdHJpZGVkQXJyYXkgU3RyaWRlZE1hdHJpeCBTdHJpZGVkVmVjT3JNYXQgU3RyaWRlZFZlY3RvciBTdHJpbmcgU3ViQXJyYXkgU3ViU3RyaW5nIFN5bVRyaWRpYWdvbmFsIFN5bWJvbCBTeW1tZXRyaWMgU3lzdGVtRXJyb3IgVENQU29ja2V0IFRhc2sgVGV4dCBUZXh0RGlzcGxheSBUaW1lciBUcmlkaWFnb25hbCBUdXBsZSBUeXBlIFR5cGVFcnJvciBUeXBlTWFwRW50cnkgVHlwZU1hcExldmVsIFR5cGVOYW1lIFR5cGVWYXIgVHlwZWRTbG90IFVEUFNvY2tldCBVSW50IFVJbnQxMjggVUludDE2IFVJbnQzMiBVSW50NjQgVUludDggVW5kZWZSZWZFcnJvciBVbmRlZlZhckVycm9yIFVuaWNvZGVFcnJvciBVbmlmb3JtU2NhbGluZyBVbmlvbiBVbmlvbkFsbCBVbml0UmFuZ2UgVW5zaWduZWQgVXBwZXJUcmlhbmd1bGFyIFZhbCBWYXJhcmcgVmVjRWxlbWVudCBWZWNPck1hdCBWZWN0b3IgVmVyc2lvbk51bWJlciBWb2lkIFdlYWtLZXlEaWN0IFdlYWtSZWYgV29ya2VyQ29uZmlnIFdvcmtlclBvb2wgIn0sdD0iW0EtWmEtel9cXHUwMEExLVxcdUZGRkZdW0EtWmEtel8wLTlcXHUwMEExLVxcdUZGRkZdKiIsYT17bDp0LGs6cixpOi88XC8vfSxuPXtjTjoibnVtYmVyIixiOi8oXGIweFtcZF9dKihcLltcZF9dKik/fDB4XC5cZFtcZF9dKilwWy0rXT9cZCt8XGIwW2JveF1bYS1mQS1GMC05XVthLWZBLUYwLTlfXSp8KFxiXGRbXGRfXSooXC5bXGRfXSopP3xcLlxkW1xkX10qKShbZUVmRl1bLStdP1xkKyk/LyxyOjB9LG89e2NOOiJzdHJpbmciLGI6LycoLnxcXFt4WHVVXVthLXpBLVowLTldKyknL30saT17Y046InN1YnN0IixiOi9cJFwoLyxlOi9cKS8sazpyfSxsPXtjTjoidmFyaWFibGUiLGI6IlxcJCIrdH0sYz17Y046InN0cmluZyIsYzpbZS5CRSxpLGxdLHY6W3tiOi9cdyoiIiIvLGU6LyIiIlx3Ki8scjoxMH0se2I6L1x3KiIvLGU6LyJcdyovfV19LHM9e2NOOiJzdHJpbmciLGM6W2UuQkUsaSxsXSxiOiJgIixlOiJgIn0sZD17Y046Im1ldGEiLGI6IkAiK3R9LHU9e2NOOiJjb21tZW50Iix2Olt7YjoiIz0iLGU6Ij0jIixyOjEwfSx7YjoiIyIsZToiJCJ9XX07cmV0dXJuIGEuYz1bbixvLGMscyxkLHUsZS5IQ00se2NOOiJrZXl3b3JkIixiOiJcXGIoKChhYnN0cmFjdHxwcmltaXRpdmUpXFxzKyl0eXBlfChtdXRhYmxlXFxzKyk/c3RydWN0KVxcYiJ9LHtiOi88Oi99XSxpLmM9YS5jLGF9KTtobGpzLnJlZ2lzdGVyTGFuZ3VhZ2UoImNvZmZlZXNjcmlwdCIsZnVuY3Rpb24oZSl7dmFyIGM9e2tleXdvcmQ6ImluIGlmIGZvciB3aGlsZSBmaW5hbGx5IG5ldyBkbyByZXR1cm4gZWxzZSBicmVhayBjYXRjaCBpbnN0YW5jZW9mIHRocm93IHRyeSB0aGlzIHN3aXRjaCBjb250aW51ZSB0eXBlb2YgZGVsZXRlIGRlYnVnZ2VyIHN1cGVyIHlpZWxkIGltcG9ydCBleHBvcnQgZnJvbSBhcyBkZWZhdWx0IGF3YWl0IHRoZW4gdW5sZXNzIHVudGlsIGxvb3Agb2YgYnkgd2hlbiBhbmQgb3IgaXMgaXNudCBub3QiLGxpdGVyYWw6InRydWUgZmFsc2UgbnVsbCB1bmRlZmluZWQgeWVzIG5vIG9uIG9mZiIsYnVpbHRfaW46Im5wbSByZXF1aXJlIGNvbnNvbGUgcHJpbnQgbW9kdWxlIGdsb2JhbCB3aW5kb3cgZG9jdW1lbnQifSxuPSJbQS1aYS16JF9dWzAtOUEtWmEteiRfXSoiLHI9e2NOOiJzdWJzdCIsYjovI1x7LyxlOi99LyxrOmN9LGk9W2UuQk5NLGUuaW5oZXJpdChlLkNOTSx7c3RhcnRzOntlOiIoXFxzKi8pPyIscjowfX0pLHtjTjoic3RyaW5nIix2Olt7YjovJycnLyxlOi8nJycvLGM6W2UuQkVdfSx7YjovJy8sZTovJy8sYzpbZS5CRV19LHtiOi8iIiIvLGU6LyIiIi8sYzpbZS5CRSxyXX0se2I6LyIvLGU6LyIvLGM6W2UuQkUscl19XX0se2NOOiJyZWdleHAiLHY6W3tiOiIvLy8iLGU6Ii8vLyIsYzpbcixlLkhDTV19LHtiOiIvL1tnaW1dKiIscjowfSx7YjovXC8oPyFbICpdKShcXFwvfC4pKj9cL1tnaW1dKig/PVxXfCQpL31dfSx7YjoiQCIrbn0se3NMOiJqYXZhc2NyaXB0IixlQjohMCxlRTohMCx2Olt7YjoiYGBgIixlOiJgYGAifSx7YjoiYCIsZToiYCJ9XX1dO3IuYz1pO3ZhciBzPWUuaW5oZXJpdChlLlRNLHtiOm59KSx0PSIoXFwoLipcXCkpP1xccypcXEJbLT1dPiIsbz17Y046InBhcmFtcyIsYjoiXFwoW15cXChdIixyQjohMCxjOlt7YjovXCgvLGU6L1wpLyxrOmMsYzpbInNlbGYiXS5jb25jYXQoaSl9XX07cmV0dXJue2FsaWFzZXM6WyJjb2ZmZWUiLCJjc29uIiwiaWNlZCJdLGs6YyxpOi9cL1wqLyxjOmkuY29uY2F0KFtlLkMoIiMjIyIsIiMjIyIpLGUuSENNLHtjTjoiZnVuY3Rpb24iLGI6Il5cXHMqIituKyJcXHMqPVxccyoiK3QsZToiWy09XT4iLHJCOiEwLGM6W3Msb119LHtiOi9bOlwoLD1dXHMqLyxyOjAsYzpbe2NOOiJmdW5jdGlvbiIsYjp0LGU6IlstPV0+IixyQjohMCxjOltvXX1dfSx7Y046ImNsYXNzIixiSzoiY2xhc3MiLGU6IiQiLGk6L1s6PSJcW1xdXS8sYzpbe2JLOiJleHRlbmRzIixlVzohMCxpOi9bOj0iXFtcXV0vLGM6W3NdfSxzXX0se2I6bisiOiIsZToiOiIsckI6ITAsckU6ITAscjowfV0pfX0pO2hsanMucmVnaXN0ZXJMYW5ndWFnZSgiY3BwIixmdW5jdGlvbih0KXt2YXIgZT17Y046ImtleXdvcmQiLGI6IlxcYlthLXpcXGRfXSpfdFxcYiJ9LHI9e2NOOiJzdHJpbmciLHY6W3tiOicodTg/fFUpP0w/IicsZTonIicsaToiXFxuIixjOlt0LkJFXX0se2I6Jyh1OD98VSk/UiInLGU6JyInLGM6W3QuQkVdfSx7YjoiJ1xcXFw/LiIsZToiJyIsaToiLiJ9XX0scz17Y046Im51bWJlciIsdjpbe2I6IlxcYigwYlswMSddKykifSx7YjoiKC0/KVxcYihbXFxkJ10rKFxcLltcXGQnXSopP3xcXC5bXFxkJ10rKSh1fFV8bHxMfHVsfFVMfGZ8RnxifEIpIn0se2I6IigtPykoXFxiMFt4WF1bYS1mQS1GMC05J10rfChcXGJbXFxkJ10rKFxcLltcXGQnXSopP3xcXC5bXFxkJ10rKShbZUVdWy0rXT9bXFxkJ10rKT8pIn1dLHI6MH0saT17Y046Im1ldGEiLGI6LyNccypbYS16XStcYi8sZTovJC8sazp7Im1ldGEta2V5d29yZCI6ImlmIGVsc2UgZWxpZiBlbmRpZiBkZWZpbmUgdW5kZWYgd2FybmluZyBlcnJvciBsaW5lIHByYWdtYSBpZmRlZiBpZm5kZWYgaW5jbHVkZSJ9LGM6W3tiOi9cXFxuLyxyOjB9LHQuaW5oZXJpdChyLHtjTjoibWV0YS1zdHJpbmcifSkse2NOOiJtZXRhLXN0cmluZyIsYjovPFteXG4+XSo+LyxlOi8kLyxpOiJcXG4ifSx0LkNMQ00sdC5DQkNNXX0sYT10LklSKyJcXHMqXFwoIixjPXtrZXl3b3JkOiJpbnQgZmxvYXQgd2hpbGUgcHJpdmF0ZSBjaGFyIGNhdGNoIGltcG9ydCBtb2R1bGUgZXhwb3J0IHZpcnR1YWwgb3BlcmF0b3Igc2l6ZW9mIGR5bmFtaWNfY2FzdHwxMCB0eXBlZGVmIGNvbnN0X2Nhc3R8MTAgY29uc3QgZm9yIHN0YXRpY19jYXN0fDEwIHVuaW9uIG5hbWVzcGFjZSB1bnNpZ25lZCBsb25nIHZvbGF0aWxlIHN0YXRpYyBwcm90ZWN0ZWQgYm9vbCB0ZW1wbGF0ZSBtdXRhYmxlIGlmIHB1YmxpYyBmcmllbmQgZG8gZ290byBhdXRvIHZvaWQgZW51bSBlbHNlIGJyZWFrIGV4dGVybiB1c2luZyBhc20gY2FzZSB0eXBlaWQgc2hvcnQgcmVpbnRlcnByZXRfY2FzdHwxMCBkZWZhdWx0IGRvdWJsZSByZWdpc3RlciBleHBsaWNpdCBzaWduZWQgdHlwZW5hbWUgdHJ5IHRoaXMgc3dpdGNoIGNvbnRpbnVlIGlubGluZSBkZWxldGUgYWxpZ25vZiBjb25zdGV4cHIgZGVjbHR5cGUgbm9leGNlcHQgc3RhdGljX2Fzc2VydCB0aHJlYWRfbG9jYWwgcmVzdHJpY3QgX0Jvb2wgY29tcGxleCBfQ29tcGxleCBfSW1hZ2luYXJ5IGF0b21pY19ib29sIGF0b21pY19jaGFyIGF0b21pY19zY2hhciBhdG9taWNfdWNoYXIgYXRvbWljX3Nob3J0IGF0b21pY191c2hvcnQgYXRvbWljX2ludCBhdG9taWNfdWludCBhdG9taWNfbG9uZyBhdG9taWNfdWxvbmcgYXRvbWljX2xsb25nIGF0b21pY191bGxvbmcgbmV3IHRocm93IHJldHVybiBhbmQgb3Igbm90IixidWlsdF9pbjoic3RkIHN0cmluZyBjaW4gY291dCBjZXJyIGNsb2cgc3RkaW4gc3Rkb3V0IHN0ZGVyciBzdHJpbmdzdHJlYW0gaXN0cmluZ3N0cmVhbSBvc3RyaW5nc3RyZWFtIGF1dG9fcHRyIGRlcXVlIGxpc3QgcXVldWUgc3RhY2sgdmVjdG9yIG1hcCBzZXQgYml0c2V0IG11bHRpc2V0IG11bHRpbWFwIHVub3JkZXJlZF9zZXQgdW5vcmRlcmVkX21hcCB1bm9yZGVyZWRfbXVsdGlzZXQgdW5vcmRlcmVkX211bHRpbWFwIGFycmF5IHNoYXJlZF9wdHIgYWJvcnQgYWJzIGFjb3MgYXNpbiBhdGFuMiBhdGFuIGNhbGxvYyBjZWlsIGNvc2ggY29zIGV4aXQgZXhwIGZhYnMgZmxvb3IgZm1vZCBmcHJpbnRmIGZwdXRzIGZyZWUgZnJleHAgZnNjYW5mIGlzYWxudW0gaXNhbHBoYSBpc2NudHJsIGlzZGlnaXQgaXNncmFwaCBpc2xvd2VyIGlzcHJpbnQgaXNwdW5jdCBpc3NwYWNlIGlzdXBwZXIgaXN4ZGlnaXQgdG9sb3dlciB0b3VwcGVyIGxhYnMgbGRleHAgbG9nMTAgbG9nIG1hbGxvYyByZWFsbG9jIG1lbWNociBtZW1jbXAgbWVtY3B5IG1lbXNldCBtb2RmIHBvdyBwcmludGYgcHV0Y2hhciBwdXRzIHNjYW5mIHNpbmggc2luIHNucHJpbnRmIHNwcmludGYgc3FydCBzc2NhbmYgc3RyY2F0IHN0cmNociBzdHJjbXAgc3RyY3B5IHN0cmNzcG4gc3RybGVuIHN0cm5jYXQgc3RybmNtcCBzdHJuY3B5IHN0cnBicmsgc3RycmNociBzdHJzcG4gc3Ryc3RyIHRhbmggdGFuIHZmcHJpbnRmIHZwcmludGYgdnNwcmludGYgZW5kbCBpbml0aWFsaXplcl9saXN0IHVuaXF1ZV9wdHIiLGxpdGVyYWw6InRydWUgZmFsc2UgbnVsbHB0ciBOVUxMIn0sbj1bZSx0LkNMQ00sdC5DQkNNLHMscl07cmV0dXJue2FsaWFzZXM6WyJjIiwiY2MiLCJoIiwiYysrIiwiaCsrIiwiaHBwIl0sazpjLGk6IjwvIixjOm4uY29uY2F0KFtpLHtiOiJcXGIoZGVxdWV8bGlzdHxxdWV1ZXxzdGFja3x2ZWN0b3J8bWFwfHNldHxiaXRzZXR8bXVsdGlzZXR8bXVsdGltYXB8dW5vcmRlcmVkX21hcHx1bm9yZGVyZWRfc2V0fHVub3JkZXJlZF9tdWx0aXNldHx1bm9yZGVyZWRfbXVsdGltYXB8YXJyYXkpXFxzKjwiLGU6Ij4iLGs6YyxjOlsic2VsZiIsZV19LHtiOnQuSVIrIjo6IixrOmN9LHt2Olt7YjovPS8sZTovOy99LHtiOi9cKC8sZTovXCkvfSx7Yks6Im5ldyB0aHJvdyByZXR1cm4gZWxzZSIsZTovOy99XSxrOmMsYzpuLmNvbmNhdChbe2I6L1woLyxlOi9cKS8sazpjLGM6bi5jb25jYXQoWyJzZWxmIl0pLHI6MH1dKSxyOjB9LHtjTjoiZnVuY3Rpb24iLGI6IigiK3QuSVIrIltcXComXFxzXSspKyIrYSxyQjohMCxlOi9bezs9XS8sZUU6ITAsazpjLGk6L1teXHdcc1wqJl0vLGM6W3tiOmEsckI6ITAsYzpbdC5UTV0scjowfSx7Y046InBhcmFtcyIsYjovXCgvLGU6L1wpLyxrOmMscjowLGM6W3QuQ0xDTSx0LkNCQ00scixzLGVdfSx0LkNMQ00sdC5DQkNNLGldfSx7Y046ImNsYXNzIixiSzoiY2xhc3Mgc3RydWN0IixlOi9bezs6XS8sYzpbe2I6LzwvLGU6Lz4vLGM6WyJzZWxmIl19LHQuVE1dfV0pLGV4cG9ydHM6e3ByZXByb2Nlc3NvcjppLHN0cmluZ3M6cixrOmN9fX0pO2hsanMucmVnaXN0ZXJMYW5ndWFnZSgicnVieSIsZnVuY3Rpb24oZSl7dmFyIGI9IlthLXpBLVpfXVxcdypbIT89XT98Wy0rfl1cXEB8PDx8Pj58PX58PT09P3w8PT58Wzw+XT0/fFxcKlxcKnxbLS8rJV4mKn5gfF18XFxbXFxdPT8iLHI9e2tleXdvcmQ6ImFuZCB0aGVuIGRlZmluZWQgbW9kdWxlIGluIHJldHVybiByZWRvIGlmIEJFR0lOIHJldHJ5IGVuZCBmb3Igc2VsZiB3aGVuIG5leHQgdW50aWwgZG8gYmVnaW4gdW5sZXNzIEVORCByZXNjdWUgZWxzZSBicmVhayB1bmRlZiBub3Qgc3VwZXIgY2xhc3MgY2FzZSByZXF1aXJlIHlpZWxkIGFsaWFzIHdoaWxlIGVuc3VyZSBlbHNpZiBvciBpbmNsdWRlIGF0dHJfcmVhZGVyIGF0dHJfd3JpdGVyIGF0dHJfYWNjZXNzb3IiLGxpdGVyYWw6InRydWUgZmFsc2UgbmlsIn0sYz17Y046ImRvY3RhZyIsYjoiQFtBLVphLXpdKyJ9LGE9e2I6IiM8IixlOiI+In0scz1bZS5DKCIjIiwiJCIse2M6W2NdfSksZS5DKCJeXFw9YmVnaW4iLCJeXFw9ZW5kIix7YzpbY10scjoxMH0pLGUuQygiXl9fRU5EX18iLCJcXG4kIildLG49e2NOOiJzdWJzdCIsYjoiI1xceyIsZToifSIsazpyfSx0PXtjTjoic3RyaW5nIixjOltlLkJFLG5dLHY6W3tiOi8nLyxlOi8nL30se2I6LyIvLGU6LyIvfSx7YjovYC8sZTovYC99LHtiOiIlW3FRd1d4XT9cXCgiLGU6IlxcKSJ9LHtiOiIlW3FRd1d4XT9cXFsiLGU6IlxcXSJ9LHtiOiIlW3FRd1d4XT97IixlOiJ9In0se2I6IiVbcVF3V3hdPzwiLGU6Ij4ifSx7YjoiJVtxUXdXeF0/LyIsZToiLyJ9LHtiOiIlW3FRd1d4XT8lIixlOiIlIn0se2I6IiVbcVF3V3hdPy0iLGU6Ii0ifSx7YjoiJVtxUXdXeF0/XFx8IixlOiJcXHwifSx7YjovXEJcPyhcXFxkezEsM318XFx4W0EtRmEtZjAtOV17MSwyfXxcXHVbQS1GYS1mMC05XXs0fXxcXD9cUylcYi99LHtiOi88PCgtPylcdyskLyxlOi9eXHMqXHcrJC99XX0saT17Y046InBhcmFtcyIsYjoiXFwoIixlOiJcXCkiLGVuZHNQYXJlbnQ6ITAsazpyfSxkPVt0LGEse2NOOiJjbGFzcyIsYks6ImNsYXNzIG1vZHVsZSIsZToiJHw7IixpOi89LyxjOltlLmluaGVyaXQoZS5UTSx7YjoiW0EtWmEtel9dXFx3Kig6OlxcdyspKihcXD98XFwhKT8ifSkse2I6IjxcXHMqIixjOlt7YjoiKCIrZS5JUisiOjopPyIrZS5JUn1dfV0uY29uY2F0KHMpfSx7Y046ImZ1bmN0aW9uIixiSzoiZGVmIixlOiIkfDsiLGM6W2UuaW5oZXJpdChlLlRNLHtiOmJ9KSxpXS5jb25jYXQocyl9LHtiOmUuSVIrIjo6In0se2NOOiJzeW1ib2wiLGI6ZS5VSVIrIihcXCF8XFw/KT86IixyOjB9LHtjTjoic3ltYm9sIixiOiI6KD8hXFxzKSIsYzpbdCx7YjpifV0scjowfSx7Y046Im51bWJlciIsYjoiKFxcYjBbMC03X10rKXwoXFxiMHhbMC05YS1mQS1GX10rKXwoXFxiWzEtOV1bMC05X10qKFxcLlswLTlfXSspPyl8WzBfXVxcYiIscjowfSx7YjoiKFxcJFxcVyl8KChcXCR8XFxAXFxAPykoXFx3KykpIn0se2NOOiJwYXJhbXMiLGI6L1x8LyxlOi9cfC8sazpyfSx7YjoiKCIrZS5SU1IrInx1bmxlc3MpXFxzKiIsazoidW5sZXNzIixjOlthLHtjTjoicmVnZXhwIixjOltlLkJFLG5dLGk6L1xuLyx2Olt7YjoiLyIsZToiL1thLXpdKiJ9LHtiOiIlcnsiLGU6In1bYS16XSoifSx7YjoiJXJcXCgiLGU6IlxcKVthLXpdKiJ9LHtiOiIlciEiLGU6IiFbYS16XSoifSx7YjoiJXJcXFsiLGU6IlxcXVthLXpdKiJ9XX1dLmNvbmNhdChzKSxyOjB9XS5jb25jYXQocyk7bi5jPWQsaS5jPWQ7dmFyIGw9Ils+P10+IixvPSJbXFx3I10rXFwoXFx3K1xcKTpcXGQrOlxcZCs+Iix1PSIoXFx3Ky0pP1xcZCtcXC5cXGQrXFwuXFxkKHBcXGQrKT9bXj5dKz4iLHc9W3tiOi9eXHMqPT4vLHN0YXJ0czp7ZToiJCIsYzpkfX0se2NOOiJtZXRhIixiOiJeKCIrbCsifCIrbysifCIrdSsiKSIsc3RhcnRzOntlOiIkIixjOmR9fV07cmV0dXJue2FsaWFzZXM6WyJyYiIsImdlbXNwZWMiLCJwb2RzcGVjIiwidGhvciIsImlyYiJdLGs6cixpOi9cL1wqLyxjOnMuY29uY2F0KHcpLmNvbmNhdChkKX19KTtobGpzLnJlZ2lzdGVyTGFuZ3VhZ2UoInlhbWwiLGZ1bmN0aW9uKGUpe3ZhciBiPSJ0cnVlIGZhbHNlIHllcyBubyBudWxsIixhPSJeWyBcXC1dKiIscj0iW2EtekEtWl9dW1xcd1xcLV0qIix0PXtjTjoiYXR0ciIsdjpbe2I6YStyKyI6In0se2I6YSsnIicrcisnIjonfSx7YjphKyInIityKyInOiJ9XX0sYz17Y046InRlbXBsYXRlLXZhcmlhYmxlIix2Olt7Yjoie3siLGU6In19In0se2I6IiV7IixlOiJ9In1dfSxsPXtjTjoic3RyaW5nIixyOjAsdjpbe2I6LycvLGU6LycvfSx7YjovIi8sZTovIi99LHtiOi9cUysvfV0sYzpbZS5CRSxjXX07cmV0dXJue2NJOiEwLGFsaWFzZXM6WyJ5bWwiLCJZQU1MIiwieWFtbCJdLGM6W3Qse2NOOiJtZXRhIixiOiJeLS0tcyokIixyOjEwfSx7Y046InN0cmluZyIsYjoiW1xcfD5dICokIixyRTohMCxjOmwuYyxlOnQudlswXS5ifSx7YjoiPCVbJT0tXT8iLGU6IlslLV0/JT4iLHNMOiJydWJ5IixlQjohMCxlRTohMCxyOjB9LHtjTjoidHlwZSIsYjoiISEiK2UuVUlSfSx7Y046Im1ldGEiLGI6IiYiK2UuVUlSKyIkIn0se2NOOiJtZXRhIixiOiJcXCoiK2UuVUlSKyIkIn0se2NOOiJidWxsZXQiLGI6Il4gKi0iLHI6MH0sZS5IQ00se2JLOmIsazp7bGl0ZXJhbDpifX0sZS5DTk0sbF19fSk7aGxqcy5yZWdpc3Rlckxhbmd1YWdlKCJjc3MiLGZ1bmN0aW9uKGUpe3ZhciBjPSJbYS16QS1aLV1bYS16QS1aMC05Xy1dKiIsdD17YjovW0EtWlxfXC5cLV0rXHMqOi8sckI6ITAsZToiOyIsZVc6ITAsYzpbe2NOOiJhdHRyaWJ1dGUiLGI6L1xTLyxlOiI6IixlRTohMCxzdGFydHM6e2VXOiEwLGVFOiEwLGM6W3tiOi9bXHctXStcKC8sckI6ITAsYzpbe2NOOiJidWlsdF9pbiIsYjovW1x3LV0rL30se2I6L1woLyxlOi9cKS8sYzpbZS5BU00sZS5RU01dfV19LGUuQ1NTTk0sZS5RU00sZS5BU00sZS5DQkNNLHtjTjoibnVtYmVyIixiOiIjWzAtOUEtRmEtZl0rIn0se2NOOiJtZXRhIixiOiIhaW1wb3J0YW50In1dfX1dfTtyZXR1cm57Y0k6ITAsaTovWz1cL3wnXCRdLyxjOltlLkNCQ00se2NOOiJzZWxlY3Rvci1pZCIsYjovI1tBLVphLXowLTlfLV0rL30se2NOOiJzZWxlY3Rvci1jbGFzcyIsYjovXC5bQS1aYS16MC05Xy1dKy99LHtjTjoic2VsZWN0b3ItYXR0ciIsYjovXFsvLGU6L1xdLyxpOiIkIn0se2NOOiJzZWxlY3Rvci1wc2V1ZG8iLGI6LzooOik/W2EtekEtWjAtOVxfXC1cK1woXCkiJy5dKy99LHtiOiJAKGZvbnQtZmFjZXxwYWdlKSIsbDoiW2Etei1dKyIsazoiZm9udC1mYWNlIHBhZ2UifSx7YjoiQCIsZToiW3s7XSIsaTovOi8sYzpbe2NOOiJrZXl3b3JkIixiOi9cdysvfSx7YjovXHMvLGVXOiEwLGVFOiEwLHI6MCxjOltlLkFTTSxlLlFTTSxlLkNTU05NXX1dfSx7Y046InNlbGVjdG9yLXRhZyIsYjpjLHI6MH0se2I6InsiLGU6In0iLGk6L1xTLyxjOltlLkNCQ00sdF19XX19KTtobGpzLnJlZ2lzdGVyTGFuZ3VhZ2UoImZvcnRyYW4iLGZ1bmN0aW9uKGUpe3ZhciB0PXtjTjoicGFyYW1zIixiOiJcXCgiLGU6IlxcKSJ9LG49e2xpdGVyYWw6Ii5GYWxzZS4gLlRydWUuIixrZXl3b3JkOiJraW5kIGRvIHdoaWxlIHByaXZhdGUgY2FsbCBpbnRyaW5zaWMgd2hlcmUgZWxzZXdoZXJlIHR5cGUgZW5kdHlwZSBlbmRtb2R1bGUgZW5kc2VsZWN0IGVuZGludGVyZmFjZSBlbmQgZW5kZG8gZW5kaWYgaWYgZm9yYWxsIGVuZGZvcmFsbCBvbmx5IGNvbnRhaW5zIGRlZmF1bHQgcmV0dXJuIHN0b3AgdGhlbiBwdWJsaWMgc3Vicm91dGluZXwxMCBmdW5jdGlvbiBwcm9ncmFtIC5hbmQuIC5vci4gLm5vdC4gLmxlLiAuZXEuIC5nZS4gLmd0LiAubHQuIGdvdG8gc2F2ZSBlbHNlIHVzZSBtb2R1bGUgc2VsZWN0IGNhc2UgYWNjZXNzIGJsYW5rIGRpcmVjdCBleGlzdCBmaWxlIGZtdCBmb3JtIGZvcm1hdHRlZCBpb3N0YXQgbmFtZSBuYW1lZCBuZXh0cmVjIG51bWJlciBvcGVuZWQgcmVjIHJlY2wgc2VxdWVudGlhbCBzdGF0dXMgdW5mb3JtYXR0ZWQgdW5pdCBjb250aW51ZSBmb3JtYXQgcGF1c2UgY3ljbGUgZXhpdCBjX251bGxfY2hhciBjX2FsZXJ0IGNfYmFja3NwYWNlIGNfZm9ybV9mZWVkIGZsdXNoIHdhaXQgZGVjaW1hbCByb3VuZCBpb21zZyBzeW5jaHJvbm91cyBub3Bhc3Mgbm9uX292ZXJyaWRhYmxlIHBhc3MgcHJvdGVjdGVkIHZvbGF0aWxlIGFic3RyYWN0IGV4dGVuZHMgaW1wb3J0IG5vbl9pbnRyaW5zaWMgdmFsdWUgZGVmZXJyZWQgZ2VuZXJpYyBmaW5hbCBlbnVtZXJhdG9yIGNsYXNzIGFzc29jaWF0ZSBiaW5kIGVudW0gY19pbnQgY19zaG9ydCBjX2xvbmcgY19sb25nX2xvbmcgY19zaWduZWRfY2hhciBjX3NpemVfdCBjX2ludDhfdCBjX2ludDE2X3QgY19pbnQzMl90IGNfaW50NjRfdCBjX2ludF9sZWFzdDhfdCBjX2ludF9sZWFzdDE2X3QgY19pbnRfbGVhc3QzMl90IGNfaW50X2xlYXN0NjRfdCBjX2ludF9mYXN0OF90IGNfaW50X2Zhc3QxNl90IGNfaW50X2Zhc3QzMl90IGNfaW50X2Zhc3Q2NF90IGNfaW50bWF4X3QgQ19pbnRwdHJfdCBjX2Zsb2F0IGNfZG91YmxlIGNfbG9uZ19kb3VibGUgY19mbG9hdF9jb21wbGV4IGNfZG91YmxlX2NvbXBsZXggY19sb25nX2RvdWJsZV9jb21wbGV4IGNfYm9vbCBjX2NoYXIgY19udWxsX3B0ciBjX251bGxfZnVucHRyIGNfbmV3X2xpbmUgY19jYXJyaWFnZV9yZXR1cm4gY19ob3Jpem9udGFsX3RhYiBjX3ZlcnRpY2FsX3RhYiBpc29fY19iaW5kaW5nIGNfbG9jIGNfZnVubG9jIGNfYXNzb2NpYXRlZCAgY19mX3BvaW50ZXIgY19wdHIgY19mdW5wdHIgaXNvX2ZvcnRyYW5fZW52IGNoYXJhY3Rlcl9zdG9yYWdlX3NpemUgZXJyb3JfdW5pdCBmaWxlX3N0b3JhZ2Vfc2l6ZSBpbnB1dF91bml0IGlvc3RhdF9lbmQgaW9zdGF0X2VvciBudW1lcmljX3N0b3JhZ2Vfc2l6ZSBvdXRwdXRfdW5pdCBjX2ZfcHJvY3BvaW50ZXIgaWVlZV9hcml0aG1ldGljIGllZWVfc3VwcG9ydF91bmRlcmZsb3dfY29udHJvbCBpZWVlX2dldF91bmRlcmZsb3dfbW9kZSBpZWVlX3NldF91bmRlcmZsb3dfbW9kZSBuZXd1bml0IGNvbnRpZ3VvdXMgcmVjdXJzaXZlIHBhZCBwb3NpdGlvbiBhY3Rpb24gZGVsaW0gcmVhZHdyaXRlIGVvciBhZHZhbmNlIG5tbCBpbnRlcmZhY2UgcHJvY2VkdXJlIG5hbWVsaXN0IGluY2x1ZGUgc2VxdWVuY2UgZWxlbWVudGFsIHB1cmUgaW50ZWdlciByZWFsIGNoYXJhY3RlciBjb21wbGV4IGxvZ2ljYWwgZGltZW5zaW9uIGFsbG9jYXRhYmxlfDEwIHBhcmFtZXRlciBleHRlcm5hbCBpbXBsaWNpdHwxMCBub25lIGRvdWJsZSBwcmVjaXNpb24gYXNzaWduIGludGVudCBvcHRpb25hbCBwb2ludGVyIHRhcmdldCBpbiBvdXQgY29tbW9uIGVxdWl2YWxlbmNlIGRhdGEiLGJ1aWx0X2luOiJhbG9nIGFsb2cxMCBhbWF4MCBhbWF4MSBhbWluMCBhbWluMSBhbW9kIGNhYnMgY2NvcyBjZXhwIGNsb2cgY3NpbiBjc3FydCBkYWJzIGRhY29zIGRhc2luIGRhdGFuIGRhdGFuMiBkY29zIGRjb3NoIGRkaW0gZGV4cCBkaW50IGRsb2cgZGxvZzEwIGRtYXgxIGRtaW4xIGRtb2QgZG5pbnQgZHNpZ24gZHNpbiBkc2luaCBkc3FydCBkdGFuIGR0YW5oIGZsb2F0IGlhYnMgaWRpbSBpZGludCBpZG5pbnQgaWZpeCBpc2lnbiBtYXgwIG1heDEgbWluMCBtaW4xIHNuZ2wgYWxnYW1hIGNkYWJzIGNkY29zIGNkZXhwIGNkbG9nIGNkc2luIGNkc3FydCBjcWFicyBjcWNvcyBjcWV4cCBjcWxvZyBjcXNpbiBjcXNxcnQgZGNtcGx4IGRjb25qZyBkZXJmIGRlcmZjIGRmbG9hdCBkZ2FtbWEgZGltYWcgZGxnYW1hIGlxaW50IHFhYnMgcWFjb3MgcWFzaW4gcWF0YW4gcWF0YW4yIHFjbXBseCBxY29uamcgcWNvcyBxY29zaCBxZGltIHFlcmYgcWVyZmMgcWV4cCBxZ2FtbWEgcWltYWcgcWxnYW1hIHFsb2cgcWxvZzEwIHFtYXgxIHFtaW4xIHFtb2QgcW5pbnQgcXNpZ24gcXNpbiBxc2luaCBxc3FydCBxdGFuIHF0YW5oIGFicyBhY29zIGFpbWFnIGFpbnQgYW5pbnQgYXNpbiBhdGFuIGF0YW4yIGNoYXIgY21wbHggY29uamcgY29zIGNvc2ggZXhwIGljaGFyIGluZGV4IGludCBsb2cgbG9nMTAgbWF4IG1pbiBuaW50IHNpZ24gc2luIHNpbmggc3FydCB0YW4gdGFuaCBwcmludCB3cml0ZSBkaW0gbGdlIGxndCBsbGUgbGx0IG1vZCBudWxsaWZ5IGFsbG9jYXRlIGRlYWxsb2NhdGUgYWRqdXN0bCBhZGp1c3RyIGFsbCBhbGxvY2F0ZWQgYW55IGFzc29jaWF0ZWQgYml0X3NpemUgYnRlc3QgY2VpbGluZyBjb3VudCBjc2hpZnQgZGF0ZV9hbmRfdGltZSBkaWdpdHMgZG90X3Byb2R1Y3QgZW9zaGlmdCBlcHNpbG9uIGV4cG9uZW50IGZsb29yIGZyYWN0aW9uIGh1Z2UgaWFuZCBpYmNsciBpYml0cyBpYnNldCBpZW9yIGlvciBpc2hmdCBpc2hmdGMgbGJvdW5kIGxlbl90cmltIG1hdG11bCBtYXhleHBvbmVudCBtYXhsb2MgbWF4dmFsIG1lcmdlIG1pbmV4cG9uZW50IG1pbmxvYyBtaW52YWwgbW9kdWxvIG12Yml0cyBuZWFyZXN0IHBhY2sgcHJlc2VudCBwcm9kdWN0IHJhZGl4IHJhbmRvbV9udW1iZXIgcmFuZG9tX3NlZWQgcmFuZ2UgcmVwZWF0IHJlc2hhcGUgcnJzcGFjaW5nIHNjYWxlIHNjYW4gc2VsZWN0ZWRfaW50X2tpbmQgc2VsZWN0ZWRfcmVhbF9raW5kIHNldF9leHBvbmVudCBzaGFwZSBzaXplIHNwYWNpbmcgc3ByZWFkIHN1bSBzeXN0ZW1fY2xvY2sgdGlueSB0cmFuc3Bvc2UgdHJpbSB1Ym91bmQgdW5wYWNrIHZlcmlmeSBhY2hhciBpYWNoYXIgdHJhbnNmZXIgZGJsZSBlbnRyeSBkcHJvZCBjcHVfdGltZSBjb21tYW5kX2FyZ3VtZW50X2NvdW50IGdldF9jb21tYW5kIGdldF9jb21tYW5kX2FyZ3VtZW50IGdldF9lbnZpcm9ubWVudF92YXJpYWJsZSBpc19pb3N0YXRfZW5kIGllZWVfYXJpdGhtZXRpYyBpZWVlX3N1cHBvcnRfdW5kZXJmbG93X2NvbnRyb2wgaWVlZV9nZXRfdW5kZXJmbG93X21vZGUgaWVlZV9zZXRfdW5kZXJmbG93X21vZGUgaXNfaW9zdGF0X2VvciBtb3ZlX2FsbG9jIG5ld19saW5lIHNlbGVjdGVkX2NoYXJfa2luZCBzYW1lX3R5cGVfYXMgZXh0ZW5kc190eXBlX29mYWNvc2ggYXNpbmggYXRhbmggYmVzc2VsX2owIGJlc3NlbF9qMSBiZXNzZWxfam4gYmVzc2VsX3kwIGJlc3NlbF95MSBiZXNzZWxfeW4gZXJmIGVyZmMgZXJmY19zY2FsZWQgZ2FtbWEgbG9nX2dhbW1hIGh5cG90IG5vcm0yIGF0b21pY19kZWZpbmUgYXRvbWljX3JlZiBleGVjdXRlX2NvbW1hbmRfbGluZSBsZWFkeiB0cmFpbHogc3RvcmFnZV9zaXplIG1lcmdlX2JpdHMgYmdlIGJndCBibGUgYmx0IGRzaGlmdGwgZHNoaWZ0ciBmaW5kbG9jIGlhbGwgaWFueSBpcGFyaXR5IGltYWdlX2luZGV4IGxjb2JvdW5kIHVjb2JvdW5kIG1hc2tsIG1hc2tyIG51bV9pbWFnZXMgcGFyaXR5IHBvcGNudCBwb3BwYXIgc2hpZnRhIHNoaWZ0bCBzaGlmdHIgdGhpc19pbWFnZSJ9O3JldHVybntjSTohMCxhbGlhc2VzOlsiZjkwIiwiZjk1Il0sazpuLGk6L1wvXCovLGM6W2UuaW5oZXJpdChlLkFTTSx7Y046InN0cmluZyIscjowfSksZS5pbmhlcml0KGUuUVNNLHtjTjoic3RyaW5nIixyOjB9KSx7Y046ImZ1bmN0aW9uIixiSzoic3Vicm91dGluZSBmdW5jdGlvbiBwcm9ncmFtIixpOiJbJHs9XFxuXSIsYzpbZS5VVE0sdF19LGUuQygiISIsIiQiLHtyOjB9KSx7Y046Im51bWJlciIsYjoiKD89XFxifFxcK3xcXC18XFwuKSg/PVxcLlxcZHxcXGQpKD86XFxkKyk/KD86XFwuP1xcZCopKD86W2RlXVsrLV0/XFxkKyk/XFxiXFwuPyIscjowfV19fSk7aGxqcy5yZWdpc3Rlckxhbmd1YWdlKCJhd2siLGZ1bmN0aW9uKGUpe3ZhciByPXtjTjoidmFyaWFibGUiLHY6W3tiOi9cJFtcd1xkI0BdW1x3XGRfXSovfSx7YjovXCRceyguKj8pfS99XX0sYj0iQkVHSU4gRU5EIGlmIGVsc2Ugd2hpbGUgZG8gZm9yIGluIGJyZWFrIGNvbnRpbnVlIGRlbGV0ZSBuZXh0IG5leHRmaWxlIGZ1bmN0aW9uIGZ1bmMgZXhpdHwxMCIsbj17Y046InN0cmluZyIsYzpbZS5CRV0sdjpbe2I6Lyh1fGIpP3I/JycnLyxlOi8nJycvLHI6MTB9LHtiOi8odXxiKT9yPyIiIi8sZTovIiIiLyxyOjEwfSx7YjovKHV8cnx1ciknLyxlOi8nLyxyOjEwfSx7YjovKHV8cnx1cikiLyxlOi8iLyxyOjEwfSx7YjovKGJ8YnIpJy8sZTovJy99LHtiOi8oYnxicikiLyxlOi8iL30sZS5BU00sZS5RU01dfTtyZXR1cm57azp7a2V5d29yZDpifSxjOltyLG4sZS5STSxlLkhDTSxlLk5NXX19KTtobGpzLnJlZ2lzdGVyTGFuZ3VhZ2UoIm1ha2VmaWxlIixmdW5jdGlvbihlKXt2YXIgaT17Y046InZhcmlhYmxlIix2Olt7YjoiXFwkXFwoIitlLlVJUisiXFwpIixjOltlLkJFXX0se2I6L1wkW0AlPD9cXlwrXCpdL31dfSxyPXtjTjoic3RyaW5nIixiOi8iLyxlOi8iLyxjOltlLkJFLGldfSxhPXtjTjoidmFyaWFibGUiLGI6L1wkXChbXHctXStccy8sZTovXCkvLGs6e2J1aWx0X2luOiJzdWJzdCBwYXRzdWJzdCBzdHJpcCBmaW5kc3RyaW5nIGZpbHRlciBmaWx0ZXItb3V0IHNvcnQgd29yZCB3b3JkbGlzdCBmaXJzdHdvcmQgbGFzdHdvcmQgZGlyIG5vdGRpciBzdWZmaXggYmFzZW5hbWUgYWRkc3VmZml4IGFkZHByZWZpeCBqb2luIHdpbGRjYXJkIHJlYWxwYXRoIGFic3BhdGggZXJyb3Igd2FybmluZyBzaGVsbCBvcmlnaW4gZmxhdm9yIGZvcmVhY2ggaWYgb3IgYW5kIGNhbGwgZXZhbCBmaWxlIHZhbHVlIn0sYzpbaV19LG49e2I6Il4iK2UuVUlSKyJcXHMqWzorP10/PSIsaToiXFxuIixyQjohMCxjOlt7YjoiXiIrZS5VSVIsZToiWzorP10/PSIsZUU6ITB9XX0sdD17Y046Im1ldGEiLGI6L15cLlBIT05ZOi8sZTovJC8sazp7Im1ldGEta2V5d29yZCI6Ii5QSE9OWSJ9LGw6L1tcLlx3XSsvfSxsPXtjTjoic2VjdGlvbiIsYjovXlteXHNdKzovLGU6LyQvLGM6W2ldfTtyZXR1cm57YWxpYXNlczpbIm1rIiwibWFrIl0sazoiZGVmaW5lIGVuZGVmIHVuZGVmaW5lIGlmZGVmIGlmbmRlZiBpZmVxIGlmbmVxIGVsc2UgZW5kaWYgaW5jbHVkZSAtaW5jbHVkZSBzaW5jbHVkZSBvdmVycmlkZSBleHBvcnQgdW5leHBvcnQgcHJpdmF0ZSB2cGF0aCIsbDovW1x3LV0rLyxjOltlLkhDTSxpLHIsYSxuLHQsbF19fSk7aGxqcy5yZWdpc3Rlckxhbmd1YWdlKCJqYXZhIixmdW5jdGlvbihlKXt2YXIgYT0iW8OALcq4YS16QS1aXyRdW8OALcq4YS16QS1aXyQwLTldKiIsdD1hKyIoPCIrYSsiKFxccyosXFxzKiIrYSsiKSo+KT8iLHI9ImZhbHNlIHN5bmNocm9uaXplZCBpbnQgYWJzdHJhY3QgZmxvYXQgcHJpdmF0ZSBjaGFyIGJvb2xlYW4gc3RhdGljIG51bGwgaWYgY29uc3QgZm9yIHRydWUgd2hpbGUgbG9uZyBzdHJpY3RmcCBmaW5hbGx5IHByb3RlY3RlZCBpbXBvcnQgbmF0aXZlIGZpbmFsIHZvaWQgZW51bSBlbHNlIGJyZWFrIHRyYW5zaWVudCBjYXRjaCBpbnN0YW5jZW9mIGJ5dGUgc3VwZXIgdm9sYXRpbGUgY2FzZSBhc3NlcnQgc2hvcnQgcGFja2FnZSBkZWZhdWx0IGRvdWJsZSBwdWJsaWMgdHJ5IHRoaXMgc3dpdGNoIGNvbnRpbnVlIHRocm93cyBwcm90ZWN0ZWQgcHVibGljIHByaXZhdGUgbW9kdWxlIHJlcXVpcmVzIGV4cG9ydHMgZG8iLHM9IlxcYigwW2JCXShbMDFdK1swMV9dK1swMV0rfFswMV0rKXwwW3hYXShbYS1mQS1GMC05XStbYS1mQS1GMC05X10rW2EtZkEtRjAtOV0rfFthLWZBLUYwLTldKyl8KChbXFxkXStbXFxkX10rW1xcZF0rfFtcXGRdKykoXFwuKFtcXGRdK1tcXGRfXStbXFxkXSt8W1xcZF0rKSk/fFxcLihbXFxkXStbXFxkX10rW1xcZF0rfFtcXGRdKykpKFtlRV1bLStdP1xcZCspPylbbExmRl0/IixjPXtjTjoibnVtYmVyIixiOnMscjowfTtyZXR1cm57YWxpYXNlczpbImpzcCJdLGs6cixpOi88XC98Iy8sYzpbZS5DKCIvXFwqXFwqIiwiXFwqLyIse3I6MCxjOlt7YjovXHcrQC8scjowfSx7Y046ImRvY3RhZyIsYjoiQFtBLVphLXpdKyJ9XX0pLGUuQ0xDTSxlLkNCQ00sZS5BU00sZS5RU00se2NOOiJjbGFzcyIsYks6ImNsYXNzIGludGVyZmFjZSIsZTovW3s7PV0vLGVFOiEwLGs6ImNsYXNzIGludGVyZmFjZSIsaTovWzoiXFtcXV0vLGM6W3tiSzoiZXh0ZW5kcyBpbXBsZW1lbnRzIn0sZS5VVE1dfSx7Yks6Im5ldyB0aHJvdyByZXR1cm4gZWxzZSIscjowfSx7Y046ImZ1bmN0aW9uIixiOiIoIit0KyJcXHMrKSsiK2UuVUlSKyJcXHMqXFwoIixyQjohMCxlOi9bezs9XS8sZUU6ITAsazpyLGM6W3tiOmUuVUlSKyJcXHMqXFwoIixyQjohMCxyOjAsYzpbZS5VVE1dfSx7Y046InBhcmFtcyIsYjovXCgvLGU6L1wpLyxrOnIscjowLGM6W2UuQVNNLGUuUVNNLGUuQ05NLGUuQ0JDTV19LGUuQ0xDTSxlLkNCQ01dfSxjLHtjTjoibWV0YSIsYjoiQFtBLVphLXpdKyJ9XX19KTtobGpzLnJlZ2lzdGVyTGFuZ3VhZ2UoInN0YW4iLGZ1bmN0aW9uKGUpe3JldHVybntjOltlLkhDTSxlLkNMQ00sZS5DQkNNLHtiOmUuVUlSLGw6ZS5VSVIsazp7bmFtZToiZm9yIGluIHdoaWxlIHJlcGVhdCB1bnRpbCBpZiB0aGVuIGVsc2UiLHN5bWJvbDoiYmVybm91bGxpIGJlcm5vdWxsaV9sb2dpdCBiaW5vbWlhbCBiaW5vbWlhbF9sb2dpdCBiZXRhX2Jpbm9taWFsIGh5cGVyZ2VvbWV0cmljIGNhdGVnb3JpY2FsIGNhdGVnb3JpY2FsX2xvZ2l0IG9yZGVyZWRfbG9naXN0aWMgbmVnX2Jpbm9taWFsIG5lZ19iaW5vbWlhbF8yIG5lZ19iaW5vbWlhbF8yX2xvZyBwb2lzc29uIHBvaXNzb25fbG9nIG11bHRpbm9taWFsIG5vcm1hbCBleHBfbW9kX25vcm1hbCBza2V3X25vcm1hbCBzdHVkZW50X3QgY2F1Y2h5IGRvdWJsZV9leHBvbmVudGlhbCBsb2dpc3RpYyBndW1iZWwgbG9nbm9ybWFsIGNoaV9zcXVhcmUgaW52X2NoaV9zcXVhcmUgc2NhbGVkX2ludl9jaGlfc3F1YXJlIGV4cG9uZW50aWFsIGludl9nYW1tYSB3ZWlidWxsIGZyZWNoZXQgcmF5bGVpZ2ggd2llbmVyIHBhcmV0byBwYXJldG9fdHlwZV8yIHZvbl9taXNlcyB1bmlmb3JtIG11bHRpX25vcm1hbCBtdWx0aV9ub3JtYWxfcHJlYyBtdWx0aV9ub3JtYWxfY2hvbGVza3kgbXVsdGlfZ3AgbXVsdGlfZ3BfY2hvbGVza3kgbXVsdGlfc3R1ZGVudF90IGdhdXNzaWFuX2RsbV9vYnMgZGlyaWNobGV0IGxral9jb3JyIGxral9jb3JyX2Nob2xlc2t5IHdpc2hhcnQgaW52X3dpc2hhcnQiLCJzZWxlY3Rvci10YWciOiJpbnQgcmVhbCB2ZWN0b3Igc2ltcGxleCB1bml0X3ZlY3RvciBvcmRlcmVkIHBvc2l0aXZlX29yZGVyZWQgcm93X3ZlY3RvciBtYXRyaXggY2hvbGVza3lfZmFjdG9yX2NvcnIgY2hvbGVza3lfZmFjdG9yX2NvdiBjb3JyX21hdHJpeCBjb3ZfbWF0cml4Iix0aXRsZToiZnVuY3Rpb25zIG1vZGVsIGRhdGEgcGFyYW1ldGVycyBxdWFudGl0aWVzIHRyYW5zZm9ybWVkIGdlbmVyYXRlZCIsbGl0ZXJhbDoidHJ1ZSBmYWxzZSJ9LHI6MH0se2NOOiJudW1iZXIiLGI6IjBbeFhdWzAtOWEtZkEtRl0rW0xpXT9cXGIiLHI6MH0se2NOOiJudW1iZXIiLGI6IjBbeFhdWzAtOWEtZkEtRl0rW0xpXT9cXGIiLHI6MH0se2NOOiJudW1iZXIiLGI6IlxcZCsoPzpbZUVdWytcXC1dP1xcZCopP0xcXGIiLHI6MH0se2NOOiJudW1iZXIiLGI6IlxcZCtcXC4oPyFcXGQpKD86aVxcYik/IixyOjB9LHtjTjoibnVtYmVyIixiOiJcXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQqKT9pP1xcYiIscjowfSx7Y046Im51bWJlciIsYjoiXFwuXFxkKyg/OltlRV1bK1xcLV0/XFxkKik/aT9cXGIiLHI6MH1dfX0pO2hsanMucmVnaXN0ZXJMYW5ndWFnZSgiamF2YXNjcmlwdCIsZnVuY3Rpb24oZSl7dmFyIHI9IltBLVphLXokX11bMC05QS1aYS16JF9dKiIsdD17a2V5d29yZDoiaW4gb2YgaWYgZm9yIHdoaWxlIGZpbmFsbHkgdmFyIG5ldyBmdW5jdGlvbiBkbyByZXR1cm4gdm9pZCBlbHNlIGJyZWFrIGNhdGNoIGluc3RhbmNlb2Ygd2l0aCB0aHJvdyBjYXNlIGRlZmF1bHQgdHJ5IHRoaXMgc3dpdGNoIGNvbnRpbnVlIHR5cGVvZiBkZWxldGUgbGV0IHlpZWxkIGNvbnN0IGV4cG9ydCBzdXBlciBkZWJ1Z2dlciBhcyBhc3luYyBhd2FpdCBzdGF0aWMgaW1wb3J0IGZyb20gYXMiLGxpdGVyYWw6InRydWUgZmFsc2UgbnVsbCB1bmRlZmluZWQgTmFOIEluZmluaXR5IixidWlsdF9pbjoiZXZhbCBpc0Zpbml0ZSBpc05hTiBwYXJzZUZsb2F0IHBhcnNlSW50IGRlY29kZVVSSSBkZWNvZGVVUklDb21wb25lbnQgZW5jb2RlVVJJIGVuY29kZVVSSUNvbXBvbmVudCBlc2NhcGUgdW5lc2NhcGUgT2JqZWN0IEZ1bmN0aW9uIEJvb2xlYW4gRXJyb3IgRXZhbEVycm9yIEludGVybmFsRXJyb3IgUmFuZ2VFcnJvciBSZWZlcmVuY2VFcnJvciBTdG9wSXRlcmF0aW9uIFN5bnRheEVycm9yIFR5cGVFcnJvciBVUklFcnJvciBOdW1iZXIgTWF0aCBEYXRlIFN0cmluZyBSZWdFeHAgQXJyYXkgRmxvYXQzMkFycmF5IEZsb2F0NjRBcnJheSBJbnQxNkFycmF5IEludDMyQXJyYXkgSW50OEFycmF5IFVpbnQxNkFycmF5IFVpbnQzMkFycmF5IFVpbnQ4QXJyYXkgVWludDhDbGFtcGVkQXJyYXkgQXJyYXlCdWZmZXIgRGF0YVZpZXcgSlNPTiBJbnRsIGFyZ3VtZW50cyByZXF1aXJlIG1vZHVsZSBjb25zb2xlIHdpbmRvdyBkb2N1bWVudCBTeW1ib2wgU2V0IE1hcCBXZWFrU2V0IFdlYWtNYXAgUHJveHkgUmVmbGVjdCBQcm9taXNlIn0sYT17Y046Im51bWJlciIsdjpbe2I6IlxcYigwW2JCXVswMV0rKSJ9LHtiOiJcXGIoMFtvT11bMC03XSspIn0se2I6ZS5DTlJ9XSxyOjB9LG49e2NOOiJzdWJzdCIsYjoiXFwkXFx7IixlOiJcXH0iLGs6dCxjOltdfSxjPXtjTjoic3RyaW5nIixiOiJgIixlOiJgIixjOltlLkJFLG5dfTtuLmM9W2UuQVNNLGUuUVNNLGMsYSxlLlJNXTt2YXIgcz1uLmMuY29uY2F0KFtlLkNCQ00sZS5DTENNXSk7cmV0dXJue2FsaWFzZXM6WyJqcyIsImpzeCJdLGs6dCxjOlt7Y046Im1ldGEiLHI6MTAsYjovXlxzKlsnIl11c2UgKHN0cmljdHxhc20pWyciXS99LHtjTjoibWV0YSIsYjovXiMhLyxlOi8kL30sZS5BU00sZS5RU00sYyxlLkNMQ00sZS5DQkNNLGEse2I6L1t7LF1ccyovLHI6MCxjOlt7YjpyKyJcXHMqOiIsckI6ITAscjowLGM6W3tjTjoiYXR0ciIsYjpyLHI6MH1dfV19LHtiOiIoIitlLlJTUisifFxcYihjYXNlfHJldHVybnx0aHJvdylcXGIpXFxzKiIsazoicmV0dXJuIHRocm93IGNhc2UiLGM6W2UuQ0xDTSxlLkNCQ00sZS5STSx7Y046ImZ1bmN0aW9uIixiOiIoXFwoLio/XFwpfCIrcisiKVxccyo9PiIsckI6ITAsZToiXFxzKj0+IixjOlt7Y046InBhcmFtcyIsdjpbe2I6cn0se2I6L1woXHMqXCkvfSx7YjovXCgvLGU6L1wpLyxlQjohMCxlRTohMCxrOnQsYzpzfV19XX0se2I6LzwvLGU6LyhcL1x3K3xcdytcLyk+LyxzTDoieG1sIixjOlt7YjovPFx3K1xzKlwvPi8sc2tpcDohMH0se2I6LzxcdysvLGU6LyhcL1x3K3xcdytcLyk+Lyxza2lwOiEwLGM6W3tiOi88XHcrXHMqXC8+Lyxza2lwOiEwfSwic2VsZiJdfV19XSxyOjB9LHtjTjoiZnVuY3Rpb24iLGJLOiJmdW5jdGlvbiIsZTovXHsvLGVFOiEwLGM6W2UuaW5oZXJpdChlLlRNLHtiOnJ9KSx7Y046InBhcmFtcyIsYjovXCgvLGU6L1wpLyxlQjohMCxlRTohMCxjOnN9XSxpOi9cW3wlL30se2I6L1wkWyguXS99LGUuTUVUSE9EX0dVQVJELHtjTjoiY2xhc3MiLGJLOiJjbGFzcyIsZTovW3s7PV0vLGVFOiEwLGk6L1s6IlxbXF1dLyxjOlt7Yks6ImV4dGVuZHMifSxlLlVUTV19LHtiSzoiY29uc3RydWN0b3IiLGU6L1x7LyxlRTohMH1dLGk6LyMoPyEhKS99fSk7aGxqcy5yZWdpc3Rlckxhbmd1YWdlKCJ0ZXgiLGZ1bmN0aW9uKGMpe3ZhciBlPXtjTjoidGFnIixiOi9cXC8scjowLGM6W3tjTjoibmFtZSIsdjpbe2I6L1thLXpBLVrQsC3Rj9CQLdGPXStbKl0/L30se2I6L1teYS16QS1a0LAt0Y/QkC3RjzAtOV0vfV0sc3RhcnRzOntlVzohMCxyOjAsYzpbe2NOOiJzdHJpbmciLHY6W3tiOi9cWy8sZTovXF0vfSx7YjovXHsvLGU6L1x9L31dfSx7YjovXHMqPVxzKi8sZVc6ITAscjowLGM6W3tjTjoibnVtYmVyIixiOi8tP1xkKlwuP1xkKyhwdHxwY3xtbXxjbXxpbnxkZHxjY3xleHxlbSk/L31dfV19fV19O3JldHVybntjOltlLHtjTjoiZm9ybXVsYSIsYzpbZV0scjowLHY6W3tiOi9cJFwkLyxlOi9cJFwkL30se2I6L1wkLyxlOi9cJC99XX0sYy5DKCIlIiwiJCIse3I6MH0pXX19KTtobGpzLnJlZ2lzdGVyTGFuZ3VhZ2UoInhtbCIsZnVuY3Rpb24ocyl7dmFyIGU9IltBLVphLXowLTlcXC5fOi1dKyIsdD17ZVc6ITAsaTovPC8scjowLGM6W3tjTjoiYXR0ciIsYjplLHI6MH0se2I6Lz1ccyovLHI6MCxjOlt7Y046InN0cmluZyIsZW5kc1BhcmVudDohMCx2Olt7YjovIi8sZTovIi99LHtiOi8nLyxlOi8nL30se2I6L1teXHMiJz08PmBdKy99XX1dfV19O3JldHVybnthbGlhc2VzOlsiaHRtbCIsInhodG1sIiwicnNzIiwiYXRvbSIsInhqYiIsInhzZCIsInhzbCIsInBsaXN0Il0sY0k6ITAsYzpbe2NOOiJtZXRhIixiOiI8IURPQ1RZUEUiLGU6Ij4iLHI6MTAsYzpbe2I6IlxcWyIsZToiXFxdIn1dfSxzLkMoIjwhLS0iLCItLT4iLHtyOjEwfSkse2I6IjxcXCFcXFtDREFUQVxcWyIsZToiXFxdXFxdPiIscjoxMH0se2I6LzxcPyhwaHApPy8sZTovXD8+LyxzTDoicGhwIixjOlt7YjoiL1xcKiIsZToiXFwqLyIsc2tpcDohMH1dfSx7Y046InRhZyIsYjoiPHN0eWxlKD89XFxzfD58JCkiLGU6Ij4iLGs6e25hbWU6InN0eWxlIn0sYzpbdF0sc3RhcnRzOntlOiI8L3N0eWxlPiIsckU6ITAsc0w6WyJjc3MiLCJ4bWwiXX19LHtjTjoidGFnIixiOiI8c2NyaXB0KD89XFxzfD58JCkiLGU6Ij4iLGs6e25hbWU6InNjcmlwdCJ9LGM6W3RdLHN0YXJ0czp7ZToiPC9zY3JpcHQ+IixyRTohMCxzTDpbImFjdGlvbnNjcmlwdCIsImphdmFzY3JpcHQiLCJoYW5kbGViYXJzIiwieG1sIl19fSx7Y046Im1ldGEiLHY6W3tiOi88XD94bWwvLGU6L1w/Pi8scjoxMH0se2I6LzxcP1x3Ky8sZTovXD8+L31dfSx7Y046InRhZyIsYjoiPC8/IixlOiIvPz4iLGM6W3tjTjoibmFtZSIsYjovW15cLz48XHNdKy8scjowfSx0XX1dfX0pO2hsanMucmVnaXN0ZXJMYW5ndWFnZSgibWFya2Rvd24iLGZ1bmN0aW9uKGUpe3JldHVybnthbGlhc2VzOlsibWQiLCJta2Rvd24iLCJta2QiXSxjOlt7Y046InNlY3Rpb24iLHY6W3tiOiJeI3sxLDZ9IixlOiIkIn0se2I6Il4uKz9cXG5bPS1dezIsfSQifV19LHtiOiI8IixlOiI+IixzTDoieG1sIixyOjB9LHtjTjoiYnVsbGV0IixiOiJeKFsqKy1dfChcXGQrXFwuKSlcXHMrIn0se2NOOiJzdHJvbmciLGI6IlsqX117Mn0uKz9bKl9dezJ9In0se2NOOiJlbXBoYXNpcyIsdjpbe2I6IlxcKi4rP1xcKiJ9LHtiOiJfLis/XyIscjowfV19LHtjTjoicXVvdGUiLGI6Il4+XFxzKyIsZToiJCJ9LHtjTjoiY29kZSIsdjpbe2I6Il5gYGB3KnMqJCIsZToiXmBgYHMqJCJ9LHtiOiJgLis/YCJ9LHtiOiJeKCB7NH18CSkiLGU6IiQiLHI6MH1dfSx7YjoiXlstXFwqXXszLH0iLGU6IiQifSx7YjoiXFxbLis/XFxdW1xcKFxcW10uKj9bXFwpXFxdXSIsckI6ITAsYzpbe2NOOiJzdHJpbmciLGI6IlxcWyIsZToiXFxdIixlQjohMCxyRTohMCxyOjB9LHtjTjoibGluayIsYjoiXFxdXFwoIixlOiJcXCkiLGVCOiEwLGVFOiEwfSx7Y046InN5bWJvbCIsYjoiXFxdXFxbIixlOiJcXF0iLGVCOiEwLGVFOiEwfV0scjoxMH0se2I6L15cW1teXG5dK1xdOi8sckI6ITAsYzpbe2NOOiJzeW1ib2wiLGI6L1xbLyxlOi9cXS8sZUI6ITAsZUU6ITB9LHtjTjoibGluayIsYjovOlxzKi8sZTovJC8sZUI6ITB9XX1dfX0pO2hsanMucmVnaXN0ZXJMYW5ndWFnZSgianNvbiIsZnVuY3Rpb24oZSl7dmFyIGk9e2xpdGVyYWw6InRydWUgZmFsc2UgbnVsbCJ9LG49W2UuUVNNLGUuQ05NXSxyPXtlOiIsIixlVzohMCxlRTohMCxjOm4sazppfSx0PXtiOiJ7IixlOiJ9IixjOlt7Y046ImF0dHIiLGI6LyIvLGU6LyIvLGM6W2UuQkVdLGk6IlxcbiJ9LGUuaW5oZXJpdChyLHtiOi86L30pXSxpOiJcXFMifSxjPXtiOiJcXFsiLGU6IlxcXSIsYzpbZS5pbmhlcml0KHIpXSxpOiJcXFMifTtyZXR1cm4gbi5zcGxpY2Uobi5sZW5ndGgsMCx0LGMpLHtjOm4sazppLGk6IlxcUyJ9fSk7"></script>
<style type="text/css">@layer htmltools {
.html-fill-container {
display: flex;
flex-direction: column;

min-height: 0;
min-width: 0;
}
.html-fill-container > .html-fill-item {

flex: 1 1 auto;
min-height: 0;
min-width: 0;
}
.html-fill-container > :not(.html-fill-item) {

flex: 0 0 auto;
}
}
</style>
<script>(function() {
  // If window.HTMLWidgets is already defined, then use it; otherwise create a
  // new object. This allows preceding code to set options that affect the
  // initialization process (though none currently exist).
  window.HTMLWidgets = window.HTMLWidgets || {};

  // See if we're running in a viewer pane. If not, we're in a web browser.
  var viewerMode = window.HTMLWidgets.viewerMode =
      /\bviewer_pane=1\b/.test(window.location);

  // See if we're running in Shiny mode. If not, it's a static document.
  // Note that static widgets can appear in both Shiny and static modes, but
  // obviously, Shiny widgets can only appear in Shiny apps/documents.
  var shinyMode = window.HTMLWidgets.shinyMode =
      typeof(window.Shiny) !== "undefined" && !!window.Shiny.outputBindings;

  // We can't count on jQuery being available, so we implement our own
  // version if necessary.
  function querySelectorAll(scope, selector) {
    if (typeof(jQuery) !== "undefined" && scope instanceof jQuery) {
      return scope.find(selector);
    }
    if (scope.querySelectorAll) {
      return scope.querySelectorAll(selector);
    }
  }

  function asArray(value) {
    if (value === null)
      return [];
    if ($.isArray(value))
      return value;
    return [value];
  }

  // Implement jQuery's extend
  function extend(target /*, ... */) {
    if (arguments.length == 1) {
      return target;
    }
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var prop in source) {
        if (source.hasOwnProperty(prop)) {
          target[prop] = source[prop];
        }
      }
    }
    return target;
  }

  // IE8 doesn't support Array.forEach.
  function forEach(values, callback, thisArg) {
    if (values.forEach) {
      values.forEach(callback, thisArg);
    } else {
      for (var i = 0; i < values.length; i++) {
        callback.call(thisArg, values[i], i, values);
      }
    }
  }

  // Replaces the specified method with the return value of funcSource.
  //
  // Note that funcSource should not BE the new method, it should be a function
  // that RETURNS the new method. funcSource receives a single argument that is
  // the overridden method, it can be called from the new method. The overridden
  // method can be called like a regular function, it has the target permanently
  // bound to it so "this" will work correctly.
  function overrideMethod(target, methodName, funcSource) {
    var superFunc = target[methodName] || function() {};
    var superFuncBound = function() {
      return superFunc.apply(target, arguments);
    };
    target[methodName] = funcSource(superFuncBound);
  }

  // Add a method to delegator that, when invoked, calls
  // delegatee.methodName. If there is no such method on
  // the delegatee, but there was one on delegator before
  // delegateMethod was called, then the original version
  // is invoked instead.
  // For example:
  //
  // var a = {
  //   method1: function() { console.log('a1'); }
  //   method2: function() { console.log('a2'); }
  // };
  // var b = {
  //   method1: function() { console.log('b1'); }
  // };
  // delegateMethod(a, b, "method1");
  // delegateMethod(a, b, "method2");
  // a.method1();
  // a.method2();
  //
  // The output would be "b1", "a2".
  function delegateMethod(delegator, delegatee, methodName) {
    var inherited = delegator[methodName];
    delegator[methodName] = function() {
      var target = delegatee;
      var method = delegatee[methodName];

      // The method doesn't exist on the delegatee. Instead,
      // call the method on the delegator, if it exists.
      if (!method) {
        target = delegator;
        method = inherited;
      }

      if (method) {
        return method.apply(target, arguments);
      }
    };
  }

  // Implement a vague facsimilie of jQuery's data method
  function elementData(el, name, value) {
    if (arguments.length == 2) {
      return el["htmlwidget_data_" + name];
    } else if (arguments.length == 3) {
      el["htmlwidget_data_" + name] = value;
      return el;
    } else {
      throw new Error("Wrong number of arguments for elementData: " +
        arguments.length);
    }
  }

  // http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
  function escapeRegExp(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  }

  function hasClass(el, className) {
    var re = new RegExp("\\b" + escapeRegExp(className) + "\\b");
    return re.test(el.className);
  }

  // elements - array (or array-like object) of HTML elements
  // className - class name to test for
  // include - if true, only return elements with given className;
  //   if false, only return elements *without* given className
  function filterByClass(elements, className, include) {
    var results = [];
    for (var i = 0; i < elements.length; i++) {
      if (hasClass(elements[i], className) == include)
        results.push(elements[i]);
    }
    return results;
  }

  function on(obj, eventName, func) {
    if (obj.addEventListener) {
      obj.addEventListener(eventName, func, false);
    } else if (obj.attachEvent) {
      obj.attachEvent(eventName, func);
    }
  }

  function off(obj, eventName, func) {
    if (obj.removeEventListener)
      obj.removeEventListener(eventName, func, false);
    else if (obj.detachEvent) {
      obj.detachEvent(eventName, func);
    }
  }

  // Translate array of values to top/right/bottom/left, as usual with
  // the "padding" CSS property
  // https://developer.mozilla.org/en-US/docs/Web/CSS/padding
  function unpackPadding(value) {
    if (typeof(value) === "number")
      value = [value];
    if (value.length === 1) {
      return {top: value[0], right: value[0], bottom: value[0], left: value[0]};
    }
    if (value.length === 2) {
      return {top: value[0], right: value[1], bottom: value[0], left: value[1]};
    }
    if (value.length === 3) {
      return {top: value[0], right: value[1], bottom: value[2], left: value[1]};
    }
    if (value.length === 4) {
      return {top: value[0], right: value[1], bottom: value[2], left: value[3]};
    }
  }

  // Convert an unpacked padding object to a CSS value
  function paddingToCss(paddingObj) {
    return paddingObj.top + "px " + paddingObj.right + "px " + paddingObj.bottom + "px " + paddingObj.left + "px";
  }

  // Makes a number suitable for CSS
  function px(x) {
    if (typeof(x) === "number")
      return x + "px";
    else
      return x;
  }

  // Retrieves runtime widget sizing information for an element.
  // The return value is either null, or an object with fill, padding,
  // defaultWidth, defaultHeight fields.
  function sizingPolicy(el) {
    var sizingEl = document.querySelector("script[data-for='" + el.id + "'][type='application/htmlwidget-sizing']");
    if (!sizingEl)
      return null;
    var sp = JSON.parse(sizingEl.textContent || sizingEl.text || "{}");
    if (viewerMode) {
      return sp.viewer;
    } else {
      return sp.browser;
    }
  }

  // @param tasks Array of strings (or falsy value, in which case no-op).
  //   Each element must be a valid JavaScript expression that yields a
  //   function. Or, can be an array of objects with "code" and "data"
  //   properties; in this case, the "code" property should be a string
  //   of JS that's an expr that yields a function, and "data" should be
  //   an object that will be added as an additional argument when that
  //   function is called.
  // @param target The object that will be "this" for each function
  //   execution.
  // @param args Array of arguments to be passed to the functions. (The
  //   same arguments will be passed to all functions.)
  function evalAndRun(tasks, target, args) {
    if (tasks) {
      forEach(tasks, function(task) {
        var theseArgs = args;
        if (typeof(task) === "object") {
          theseArgs = theseArgs.concat([task.data]);
          task = task.code;
        }
        var taskFunc = tryEval(task);
        if (typeof(taskFunc) !== "function") {
          throw new Error("Task must be a function! Source:\n" + task);
        }
        taskFunc.apply(target, theseArgs);
      });
    }
  }

  // Attempt eval() both with and without enclosing in parentheses.
  // Note that enclosing coerces a function declaration into
  // an expression that eval() can parse
  // (otherwise, a SyntaxError is thrown)
  function tryEval(code) {
    var result = null;
    try {
      result = eval("(" + code + ")");
    } catch(error) {
      if (!(error instanceof SyntaxError)) {
        throw error;
      }
      try {
        result = eval(code);
      } catch(e) {
        if (e instanceof SyntaxError) {
          throw error;
        } else {
          throw e;
        }
      }
    }
    return result;
  }

  function initSizing(el) {
    var sizing = sizingPolicy(el);
    if (!sizing)
      return;

    var cel = document.getElementById("htmlwidget_container");
    if (!cel)
      return;

    if (typeof(sizing.padding) !== "undefined") {
      document.body.style.margin = "0";
      document.body.style.padding = paddingToCss(unpackPadding(sizing.padding));
    }

    if (sizing.fill) {
      document.body.style.overflow = "hidden";
      document.body.style.width = "100%";
      document.body.style.height = "100%";
      document.documentElement.style.width = "100%";
      document.documentElement.style.height = "100%";
      cel.style.position = "absolute";
      var pad = unpackPadding(sizing.padding);
      cel.style.top = pad.top + "px";
      cel.style.right = pad.right + "px";
      cel.style.bottom = pad.bottom + "px";
      cel.style.left = pad.left + "px";
      el.style.width = "100%";
      el.style.height = "100%";

      return {
        getWidth: function() { return cel.getBoundingClientRect().width; },
        getHeight: function() { return cel.getBoundingClientRect().height; }
      };

    } else {
      el.style.width = px(sizing.width);
      el.style.height = px(sizing.height);

      return {
        getWidth: function() { return cel.getBoundingClientRect().width; },
        getHeight: function() { return cel.getBoundingClientRect().height; }
      };
    }
  }

  // Default implementations for methods
  var defaults = {
    find: function(scope) {
      return querySelectorAll(scope, "." + this.name);
    },
    renderError: function(el, err) {
      var $el = $(el);

      this.clearError(el);

      // Add all these error classes, as Shiny does
      var errClass = "shiny-output-error";
      if (err.type !== null) {
        // use the classes of the error condition as CSS class names
        errClass = errClass + " " + $.map(asArray(err.type), function(type) {
          return errClass + "-" + type;
        }).join(" ");
      }
      errClass = errClass + " htmlwidgets-error";

      // Is el inline or block? If inline or inline-block, just display:none it
      // and add an inline error.
      var display = $el.css("display");
      $el.data("restore-display-mode", display);

      if (display === "inline" || display === "inline-block") {
        $el.hide();
        if (err.message !== "") {
          var errorSpan = $("<span>").addClass(errClass);
          errorSpan.text(err.message);
          $el.after(errorSpan);
        }
      } else if (display === "block") {
        // If block, add an error just after the el, set visibility:none on the
        // el, and position the error to be on top of the el.
        // Mark it with a unique ID and CSS class so we can remove it later.
        $el.css("visibility", "hidden");
        if (err.message !== "") {
          var errorDiv = $("<div>").addClass(errClass).css("position", "absolute")
            .css("top", el.offsetTop)
            .css("left", el.offsetLeft)
            // setting width can push out the page size, forcing otherwise
            // unnecessary scrollbars to appear and making it impossible for
            // the element to shrink; so use max-width instead
            .css("maxWidth", el.offsetWidth)
            .css("height", el.offsetHeight);
          errorDiv.text(err.message);
          $el.after(errorDiv);

          // Really dumb way to keep the size/position of the error in sync with
          // the parent element as the window is resized or whatever.
          var intId = setInterval(function() {
            if (!errorDiv[0].parentElement) {
              clearInterval(intId);
              return;
            }
            errorDiv
              .css("top", el.offsetTop)
              .css("left", el.offsetLeft)
              .css("maxWidth", el.offsetWidth)
              .css("height", el.offsetHeight);
          }, 500);
        }
      }
    },
    clearError: function(el) {
      var $el = $(el);
      var display = $el.data("restore-display-mode");
      $el.data("restore-display-mode", null);

      if (display === "inline" || display === "inline-block") {
        if (display)
          $el.css("display", display);
        $(el.nextSibling).filter(".htmlwidgets-error").remove();
      } else if (display === "block"){
        $el.css("visibility", "inherit");
        $(el.nextSibling).filter(".htmlwidgets-error").remove();
      }
    },
    sizing: {}
  };

  // Called by widget bindings to register a new type of widget. The definition
  // object can contain the following properties:
  // - name (required) - A string indicating the binding name, which will be
  //   used by default as the CSS classname to look for.
  // - initialize (optional) - A function(el) that will be called once per
  //   widget element; if a value is returned, it will be passed as the third
  //   value to renderValue.
  // - renderValue (required) - A function(el, data, initValue) that will be
  //   called with data. Static contexts will cause this to be called once per
  //   element; Shiny apps will cause this to be called multiple times per
  //   element, as the data changes.
  window.HTMLWidgets.widget = function(definition) {
    if (!definition.name) {
      throw new Error("Widget must have a name");
    }
    if (!definition.type) {
      throw new Error("Widget must have a type");
    }
    // Currently we only support output widgets
    if (definition.type !== "output") {
      throw new Error("Unrecognized widget type '" + definition.type + "'");
    }
    // TODO: Verify that .name is a valid CSS classname

    // Support new-style instance-bound definitions. Old-style class-bound
    // definitions have one widget "object" per widget per type/class of
    // widget; the renderValue and resize methods on such widget objects
    // take el and instance arguments, because the widget object can't
    // store them. New-style instance-bound definitions have one widget
    // object per widget instance; the definition that's passed in doesn't
    // provide renderValue or resize methods at all, just the single method
    //   factory(el, width, height)
    // which returns an object that has renderValue(x) and resize(w, h).
    // This enables a far more natural programming style for the widget
    // author, who can store per-instance state using either OO-style
    // instance fields or functional-style closure variables (I guess this
    // is in contrast to what can only be called C-style pseudo-OO which is
    // what we required before).
    if (definition.factory) {
      definition = createLegacyDefinitionAdapter(definition);
    }

    if (!definition.renderValue) {
      throw new Error("Widget must have a renderValue function");
    }

    // For static rendering (non-Shiny), use a simple widget registration
    // scheme. We also use this scheme for Shiny apps/documents that also
    // contain static widgets.
    window.HTMLWidgets.widgets = window.HTMLWidgets.widgets || [];
    // Merge defaults into the definition; don't mutate the original definition.
    var staticBinding = extend({}, defaults, definition);
    overrideMethod(staticBinding, "find", function(superfunc) {
      return function(scope) {
        var results = superfunc(scope);
        // Filter out Shiny outputs, we only want the static kind
        return filterByClass(results, "html-widget-output", false);
      };
    });
    window.HTMLWidgets.widgets.push(staticBinding);

    if (shinyMode) {
      // Shiny is running. Register the definition with an output binding.
      // The definition itself will not be the output binding, instead
      // we will make an output binding object that delegates to the
      // definition. This is because we foolishly used the same method
      // name (renderValue) for htmlwidgets definition and Shiny bindings
      // but they actually have quite different semantics (the Shiny
      // bindings receive data that includes lots of metadata that it
      // strips off before calling htmlwidgets renderValue). We can't
      // just ignore the difference because in some widgets it's helpful
      // to call this.renderValue() from inside of resize(), and if
      // we're not delegating, then that call will go to the Shiny
      // version instead of the htmlwidgets version.

      // Merge defaults with definition, without mutating either.
      var bindingDef = extend({}, defaults, definition);

      // This object will be our actual Shiny binding.
      var shinyBinding = new Shiny.OutputBinding();

      // With a few exceptions, we'll want to simply use the bindingDef's
      // version of methods if they are available, otherwise fall back to
      // Shiny's defaults. NOTE: If Shiny's output bindings gain additional
      // methods in the future, and we want them to be overrideable by
      // HTMLWidget binding definitions, then we'll need to add them to this
      // list.
      delegateMethod(shinyBinding, bindingDef, "getId");
      delegateMethod(shinyBinding, bindingDef, "onValueChange");
      delegateMethod(shinyBinding, bindingDef, "onValueError");
      delegateMethod(shinyBinding, bindingDef, "renderError");
      delegateMethod(shinyBinding, bindingDef, "clearError");
      delegateMethod(shinyBinding, bindingDef, "showProgress");

      // The find, renderValue, and resize are handled differently, because we
      // want to actually decorate the behavior of the bindingDef methods.

      shinyBinding.find = function(scope) {
        var results = bindingDef.find(scope);

        // Only return elements that are Shiny outputs, not static ones
        var dynamicResults = results.filter(".html-widget-output");

        // It's possible that whatever caused Shiny to think there might be
        // new dynamic outputs, also caused there to be new static outputs.
        // Since there might be lots of different htmlwidgets bindings, we
        // schedule execution for later--no need to staticRender multiple
        // times.
        if (results.length !== dynamicResults.length)
          scheduleStaticRender();

        return dynamicResults;
      };

      // Wrap renderValue to handle initialization, which unfortunately isn't
      // supported natively by Shiny at the time of this writing.

      shinyBinding.renderValue = function(el, data) {
        Shiny.renderDependencies(data.deps);
        // Resolve strings marked as javascript literals to objects
        if (!(data.evals instanceof Array)) data.evals = [data.evals];
        for (var i = 0; data.evals && i < data.evals.length; i++) {
          window.HTMLWidgets.evaluateStringMember(data.x, data.evals[i]);
        }
        if (!bindingDef.renderOnNullValue) {
          if (data.x === null) {
            el.style.visibility = "hidden";
            return;
          } else {
            el.style.visibility = "inherit";
          }
        }
        if (!elementData(el, "initialized")) {
          initSizing(el);

          elementData(el, "initialized", true);
          if (bindingDef.initialize) {
            var rect = el.getBoundingClientRect();
            var result = bindingDef.initialize(el, rect.width, rect.height);
            elementData(el, "init_result", result);
          }
        }
        bindingDef.renderValue(el, data.x, elementData(el, "init_result"));
        evalAndRun(data.jsHooks.render, elementData(el, "init_result"), [el, data.x]);
      };

      // Only override resize if bindingDef implements it
      if (bindingDef.resize) {
        shinyBinding.resize = function(el, width, height) {
          // Shiny can call resize before initialize/renderValue have been
          // called, which doesn't make sense for widgets.
          if (elementData(el, "initialized")) {
            bindingDef.resize(el, width, height, elementData(el, "init_result"));
          }
        };
      }

      Shiny.outputBindings.register(shinyBinding, bindingDef.name);
    }
  };

  var scheduleStaticRenderTimerId = null;
  function scheduleStaticRender() {
    if (!scheduleStaticRenderTimerId) {
      scheduleStaticRenderTimerId = setTimeout(function() {
        scheduleStaticRenderTimerId = null;
        window.HTMLWidgets.staticRender();
      }, 1);
    }
  }

  // Render static widgets after the document finishes loading
  // Statically render all elements that are of this widget's class
  window.HTMLWidgets.staticRender = function() {
    var bindings = window.HTMLWidgets.widgets || [];
    forEach(bindings, function(binding) {
      var matches = binding.find(document.documentElement);
      forEach(matches, function(el) {
        var sizeObj = initSizing(el, binding);

        var getSize = function(el) {
          if (sizeObj) {
            return {w: sizeObj.getWidth(), h: sizeObj.getHeight()}
          } else {
            var rect = el.getBoundingClientRect();
            return {w: rect.width, h: rect.height}
          }
        };

        if (hasClass(el, "html-widget-static-bound"))
          return;
        el.className = el.className + " html-widget-static-bound";

        var initResult;
        if (binding.initialize) {
          var size = getSize(el);
          initResult = binding.initialize(el, size.w, size.h);
          elementData(el, "init_result", initResult);
        }

        if (binding.resize) {
          var lastSize = getSize(el);
          var resizeHandler = function(e) {
            var size = getSize(el);
            if (size.w === 0 && size.h === 0)
              return;
            if (size.w === lastSize.w && size.h === lastSize.h)
              return;
            lastSize = size;
            binding.resize(el, size.w, size.h, initResult);
          };

          on(window, "resize", resizeHandler);

          // This is needed for cases where we're running in a Shiny
          // app, but the widget itself is not a Shiny output, but
          // rather a simple static widget. One example of this is
          // an rmarkdown document that has runtime:shiny and widget
          // that isn't in a render function. Shiny only knows to
          // call resize handlers for Shiny outputs, not for static
          // widgets, so we do it ourselves.
          if (window.jQuery) {
            window.jQuery(document).on(
              "shown.htmlwidgets shown.bs.tab.htmlwidgets shown.bs.collapse.htmlwidgets",
              resizeHandler
            );
            window.jQuery(document).on(
              "hidden.htmlwidgets hidden.bs.tab.htmlwidgets hidden.bs.collapse.htmlwidgets",
              resizeHandler
            );
          }

          // This is needed for the specific case of ioslides, which
          // flips slides between display:none and display:block.
          // Ideally we would not have to have ioslide-specific code
          // here, but rather have ioslides raise a generic event,
          // but the rmarkdown package just went to CRAN so the
          // window to getting that fixed may be long.
          if (window.addEventListener) {
            // It's OK to limit this to window.addEventListener
            // browsers because ioslides itself only supports
            // such browsers.
            on(document, "slideenter", resizeHandler);
            on(document, "slideleave", resizeHandler);
          }
        }

        var scriptData = document.querySelector("script[data-for='" + el.id + "'][type='application/json']");
        if (scriptData) {
          var data = JSON.parse(scriptData.textContent || scriptData.text);
          // Resolve strings marked as javascript literals to objects
          if (!(data.evals instanceof Array)) data.evals = [data.evals];
          for (var k = 0; data.evals && k < data.evals.length; k++) {
            window.HTMLWidgets.evaluateStringMember(data.x, data.evals[k]);
          }
          binding.renderValue(el, data.x, initResult);
          evalAndRun(data.jsHooks.render, initResult, [el, data.x]);
        }
      });
    });

    invokePostRenderHandlers();
  }


  function has_jQuery3() {
    if (!window.jQuery) {
      return false;
    }
    var $version = window.jQuery.fn.jquery;
    var $major_version = parseInt($version.split(".")[0]);
    return $major_version >= 3;
  }

  /*
  / Shiny 1.4 bumped jQuery from 1.x to 3.x which means jQuery's
  / on-ready handler (i.e., $(fn)) is now asyncronous (i.e., it now
  / really means $(setTimeout(fn)).
  / https://jquery.com/upgrade-guide/3.0/#breaking-change-document-ready-handlers-are-now-asynchronous
  /
  / Since Shiny uses $() to schedule initShiny, shiny>=1.4 calls initShiny
  / one tick later than it did before, which means staticRender() is
  / called renderValue() earlier than (advanced) widget authors might be expecting.
  / https://github.com/rstudio/shiny/issues/2630
  /
  / For a concrete example, leaflet has some methods (e.g., updateBounds)
  / which reference Shiny methods registered in initShiny (e.g., setInputValue).
  / Since leaflet is privy to this life-cycle, it knows to use setTimeout() to
  / delay execution of those methods (until Shiny methods are ready)
  / https://github.com/rstudio/leaflet/blob/18ec981/javascript/src/index.js#L266-L268
  /
  / Ideally widget authors wouldn't need to use this setTimeout() hack that
  / leaflet uses to call Shiny methods on a staticRender(). In the long run,
  / the logic initShiny should be broken up so that method registration happens
  / right away, but binding happens later.
  */
  function maybeStaticRenderLater() {
    if (shinyMode && has_jQuery3()) {
      window.jQuery(window.HTMLWidgets.staticRender);
    } else {
      window.HTMLWidgets.staticRender();
    }
  }

  if (document.addEventListener) {
    document.addEventListener("DOMContentLoaded", function() {
      document.removeEventListener("DOMContentLoaded", arguments.callee, false);
      maybeStaticRenderLater();
    }, false);
  } else if (document.attachEvent) {
    document.attachEvent("onreadystatechange", function() {
      if (document.readyState === "complete") {
        document.detachEvent("onreadystatechange", arguments.callee);
        maybeStaticRenderLater();
      }
    });
  }


  window.HTMLWidgets.getAttachmentUrl = function(depname, key) {
    // If no key, default to the first item
    if (typeof(key) === "undefined")
      key = 1;

    var link = document.getElementById(depname + "-" + key + "-attachment");
    if (!link) {
      throw new Error("Attachment " + depname + "/" + key + " not found in document");
    }
    return link.getAttribute("href");
  };

  window.HTMLWidgets.dataframeToD3 = function(df) {
    var names = [];
    var length;
    for (var name in df) {
        if (df.hasOwnProperty(name))
            names.push(name);
        if (typeof(df[name]) !== "object" || typeof(df[name].length) === "undefined") {
            throw new Error("All fields must be arrays");
        } else if (typeof(length) !== "undefined" && length !== df[name].length) {
            throw new Error("All fields must be arrays of the same length");
        }
        length = df[name].length;
    }
    var results = [];
    var item;
    for (var row = 0; row < length; row++) {
        item = {};
        for (var col = 0; col < names.length; col++) {
            item[names[col]] = df[names[col]][row];
        }
        results.push(item);
    }
    return results;
  };

  window.HTMLWidgets.transposeArray2D = function(array) {
      if (array.length === 0) return array;
      var newArray = array[0].map(function(col, i) {
          return array.map(function(row) {
              return row[i]
          })
      });
      return newArray;
  };
  // Split value at splitChar, but allow splitChar to be escaped
  // using escapeChar. Any other characters escaped by escapeChar
  // will be included as usual (including escapeChar itself).
  function splitWithEscape(value, splitChar, escapeChar) {
    var results = [];
    var escapeMode = false;
    var currentResult = "";
    for (var pos = 0; pos < value.length; pos++) {
      if (!escapeMode) {
        if (value[pos] === splitChar) {
          results.push(currentResult);
          currentResult = "";
        } else if (value[pos] === escapeChar) {
          escapeMode = true;
        } else {
          currentResult += value[pos];
        }
      } else {
        currentResult += value[pos];
        escapeMode = false;
      }
    }
    if (currentResult !== "") {
      results.push(currentResult);
    }
    return results;
  }
  // Function authored by Yihui/JJ Allaire
  window.HTMLWidgets.evaluateStringMember = function(o, member) {
    var parts = splitWithEscape(member, '.', '\\');
    for (var i = 0, l = parts.length; i < l; i++) {
      var part = parts[i];
      // part may be a character or 'numeric' member name
      if (o !== null && typeof o === "object" && part in o) {
        if (i == (l - 1)) { // if we are at the end of the line then evalulate
          if (typeof o[part] === "string")
            o[part] = tryEval(o[part]);
        } else { // otherwise continue to next embedded object
          o = o[part];
        }
      }
    }
  };

  // Retrieve the HTMLWidget instance (i.e. the return value of an
  // HTMLWidget binding's initialize() or factory() function)
  // associated with an element, or null if none.
  window.HTMLWidgets.getInstance = function(el) {
    return elementData(el, "init_result");
  };

  // Finds the first element in the scope that matches the selector,
  // and returns the HTMLWidget instance (i.e. the return value of
  // an HTMLWidget binding's initialize() or factory() function)
  // associated with that element, if any. If no element matches the
  // selector, or the first matching element has no HTMLWidget
  // instance associated with it, then null is returned.
  //
  // The scope argument is optional, and defaults to window.document.
  window.HTMLWidgets.find = function(scope, selector) {
    if (arguments.length == 1) {
      selector = scope;
      scope = document;
    }

    var el = scope.querySelector(selector);
    if (el === null) {
      return null;
    } else {
      return window.HTMLWidgets.getInstance(el);
    }
  };

  // Finds all elements in the scope that match the selector, and
  // returns the HTMLWidget instances (i.e. the return values of
  // an HTMLWidget binding's initialize() or factory() function)
  // associated with the elements, in an array. If elements that
  // match the selector don't have an associated HTMLWidget
  // instance, the returned array will contain nulls.
  //
  // The scope argument is optional, and defaults to window.document.
  window.HTMLWidgets.findAll = function(scope, selector) {
    if (arguments.length == 1) {
      selector = scope;
      scope = document;
    }

    var nodes = scope.querySelectorAll(selector);
    var results = [];
    for (var i = 0; i < nodes.length; i++) {
      results.push(window.HTMLWidgets.getInstance(nodes[i]));
    }
    return results;
  };

  var postRenderHandlers = [];
  function invokePostRenderHandlers() {
    while (postRenderHandlers.length) {
      var handler = postRenderHandlers.shift();
      if (handler) {
        handler();
      }
    }
  }

  // Register the given callback function to be invoked after the
  // next time static widgets are rendered.
  window.HTMLWidgets.addPostRenderHandler = function(callback) {
    postRenderHandlers.push(callback);
  };

  // Takes a new-style instance-bound definition, and returns an
  // old-style class-bound definition. This saves us from having
  // to rewrite all the logic in this file to accomodate both
  // types of definitions.
  function createLegacyDefinitionAdapter(defn) {
    var result = {
      name: defn.name,
      type: defn.type,
      initialize: function(el, width, height) {
        return defn.factory(el, width, height);
      },
      renderValue: function(el, x, instance) {
        return instance.renderValue(x);
      },
      resize: function(el, width, height, instance) {
        return instance.resize(width, height);
      }
    };

    if (defn.find)
      result.find = defn.find;
    if (defn.renderError)
      result.renderError = defn.renderError;
    if (defn.clearError)
      result.clearError = defn.clearError;

    return result;
  }
})();
</script>
<script>'use strict';
var gsmViz = (() => {
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
        for (var name in all)
            __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to2, from2, except, desc) => {
        if (
            (from2 && typeof from2 === 'object') ||
            typeof from2 === 'function'
        ) {
            for (let key of __getOwnPropNames(from2))
                if (!__hasOwnProp.call(to2, key) && key !== except)
                    __defProp(to2, key, {
                        get: () => from2[key],
                        enumerable:
                            !(desc = __getOwnPropDesc(from2, key)) ||
                            desc.enumerable,
                    });
        }
        return to2;
    };
    var __toCommonJS = (mod) =>
        __copyProps(__defProp({}, '__esModule', { value: true }), mod);

    // src/main.js
    var main_exports = {};
    __export(main_exports, {
        default: () => main_default,
    });

    // node_modules/chart.js/dist/chunks/helpers.segment.mjs
    function noop() {}
    var uid = /* @__PURE__ */ (function () {
        let id2 = 0;
        return function () {
            return id2++;
        };
    })();
    function isNullOrUndef(value) {
        return value === null || typeof value === 'undefined';
    }
    function isArray(value) {
        if (Array.isArray && Array.isArray(value)) {
            return true;
        }
        const type2 = Object.prototype.toString.call(value);
        if (type2.slice(0, 7) === '[object' && type2.slice(-6) === 'Array]') {
            return true;
        }
        return false;
    }
    function isObject(value) {
        return (
            value !== null &&
            Object.prototype.toString.call(value) === '[object Object]'
        );
    }
    var isNumberFinite = (value) =>
        (typeof value === 'number' || value instanceof Number) &&
        isFinite(+value);
    function finiteOrDefault(value, defaultValue) {
        return isNumberFinite(value) ? value : defaultValue;
    }
    function valueOrDefault(value, defaultValue) {
        return typeof value === 'undefined' ? defaultValue : value;
    }
    var toPercentage = (value, dimension) =>
        typeof value === 'string' && value.endsWith('%')
            ? parseFloat(value) / 100
            : value / dimension;
    var toDimension = (value, dimension) =>
        typeof value === 'string' && value.endsWith('%')
            ? (parseFloat(value) / 100) * dimension
            : +value;
    function callback(fn, args, thisArg) {
        if (fn && typeof fn.call === 'function') {
            return fn.apply(thisArg, args);
        }
    }
    function each(loopable, fn, thisArg, reverse) {
        let i, len, keys;
        if (isArray(loopable)) {
            len = loopable.length;
            if (reverse) {
                for (i = len - 1; i >= 0; i--) {
                    fn.call(thisArg, loopable[i], i);
                }
            } else {
                for (i = 0; i < len; i++) {
                    fn.call(thisArg, loopable[i], i);
                }
            }
        } else if (isObject(loopable)) {
            keys = Object.keys(loopable);
            len = keys.length;
            for (i = 0; i < len; i++) {
                fn.call(thisArg, loopable[keys[i]], keys[i]);
            }
        }
    }
    function _elementsEqual(a0, a1) {
        let i, ilen, v0, v1;
        if (!a0 || !a1 || a0.length !== a1.length) {
            return false;
        }
        for (i = 0, ilen = a0.length; i < ilen; ++i) {
            v0 = a0[i];
            v1 = a1[i];
            if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
                return false;
            }
        }
        return true;
    }
    function clone$1(source) {
        if (isArray(source)) {
            return source.map(clone$1);
        }
        if (isObject(source)) {
            const target = /* @__PURE__ */ Object.create(null);
            const keys = Object.keys(source);
            const klen = keys.length;
            let k = 0;
            for (; k < klen; ++k) {
                target[keys[k]] = clone$1(source[keys[k]]);
            }
            return target;
        }
        return source;
    }
    function isValidKey(key) {
        return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;
    }
    function _merger(key, target, source, options) {
        if (!isValidKey(key)) {
            return;
        }
        const tval = target[key];
        const sval = source[key];
        if (isObject(tval) && isObject(sval)) {
            merge(tval, sval, options);
        } else {
            target[key] = clone$1(sval);
        }
    }
    function merge(target, source, options) {
        const sources = isArray(source) ? source : [source];
        const ilen = sources.length;
        if (!isObject(target)) {
            return target;
        }
        options = options || {};
        const merger = options.merger || _merger;
        for (let i = 0; i < ilen; ++i) {
            source = sources[i];
            if (!isObject(source)) {
                continue;
            }
            const keys = Object.keys(source);
            for (let k = 0, klen = keys.length; k < klen; ++k) {
                merger(keys[k], target, source, options);
            }
        }
        return target;
    }
    function mergeIf(target, source) {
        return merge(target, source, { merger: _mergerIf });
    }
    function _mergerIf(key, target, source) {
        if (!isValidKey(key)) {
            return;
        }
        const tval = target[key];
        const sval = source[key];
        if (isObject(tval) && isObject(sval)) {
            mergeIf(tval, sval);
        } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
            target[key] = clone$1(sval);
        }
    }
    var keyResolvers = {
        '': (v) => v,
        x: (o) => o.x,
        y: (o) => o.y,
    };
    function resolveObjectKey(obj, key) {
        const resolver =
            keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
        return resolver(obj);
    }
    function _getKeyResolver(key) {
        const keys = _splitKey(key);
        return (obj) => {
            for (const k of keys) {
                if (k === '') {
                    break;
                }
                obj = obj && obj[k];
            }
            return obj;
        };
    }
    function _splitKey(key) {
        const parts = key.split('.');
        const keys = [];
        let tmp = '';
        for (const part of parts) {
            tmp += part;
            if (tmp.endsWith('\\')) {
                tmp = tmp.slice(0, -1) + '.';
            } else {
                keys.push(tmp);
                tmp = '';
            }
        }
        return keys;
    }
    function _capitalize(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }
    var defined = (value) => typeof value !== 'undefined';
    var isFunction = (value) => typeof value === 'function';
    var setsEqual = (a, b) => {
        if (a.size !== b.size) {
            return false;
        }
        for (const item of a) {
            if (!b.has(item)) {
                return false;
            }
        }
        return true;
    };
    function _isClickEvent(e) {
        return (
            e.type === 'mouseup' ||
            e.type === 'click' ||
            e.type === 'contextmenu'
        );
    }
    var PI = Math.PI;
    var TAU = 2 * PI;
    var PITAU = TAU + PI;
    var INFINITY = Number.POSITIVE_INFINITY;
    var RAD_PER_DEG = PI / 180;
    var HALF_PI = PI / 2;
    var QUARTER_PI = PI / 4;
    var TWO_THIRDS_PI = (PI * 2) / 3;
    var log10 = Math.log10;
    var sign = Math.sign;
    function niceNum(range) {
        const roundedRange = Math.round(range);
        range = almostEquals(range, roundedRange, range / 1e3)
            ? roundedRange
            : range;
        const niceRange = Math.pow(10, Math.floor(log10(range)));
        const fraction = range / niceRange;
        const niceFraction =
            fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
        return niceFraction * niceRange;
    }
    function _factorize(value) {
        const result = [];
        const sqrt = Math.sqrt(value);
        let i;
        for (i = 1; i < sqrt; i++) {
            if (value % i === 0) {
                result.push(i);
                result.push(value / i);
            }
        }
        if (sqrt === (sqrt | 0)) {
            result.push(sqrt);
        }
        result.sort((a, b) => a - b).pop();
        return result;
    }
    function isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }
    function almostEquals(x, y, epsilon) {
        return Math.abs(x - y) < epsilon;
    }
    function almostWhole(x, epsilon) {
        const rounded = Math.round(x);
        return rounded - epsilon <= x && rounded + epsilon >= x;
    }
    function _setMinAndMaxByKey(array2, target, property) {
        let i, ilen, value;
        for (i = 0, ilen = array2.length; i < ilen; i++) {
            value = array2[i][property];
            if (!isNaN(value)) {
                target.min = Math.min(target.min, value);
                target.max = Math.max(target.max, value);
            }
        }
    }
    function toRadians(degrees2) {
        return degrees2 * (PI / 180);
    }
    function toDegrees(radians) {
        return radians * (180 / PI);
    }
    function _decimalPlaces(x) {
        if (!isNumberFinite(x)) {
            return;
        }
        let e = 1;
        let p = 0;
        while (Math.round(x * e) / e !== x) {
            e *= 10;
            p++;
        }
        return p;
    }
    function getAngleFromPoint(centrePoint, anglePoint) {
        const distanceFromXCenter = anglePoint.x - centrePoint.x;
        const distanceFromYCenter = anglePoint.y - centrePoint.y;
        const radialDistanceFromCenter = Math.sqrt(
            distanceFromXCenter * distanceFromXCenter +
                distanceFromYCenter * distanceFromYCenter
        );
        let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
        if (angle < -0.5 * PI) {
            angle += TAU;
        }
        return {
            angle,
            distance: radialDistanceFromCenter,
        };
    }
    function distanceBetweenPoints(pt1, pt2) {
        return Math.sqrt(
            Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2)
        );
    }
    function _angleDiff(a, b) {
        return ((a - b + PITAU) % TAU) - PI;
    }
    function _normalizeAngle(a) {
        return ((a % TAU) + TAU) % TAU;
    }
    function _angleBetween(angle, start2, end, sameAngleIsFullCircle) {
        const a = _normalizeAngle(angle);
        const s = _normalizeAngle(start2);
        const e = _normalizeAngle(end);
        const angleToStart = _normalizeAngle(s - a);
        const angleToEnd = _normalizeAngle(e - a);
        const startToAngle = _normalizeAngle(a - s);
        const endToAngle = _normalizeAngle(a - e);
        return (
            a === s ||
            a === e ||
            (sameAngleIsFullCircle && s === e) ||
            (angleToStart > angleToEnd && startToAngle < endToAngle)
        );
    }
    function _limitValue(value, min3, max3) {
        return Math.max(min3, Math.min(max3, value));
    }
    function _int16Range(value) {
        return _limitValue(value, -32768, 32767);
    }
    function _isBetween(value, start2, end, epsilon = 1e-6) {
        return (
            value >= Math.min(start2, end) - epsilon &&
            value <= Math.max(start2, end) + epsilon
        );
    }
    function _lookup(table, value, cmp) {
        cmp = cmp || ((index3) => table[index3] < value);
        let hi = table.length - 1;
        let lo = 0;
        let mid;
        while (hi - lo > 1) {
            mid = (lo + hi) >> 1;
            if (cmp(mid)) {
                lo = mid;
            } else {
                hi = mid;
            }
        }
        return { lo, hi };
    }
    var _lookupByKey = (table, key, value, last) =>
        _lookup(
            table,
            value,
            last
                ? (index3) => table[index3][key] <= value
                : (index3) => table[index3][key] < value
        );
    var _rlookupByKey = (table, key, value) =>
        _lookup(table, value, (index3) => table[index3][key] >= value);
    function _filterBetween(values, min3, max3) {
        let start2 = 0;
        let end = values.length;
        while (start2 < end && values[start2] < min3) {
            start2++;
        }
        while (end > start2 && values[end - 1] > max3) {
            end--;
        }
        return start2 > 0 || end < values.length
            ? values.slice(start2, end)
            : values;
    }
    var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];
    function listenArrayEvents(array2, listener) {
        if (array2._chartjs) {
            array2._chartjs.listeners.push(listener);
            return;
        }
        Object.defineProperty(array2, '_chartjs', {
            configurable: true,
            enumerable: false,
            value: {
                listeners: [listener],
            },
        });
        arrayEvents.forEach((key) => {
            const method = '_onData' + _capitalize(key);
            const base = array2[key];
            Object.defineProperty(array2, key, {
                configurable: true,
                enumerable: false,
                value(...args) {
                    const res = base.apply(this, args);
                    array2._chartjs.listeners.forEach((object) => {
                        if (typeof object[method] === 'function') {
                            object[method](...args);
                        }
                    });
                    return res;
                },
            });
        });
    }
    function unlistenArrayEvents(array2, listener) {
        const stub = array2._chartjs;
        if (!stub) {
            return;
        }
        const listeners = stub.listeners;
        const index3 = listeners.indexOf(listener);
        if (index3 !== -1) {
            listeners.splice(index3, 1);
        }
        if (listeners.length > 0) {
            return;
        }
        arrayEvents.forEach((key) => {
            delete array2[key];
        });
        delete array2._chartjs;
    }
    function _arrayUnique(items) {
        const set4 = /* @__PURE__ */ new Set();
        let i, ilen;
        for (i = 0, ilen = items.length; i < ilen; ++i) {
            set4.add(items[i]);
        }
        if (set4.size === ilen) {
            return items;
        }
        return Array.from(set4);
    }
    var requestAnimFrame = (function () {
        if (typeof window === 'undefined') {
            return function (callback2) {
                return callback2();
            };
        }
        return window.requestAnimationFrame;
    })();
    function throttled(fn, thisArg, updateFn) {
        const updateArgs =
            updateFn || ((args2) => Array.prototype.slice.call(args2));
        let ticking = false;
        let args = [];
        return function (...rest) {
            args = updateArgs(rest);
            if (!ticking) {
                ticking = true;
                requestAnimFrame.call(window, () => {
                    ticking = false;
                    fn.apply(thisArg, args);
                });
            }
        };
    }
    function debounce(fn, delay) {
        let timeout2;
        return function (...args) {
            if (delay) {
                clearTimeout(timeout2);
                timeout2 = setTimeout(fn, delay, args);
            } else {
                fn.apply(this, args);
            }
            return delay;
        };
    }
    var _toLeftRightCenter = (align) =>
        align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';
    var _alignStartEnd = (align, start2, end) =>
        align === 'start' ? start2 : align === 'end' ? end : (start2 + end) / 2;
    var _textX = (align, left, right, rtl) => {
        const check = rtl ? 'left' : 'right';
        return align === check
            ? right
            : align === 'center'
            ? (left + right) / 2
            : left;
    };
    function _getStartAndCountOfVisiblePoints(
        meta,
        points,
        animationsDisabled
    ) {
        const pointCount = points.length;
        let start2 = 0;
        let count = pointCount;
        if (meta._sorted) {
            const { iScale, _parsed } = meta;
            const axis = iScale.axis;
            const {
                min: min3,
                max: max3,
                minDefined,
                maxDefined,
            } = iScale.getUserBounds();
            if (minDefined) {
                start2 = _limitValue(
                    Math.min(
                        _lookupByKey(_parsed, iScale.axis, min3).lo,
                        animationsDisabled
                            ? pointCount
                            : _lookupByKey(
                                  points,
                                  axis,
                                  iScale.getPixelForValue(min3)
                              ).lo
                    ),
                    0,
                    pointCount - 1
                );
            }
            if (maxDefined) {
                count =
                    _limitValue(
                        Math.max(
                            _lookupByKey(_parsed, iScale.axis, max3, true).hi +
                                1,
                            animationsDisabled
                                ? 0
                                : _lookupByKey(
                                      points,
                                      axis,
                                      iScale.getPixelForValue(max3),
                                      true
                                  ).hi + 1
                        ),
                        start2,
                        pointCount
                    ) - start2;
            } else {
                count = pointCount - start2;
            }
        }
        return { start: start2, count };
    }
    function _scaleRangesChanged(meta) {
        const { xScale, yScale, _scaleRanges } = meta;
        const newRanges = {
            xmin: xScale.min,
            xmax: xScale.max,
            ymin: yScale.min,
            ymax: yScale.max,
        };
        if (!_scaleRanges) {
            meta._scaleRanges = newRanges;
            return true;
        }
        const changed =
            _scaleRanges.xmin !== xScale.min ||
            _scaleRanges.xmax !== xScale.max ||
            _scaleRanges.ymin !== yScale.min ||
            _scaleRanges.ymax !== yScale.max;
        Object.assign(_scaleRanges, newRanges);
        return changed;
    }
    var atEdge = (t) => t === 0 || t === 1;
    var elasticIn = (t, s, p) =>
        -(Math.pow(2, 10 * (t -= 1)) * Math.sin(((t - s) * TAU) / p));
    var elasticOut = (t, s, p) =>
        Math.pow(2, -10 * t) * Math.sin(((t - s) * TAU) / p) + 1;
    var effects = {
        linear: (t) => t,
        easeInQuad: (t) => t * t,
        easeOutQuad: (t) => -t * (t - 2),
        easeInOutQuad: (t) =>
            (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
        easeInCubic: (t) => t * t * t,
        easeOutCubic: (t) => (t -= 1) * t * t + 1,
        easeInOutCubic: (t) =>
            (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
        easeInQuart: (t) => t * t * t * t,
        easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
        easeInOutQuart: (t) =>
            (t /= 0.5) < 1
                ? 0.5 * t * t * t * t
                : -0.5 * ((t -= 2) * t * t * t - 2),
        easeInQuint: (t) => t * t * t * t * t,
        easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
        easeInOutQuint: (t) =>
            (t /= 0.5) < 1
                ? 0.5 * t * t * t * t * t
                : 0.5 * ((t -= 2) * t * t * t * t + 2),
        easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
        easeOutSine: (t) => Math.sin(t * HALF_PI),
        easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
        easeInExpo: (t) => (t === 0 ? 0 : Math.pow(2, 10 * (t - 1))),
        easeOutExpo: (t) => (t === 1 ? 1 : -Math.pow(2, -10 * t) + 1),
        easeInOutExpo: (t) =>
            atEdge(t)
                ? t
                : t < 0.5
                ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))
                : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
        easeInCirc: (t) => (t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1)),
        easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
        easeInOutCirc: (t) =>
            (t /= 0.5) < 1
                ? -0.5 * (Math.sqrt(1 - t * t) - 1)
                : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
        easeInElastic: (t) => (atEdge(t) ? t : elasticIn(t, 0.075, 0.3)),
        easeOutElastic: (t) => (atEdge(t) ? t : elasticOut(t, 0.075, 0.3)),
        easeInOutElastic(t) {
            const s = 0.1125;
            const p = 0.45;
            return atEdge(t)
                ? t
                : t < 0.5
                ? 0.5 * elasticIn(t * 2, s, p)
                : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
        },
        easeInBack(t) {
            const s = 1.70158;
            return t * t * ((s + 1) * t - s);
        },
        easeOutBack(t) {
            const s = 1.70158;
            return (t -= 1) * t * ((s + 1) * t + s) + 1;
        },
        easeInOutBack(t) {
            let s = 1.70158;
            if ((t /= 0.5) < 1) {
                return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
            }
            return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
        },
        easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
        easeOutBounce(t) {
            const m = 7.5625;
            const d = 2.75;
            if (t < 1 / d) {
                return m * t * t;
            }
            if (t < 2 / d) {
                return m * (t -= 1.5 / d) * t + 0.75;
            }
            if (t < 2.5 / d) {
                return m * (t -= 2.25 / d) * t + 0.9375;
            }
            return m * (t -= 2.625 / d) * t + 0.984375;
        },
        easeInOutBounce: (t) =>
            t < 0.5
                ? effects.easeInBounce(t * 2) * 0.5
                : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,
    };
    function round(v) {
        return (v + 0.5) | 0;
    }
    var lim = (v, l, h) => Math.max(Math.min(v, h), l);
    function p2b(v) {
        return lim(round(v * 2.55), 0, 255);
    }
    function n2b(v) {
        return lim(round(v * 255), 0, 255);
    }
    function b2n(v) {
        return lim(round(v / 2.55) / 100, 0, 1);
    }
    function n2p(v) {
        return lim(round(v * 100), 0, 100);
    }
    var map$1 = {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        A: 10,
        B: 11,
        C: 12,
        D: 13,
        E: 14,
        F: 15,
        a: 10,
        b: 11,
        c: 12,
        d: 13,
        e: 14,
        f: 15,
    };
    var hex = [...'0123456789ABCDEF'];
    var h1 = (b) => hex[b & 15];
    var h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
    var eq = (b) => (b & 240) >> 4 === (b & 15);
    var isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
    function hexParse(str) {
        var len = str.length;
        var ret;
        if (str[0] === '#') {
            if (len === 4 || len === 5) {
                ret = {
                    r: 255 & (map$1[str[1]] * 17),
                    g: 255 & (map$1[str[2]] * 17),
                    b: 255 & (map$1[str[3]] * 17),
                    a: len === 5 ? map$1[str[4]] * 17 : 255,
                };
            } else if (len === 7 || len === 9) {
                ret = {
                    r: (map$1[str[1]] << 4) | map$1[str[2]],
                    g: (map$1[str[3]] << 4) | map$1[str[4]],
                    b: (map$1[str[5]] << 4) | map$1[str[6]],
                    a: len === 9 ? (map$1[str[7]] << 4) | map$1[str[8]] : 255,
                };
            }
        }
        return ret;
    }
    var alpha = (a, f) => (a < 255 ? f(a) : '');
    function hexString(v) {
        var f = isShort(v) ? h1 : h2;
        return v ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
    }
    var HUE_RE =
        /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
    function hsl2rgbn(h, s, l) {
        const a = s * Math.min(l, 1 - l);
        const f = (n, k = (n + h / 30) % 12) =>
            l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
        return [f(0), f(8), f(4)];
    }
    function hsv2rgbn(h, s, v) {
        const f = (n, k = (n + h / 60) % 6) =>
            v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
        return [f(5), f(3), f(1)];
    }
    function hwb2rgbn(h, w, b) {
        const rgb2 = hsl2rgbn(h, 1, 0.5);
        let i;
        if (w + b > 1) {
            i = 1 / (w + b);
            w *= i;
            b *= i;
        }
        for (i = 0; i < 3; i++) {
            rgb2[i] *= 1 - w - b;
            rgb2[i] += w;
        }
        return rgb2;
    }
    function hueValue(r, g, b, d, max3) {
        if (r === max3) {
            return (g - b) / d + (g < b ? 6 : 0);
        }
        if (g === max3) {
            return (b - r) / d + 2;
        }
        return (r - g) / d + 4;
    }
    function rgb2hsl(v) {
        const range = 255;
        const r = v.r / range;
        const g = v.g / range;
        const b = v.b / range;
        const max3 = Math.max(r, g, b);
        const min3 = Math.min(r, g, b);
        const l = (max3 + min3) / 2;
        let h, s, d;
        if (max3 !== min3) {
            d = max3 - min3;
            s = l > 0.5 ? d / (2 - max3 - min3) : d / (max3 + min3);
            h = hueValue(r, g, b, d, max3);
            h = h * 60 + 0.5;
        }
        return [h | 0, s || 0, l];
    }
    function calln(f, a, b, c) {
        return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
    }
    function hsl2rgb(h, s, l) {
        return calln(hsl2rgbn, h, s, l);
    }
    function hwb2rgb(h, w, b) {
        return calln(hwb2rgbn, h, w, b);
    }
    function hsv2rgb(h, s, v) {
        return calln(hsv2rgbn, h, s, v);
    }
    function hue(h) {
        return ((h % 360) + 360) % 360;
    }
    function hueParse(str) {
        const m = HUE_RE.exec(str);
        let a = 255;
        let v;
        if (!m) {
            return;
        }
        if (m[5] !== v) {
            a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
        }
        const h = hue(+m[2]);
        const p1 = +m[3] / 100;
        const p2 = +m[4] / 100;
        if (m[1] === 'hwb') {
            v = hwb2rgb(h, p1, p2);
        } else if (m[1] === 'hsv') {
            v = hsv2rgb(h, p1, p2);
        } else {
            v = hsl2rgb(h, p1, p2);
        }
        return {
            r: v[0],
            g: v[1],
            b: v[2],
            a,
        };
    }
    function rotate(v, deg) {
        var h = rgb2hsl(v);
        h[0] = hue(h[0] + deg);
        h = hsl2rgb(h);
        v.r = h[0];
        v.g = h[1];
        v.b = h[2];
    }
    function hslString(v) {
        if (!v) {
            return;
        }
        const a = rgb2hsl(v);
        const h = a[0];
        const s = n2p(a[1]);
        const l = n2p(a[2]);
        return v.a < 255
            ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`
            : `hsl(${h}, ${s}%, ${l}%)`;
    }
    var map = {
        x: 'dark',
        Z: 'light',
        Y: 're',
        X: 'blu',
        W: 'gr',
        V: 'medium',
        U: 'slate',
        A: 'ee',
        T: 'ol',
        S: 'or',
        B: 'ra',
        C: 'lateg',
        D: 'ights',
        R: 'in',
        Q: 'turquois',
        E: 'hi',
        P: 'ro',
        O: 'al',
        N: 'le',
        M: 'de',
        L: 'yello',
        F: 'en',
        K: 'ch',
        G: 'arks',
        H: 'ea',
        I: 'ightg',
        J: 'wh',
    };
    var names$1 = {
        OiceXe: 'f0f8ff',
        antiquewEte: 'faebd7',
        aqua: 'ffff',
        aquamarRe: '7fffd4',
        azuY: 'f0ffff',
        beige: 'f5f5dc',
        bisque: 'ffe4c4',
        black: '0',
        blanKedOmond: 'ffebcd',
        Xe: 'ff',
        XeviTet: '8a2be2',
        bPwn: 'a52a2a',
        burlywood: 'deb887',
        caMtXe: '5f9ea0',
        KartYuse: '7fff00',
        KocTate: 'd2691e',
        cSO: 'ff7f50',
        cSnflowerXe: '6495ed',
        cSnsilk: 'fff8dc',
        crimson: 'dc143c',
        cyan: 'ffff',
        xXe: '8b',
        xcyan: '8b8b',
        xgTMnPd: 'b8860b',
        xWay: 'a9a9a9',
        xgYF: '6400',
        xgYy: 'a9a9a9',
        xkhaki: 'bdb76b',
        xmagFta: '8b008b',
        xTivegYF: '556b2f',
        xSange: 'ff8c00',
        xScEd: '9932cc',
        xYd: '8b0000',
        xsOmon: 'e9967a',
        xsHgYF: '8fbc8f',
        xUXe: '483d8b',
        xUWay: '2f4f4f',
        xUgYy: '2f4f4f',
        xQe: 'ced1',
        xviTet: '9400d3',
        dAppRk: 'ff1493',
        dApskyXe: 'bfff',
        dimWay: '696969',
        dimgYy: '696969',
        dodgerXe: '1e90ff',
        fiYbrick: 'b22222',
        flSOwEte: 'fffaf0',
        foYstWAn: '228b22',
        fuKsia: 'ff00ff',
        gaRsbSo: 'dcdcdc',
        ghostwEte: 'f8f8ff',
        gTd: 'ffd700',
        gTMnPd: 'daa520',
        Way: '808080',
        gYF: '8000',
        gYFLw: 'adff2f',
        gYy: '808080',
        honeyMw: 'f0fff0',
        hotpRk: 'ff69b4',
        RdianYd: 'cd5c5c',
        Rdigo: '4b0082',
        ivSy: 'fffff0',
        khaki: 'f0e68c',
        lavFMr: 'e6e6fa',
        lavFMrXsh: 'fff0f5',
        lawngYF: '7cfc00',
        NmoncEffon: 'fffacd',
        ZXe: 'add8e6',
        ZcSO: 'f08080',
        Zcyan: 'e0ffff',
        ZgTMnPdLw: 'fafad2',
        ZWay: 'd3d3d3',
        ZgYF: '90ee90',
        ZgYy: 'd3d3d3',
        ZpRk: 'ffb6c1',
        ZsOmon: 'ffa07a',
        ZsHgYF: '20b2aa',
        ZskyXe: '87cefa',
        ZUWay: '778899',
        ZUgYy: '778899',
        ZstAlXe: 'b0c4de',
        ZLw: 'ffffe0',
        lime: 'ff00',
        limegYF: '32cd32',
        lRF: 'faf0e6',
        magFta: 'ff00ff',
        maPon: '800000',
        VaquamarRe: '66cdaa',
        VXe: 'cd',
        VScEd: 'ba55d3',
        VpurpN: '9370db',
        VsHgYF: '3cb371',
        VUXe: '7b68ee',
        VsprRggYF: 'fa9a',
        VQe: '48d1cc',
        VviTetYd: 'c71585',
        midnightXe: '191970',
        mRtcYam: 'f5fffa',
        mistyPse: 'ffe4e1',
        moccasR: 'ffe4b5',
        navajowEte: 'ffdead',
        navy: '80',
        Tdlace: 'fdf5e6',
        Tive: '808000',
        TivedBb: '6b8e23',
        Sange: 'ffa500',
        SangeYd: 'ff4500',
        ScEd: 'da70d6',
        pOegTMnPd: 'eee8aa',
        pOegYF: '98fb98',
        pOeQe: 'afeeee',
        pOeviTetYd: 'db7093',
        papayawEp: 'ffefd5',
        pHKpuff: 'ffdab9',
        peru: 'cd853f',
        pRk: 'ffc0cb',
        plum: 'dda0dd',
        powMrXe: 'b0e0e6',
        purpN: '800080',
        YbeccapurpN: '663399',
        Yd: 'ff0000',
        Psybrown: 'bc8f8f',
        PyOXe: '4169e1',
        saddNbPwn: '8b4513',
        sOmon: 'fa8072',
        sandybPwn: 'f4a460',
        sHgYF: '2e8b57',
        sHshell: 'fff5ee',
        siFna: 'a0522d',
        silver: 'c0c0c0',
        skyXe: '87ceeb',
        UXe: '6a5acd',
        UWay: '708090',
        UgYy: '708090',
        snow: 'fffafa',
        sprRggYF: 'ff7f',
        stAlXe: '4682b4',
        tan: 'd2b48c',
        teO: '8080',
        tEstN: 'd8bfd8',
        tomato: 'ff6347',
        Qe: '40e0d0',
        viTet: 'ee82ee',
        JHt: 'f5deb3',
        wEte: 'ffffff',
        wEtesmoke: 'f5f5f5',
        Lw: 'ffff00',
        LwgYF: '9acd32',
    };
    function unpack() {
        const unpacked = {};
        const keys = Object.keys(names$1);
        const tkeys = Object.keys(map);
        let i, j, k, ok, nk;
        for (i = 0; i < keys.length; i++) {
            ok = nk = keys[i];
            for (j = 0; j < tkeys.length; j++) {
                k = tkeys[j];
                nk = nk.replace(k, map[k]);
            }
            k = parseInt(names$1[ok], 16);
            unpacked[nk] = [(k >> 16) & 255, (k >> 8) & 255, k & 255];
        }
        return unpacked;
    }
    var names;
    function nameParse(str) {
        if (!names) {
            names = unpack();
            names.transparent = [0, 0, 0, 0];
        }
        const a = names[str.toLowerCase()];
        return (
            a && {
                r: a[0],
                g: a[1],
                b: a[2],
                a: a.length === 4 ? a[3] : 255,
            }
        );
    }
    var RGB_RE =
        /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
    function rgbParse(str) {
        const m = RGB_RE.exec(str);
        let a = 255;
        let r, g, b;
        if (!m) {
            return;
        }
        if (m[7] !== r) {
            const v = +m[7];
            a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
        }
        r = +m[1];
        g = +m[3];
        b = +m[5];
        r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
        g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
        b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
        return {
            r,
            g,
            b,
            a,
        };
    }
    function rgbString(v) {
        return (
            v &&
            (v.a < 255
                ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`
                : `rgb(${v.r}, ${v.g}, ${v.b})`)
        );
    }
    var to = (v) =>
        v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
    var from = (v) =>
        v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
    function interpolate(rgb1, rgb2, t) {
        const r = from(b2n(rgb1.r));
        const g = from(b2n(rgb1.g));
        const b = from(b2n(rgb1.b));
        return {
            r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
            g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
            b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
            a: rgb1.a + t * (rgb2.a - rgb1.a),
        };
    }
    function modHSL(v, i, ratio) {
        if (v) {
            let tmp = rgb2hsl(v);
            tmp[i] = Math.max(
                0,
                Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1)
            );
            tmp = hsl2rgb(tmp);
            v.r = tmp[0];
            v.g = tmp[1];
            v.b = tmp[2];
        }
    }
    function clone(v, proto) {
        return v ? Object.assign(proto || {}, v) : v;
    }
    function fromObject(input) {
        var v = { r: 0, g: 0, b: 0, a: 255 };
        if (Array.isArray(input)) {
            if (input.length >= 3) {
                v = { r: input[0], g: input[1], b: input[2], a: 255 };
                if (input.length > 3) {
                    v.a = n2b(input[3]);
                }
            }
        } else {
            v = clone(input, { r: 0, g: 0, b: 0, a: 1 });
            v.a = n2b(v.a);
        }
        return v;
    }
    function functionParse(str) {
        if (str.charAt(0) === 'r') {
            return rgbParse(str);
        }
        return hueParse(str);
    }
    var Color = class _Color {
        constructor(input) {
            if (input instanceof _Color) {
                return input;
            }
            const type2 = typeof input;
            let v;
            if (type2 === 'object') {
                v = fromObject(input);
            } else if (type2 === 'string') {
                v = hexParse(input) || nameParse(input) || functionParse(input);
            }
            this._rgb = v;
            this._valid = !!v;
        }
        get valid() {
            return this._valid;
        }
        get rgb() {
            var v = clone(this._rgb);
            if (v) {
                v.a = b2n(v.a);
            }
            return v;
        }
        set rgb(obj) {
            this._rgb = fromObject(obj);
        }
        rgbString() {
            return this._valid ? rgbString(this._rgb) : void 0;
        }
        hexString() {
            return this._valid ? hexString(this._rgb) : void 0;
        }
        hslString() {
            return this._valid ? hslString(this._rgb) : void 0;
        }
        mix(color3, weight) {
            if (color3) {
                const c1 = this.rgb;
                const c2 = color3.rgb;
                let w2;
                const p = weight === w2 ? 0.5 : weight;
                const w = 2 * p - 1;
                const a = c1.a - c2.a;
                const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
                w2 = 1 - w1;
                c1.r = 255 & (w1 * c1.r + w2 * c2.r + 0.5);
                c1.g = 255 & (w1 * c1.g + w2 * c2.g + 0.5);
                c1.b = 255 & (w1 * c1.b + w2 * c2.b + 0.5);
                c1.a = p * c1.a + (1 - p) * c2.a;
                this.rgb = c1;
            }
            return this;
        }
        interpolate(color3, t) {
            if (color3) {
                this._rgb = interpolate(this._rgb, color3._rgb, t);
            }
            return this;
        }
        clone() {
            return new _Color(this.rgb);
        }
        alpha(a) {
            this._rgb.a = n2b(a);
            return this;
        }
        clearer(ratio) {
            const rgb2 = this._rgb;
            rgb2.a *= 1 - ratio;
            return this;
        }
        greyscale() {
            const rgb2 = this._rgb;
            const val = round(rgb2.r * 0.3 + rgb2.g * 0.59 + rgb2.b * 0.11);
            rgb2.r = rgb2.g = rgb2.b = val;
            return this;
        }
        opaquer(ratio) {
            const rgb2 = this._rgb;
            rgb2.a *= 1 + ratio;
            return this;
        }
        negate() {
            const v = this._rgb;
            v.r = 255 - v.r;
            v.g = 255 - v.g;
            v.b = 255 - v.b;
            return this;
        }
        lighten(ratio) {
            modHSL(this._rgb, 2, ratio);
            return this;
        }
        darken(ratio) {
            modHSL(this._rgb, 2, -ratio);
            return this;
        }
        saturate(ratio) {
            modHSL(this._rgb, 1, ratio);
            return this;
        }
        desaturate(ratio) {
            modHSL(this._rgb, 1, -ratio);
            return this;
        }
        rotate(deg) {
            rotate(this._rgb, deg);
            return this;
        }
    };
    function index_esm(input) {
        return new Color(input);
    }
    function isPatternOrGradient(value) {
        if (value && typeof value === 'object') {
            const type2 = value.toString();
            return (
                type2 === '[object CanvasPattern]' ||
                type2 === '[object CanvasGradient]'
            );
        }
        return false;
    }
    function color(value) {
        return isPatternOrGradient(value) ? value : index_esm(value);
    }
    function getHoverColor(value) {
        return isPatternOrGradient(value)
            ? value
            : index_esm(value).saturate(0.5).darken(0.1).hexString();
    }
    var overrides = /* @__PURE__ */ Object.create(null);
    var descriptors = /* @__PURE__ */ Object.create(null);
    function getScope$1(node, key) {
        if (!key) {
            return node;
        }
        const keys = key.split('.');
        for (let i = 0, n = keys.length; i < n; ++i) {
            const k = keys[i];
            node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));
        }
        return node;
    }
    function set(root2, scope, values) {
        if (typeof scope === 'string') {
            return merge(getScope$1(root2, scope), values);
        }
        return merge(getScope$1(root2, ''), scope);
    }
    var Defaults = class {
        constructor(_descriptors2) {
            this.animation = void 0;
            this.backgroundColor = 'rgba(0,0,0,0.1)';
            this.borderColor = 'rgba(0,0,0,0.1)';
            this.color = '#666';
            this.datasets = {};
            this.devicePixelRatio = (context) =>
                context.chart.platform.getDevicePixelRatio();
            this.elements = {};
            this.events = [
                'mousemove',
                'mouseout',
                'click',
                'touchstart',
                'touchmove',
            ];
            this.font = {
                family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
                size: 12,
                style: 'normal',
                lineHeight: 1.2,
                weight: null,
            };
            this.hover = {};
            this.hoverBackgroundColor = (ctx, options) =>
                getHoverColor(options.backgroundColor);
            this.hoverBorderColor = (ctx, options) =>
                getHoverColor(options.borderColor);
            this.hoverColor = (ctx, options) => getHoverColor(options.color);
            this.indexAxis = 'x';
            this.interaction = {
                mode: 'nearest',
                intersect: true,
                includeInvisible: false,
            };
            this.maintainAspectRatio = true;
            this.onHover = null;
            this.onClick = null;
            this.parsing = true;
            this.plugins = {};
            this.responsive = true;
            this.scale = void 0;
            this.scales = {};
            this.showLine = true;
            this.drawActiveElementsOnTop = true;
            this.describe(_descriptors2);
        }
        set(scope, values) {
            return set(this, scope, values);
        }
        get(scope) {
            return getScope$1(this, scope);
        }
        describe(scope, values) {
            return set(descriptors, scope, values);
        }
        override(scope, values) {
            return set(overrides, scope, values);
        }
        route(scope, name, targetScope, targetName) {
            const scopeObject = getScope$1(this, scope);
            const targetScopeObject = getScope$1(this, targetScope);
            const privateName = '_' + name;
            Object.defineProperties(scopeObject, {
                [privateName]: {
                    value: scopeObject[name],
                    writable: true,
                },
                [name]: {
                    enumerable: true,
                    get() {
                        const local = this[privateName];
                        const target = targetScopeObject[targetName];
                        if (isObject(local)) {
                            return Object.assign({}, target, local);
                        }
                        return valueOrDefault(local, target);
                    },
                    set(value) {
                        this[privateName] = value;
                    },
                },
            });
        }
    };
    var defaults = new Defaults({
        _scriptable: (name) => !name.startsWith('on'),
        _indexable: (name) => name !== 'events',
        hover: {
            _fallback: 'interaction',
        },
        interaction: {
            _scriptable: false,
            _indexable: false,
        },
    });
    function toFontString(font) {
        if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
            return null;
        }
        return (
            (font.style ? font.style + ' ' : '') +
            (font.weight ? font.weight + ' ' : '') +
            font.size +
            'px ' +
            font.family
        );
    }
    function _measureText(ctx, data, gc, longest, string) {
        let textWidth = data[string];
        if (!textWidth) {
            textWidth = data[string] = ctx.measureText(string).width;
            gc.push(string);
        }
        if (textWidth > longest) {
            longest = textWidth;
        }
        return longest;
    }
    function _longestText(ctx, font, arrayOfThings, cache) {
        cache = cache || {};
        let data = (cache.data = cache.data || {});
        let gc = (cache.garbageCollect = cache.garbageCollect || []);
        if (cache.font !== font) {
            data = cache.data = {};
            gc = cache.garbageCollect = [];
            cache.font = font;
        }
        ctx.save();
        ctx.font = font;
        let longest = 0;
        const ilen = arrayOfThings.length;
        let i, j, jlen, thing, nestedThing;
        for (i = 0; i < ilen; i++) {
            thing = arrayOfThings[i];
            if (thing !== void 0 && thing !== null && isArray(thing) !== true) {
                longest = _measureText(ctx, data, gc, longest, thing);
            } else if (isArray(thing)) {
                for (j = 0, jlen = thing.length; j < jlen; j++) {
                    nestedThing = thing[j];
                    if (
                        nestedThing !== void 0 &&
                        nestedThing !== null &&
                        !isArray(nestedThing)
                    ) {
                        longest = _measureText(
                            ctx,
                            data,
                            gc,
                            longest,
                            nestedThing
                        );
                    }
                }
            }
        }
        ctx.restore();
        const gcLen = gc.length / 2;
        if (gcLen > arrayOfThings.length) {
            for (i = 0; i < gcLen; i++) {
                delete data[gc[i]];
            }
            gc.splice(0, gcLen);
        }
        return longest;
    }
    function _alignPixel(chart, pixel, width) {
        const devicePixelRatio2 = chart.currentDevicePixelRatio;
        const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
        return (
            Math.round((pixel - halfWidth) * devicePixelRatio2) /
                devicePixelRatio2 +
            halfWidth
        );
    }
    function clearCanvas(canvas, ctx) {
        ctx = ctx || canvas.getContext('2d');
        ctx.save();
        ctx.resetTransform();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
    }
    function drawPoint(ctx, options, x, y) {
        drawPointLegend(ctx, options, x, y, null);
    }
    function drawPointLegend(ctx, options, x, y, w) {
        let type2, xOffset, yOffset, size, cornerRadius, width;
        const style = options.pointStyle;
        const rotation = options.rotation;
        const radius3 = options.radius;
        let rad = (rotation || 0) * RAD_PER_DEG;
        if (style && typeof style === 'object') {
            type2 = style.toString();
            if (
                type2 === '[object HTMLImageElement]' ||
                type2 === '[object HTMLCanvasElement]'
            ) {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rad);
                ctx.drawImage(
                    style,
                    -style.width / 2,
                    -style.height / 2,
                    style.width,
                    style.height
                );
                ctx.restore();
                return;
            }
        }
        if (isNaN(radius3) || radius3 <= 0) {
            return;
        }
        ctx.beginPath();
        switch (style) {
            default:
                if (w) {
                    ctx.ellipse(x, y, w / 2, radius3, 0, 0, TAU);
                } else {
                    ctx.arc(x, y, radius3, 0, TAU);
                }
                ctx.closePath();
                break;
            case 'triangle':
                ctx.moveTo(
                    x + Math.sin(rad) * radius3,
                    y - Math.cos(rad) * radius3
                );
                rad += TWO_THIRDS_PI;
                ctx.lineTo(
                    x + Math.sin(rad) * radius3,
                    y - Math.cos(rad) * radius3
                );
                rad += TWO_THIRDS_PI;
                ctx.lineTo(
                    x + Math.sin(rad) * radius3,
                    y - Math.cos(rad) * radius3
                );
                ctx.closePath();
                break;
            case 'rectRounded':
                cornerRadius = radius3 * 0.516;
                size = radius3 - cornerRadius;
                xOffset = Math.cos(rad + QUARTER_PI) * size;
                yOffset = Math.sin(rad + QUARTER_PI) * size;
                ctx.arc(
                    x - xOffset,
                    y - yOffset,
                    cornerRadius,
                    rad - PI,
                    rad - HALF_PI
                );
                ctx.arc(
                    x + yOffset,
                    y - xOffset,
                    cornerRadius,
                    rad - HALF_PI,
                    rad
                );
                ctx.arc(
                    x + xOffset,
                    y + yOffset,
                    cornerRadius,
                    rad,
                    rad + HALF_PI
                );
                ctx.arc(
                    x - yOffset,
                    y + xOffset,
                    cornerRadius,
                    rad + HALF_PI,
                    rad + PI
                );
                ctx.closePath();
                break;
            case 'rect':
                if (!rotation) {
                    size = Math.SQRT1_2 * radius3;
                    width = w ? w / 2 : size;
                    ctx.rect(x - width, y - size, 2 * width, 2 * size);
                    break;
                }
                rad += QUARTER_PI;
            case 'rectRot':
                xOffset = Math.cos(rad) * radius3;
                yOffset = Math.sin(rad) * radius3;
                ctx.moveTo(x - xOffset, y - yOffset);
                ctx.lineTo(x + yOffset, y - xOffset);
                ctx.lineTo(x + xOffset, y + yOffset);
                ctx.lineTo(x - yOffset, y + xOffset);
                ctx.closePath();
                break;
            case 'crossRot':
                rad += QUARTER_PI;
            case 'cross':
                xOffset = Math.cos(rad) * radius3;
                yOffset = Math.sin(rad) * radius3;
                ctx.moveTo(x - xOffset, y - yOffset);
                ctx.lineTo(x + xOffset, y + yOffset);
                ctx.moveTo(x + yOffset, y - xOffset);
                ctx.lineTo(x - yOffset, y + xOffset);
                break;
            case 'star':
                xOffset = Math.cos(rad) * radius3;
                yOffset = Math.sin(rad) * radius3;
                ctx.moveTo(x - xOffset, y - yOffset);
                ctx.lineTo(x + xOffset, y + yOffset);
                ctx.moveTo(x + yOffset, y - xOffset);
                ctx.lineTo(x - yOffset, y + xOffset);
                rad += QUARTER_PI;
                xOffset = Math.cos(rad) * radius3;
                yOffset = Math.sin(rad) * radius3;
                ctx.moveTo(x - xOffset, y - yOffset);
                ctx.lineTo(x + xOffset, y + yOffset);
                ctx.moveTo(x + yOffset, y - xOffset);
                ctx.lineTo(x - yOffset, y + xOffset);
                break;
            case 'line':
                xOffset = w ? w / 2 : Math.cos(rad) * radius3;
                yOffset = Math.sin(rad) * radius3;
                ctx.moveTo(x - xOffset, y - yOffset);
                ctx.lineTo(x + xOffset, y + yOffset);
                break;
            case 'dash':
                ctx.moveTo(x, y);
                ctx.lineTo(
                    x + Math.cos(rad) * radius3,
                    y + Math.sin(rad) * radius3
                );
                break;
        }
        ctx.fill();
        if (options.borderWidth > 0) {
            ctx.stroke();
        }
    }
    function _isPointInArea(point, area, margin) {
        margin = margin || 0.5;
        return (
            !area ||
            (point &&
                point.x > area.left - margin &&
                point.x < area.right + margin &&
                point.y > area.top - margin &&
                point.y < area.bottom + margin)
        );
    }
    function clipArea(ctx, area) {
        ctx.save();
        ctx.beginPath();
        ctx.rect(
            area.left,
            area.top,
            area.right - area.left,
            area.bottom - area.top
        );
        ctx.clip();
    }
    function unclipArea(ctx) {
        ctx.restore();
    }
    function _steppedLineTo(ctx, previous, target, flip, mode) {
        if (!previous) {
            return ctx.lineTo(target.x, target.y);
        }
        if (mode === 'middle') {
            const midpoint = (previous.x + target.x) / 2;
            ctx.lineTo(midpoint, previous.y);
            ctx.lineTo(midpoint, target.y);
        } else if ((mode === 'after') !== !!flip) {
            ctx.lineTo(previous.x, target.y);
        } else {
            ctx.lineTo(target.x, previous.y);
        }
        ctx.lineTo(target.x, target.y);
    }
    function _bezierCurveTo(ctx, previous, target, flip) {
        if (!previous) {
            return ctx.lineTo(target.x, target.y);
        }
        ctx.bezierCurveTo(
            flip ? previous.cp1x : previous.cp2x,
            flip ? previous.cp1y : previous.cp2y,
            flip ? target.cp2x : target.cp1x,
            flip ? target.cp2y : target.cp1y,
            target.x,
            target.y
        );
    }
    function renderText(ctx, text, x, y, font, opts = {}) {
        const lines = isArray(text) ? text : [text];
        const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';
        let i, line;
        ctx.save();
        ctx.font = font.string;
        setRenderOpts(ctx, opts);
        for (i = 0; i < lines.length; ++i) {
            line = lines[i];
            if (stroke) {
                if (opts.strokeColor) {
                    ctx.strokeStyle = opts.strokeColor;
                }
                if (!isNullOrUndef(opts.strokeWidth)) {
                    ctx.lineWidth = opts.strokeWidth;
                }
                ctx.strokeText(line, x, y, opts.maxWidth);
            }
            ctx.fillText(line, x, y, opts.maxWidth);
            decorateText(ctx, x, y, line, opts);
            y += font.lineHeight;
        }
        ctx.restore();
    }
    function setRenderOpts(ctx, opts) {
        if (opts.translation) {
            ctx.translate(opts.translation[0], opts.translation[1]);
        }
        if (!isNullOrUndef(opts.rotation)) {
            ctx.rotate(opts.rotation);
        }
        if (opts.color) {
            ctx.fillStyle = opts.color;
        }
        if (opts.textAlign) {
            ctx.textAlign = opts.textAlign;
        }
        if (opts.textBaseline) {
            ctx.textBaseline = opts.textBaseline;
        }
    }
    function decorateText(ctx, x, y, line, opts) {
        if (opts.strikethrough || opts.underline) {
            const metrics = ctx.measureText(line);
            const left = x - metrics.actualBoundingBoxLeft;
            const right = x + metrics.actualBoundingBoxRight;
            const top = y - metrics.actualBoundingBoxAscent;
            const bottom = y + metrics.actualBoundingBoxDescent;
            const yDecoration = opts.strikethrough
                ? (top + bottom) / 2
                : bottom;
            ctx.strokeStyle = ctx.fillStyle;
            ctx.beginPath();
            ctx.lineWidth = opts.decorationWidth || 2;
            ctx.moveTo(left, yDecoration);
            ctx.lineTo(right, yDecoration);
            ctx.stroke();
        }
    }
    function addRoundedRectPath(ctx, rect) {
        const { x, y, w, h, radius: radius3 } = rect;
        ctx.arc(
            x + radius3.topLeft,
            y + radius3.topLeft,
            radius3.topLeft,
            -HALF_PI,
            PI,
            true
        );
        ctx.lineTo(x, y + h - radius3.bottomLeft);
        ctx.arc(
            x + radius3.bottomLeft,
            y + h - radius3.bottomLeft,
            radius3.bottomLeft,
            PI,
            HALF_PI,
            true
        );
        ctx.lineTo(x + w - radius3.bottomRight, y + h);
        ctx.arc(
            x + w - radius3.bottomRight,
            y + h - radius3.bottomRight,
            radius3.bottomRight,
            HALF_PI,
            0,
            true
        );
        ctx.lineTo(x + w, y + radius3.topRight);
        ctx.arc(
            x + w - radius3.topRight,
            y + radius3.topRight,
            radius3.topRight,
            0,
            -HALF_PI,
            true
        );
        ctx.lineTo(x + radius3.topLeft, y);
    }
    var LINE_HEIGHT = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
    var FONT_STYLE = new RegExp(
        /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/
    );
    function toLineHeight(value, size) {
        const matches = ('' + value).match(LINE_HEIGHT);
        if (!matches || matches[1] === 'normal') {
            return size * 1.2;
        }
        value = +matches[2];
        switch (matches[3]) {
            case 'px':
                return value;
            case '%':
                value /= 100;
                break;
        }
        return size * value;
    }
    var numberOrZero = (v) => +v || 0;
    function _readValueToProps(value, props) {
        const ret = {};
        const objProps = isObject(props);
        const keys = objProps ? Object.keys(props) : props;
        const read = isObject(value)
            ? objProps
                ? (prop) => valueOrDefault(value[prop], value[props[prop]])
                : (prop) => value[prop]
            : () => value;
        for (const prop of keys) {
            ret[prop] = numberOrZero(read(prop));
        }
        return ret;
    }
    function toTRBL(value) {
        return _readValueToProps(value, {
            top: 'y',
            right: 'x',
            bottom: 'y',
            left: 'x',
        });
    }
    function toTRBLCorners(value) {
        return _readValueToProps(value, [
            'topLeft',
            'topRight',
            'bottomLeft',
            'bottomRight',
        ]);
    }
    function toPadding(value) {
        const obj = toTRBL(value);
        obj.width = obj.left + obj.right;
        obj.height = obj.top + obj.bottom;
        return obj;
    }
    function toFont(options, fallback) {
        options = options || {};
        fallback = fallback || defaults.font;
        let size = valueOrDefault(options.size, fallback.size);
        if (typeof size === 'string') {
            size = parseInt(size, 10);
        }
        let style = valueOrDefault(options.style, fallback.style);
        if (style && !('' + style).match(FONT_STYLE)) {
            console.warn('Invalid font style specified: "' + style + '"');
            style = '';
        }
        const font = {
            family: valueOrDefault(options.family, fallback.family),
            lineHeight: toLineHeight(
                valueOrDefault(options.lineHeight, fallback.lineHeight),
                size
            ),
            size,
            style,
            weight: valueOrDefault(options.weight, fallback.weight),
            string: '',
        };
        font.string = toFontString(font);
        return font;
    }
    function resolve(inputs, context, index3, info) {
        let cacheable = true;
        let i, ilen, value;
        for (i = 0, ilen = inputs.length; i < ilen; ++i) {
            value = inputs[i];
            if (value === void 0) {
                continue;
            }
            if (context !== void 0 && typeof value === 'function') {
                value = value(context);
                cacheable = false;
            }
            if (index3 !== void 0 && isArray(value)) {
                value = value[index3 % value.length];
                cacheable = false;
            }
            if (value !== void 0) {
                if (info && !cacheable) {
                    info.cacheable = false;
                }
                return value;
            }
        }
    }
    function _addGrace(minmax, grace, beginAtZero) {
        const { min: min3, max: max3 } = minmax;
        const change = toDimension(grace, (max3 - min3) / 2);
        const keepZero = (value, add) =>
            beginAtZero && value === 0 ? 0 : value + add;
        return {
            min: keepZero(min3, -Math.abs(change)),
            max: keepZero(max3, change),
        };
    }
    function createContext(parentContext, context) {
        return Object.assign(Object.create(parentContext), context);
    }
    function _createResolver(
        scopes,
        prefixes2 = [''],
        rootScopes = scopes,
        fallback,
        getTarget = () => scopes[0]
    ) {
        if (!defined(fallback)) {
            fallback = _resolve('_fallback', scopes);
        }
        const cache = {
            [Symbol.toStringTag]: 'Object',
            _cacheable: true,
            _scopes: scopes,
            _rootScopes: rootScopes,
            _fallback: fallback,
            _getTarget: getTarget,
            override: (scope) =>
                _createResolver(
                    [scope, ...scopes],
                    prefixes2,
                    rootScopes,
                    fallback
                ),
        };
        return new Proxy(cache, {
            deleteProperty(target, prop) {
                delete target[prop];
                delete target._keys;
                delete scopes[0][prop];
                return true;
            },
            get(target, prop) {
                return _cached(target, prop, () =>
                    _resolveWithPrefixes(prop, prefixes2, scopes, target)
                );
            },
            getOwnPropertyDescriptor(target, prop) {
                return Reflect.getOwnPropertyDescriptor(
                    target._scopes[0],
                    prop
                );
            },
            getPrototypeOf() {
                return Reflect.getPrototypeOf(scopes[0]);
            },
            has(target, prop) {
                return getKeysFromAllScopes(target).includes(prop);
            },
            ownKeys(target) {
                return getKeysFromAllScopes(target);
            },
            set(target, prop, value) {
                const storage =
                    target._storage || (target._storage = getTarget());
                target[prop] = storage[prop] = value;
                delete target._keys;
                return true;
            },
        });
    }
    function _attachContext(proxy, context, subProxy, descriptorDefaults) {
        const cache = {
            _cacheable: false,
            _proxy: proxy,
            _context: context,
            _subProxy: subProxy,
            _stack: /* @__PURE__ */ new Set(),
            _descriptors: _descriptors(proxy, descriptorDefaults),
            setContext: (ctx) =>
                _attachContext(proxy, ctx, subProxy, descriptorDefaults),
            override: (scope) =>
                _attachContext(
                    proxy.override(scope),
                    context,
                    subProxy,
                    descriptorDefaults
                ),
        };
        return new Proxy(cache, {
            deleteProperty(target, prop) {
                delete target[prop];
                delete proxy[prop];
                return true;
            },
            get(target, prop, receiver) {
                return _cached(target, prop, () =>
                    _resolveWithContext(target, prop, receiver)
                );
            },
            getOwnPropertyDescriptor(target, prop) {
                return target._descriptors.allKeys
                    ? Reflect.has(proxy, prop)
                        ? { enumerable: true, configurable: true }
                        : void 0
                    : Reflect.getOwnPropertyDescriptor(proxy, prop);
            },
            getPrototypeOf() {
                return Reflect.getPrototypeOf(proxy);
            },
            has(target, prop) {
                return Reflect.has(proxy, prop);
            },
            ownKeys() {
                return Reflect.ownKeys(proxy);
            },
            set(target, prop, value) {
                proxy[prop] = value;
                delete target[prop];
                return true;
            },
        });
    }
    function _descriptors(
        proxy,
        defaults3 = { scriptable: true, indexable: true }
    ) {
        const {
            _scriptable = defaults3.scriptable,
            _indexable = defaults3.indexable,
            _allKeys = defaults3.allKeys,
        } = proxy;
        return {
            allKeys: _allKeys,
            scriptable: _scriptable,
            indexable: _indexable,
            isScriptable: isFunction(_scriptable)
                ? _scriptable
                : () => _scriptable,
            isIndexable: isFunction(_indexable) ? _indexable : () => _indexable,
        };
    }
    var readKey = (prefix, name) =>
        prefix ? prefix + _capitalize(name) : name;
    var needsSubResolver = (prop, value) =>
        isObject(value) &&
        prop !== 'adapters' &&
        (Object.getPrototypeOf(value) === null || value.constructor === Object);
    function _cached(target, prop, resolve2) {
        if (Object.prototype.hasOwnProperty.call(target, prop)) {
            return target[prop];
        }
        const value = resolve2();
        target[prop] = value;
        return value;
    }
    function _resolveWithContext(target, prop, receiver) {
        const {
            _proxy,
            _context,
            _subProxy,
            _descriptors: descriptors2,
        } = target;
        let value = _proxy[prop];
        if (isFunction(value) && descriptors2.isScriptable(prop)) {
            value = _resolveScriptable(prop, value, target, receiver);
        }
        if (isArray(value) && value.length) {
            value = _resolveArray(
                prop,
                value,
                target,
                descriptors2.isIndexable
            );
        }
        if (needsSubResolver(prop, value)) {
            value = _attachContext(
                value,
                _context,
                _subProxy && _subProxy[prop],
                descriptors2
            );
        }
        return value;
    }
    function _resolveScriptable(prop, value, target, receiver) {
        const { _proxy, _context, _subProxy, _stack } = target;
        if (_stack.has(prop)) {
            throw new Error(
                'Recursion detected: ' +
                    Array.from(_stack).join('->') +
                    '->' +
                    prop
            );
        }
        _stack.add(prop);
        value = value(_context, _subProxy || receiver);
        _stack.delete(prop);
        if (needsSubResolver(prop, value)) {
            value = createSubResolver(_proxy._scopes, _proxy, prop, value);
        }
        return value;
    }
    function _resolveArray(prop, value, target, isIndexable) {
        const {
            _proxy,
            _context,
            _subProxy,
            _descriptors: descriptors2,
        } = target;
        if (defined(_context.index) && isIndexable(prop)) {
            value = value[_context.index % value.length];
        } else if (isObject(value[0])) {
            const arr = value;
            const scopes = _proxy._scopes.filter((s) => s !== arr);
            value = [];
            for (const item of arr) {
                const resolver = createSubResolver(scopes, _proxy, prop, item);
                value.push(
                    _attachContext(
                        resolver,
                        _context,
                        _subProxy && _subProxy[prop],
                        descriptors2
                    )
                );
            }
        }
        return value;
    }
    function resolveFallback(fallback, prop, value) {
        return isFunction(fallback) ? fallback(prop, value) : fallback;
    }
    var getScope = (key, parent) =>
        key === true
            ? parent
            : typeof key === 'string'
            ? resolveObjectKey(parent, key)
            : void 0;
    function addScopes(set4, parentScopes, key, parentFallback, value) {
        for (const parent of parentScopes) {
            const scope = getScope(key, parent);
            if (scope) {
                set4.add(scope);
                const fallback = resolveFallback(scope._fallback, key, value);
                if (
                    defined(fallback) &&
                    fallback !== key &&
                    fallback !== parentFallback
                ) {
                    return fallback;
                }
            } else if (
                scope === false &&
                defined(parentFallback) &&
                key !== parentFallback
            ) {
                return null;
            }
        }
        return false;
    }
    function createSubResolver(parentScopes, resolver, prop, value) {
        const rootScopes = resolver._rootScopes;
        const fallback = resolveFallback(resolver._fallback, prop, value);
        const allScopes = [...parentScopes, ...rootScopes];
        const set4 = /* @__PURE__ */ new Set();
        set4.add(value);
        let key = addScopesFromKey(
            set4,
            allScopes,
            prop,
            fallback || prop,
            value
        );
        if (key === null) {
            return false;
        }
        if (defined(fallback) && fallback !== prop) {
            key = addScopesFromKey(set4, allScopes, fallback, key, value);
            if (key === null) {
                return false;
            }
        }
        return _createResolver(
            Array.from(set4),
            [''],
            rootScopes,
            fallback,
            () => subGetTarget(resolver, prop, value)
        );
    }
    function addScopesFromKey(set4, allScopes, key, fallback, item) {
        while (key) {
            key = addScopes(set4, allScopes, key, fallback, item);
        }
        return key;
    }
    function subGetTarget(resolver, prop, value) {
        const parent = resolver._getTarget();
        if (!(prop in parent)) {
            parent[prop] = {};
        }
        const target = parent[prop];
        if (isArray(target) && isObject(value)) {
            return value;
        }
        return target;
    }
    function _resolveWithPrefixes(prop, prefixes2, scopes, proxy) {
        let value;
        for (const prefix of prefixes2) {
            value = _resolve(readKey(prefix, prop), scopes);
            if (defined(value)) {
                return needsSubResolver(prop, value)
                    ? createSubResolver(scopes, proxy, prop, value)
                    : value;
            }
        }
    }
    function _resolve(key, scopes) {
        for (const scope of scopes) {
            if (!scope) {
                continue;
            }
            const value = scope[key];
            if (defined(value)) {
                return value;
            }
        }
    }
    function getKeysFromAllScopes(target) {
        let keys = target._keys;
        if (!keys) {
            keys = target._keys = resolveKeysFromAllScopes(target._scopes);
        }
        return keys;
    }
    function resolveKeysFromAllScopes(scopes) {
        const set4 = /* @__PURE__ */ new Set();
        for (const scope of scopes) {
            for (const key of Object.keys(scope).filter(
                (k) => !k.startsWith('_')
            )) {
                set4.add(key);
            }
        }
        return Array.from(set4);
    }
    function _parseObjectDataRadialScale(meta, data, start2, count) {
        const { iScale } = meta;
        const { key = 'r' } = this._parsing;
        const parsed = new Array(count);
        let i, ilen, index3, item;
        for (i = 0, ilen = count; i < ilen; ++i) {
            index3 = i + start2;
            item = data[index3];
            parsed[i] = {
                r: iScale.parse(resolveObjectKey(item, key), index3),
            };
        }
        return parsed;
    }
    var EPSILON = Number.EPSILON || 1e-14;
    var getPoint = (points, i) =>
        i < points.length && !points[i].skip && points[i];
    var getValueAxis = (indexAxis) => (indexAxis === 'x' ? 'y' : 'x');
    function splineCurve(firstPoint, middlePoint, afterPoint, t) {
        const previous = firstPoint.skip ? middlePoint : firstPoint;
        const current = middlePoint;
        const next = afterPoint.skip ? middlePoint : afterPoint;
        const d01 = distanceBetweenPoints(current, previous);
        const d12 = distanceBetweenPoints(next, current);
        let s01 = d01 / (d01 + d12);
        let s12 = d12 / (d01 + d12);
        s01 = isNaN(s01) ? 0 : s01;
        s12 = isNaN(s12) ? 0 : s12;
        const fa = t * s01;
        const fb = t * s12;
        return {
            previous: {
                x: current.x - fa * (next.x - previous.x),
                y: current.y - fa * (next.y - previous.y),
            },
            next: {
                x: current.x + fb * (next.x - previous.x),
                y: current.y + fb * (next.y - previous.y),
            },
        };
    }
    function monotoneAdjust(points, deltaK, mK) {
        const pointsLen = points.length;
        let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
        let pointAfter = getPoint(points, 0);
        for (let i = 0; i < pointsLen - 1; ++i) {
            pointCurrent = pointAfter;
            pointAfter = getPoint(points, i + 1);
            if (!pointCurrent || !pointAfter) {
                continue;
            }
            if (almostEquals(deltaK[i], 0, EPSILON)) {
                mK[i] = mK[i + 1] = 0;
                continue;
            }
            alphaK = mK[i] / deltaK[i];
            betaK = mK[i + 1] / deltaK[i];
            squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
            if (squaredMagnitude <= 9) {
                continue;
            }
            tauK = 3 / Math.sqrt(squaredMagnitude);
            mK[i] = alphaK * tauK * deltaK[i];
            mK[i + 1] = betaK * tauK * deltaK[i];
        }
    }
    function monotoneCompute(points, mK, indexAxis = 'x') {
        const valueAxis = getValueAxis(indexAxis);
        const pointsLen = points.length;
        let delta, pointBefore, pointCurrent;
        let pointAfter = getPoint(points, 0);
        for (let i = 0; i < pointsLen; ++i) {
            pointBefore = pointCurrent;
            pointCurrent = pointAfter;
            pointAfter = getPoint(points, i + 1);
            if (!pointCurrent) {
                continue;
            }
            const iPixel = pointCurrent[indexAxis];
            const vPixel = pointCurrent[valueAxis];
            if (pointBefore) {
                delta = (iPixel - pointBefore[indexAxis]) / 3;
                pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
                pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
            }
            if (pointAfter) {
                delta = (pointAfter[indexAxis] - iPixel) / 3;
                pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
                pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
            }
        }
    }
    function splineCurveMonotone(points, indexAxis = 'x') {
        const valueAxis = getValueAxis(indexAxis);
        const pointsLen = points.length;
        const deltaK = Array(pointsLen).fill(0);
        const mK = Array(pointsLen);
        let i, pointBefore, pointCurrent;
        let pointAfter = getPoint(points, 0);
        for (i = 0; i < pointsLen; ++i) {
            pointBefore = pointCurrent;
            pointCurrent = pointAfter;
            pointAfter = getPoint(points, i + 1);
            if (!pointCurrent) {
                continue;
            }
            if (pointAfter) {
                const slopeDelta =
                    pointAfter[indexAxis] - pointCurrent[indexAxis];
                deltaK[i] =
                    slopeDelta !== 0
                        ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) /
                          slopeDelta
                        : 0;
            }
            mK[i] = !pointBefore
                ? deltaK[i]
                : !pointAfter
                ? deltaK[i - 1]
                : sign(deltaK[i - 1]) !== sign(deltaK[i])
                ? 0
                : (deltaK[i - 1] + deltaK[i]) / 2;
        }
        monotoneAdjust(points, deltaK, mK);
        monotoneCompute(points, mK, indexAxis);
    }
    function capControlPoint(pt, min3, max3) {
        return Math.max(Math.min(pt, max3), min3);
    }
    function capBezierPoints(points, area) {
        let i, ilen, point, inArea, inAreaPrev;
        let inAreaNext = _isPointInArea(points[0], area);
        for (i = 0, ilen = points.length; i < ilen; ++i) {
            inAreaPrev = inArea;
            inArea = inAreaNext;
            inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
            if (!inArea) {
                continue;
            }
            point = points[i];
            if (inAreaPrev) {
                point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
                point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
            }
            if (inAreaNext) {
                point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
                point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
            }
        }
    }
    function _updateBezierControlPoints(
        points,
        options,
        area,
        loop,
        indexAxis
    ) {
        let i, ilen, point, controlPoints;
        if (options.spanGaps) {
            points = points.filter((pt) => !pt.skip);
        }
        if (options.cubicInterpolationMode === 'monotone') {
            splineCurveMonotone(points, indexAxis);
        } else {
            let prev = loop ? points[points.length - 1] : points[0];
            for (i = 0, ilen = points.length; i < ilen; ++i) {
                point = points[i];
                controlPoints = splineCurve(
                    prev,
                    point,
                    points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],
                    options.tension
                );
                point.cp1x = controlPoints.previous.x;
                point.cp1y = controlPoints.previous.y;
                point.cp2x = controlPoints.next.x;
                point.cp2y = controlPoints.next.y;
                prev = point;
            }
        }
        if (options.capBezierPoints) {
            capBezierPoints(points, area);
        }
    }
    function _isDomSupported() {
        return typeof window !== 'undefined' && typeof document !== 'undefined';
    }
    function _getParentNode(domNode) {
        let parent = domNode.parentNode;
        if (parent && parent.toString() === '[object ShadowRoot]') {
            parent = parent.host;
        }
        return parent;
    }
    function parseMaxStyle(styleValue2, node, parentProperty) {
        let valueInPixels;
        if (typeof styleValue2 === 'string') {
            valueInPixels = parseInt(styleValue2, 10);
            if (styleValue2.indexOf('%') !== -1) {
                valueInPixels =
                    (valueInPixels / 100) * node.parentNode[parentProperty];
            }
        } else {
            valueInPixels = styleValue2;
        }
        return valueInPixels;
    }
    var getComputedStyle = (element) => window.getComputedStyle(element, null);
    function getStyle(el, property) {
        return getComputedStyle(el).getPropertyValue(property);
    }
    var positions = ['top', 'right', 'bottom', 'left'];
    function getPositionedStyle(styles, style, suffix) {
        const result = {};
        suffix = suffix ? '-' + suffix : '';
        for (let i = 0; i < 4; i++) {
            const pos = positions[i];
            result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;
        }
        result.width = result.left + result.right;
        result.height = result.top + result.bottom;
        return result;
    }
    var useOffsetPos = (x, y, target) =>
        (x > 0 || y > 0) && (!target || !target.shadowRoot);
    function getCanvasPosition(e, canvas) {
        const touches = e.touches;
        const source = touches && touches.length ? touches[0] : e;
        const { offsetX, offsetY } = source;
        let box = false;
        let x, y;
        if (useOffsetPos(offsetX, offsetY, e.target)) {
            x = offsetX;
            y = offsetY;
        } else {
            const rect = canvas.getBoundingClientRect();
            x = source.clientX - rect.left;
            y = source.clientY - rect.top;
            box = true;
        }
        return { x, y, box };
    }
    function getRelativePosition(evt, chart) {
        if ('native' in evt) {
            return evt;
        }
        const { canvas, currentDevicePixelRatio } = chart;
        const style = getComputedStyle(canvas);
        const borderBox = style.boxSizing === 'border-box';
        const paddings = getPositionedStyle(style, 'padding');
        const borders = getPositionedStyle(style, 'border', 'width');
        const { x, y, box } = getCanvasPosition(evt, canvas);
        const xOffset = paddings.left + (box && borders.left);
        const yOffset = paddings.top + (box && borders.top);
        let { width, height } = chart;
        if (borderBox) {
            width -= paddings.width + borders.width;
            height -= paddings.height + borders.height;
        }
        return {
            x: Math.round(
                (((x - xOffset) / width) * canvas.width) /
                    currentDevicePixelRatio
            ),
            y: Math.round(
                (((y - yOffset) / height) * canvas.height) /
                    currentDevicePixelRatio
            ),
        };
    }
    function getContainerSize(canvas, width, height) {
        let maxWidth, maxHeight;
        if (width === void 0 || height === void 0) {
            const container = _getParentNode(canvas);
            if (!container) {
                width = canvas.clientWidth;
                height = canvas.clientHeight;
            } else {
                const rect = container.getBoundingClientRect();
                const containerStyle = getComputedStyle(container);
                const containerBorder = getPositionedStyle(
                    containerStyle,
                    'border',
                    'width'
                );
                const containerPadding = getPositionedStyle(
                    containerStyle,
                    'padding'
                );
                width =
                    rect.width - containerPadding.width - containerBorder.width;
                height =
                    rect.height -
                    containerPadding.height -
                    containerBorder.height;
                maxWidth = parseMaxStyle(
                    containerStyle.maxWidth,
                    container,
                    'clientWidth'
                );
                maxHeight = parseMaxStyle(
                    containerStyle.maxHeight,
                    container,
                    'clientHeight'
                );
            }
        }
        return {
            width,
            height,
            maxWidth: maxWidth || INFINITY,
            maxHeight: maxHeight || INFINITY,
        };
    }
    var round1 = (v) => Math.round(v * 10) / 10;
    function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
        const style = getComputedStyle(canvas);
        const margins = getPositionedStyle(style, 'margin');
        const maxWidth =
            parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;
        const maxHeight =
            parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;
        const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
        let { width, height } = containerSize;
        if (style.boxSizing === 'content-box') {
            const borders = getPositionedStyle(style, 'border', 'width');
            const paddings = getPositionedStyle(style, 'padding');
            width -= paddings.width + borders.width;
            height -= paddings.height + borders.height;
        }
        width = Math.max(0, width - margins.width);
        height = Math.max(
            0,
            aspectRatio
                ? Math.floor(width / aspectRatio)
                : height - margins.height
        );
        width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
        height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
        if (width && !height) {
            height = round1(width / 2);
        }
        return {
            width,
            height,
        };
    }
    function retinaScale(chart, forceRatio, forceStyle) {
        const pixelRatio = forceRatio || 1;
        const deviceHeight = Math.floor(chart.height * pixelRatio);
        const deviceWidth = Math.floor(chart.width * pixelRatio);
        chart.height = deviceHeight / pixelRatio;
        chart.width = deviceWidth / pixelRatio;
        const canvas = chart.canvas;
        if (
            canvas.style &&
            (forceStyle || (!canvas.style.height && !canvas.style.width))
        ) {
            canvas.style.height = `${chart.height}px`;
            canvas.style.width = `${chart.width}px`;
        }
        if (
            chart.currentDevicePixelRatio !== pixelRatio ||
            canvas.height !== deviceHeight ||
            canvas.width !== deviceWidth
        ) {
            chart.currentDevicePixelRatio = pixelRatio;
            canvas.height = deviceHeight;
            canvas.width = deviceWidth;
            chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
            return true;
        }
        return false;
    }
    var supportsEventListenerOptions = (function () {
        let passiveSupported = false;
        try {
            const options = {
                get passive() {
                    passiveSupported = true;
                    return false;
                },
            };
            window.addEventListener('test', null, options);
            window.removeEventListener('test', null, options);
        } catch (e) {}
        return passiveSupported;
    })();
    function readUsedSize(element, property) {
        const value = getStyle(element, property);
        const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
        return matches ? +matches[1] : void 0;
    }
    function _pointInLine(p1, p2, t, mode) {
        return {
            x: p1.x + t * (p2.x - p1.x),
            y: p1.y + t * (p2.y - p1.y),
        };
    }
    function _steppedInterpolation(p1, p2, t, mode) {
        return {
            x: p1.x + t * (p2.x - p1.x),
            y:
                mode === 'middle'
                    ? t < 0.5
                        ? p1.y
                        : p2.y
                    : mode === 'after'
                    ? t < 1
                        ? p1.y
                        : p2.y
                    : t > 0
                    ? p2.y
                    : p1.y,
        };
    }
    function _bezierInterpolation(p1, p2, t, mode) {
        const cp1 = { x: p1.cp2x, y: p1.cp2y };
        const cp2 = { x: p2.cp1x, y: p2.cp1y };
        const a = _pointInLine(p1, cp1, t);
        const b = _pointInLine(cp1, cp2, t);
        const c = _pointInLine(cp2, p2, t);
        const d = _pointInLine(a, b, t);
        const e = _pointInLine(b, c, t);
        return _pointInLine(d, e, t);
    }
    var intlCache = /* @__PURE__ */ new Map();
    function getNumberFormat(locale2, options) {
        options = options || {};
        const cacheKey = locale2 + JSON.stringify(options);
        let formatter2 = intlCache.get(cacheKey);
        if (!formatter2) {
            formatter2 = new Intl.NumberFormat(locale2, options);
            intlCache.set(cacheKey, formatter2);
        }
        return formatter2;
    }
    function formatNumber(num, locale2, options) {
        return getNumberFormat(locale2, options).format(num);
    }
    var getRightToLeftAdapter = function (rectX, width) {
        return {
            x(x) {
                return rectX + rectX + width - x;
            },
            setWidth(w) {
                width = w;
            },
            textAlign(align) {
                if (align === 'center') {
                    return align;
                }
                return align === 'right' ? 'left' : 'right';
            },
            xPlus(x, value) {
                return x - value;
            },
            leftForLtr(x, itemWidth) {
                return x - itemWidth;
            },
        };
    };
    var getLeftToRightAdapter = function () {
        return {
            x(x) {
                return x;
            },
            setWidth(w) {},
            textAlign(align) {
                return align;
            },
            xPlus(x, value) {
                return x + value;
            },
            leftForLtr(x, _itemWidth) {
                return x;
            },
        };
    };
    function getRtlAdapter(rtl, rectX, width) {
        return rtl
            ? getRightToLeftAdapter(rectX, width)
            : getLeftToRightAdapter();
    }
    function overrideTextDirection(ctx, direction) {
        let style, original;
        if (direction === 'ltr' || direction === 'rtl') {
            style = ctx.canvas.style;
            original = [
                style.getPropertyValue('direction'),
                style.getPropertyPriority('direction'),
            ];
            style.setProperty('direction', direction, 'important');
            ctx.prevTextDirection = original;
        }
    }
    function restoreTextDirection(ctx, original) {
        if (original !== void 0) {
            delete ctx.prevTextDirection;
            ctx.canvas.style.setProperty('direction', original[0], original[1]);
        }
    }
    function propertyFn(property) {
        if (property === 'angle') {
            return {
                between: _angleBetween,
                compare: _angleDiff,
                normalize: _normalizeAngle,
            };
        }
        return {
            between: _isBetween,
            compare: (a, b) => a - b,
            normalize: (x) => x,
        };
    }
    function normalizeSegment({ start: start2, end, count, loop, style }) {
        return {
            start: start2 % count,
            end: end % count,
            loop: loop && (end - start2 + 1) % count === 0,
            style,
        };
    }
    function getSegment(segment, points, bounds) {
        const { property, start: startBound, end: endBound } = bounds;
        const { between, normalize } = propertyFn(property);
        const count = points.length;
        let { start: start2, end, loop } = segment;
        let i, ilen;
        if (loop) {
            start2 += count;
            end += count;
            for (i = 0, ilen = count; i < ilen; ++i) {
                if (
                    !between(
                        normalize(points[start2 % count][property]),
                        startBound,
                        endBound
                    )
                ) {
                    break;
                }
                start2--;
                end--;
            }
            start2 %= count;
            end %= count;
        }
        if (end < start2) {
            end += count;
        }
        return { start: start2, end, loop, style: segment.style };
    }
    function _boundSegment(segment, points, bounds) {
        if (!bounds) {
            return [segment];
        }
        const { property, start: startBound, end: endBound } = bounds;
        const count = points.length;
        const { compare, between, normalize } = propertyFn(property);
        const {
            start: start2,
            end,
            loop,
            style,
        } = getSegment(segment, points, bounds);
        const result = [];
        let inside = false;
        let subStart = null;
        let value, point, prevValue;
        const startIsBefore = () =>
            between(startBound, prevValue, value) &&
            compare(startBound, prevValue) !== 0;
        const endIsBefore = () =>
            compare(endBound, value) === 0 ||
            between(endBound, prevValue, value);
        const shouldStart = () => inside || startIsBefore();
        const shouldStop = () => !inside || endIsBefore();
        for (let i = start2, prev = start2; i <= end; ++i) {
            point = points[i % count];
            if (point.skip) {
                continue;
            }
            value = normalize(point[property]);
            if (value === prevValue) {
                continue;
            }
            inside = between(value, startBound, endBound);
            if (subStart === null && shouldStart()) {
                subStart = compare(value, startBound) === 0 ? i : prev;
            }
            if (subStart !== null && shouldStop()) {
                result.push(
                    normalizeSegment({
                        start: subStart,
                        end: i,
                        loop,
                        count,
                        style,
                    })
                );
                subStart = null;
            }
            prev = i;
            prevValue = value;
        }
        if (subStart !== null) {
            result.push(
                normalizeSegment({ start: subStart, end, loop, count, style })
            );
        }
        return result;
    }
    function _boundSegments(line, bounds) {
        const result = [];
        const segments = line.segments;
        for (let i = 0; i < segments.length; i++) {
            const sub = _boundSegment(segments[i], line.points, bounds);
            if (sub.length) {
                result.push(...sub);
            }
        }
        return result;
    }
    function findStartAndEnd(points, count, loop, spanGaps) {
        let start2 = 0;
        let end = count - 1;
        if (loop && !spanGaps) {
            while (start2 < count && !points[start2].skip) {
                start2++;
            }
        }
        while (start2 < count && points[start2].skip) {
            start2++;
        }
        start2 %= count;
        if (loop) {
            end += start2;
        }
        while (end > start2 && points[end % count].skip) {
            end--;
        }
        end %= count;
        return { start: start2, end };
    }
    function solidSegments(points, start2, max3, loop) {
        const count = points.length;
        const result = [];
        let last = start2;
        let prev = points[start2];
        let end;
        for (end = start2 + 1; end <= max3; ++end) {
            const cur = points[end % count];
            if (cur.skip || cur.stop) {
                if (!prev.skip) {
                    loop = false;
                    result.push({
                        start: start2 % count,
                        end: (end - 1) % count,
                        loop,
                    });
                    start2 = last = cur.stop ? end : null;
                }
            } else {
                last = end;
                if (prev.skip) {
                    start2 = end;
                }
            }
            prev = cur;
        }
        if (last !== null) {
            result.push({ start: start2 % count, end: last % count, loop });
        }
        return result;
    }
    function _computeSegments(line, segmentOptions) {
        const points = line.points;
        const spanGaps = line.options.spanGaps;
        const count = points.length;
        if (!count) {
            return [];
        }
        const loop = !!line._loop;
        const { start: start2, end } = findStartAndEnd(
            points,
            count,
            loop,
            spanGaps
        );
        if (spanGaps === true) {
            return splitByStyles(
                line,
                [{ start: start2, end, loop }],
                points,
                segmentOptions
            );
        }
        const max3 = end < start2 ? end + count : end;
        const completeLoop =
            !!line._fullLoop && start2 === 0 && end === count - 1;
        return splitByStyles(
            line,
            solidSegments(points, start2, max3, completeLoop),
            points,
            segmentOptions
        );
    }
    function splitByStyles(line, segments, points, segmentOptions) {
        if (!segmentOptions || !segmentOptions.setContext || !points) {
            return segments;
        }
        return doSplitByStyles(line, segments, points, segmentOptions);
    }
    function doSplitByStyles(line, segments, points, segmentOptions) {
        const chartContext = line._chart.getContext();
        const baseStyle = readStyle(line.options);
        const {
            _datasetIndex: datasetIndex,
            options: { spanGaps },
        } = line;
        const count = points.length;
        const result = [];
        let prevStyle = baseStyle;
        let start2 = segments[0].start;
        let i = start2;
        function addStyle(s, e, l, st) {
            const dir = spanGaps ? -1 : 1;
            if (s === e) {
                return;
            }
            s += count;
            while (points[s % count].skip) {
                s -= dir;
            }
            while (points[e % count].skip) {
                e += dir;
            }
            if (s % count !== e % count) {
                result.push({
                    start: s % count,
                    end: e % count,
                    loop: l,
                    style: st,
                });
                prevStyle = st;
                start2 = e % count;
            }
        }
        for (const segment of segments) {
            start2 = spanGaps ? start2 : segment.start;
            let prev = points[start2 % count];
            let style;
            for (i = start2 + 1; i <= segment.end; i++) {
                const pt = points[i % count];
                style = readStyle(
                    segmentOptions.setContext(
                        createContext(chartContext, {
                            type: 'segment',
                            p0: prev,
                            p1: pt,
                            p0DataIndex: (i - 1) % count,
                            p1DataIndex: i % count,
                            datasetIndex,
                        })
                    )
                );
                if (styleChanged(style, prevStyle)) {
                    addStyle(start2, i - 1, segment.loop, prevStyle);
                }
                prev = pt;
                prevStyle = style;
            }
            if (start2 < i - 1) {
                addStyle(start2, i - 1, segment.loop, prevStyle);
            }
        }
        return result;
    }
    function readStyle(options) {
        return {
            backgroundColor: options.backgroundColor,
            borderCapStyle: options.borderCapStyle,
            borderDash: options.borderDash,
            borderDashOffset: options.borderDashOffset,
            borderJoinStyle: options.borderJoinStyle,
            borderWidth: options.borderWidth,
            borderColor: options.borderColor,
        };
    }
    function styleChanged(style, prevStyle) {
        return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
    }

    // node_modules/chart.js/dist/chart.mjs
    var Animator = class {
        constructor() {
            this._request = null;
            this._charts = /* @__PURE__ */ new Map();
            this._running = false;
            this._lastDate = void 0;
        }
        _notify(chart, anims, date, type2) {
            const callbacks = anims.listeners[type2];
            const numSteps = anims.duration;
            callbacks.forEach((fn) =>
                fn({
                    chart,
                    initial: anims.initial,
                    numSteps,
                    currentStep: Math.min(date - anims.start, numSteps),
                })
            );
        }
        _refresh() {
            if (this._request) {
                return;
            }
            this._running = true;
            this._request = requestAnimFrame.call(window, () => {
                this._update();
                this._request = null;
                if (this._running) {
                    this._refresh();
                }
            });
        }
        _update(date = Date.now()) {
            let remaining = 0;
            this._charts.forEach((anims, chart) => {
                if (!anims.running || !anims.items.length) {
                    return;
                }
                const items = anims.items;
                let i = items.length - 1;
                let draw3 = false;
                let item;
                for (; i >= 0; --i) {
                    item = items[i];
                    if (item._active) {
                        if (item._total > anims.duration) {
                            anims.duration = item._total;
                        }
                        item.tick(date);
                        draw3 = true;
                    } else {
                        items[i] = items[items.length - 1];
                        items.pop();
                    }
                }
                if (draw3) {
                    chart.draw();
                    this._notify(chart, anims, date, 'progress');
                }
                if (!items.length) {
                    anims.running = false;
                    this._notify(chart, anims, date, 'complete');
                    anims.initial = false;
                }
                remaining += items.length;
            });
            this._lastDate = date;
            if (remaining === 0) {
                this._running = false;
            }
        }
        _getAnims(chart) {
            const charts = this._charts;
            let anims = charts.get(chart);
            if (!anims) {
                anims = {
                    running: false,
                    initial: true,
                    items: [],
                    listeners: {
                        complete: [],
                        progress: [],
                    },
                };
                charts.set(chart, anims);
            }
            return anims;
        }
        listen(chart, event, cb) {
            this._getAnims(chart).listeners[event].push(cb);
        }
        add(chart, items) {
            if (!items || !items.length) {
                return;
            }
            this._getAnims(chart).items.push(...items);
        }
        has(chart) {
            return this._getAnims(chart).items.length > 0;
        }
        start(chart) {
            const anims = this._charts.get(chart);
            if (!anims) {
                return;
            }
            anims.running = true;
            anims.start = Date.now();
            anims.duration = anims.items.reduce(
                (acc, cur) => Math.max(acc, cur._duration),
                0
            );
            this._refresh();
        }
        running(chart) {
            if (!this._running) {
                return false;
            }
            const anims = this._charts.get(chart);
            if (!anims || !anims.running || !anims.items.length) {
                return false;
            }
            return true;
        }
        stop(chart) {
            const anims = this._charts.get(chart);
            if (!anims || !anims.items.length) {
                return;
            }
            const items = anims.items;
            let i = items.length - 1;
            for (; i >= 0; --i) {
                items[i].cancel();
            }
            anims.items = [];
            this._notify(chart, anims, Date.now(), 'complete');
        }
        remove(chart) {
            return this._charts.delete(chart);
        }
    };
    var animator = new Animator();
    var transparent = 'transparent';
    var interpolators = {
        boolean(from2, to2, factor) {
            return factor > 0.5 ? to2 : from2;
        },
        color(from2, to2, factor) {
            const c0 = color(from2 || transparent);
            const c1 = c0.valid && color(to2 || transparent);
            return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
        },
        number(from2, to2, factor) {
            return from2 + (to2 - from2) * factor;
        },
    };
    var Animation = class {
        constructor(cfg, target, prop, to2) {
            const currentValue = target[prop];
            to2 = resolve([cfg.to, to2, currentValue, cfg.from]);
            const from2 = resolve([cfg.from, currentValue, to2]);
            this._active = true;
            this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
            this._easing = effects[cfg.easing] || effects.linear;
            this._start = Math.floor(Date.now() + (cfg.delay || 0));
            this._duration = this._total = Math.floor(cfg.duration);
            this._loop = !!cfg.loop;
            this._target = target;
            this._prop = prop;
            this._from = from2;
            this._to = to2;
            this._promises = void 0;
        }
        active() {
            return this._active;
        }
        update(cfg, to2, date) {
            if (this._active) {
                this._notify(false);
                const currentValue = this._target[this._prop];
                const elapsed = date - this._start;
                const remain = this._duration - elapsed;
                this._start = date;
                this._duration = Math.floor(Math.max(remain, cfg.duration));
                this._total += elapsed;
                this._loop = !!cfg.loop;
                this._to = resolve([cfg.to, to2, currentValue, cfg.from]);
                this._from = resolve([cfg.from, currentValue, to2]);
            }
        }
        cancel() {
            if (this._active) {
                this.tick(Date.now());
                this._active = false;
                this._notify(false);
            }
        }
        tick(date) {
            const elapsed = date - this._start;
            const duration = this._duration;
            const prop = this._prop;
            const from2 = this._from;
            const loop = this._loop;
            const to2 = this._to;
            let factor;
            this._active = from2 !== to2 && (loop || elapsed < duration);
            if (!this._active) {
                this._target[prop] = to2;
                this._notify(true);
                return;
            }
            if (elapsed < 0) {
                this._target[prop] = from2;
                return;
            }
            factor = (elapsed / duration) % 2;
            factor = loop && factor > 1 ? 2 - factor : factor;
            factor = this._easing(Math.min(1, Math.max(0, factor)));
            this._target[prop] = this._fn(from2, to2, factor);
        }
        wait() {
            const promises = this._promises || (this._promises = []);
            return new Promise((res, rej) => {
                promises.push({ res, rej });
            });
        }
        _notify(resolved) {
            const method = resolved ? 'res' : 'rej';
            const promises = this._promises || [];
            for (let i = 0; i < promises.length; i++) {
                promises[i][method]();
            }
        }
    };
    var numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];
    var colors = ['color', 'borderColor', 'backgroundColor'];
    defaults.set('animation', {
        delay: void 0,
        duration: 1e3,
        easing: 'easeOutQuart',
        fn: void 0,
        from: void 0,
        loop: void 0,
        to: void 0,
        type: void 0,
    });
    var animationOptions = Object.keys(defaults.animation);
    defaults.describe('animation', {
        _fallback: false,
        _indexable: false,
        _scriptable: (name) =>
            name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',
    });
    defaults.set('animations', {
        colors: {
            type: 'color',
            properties: colors,
        },
        numbers: {
            type: 'number',
            properties: numbers,
        },
    });
    defaults.describe('animations', {
        _fallback: 'animation',
    });
    defaults.set('transitions', {
        active: {
            animation: {
                duration: 400,
            },
        },
        resize: {
            animation: {
                duration: 0,
            },
        },
        show: {
            animations: {
                colors: {
                    from: 'transparent',
                },
                visible: {
                    type: 'boolean',
                    duration: 0,
                },
            },
        },
        hide: {
            animations: {
                colors: {
                    to: 'transparent',
                },
                visible: {
                    type: 'boolean',
                    easing: 'linear',
                    fn: (v) => v | 0,
                },
            },
        },
    });
    var Animations = class {
        constructor(chart, config) {
            this._chart = chart;
            this._properties = /* @__PURE__ */ new Map();
            this.configure(config);
        }
        configure(config) {
            if (!isObject(config)) {
                return;
            }
            const animatedProps = this._properties;
            Object.getOwnPropertyNames(config).forEach((key) => {
                const cfg = config[key];
                if (!isObject(cfg)) {
                    return;
                }
                const resolved = {};
                for (const option of animationOptions) {
                    resolved[option] = cfg[option];
                }
                ((isArray(cfg.properties) && cfg.properties) || [key]).forEach(
                    (prop) => {
                        if (prop === key || !animatedProps.has(prop)) {
                            animatedProps.set(prop, resolved);
                        }
                    }
                );
            });
        }
        _animateOptions(target, values) {
            const newOptions = values.options;
            const options = resolveTargetOptions(target, newOptions);
            if (!options) {
                return [];
            }
            const animations = this._createAnimations(options, newOptions);
            if (newOptions.$shared) {
                awaitAll(target.options.$animations, newOptions).then(
                    () => {
                        target.options = newOptions;
                    },
                    () => {}
                );
            }
            return animations;
        }
        _createAnimations(target, values) {
            const animatedProps = this._properties;
            const animations = [];
            const running = target.$animations || (target.$animations = {});
            const props = Object.keys(values);
            const date = Date.now();
            let i;
            for (i = props.length - 1; i >= 0; --i) {
                const prop = props[i];
                if (prop.charAt(0) === '$') {
                    continue;
                }
                if (prop === 'options') {
                    animations.push(...this._animateOptions(target, values));
                    continue;
                }
                const value = values[prop];
                let animation = running[prop];
                const cfg = animatedProps.get(prop);
                if (animation) {
                    if (cfg && animation.active()) {
                        animation.update(cfg, value, date);
                        continue;
                    } else {
                        animation.cancel();
                    }
                }
                if (!cfg || !cfg.duration) {
                    target[prop] = value;
                    continue;
                }
                running[prop] = animation = new Animation(
                    cfg,
                    target,
                    prop,
                    value
                );
                animations.push(animation);
            }
            return animations;
        }
        update(target, values) {
            if (this._properties.size === 0) {
                Object.assign(target, values);
                return;
            }
            const animations = this._createAnimations(target, values);
            if (animations.length) {
                animator.add(this._chart, animations);
                return true;
            }
        }
    };
    function awaitAll(animations, properties) {
        const running = [];
        const keys = Object.keys(properties);
        for (let i = 0; i < keys.length; i++) {
            const anim = animations[keys[i]];
            if (anim && anim.active()) {
                running.push(anim.wait());
            }
        }
        return Promise.all(running);
    }
    function resolveTargetOptions(target, newOptions) {
        if (!newOptions) {
            return;
        }
        let options = target.options;
        if (!options) {
            target.options = newOptions;
            return;
        }
        if (options.$shared) {
            target.options = options = Object.assign({}, options, {
                $shared: false,
                $animations: {},
            });
        }
        return options;
    }
    function scaleClip(scale, allowedOverflow) {
        const opts = (scale && scale.options) || {};
        const reverse = opts.reverse;
        const min3 = opts.min === void 0 ? allowedOverflow : 0;
        const max3 = opts.max === void 0 ? allowedOverflow : 0;
        return {
            start: reverse ? max3 : min3,
            end: reverse ? min3 : max3,
        };
    }
    function defaultClip(xScale, yScale, allowedOverflow) {
        if (allowedOverflow === false) {
            return false;
        }
        const x = scaleClip(xScale, allowedOverflow);
        const y = scaleClip(yScale, allowedOverflow);
        return {
            top: y.end,
            right: x.end,
            bottom: y.start,
            left: x.start,
        };
    }
    function toClip(value) {
        let t, r, b, l;
        if (isObject(value)) {
            t = value.top;
            r = value.right;
            b = value.bottom;
            l = value.left;
        } else {
            t = r = b = l = value;
        }
        return {
            top: t,
            right: r,
            bottom: b,
            left: l,
            disabled: value === false,
        };
    }
    function getSortedDatasetIndices(chart, filterVisible) {
        const keys = [];
        const metasets = chart._getSortedDatasetMetas(filterVisible);
        let i, ilen;
        for (i = 0, ilen = metasets.length; i < ilen; ++i) {
            keys.push(metasets[i].index);
        }
        return keys;
    }
    function applyStack(stack, value, dsIndex, options = {}) {
        const keys = stack.keys;
        const singleMode = options.mode === 'single';
        let i, ilen, datasetIndex, otherValue;
        if (value === null) {
            return;
        }
        for (i = 0, ilen = keys.length; i < ilen; ++i) {
            datasetIndex = +keys[i];
            if (datasetIndex === dsIndex) {
                if (options.all) {
                    continue;
                }
                break;
            }
            otherValue = stack.values[datasetIndex];
            if (
                isNumberFinite(otherValue) &&
                (singleMode || value === 0 || sign(value) === sign(otherValue))
            ) {
                value += otherValue;
            }
        }
        return value;
    }
    function convertObjectDataToArray(data) {
        const keys = Object.keys(data);
        const adata = new Array(keys.length);
        let i, ilen, key;
        for (i = 0, ilen = keys.length; i < ilen; ++i) {
            key = keys[i];
            adata[i] = {
                x: key,
                y: data[key],
            };
        }
        return adata;
    }
    function isStacked(scale, meta) {
        const stacked = scale && scale.options.stacked;
        return stacked || (stacked === void 0 && meta.stack !== void 0);
    }
    function getStackKey(indexScale, valueScale, meta) {
        return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
    }
    function getUserBounds(scale) {
        const {
            min: min3,
            max: max3,
            minDefined,
            maxDefined,
        } = scale.getUserBounds();
        return {
            min: minDefined ? min3 : Number.NEGATIVE_INFINITY,
            max: maxDefined ? max3 : Number.POSITIVE_INFINITY,
        };
    }
    function getOrCreateStack(stacks, stackKey, indexValue) {
        const subStack = stacks[stackKey] || (stacks[stackKey] = {});
        return subStack[indexValue] || (subStack[indexValue] = {});
    }
    function getLastIndexInStack(stack, vScale, positive, type2) {
        for (const meta of vScale.getMatchingVisibleMetas(type2).reverse()) {
            const value = stack[meta.index];
            if ((positive && value > 0) || (!positive && value < 0)) {
                return meta.index;
            }
        }
        return null;
    }
    function updateStacks(controller, parsed) {
        const { chart, _cachedMeta: meta } = controller;
        const stacks = chart._stacks || (chart._stacks = {});
        const { iScale, vScale, index: datasetIndex } = meta;
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        const key = getStackKey(iScale, vScale, meta);
        const ilen = parsed.length;
        let stack;
        for (let i = 0; i < ilen; ++i) {
            const item = parsed[i];
            const { [iAxis]: index3, [vAxis]: value } = item;
            const itemStacks = item._stacks || (item._stacks = {});
            stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index3);
            stack[datasetIndex] = value;
            stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
            stack._bottom = getLastIndexInStack(
                stack,
                vScale,
                false,
                meta.type
            );
        }
    }
    function getFirstScaleId(chart, axis) {
        const scales2 = chart.scales;
        return Object.keys(scales2)
            .filter((key) => scales2[key].axis === axis)
            .shift();
    }
    function createDatasetContext(parent, index3) {
        return createContext(parent, {
            active: false,
            dataset: void 0,
            datasetIndex: index3,
            index: index3,
            mode: 'default',
            type: 'dataset',
        });
    }
    function createDataContext(parent, index3, element) {
        return createContext(parent, {
            active: false,
            dataIndex: index3,
            parsed: void 0,
            raw: void 0,
            element,
            index: index3,
            mode: 'default',
            type: 'data',
        });
    }
    function clearStacks(meta, items) {
        const datasetIndex = meta.controller.index;
        const axis = meta.vScale && meta.vScale.axis;
        if (!axis) {
            return;
        }
        items = items || meta._parsed;
        for (const parsed of items) {
            const stacks = parsed._stacks;
            if (
                !stacks ||
                stacks[axis] === void 0 ||
                stacks[axis][datasetIndex] === void 0
            ) {
                return;
            }
            delete stacks[axis][datasetIndex];
        }
    }
    var isDirectUpdateMode = (mode) => mode === 'reset' || mode === 'none';
    var cloneIfNotShared = (cached, shared) =>
        shared ? cached : Object.assign({}, cached);
    var createStack = (canStack, meta, chart) =>
        canStack &&
        !meta.hidden &&
        meta._stacked && {
            keys: getSortedDatasetIndices(chart, true),
            values: null,
        };
    var DatasetController = class {
        constructor(chart, datasetIndex) {
            this.chart = chart;
            this._ctx = chart.ctx;
            this.index = datasetIndex;
            this._cachedDataOpts = {};
            this._cachedMeta = this.getMeta();
            this._type = this._cachedMeta.type;
            this.options = void 0;
            this._parsing = false;
            this._data = void 0;
            this._objectData = void 0;
            this._sharedOptions = void 0;
            this._drawStart = void 0;
            this._drawCount = void 0;
            this.enableOptionSharing = false;
            this.supportsDecimation = false;
            this.$context = void 0;
            this._syncList = [];
            this.initialize();
        }
        initialize() {
            const meta = this._cachedMeta;
            this.configure();
            this.linkScales();
            meta._stacked = isStacked(meta.vScale, meta);
            this.addElements();
        }
        updateIndex(datasetIndex) {
            if (this.index !== datasetIndex) {
                clearStacks(this._cachedMeta);
            }
            this.index = datasetIndex;
        }
        linkScales() {
            const chart = this.chart;
            const meta = this._cachedMeta;
            const dataset = this.getDataset();
            const chooseId = (axis, x, y, r) =>
                axis === 'x' ? x : axis === 'r' ? r : y;
            const xid = (meta.xAxisID = valueOrDefault(
                dataset.xAxisID,
                getFirstScaleId(chart, 'x')
            ));
            const yid = (meta.yAxisID = valueOrDefault(
                dataset.yAxisID,
                getFirstScaleId(chart, 'y')
            ));
            const rid = (meta.rAxisID = valueOrDefault(
                dataset.rAxisID,
                getFirstScaleId(chart, 'r')
            ));
            const indexAxis = meta.indexAxis;
            const iid = (meta.iAxisID = chooseId(indexAxis, xid, yid, rid));
            const vid = (meta.vAxisID = chooseId(indexAxis, yid, xid, rid));
            meta.xScale = this.getScaleForId(xid);
            meta.yScale = this.getScaleForId(yid);
            meta.rScale = this.getScaleForId(rid);
            meta.iScale = this.getScaleForId(iid);
            meta.vScale = this.getScaleForId(vid);
        }
        getDataset() {
            return this.chart.data.datasets[this.index];
        }
        getMeta() {
            return this.chart.getDatasetMeta(this.index);
        }
        getScaleForId(scaleID) {
            return this.chart.scales[scaleID];
        }
        _getOtherScale(scale) {
            const meta = this._cachedMeta;
            return scale === meta.iScale ? meta.vScale : meta.iScale;
        }
        reset() {
            this._update('reset');
        }
        _destroy() {
            const meta = this._cachedMeta;
            if (this._data) {
                unlistenArrayEvents(this._data, this);
            }
            if (meta._stacked) {
                clearStacks(meta);
            }
        }
        _dataCheck() {
            const dataset = this.getDataset();
            const data = dataset.data || (dataset.data = []);
            const _data = this._data;
            if (isObject(data)) {
                this._data = convertObjectDataToArray(data);
            } else if (_data !== data) {
                if (_data) {
                    unlistenArrayEvents(_data, this);
                    const meta = this._cachedMeta;
                    clearStacks(meta);
                    meta._parsed = [];
                }
                if (data && Object.isExtensible(data)) {
                    listenArrayEvents(data, this);
                }
                this._syncList = [];
                this._data = data;
            }
        }
        addElements() {
            const meta = this._cachedMeta;
            this._dataCheck();
            if (this.datasetElementType) {
                meta.dataset = new this.datasetElementType();
            }
        }
        buildOrUpdateElements(resetNewElements) {
            const meta = this._cachedMeta;
            const dataset = this.getDataset();
            let stackChanged = false;
            this._dataCheck();
            const oldStacked = meta._stacked;
            meta._stacked = isStacked(meta.vScale, meta);
            if (meta.stack !== dataset.stack) {
                stackChanged = true;
                clearStacks(meta);
                meta.stack = dataset.stack;
            }
            this._resyncElements(resetNewElements);
            if (stackChanged || oldStacked !== meta._stacked) {
                updateStacks(this, meta._parsed);
            }
        }
        configure() {
            const config = this.chart.config;
            const scopeKeys = config.datasetScopeKeys(this._type);
            const scopes = config.getOptionScopes(
                this.getDataset(),
                scopeKeys,
                true
            );
            this.options = config.createResolver(scopes, this.getContext());
            this._parsing = this.options.parsing;
            this._cachedDataOpts = {};
        }
        parse(start2, count) {
            const { _cachedMeta: meta, _data: data } = this;
            const { iScale, _stacked } = meta;
            const iAxis = iScale.axis;
            let sorted =
                start2 === 0 && count === data.length ? true : meta._sorted;
            let prev = start2 > 0 && meta._parsed[start2 - 1];
            let i, cur, parsed;
            if (this._parsing === false) {
                meta._parsed = data;
                meta._sorted = true;
                parsed = data;
            } else {
                if (isArray(data[start2])) {
                    parsed = this.parseArrayData(meta, data, start2, count);
                } else if (isObject(data[start2])) {
                    parsed = this.parseObjectData(meta, data, start2, count);
                } else {
                    parsed = this.parsePrimitiveData(meta, data, start2, count);
                }
                const isNotInOrderComparedToPrev = () =>
                    cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);
                for (i = 0; i < count; ++i) {
                    meta._parsed[i + start2] = cur = parsed[i];
                    if (sorted) {
                        if (isNotInOrderComparedToPrev()) {
                            sorted = false;
                        }
                        prev = cur;
                    }
                }
                meta._sorted = sorted;
            }
            if (_stacked) {
                updateStacks(this, parsed);
            }
        }
        parsePrimitiveData(meta, data, start2, count) {
            const { iScale, vScale } = meta;
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            const labels = iScale.getLabels();
            const singleScale = iScale === vScale;
            const parsed = new Array(count);
            let i, ilen, index3;
            for (i = 0, ilen = count; i < ilen; ++i) {
                index3 = i + start2;
                parsed[i] = {
                    [iAxis]:
                        singleScale || iScale.parse(labels[index3], index3),
                    [vAxis]: vScale.parse(data[index3], index3),
                };
            }
            return parsed;
        }
        parseArrayData(meta, data, start2, count) {
            const { xScale, yScale } = meta;
            const parsed = new Array(count);
            let i, ilen, index3, item;
            for (i = 0, ilen = count; i < ilen; ++i) {
                index3 = i + start2;
                item = data[index3];
                parsed[i] = {
                    x: xScale.parse(item[0], index3),
                    y: yScale.parse(item[1], index3),
                };
            }
            return parsed;
        }
        parseObjectData(meta, data, start2, count) {
            const { xScale, yScale } = meta;
            const { xAxisKey = 'x', yAxisKey = 'y' } = this._parsing;
            const parsed = new Array(count);
            let i, ilen, index3, item;
            for (i = 0, ilen = count; i < ilen; ++i) {
                index3 = i + start2;
                item = data[index3];
                parsed[i] = {
                    x: xScale.parse(resolveObjectKey(item, xAxisKey), index3),
                    y: yScale.parse(resolveObjectKey(item, yAxisKey), index3),
                };
            }
            return parsed;
        }
        getParsed(index3) {
            return this._cachedMeta._parsed[index3];
        }
        getDataElement(index3) {
            return this._cachedMeta.data[index3];
        }
        applyStack(scale, parsed, mode) {
            const chart = this.chart;
            const meta = this._cachedMeta;
            const value = parsed[scale.axis];
            const stack = {
                keys: getSortedDatasetIndices(chart, true),
                values: parsed._stacks[scale.axis],
            };
            return applyStack(stack, value, meta.index, { mode });
        }
        updateRangeFromParsed(range, scale, parsed, stack) {
            const parsedValue = parsed[scale.axis];
            let value = parsedValue === null ? NaN : parsedValue;
            const values = stack && parsed._stacks[scale.axis];
            if (stack && values) {
                stack.values = values;
                value = applyStack(stack, parsedValue, this._cachedMeta.index);
            }
            range.min = Math.min(range.min, value);
            range.max = Math.max(range.max, value);
        }
        getMinMax(scale, canStack) {
            const meta = this._cachedMeta;
            const _parsed = meta._parsed;
            const sorted = meta._sorted && scale === meta.iScale;
            const ilen = _parsed.length;
            const otherScale = this._getOtherScale(scale);
            const stack = createStack(canStack, meta, this.chart);
            const range = {
                min: Number.POSITIVE_INFINITY,
                max: Number.NEGATIVE_INFINITY,
            };
            const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
            let i, parsed;
            function _skip() {
                parsed = _parsed[i];
                const otherValue = parsed[otherScale.axis];
                return (
                    !isNumberFinite(parsed[scale.axis]) ||
                    otherMin > otherValue ||
                    otherMax < otherValue
                );
            }
            for (i = 0; i < ilen; ++i) {
                if (_skip()) {
                    continue;
                }
                this.updateRangeFromParsed(range, scale, parsed, stack);
                if (sorted) {
                    break;
                }
            }
            if (sorted) {
                for (i = ilen - 1; i >= 0; --i) {
                    if (_skip()) {
                        continue;
                    }
                    this.updateRangeFromParsed(range, scale, parsed, stack);
                    break;
                }
            }
            return range;
        }
        getAllParsedValues(scale) {
            const parsed = this._cachedMeta._parsed;
            const values = [];
            let i, ilen, value;
            for (i = 0, ilen = parsed.length; i < ilen; ++i) {
                value = parsed[i][scale.axis];
                if (isNumberFinite(value)) {
                    values.push(value);
                }
            }
            return values;
        }
        getMaxOverflow() {
            return false;
        }
        getLabelAndValue(index3) {
            const meta = this._cachedMeta;
            const iScale = meta.iScale;
            const vScale = meta.vScale;
            const parsed = this.getParsed(index3);
            return {
                label: iScale
                    ? '' + iScale.getLabelForValue(parsed[iScale.axis])
                    : '',
                value: vScale
                    ? '' + vScale.getLabelForValue(parsed[vScale.axis])
                    : '',
            };
        }
        _update(mode) {
            const meta = this._cachedMeta;
            this.update(mode || 'default');
            meta._clip = toClip(
                valueOrDefault(
                    this.options.clip,
                    defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())
                )
            );
        }
        update(mode) {}
        draw() {
            const ctx = this._ctx;
            const chart = this.chart;
            const meta = this._cachedMeta;
            const elements2 = meta.data || [];
            const area = chart.chartArea;
            const active = [];
            const start2 = this._drawStart || 0;
            const count = this._drawCount || elements2.length - start2;
            const drawActiveElementsOnTop =
                this.options.drawActiveElementsOnTop;
            let i;
            if (meta.dataset) {
                meta.dataset.draw(ctx, area, start2, count);
            }
            for (i = start2; i < start2 + count; ++i) {
                const element = elements2[i];
                if (element.hidden) {
                    continue;
                }
                if (element.active && drawActiveElementsOnTop) {
                    active.push(element);
                } else {
                    element.draw(ctx, area);
                }
            }
            for (i = 0; i < active.length; ++i) {
                active[i].draw(ctx, area);
            }
        }
        getStyle(index3, active) {
            const mode = active ? 'active' : 'default';
            return index3 === void 0 && this._cachedMeta.dataset
                ? this.resolveDatasetElementOptions(mode)
                : this.resolveDataElementOptions(index3 || 0, mode);
        }
        getContext(index3, active, mode) {
            const dataset = this.getDataset();
            let context;
            if (index3 >= 0 && index3 < this._cachedMeta.data.length) {
                const element = this._cachedMeta.data[index3];
                context =
                    element.$context ||
                    (element.$context = createDataContext(
                        this.getContext(),
                        index3,
                        element
                    ));
                context.parsed = this.getParsed(index3);
                context.raw = dataset.data[index3];
                context.index = context.dataIndex = index3;
            } else {
                context =
                    this.$context ||
                    (this.$context = createDatasetContext(
                        this.chart.getContext(),
                        this.index
                    ));
                context.dataset = dataset;
                context.index = context.datasetIndex = this.index;
            }
            context.active = !!active;
            context.mode = mode;
            return context;
        }
        resolveDatasetElementOptions(mode) {
            return this._resolveElementOptions(
                this.datasetElementType.id,
                mode
            );
        }
        resolveDataElementOptions(index3, mode) {
            return this._resolveElementOptions(
                this.dataElementType.id,
                mode,
                index3
            );
        }
        _resolveElementOptions(elementType, mode = 'default', index3) {
            const active = mode === 'active';
            const cache = this._cachedDataOpts;
            const cacheKey = elementType + '-' + mode;
            const cached = cache[cacheKey];
            const sharing = this.enableOptionSharing && defined(index3);
            if (cached) {
                return cloneIfNotShared(cached, sharing);
            }
            const config = this.chart.config;
            const scopeKeys = config.datasetElementScopeKeys(
                this._type,
                elementType
            );
            const prefixes2 = active
                ? [`${elementType}Hover`, 'hover', elementType, '']
                : [elementType, ''];
            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
            const names2 = Object.keys(defaults.elements[elementType]);
            const context = () => this.getContext(index3, active);
            const values = config.resolveNamedOptions(
                scopes,
                names2,
                context,
                prefixes2
            );
            if (values.$shared) {
                values.$shared = sharing;
                cache[cacheKey] = Object.freeze(
                    cloneIfNotShared(values, sharing)
                );
            }
            return values;
        }
        _resolveAnimations(index3, transition2, active) {
            const chart = this.chart;
            const cache = this._cachedDataOpts;
            const cacheKey = `animation-${transition2}`;
            const cached = cache[cacheKey];
            if (cached) {
                return cached;
            }
            let options;
            if (chart.options.animation !== false) {
                const config = this.chart.config;
                const scopeKeys = config.datasetAnimationScopeKeys(
                    this._type,
                    transition2
                );
                const scopes = config.getOptionScopes(
                    this.getDataset(),
                    scopeKeys
                );
                options = config.createResolver(
                    scopes,
                    this.getContext(index3, active, transition2)
                );
            }
            const animations = new Animations(
                chart,
                options && options.animations
            );
            if (options && options._cacheable) {
                cache[cacheKey] = Object.freeze(animations);
            }
            return animations;
        }
        getSharedOptions(options) {
            if (!options.$shared) {
                return;
            }
            return (
                this._sharedOptions ||
                (this._sharedOptions = Object.assign({}, options))
            );
        }
        includeOptions(mode, sharedOptions) {
            return (
                !sharedOptions ||
                isDirectUpdateMode(mode) ||
                this.chart._animationsDisabled
            );
        }
        _getSharedOptions(start2, mode) {
            const firstOpts = this.resolveDataElementOptions(start2, mode);
            const previouslySharedOptions = this._sharedOptions;
            const sharedOptions = this.getSharedOptions(firstOpts);
            const includeOptions =
                this.includeOptions(mode, sharedOptions) ||
                sharedOptions !== previouslySharedOptions;
            this.updateSharedOptions(sharedOptions, mode, firstOpts);
            return { sharedOptions, includeOptions };
        }
        updateElement(element, index3, properties, mode) {
            if (isDirectUpdateMode(mode)) {
                Object.assign(element, properties);
            } else {
                this._resolveAnimations(index3, mode).update(
                    element,
                    properties
                );
            }
        }
        updateSharedOptions(sharedOptions, mode, newOptions) {
            if (sharedOptions && !isDirectUpdateMode(mode)) {
                this._resolveAnimations(void 0, mode).update(
                    sharedOptions,
                    newOptions
                );
            }
        }
        _setStyle(element, index3, mode, active) {
            element.active = active;
            const options = this.getStyle(index3, active);
            this._resolveAnimations(index3, mode, active).update(element, {
                options: (!active && this.getSharedOptions(options)) || options,
            });
        }
        removeHoverStyle(element, datasetIndex, index3) {
            this._setStyle(element, index3, 'active', false);
        }
        setHoverStyle(element, datasetIndex, index3) {
            this._setStyle(element, index3, 'active', true);
        }
        _removeDatasetHoverStyle() {
            const element = this._cachedMeta.dataset;
            if (element) {
                this._setStyle(element, void 0, 'active', false);
            }
        }
        _setDatasetHoverStyle() {
            const element = this._cachedMeta.dataset;
            if (element) {
                this._setStyle(element, void 0, 'active', true);
            }
        }
        _resyncElements(resetNewElements) {
            const data = this._data;
            const elements2 = this._cachedMeta.data;
            for (const [method, arg1, arg2] of this._syncList) {
                this[method](arg1, arg2);
            }
            this._syncList = [];
            const numMeta = elements2.length;
            const numData = data.length;
            const count = Math.min(numData, numMeta);
            if (count) {
                this.parse(0, count);
            }
            if (numData > numMeta) {
                this._insertElements(
                    numMeta,
                    numData - numMeta,
                    resetNewElements
                );
            } else if (numData < numMeta) {
                this._removeElements(numData, numMeta - numData);
            }
        }
        _insertElements(start2, count, resetNewElements = true) {
            const meta = this._cachedMeta;
            const data = meta.data;
            const end = start2 + count;
            let i;
            const move = (arr) => {
                arr.length += count;
                for (i = arr.length - 1; i >= end; i--) {
                    arr[i] = arr[i - count];
                }
            };
            move(data);
            for (i = start2; i < end; ++i) {
                data[i] = new this.dataElementType();
            }
            if (this._parsing) {
                move(meta._parsed);
            }
            this.parse(start2, count);
            if (resetNewElements) {
                this.updateElements(data, start2, count, 'reset');
            }
        }
        updateElements(element, start2, count, mode) {}
        _removeElements(start2, count) {
            const meta = this._cachedMeta;
            if (this._parsing) {
                const removed = meta._parsed.splice(start2, count);
                if (meta._stacked) {
                    clearStacks(meta, removed);
                }
            }
            meta.data.splice(start2, count);
        }
        _sync(args) {
            if (this._parsing) {
                this._syncList.push(args);
            } else {
                const [method, arg1, arg2] = args;
                this[method](arg1, arg2);
            }
            this.chart._dataChanges.push([this.index, ...args]);
        }
        _onDataPush() {
            const count = arguments.length;
            this._sync([
                '_insertElements',
                this.getDataset().data.length - count,
                count,
            ]);
        }
        _onDataPop() {
            this._sync([
                '_removeElements',
                this._cachedMeta.data.length - 1,
                1,
            ]);
        }
        _onDataShift() {
            this._sync(['_removeElements', 0, 1]);
        }
        _onDataSplice(start2, count) {
            if (count) {
                this._sync(['_removeElements', start2, count]);
            }
            const newCount = arguments.length - 2;
            if (newCount) {
                this._sync(['_insertElements', start2, newCount]);
            }
        }
        _onDataUnshift() {
            this._sync(['_insertElements', 0, arguments.length]);
        }
    };
    DatasetController.defaults = {};
    DatasetController.prototype.datasetElementType = null;
    DatasetController.prototype.dataElementType = null;
    function getAllScaleValues(scale, type2) {
        if (!scale._cache.$bar) {
            const visibleMetas = scale.getMatchingVisibleMetas(type2);
            let values = [];
            for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
                values = values.concat(
                    visibleMetas[i].controller.getAllParsedValues(scale)
                );
            }
            scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
        }
        return scale._cache.$bar;
    }
    function computeMinSampleSize(meta) {
        const scale = meta.iScale;
        const values = getAllScaleValues(scale, meta.type);
        let min3 = scale._length;
        let i, ilen, curr, prev;
        const updateMinAndPrev = () => {
            if (curr === 32767 || curr === -32768) {
                return;
            }
            if (defined(prev)) {
                min3 = Math.min(min3, Math.abs(curr - prev) || min3);
            }
            prev = curr;
        };
        for (i = 0, ilen = values.length; i < ilen; ++i) {
            curr = scale.getPixelForValue(values[i]);
            updateMinAndPrev();
        }
        prev = void 0;
        for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
            curr = scale.getPixelForTick(i);
            updateMinAndPrev();
        }
        return min3;
    }
    function computeFitCategoryTraits(index3, ruler, options, stackCount) {
        const thickness = options.barThickness;
        let size, ratio;
        if (isNullOrUndef(thickness)) {
            size = ruler.min * options.categoryPercentage;
            ratio = options.barPercentage;
        } else {
            size = thickness * stackCount;
            ratio = 1;
        }
        return {
            chunk: size / stackCount,
            ratio,
            start: ruler.pixels[index3] - size / 2,
        };
    }
    function computeFlexCategoryTraits(index3, ruler, options, stackCount) {
        const pixels = ruler.pixels;
        const curr = pixels[index3];
        let prev = index3 > 0 ? pixels[index3 - 1] : null;
        let next = index3 < pixels.length - 1 ? pixels[index3 + 1] : null;
        const percent = options.categoryPercentage;
        if (prev === null) {
            prev =
                curr - (next === null ? ruler.end - ruler.start : next - curr);
        }
        if (next === null) {
            next = curr + curr - prev;
        }
        const start2 = curr - ((curr - Math.min(prev, next)) / 2) * percent;
        const size = (Math.abs(next - prev) / 2) * percent;
        return {
            chunk: size / stackCount,
            ratio: options.barPercentage,
            start: start2,
        };
    }
    function parseFloatBar(entry, item, vScale, i) {
        const startValue = vScale.parse(entry[0], i);
        const endValue = vScale.parse(entry[1], i);
        const min3 = Math.min(startValue, endValue);
        const max3 = Math.max(startValue, endValue);
        let barStart = min3;
        let barEnd = max3;
        if (Math.abs(min3) > Math.abs(max3)) {
            barStart = max3;
            barEnd = min3;
        }
        item[vScale.axis] = barEnd;
        item._custom = {
            barStart,
            barEnd,
            start: startValue,
            end: endValue,
            min: min3,
            max: max3,
        };
    }
    function parseValue(entry, item, vScale, i) {
        if (isArray(entry)) {
            parseFloatBar(entry, item, vScale, i);
        } else {
            item[vScale.axis] = vScale.parse(entry, i);
        }
        return item;
    }
    function parseArrayOrPrimitive(meta, data, start2, count) {
        const iScale = meta.iScale;
        const vScale = meta.vScale;
        const labels = iScale.getLabels();
        const singleScale = iScale === vScale;
        const parsed = [];
        let i, ilen, item, entry;
        for (i = start2, ilen = start2 + count; i < ilen; ++i) {
            entry = data[i];
            item = {};
            item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
            parsed.push(parseValue(entry, item, vScale, i));
        }
        return parsed;
    }
    function isFloatBar(custom) {
        return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
    }
    function barSign(size, vScale, actualBase) {
        if (size !== 0) {
            return sign(size);
        }
        return (
            (vScale.isHorizontal() ? 1 : -1) *
            (vScale.min >= actualBase ? 1 : -1)
        );
    }
    function borderProps(properties) {
        let reverse, start2, end, top, bottom;
        if (properties.horizontal) {
            reverse = properties.base > properties.x;
            start2 = 'left';
            end = 'right';
        } else {
            reverse = properties.base < properties.y;
            start2 = 'bottom';
            end = 'top';
        }
        if (reverse) {
            top = 'end';
            bottom = 'start';
        } else {
            top = 'start';
            bottom = 'end';
        }
        return { start: start2, end, reverse, top, bottom };
    }
    function setBorderSkipped(properties, options, stack, index3) {
        let edge = options.borderSkipped;
        const res = {};
        if (!edge) {
            properties.borderSkipped = res;
            return;
        }
        if (edge === true) {
            properties.borderSkipped = {
                top: true,
                right: true,
                bottom: true,
                left: true,
            };
            return;
        }
        const {
            start: start2,
            end,
            reverse,
            top,
            bottom,
        } = borderProps(properties);
        if (edge === 'middle' && stack) {
            properties.enableBorderRadius = true;
            if ((stack._top || 0) === index3) {
                edge = top;
            } else if ((stack._bottom || 0) === index3) {
                edge = bottom;
            } else {
                res[parseEdge(bottom, start2, end, reverse)] = true;
                edge = top;
            }
        }
        res[parseEdge(edge, start2, end, reverse)] = true;
        properties.borderSkipped = res;
    }
    function parseEdge(edge, a, b, reverse) {
        if (reverse) {
            edge = swap(edge, a, b);
            edge = startEnd(edge, b, a);
        } else {
            edge = startEnd(edge, a, b);
        }
        return edge;
    }
    function swap(orig, v1, v2) {
        return orig === v1 ? v2 : orig === v2 ? v1 : orig;
    }
    function startEnd(v, start2, end) {
        return v === 'start' ? start2 : v === 'end' ? end : v;
    }
    function setInflateAmount(properties, { inflateAmount }, ratio) {
        properties.inflateAmount =
            inflateAmount === 'auto' ? (ratio === 1 ? 0.33 : 0) : inflateAmount;
    }
    var BarController = class extends DatasetController {
        parsePrimitiveData(meta, data, start2, count) {
            return parseArrayOrPrimitive(meta, data, start2, count);
        }
        parseArrayData(meta, data, start2, count) {
            return parseArrayOrPrimitive(meta, data, start2, count);
        }
        parseObjectData(meta, data, start2, count) {
            const { iScale, vScale } = meta;
            const { xAxisKey = 'x', yAxisKey = 'y' } = this._parsing;
            const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;
            const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;
            const parsed = [];
            let i, ilen, item, obj;
            for (i = start2, ilen = start2 + count; i < ilen; ++i) {
                obj = data[i];
                item = {};
                item[iScale.axis] = iScale.parse(
                    resolveObjectKey(obj, iAxisKey),
                    i
                );
                parsed.push(
                    parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i)
                );
            }
            return parsed;
        }
        updateRangeFromParsed(range, scale, parsed, stack) {
            super.updateRangeFromParsed(range, scale, parsed, stack);
            const custom = parsed._custom;
            if (custom && scale === this._cachedMeta.vScale) {
                range.min = Math.min(range.min, custom.min);
                range.max = Math.max(range.max, custom.max);
            }
        }
        getMaxOverflow() {
            return 0;
        }
        getLabelAndValue(index3) {
            const meta = this._cachedMeta;
            const { iScale, vScale } = meta;
            const parsed = this.getParsed(index3);
            const custom = parsed._custom;
            const value = isFloatBar(custom)
                ? '[' + custom.start + ', ' + custom.end + ']'
                : '' + vScale.getLabelForValue(parsed[vScale.axis]);
            return {
                label: '' + iScale.getLabelForValue(parsed[iScale.axis]),
                value,
            };
        }
        initialize() {
            this.enableOptionSharing = true;
            super.initialize();
            const meta = this._cachedMeta;
            meta.stack = this.getDataset().stack;
        }
        update(mode) {
            const meta = this._cachedMeta;
            this.updateElements(meta.data, 0, meta.data.length, mode);
        }
        updateElements(bars, start2, count, mode) {
            const reset = mode === 'reset';
            const {
                index: index3,
                _cachedMeta: { vScale },
            } = this;
            const base = vScale.getBasePixel();
            const horizontal = vScale.isHorizontal();
            const ruler = this._getRuler();
            const { sharedOptions, includeOptions } = this._getSharedOptions(
                start2,
                mode
            );
            for (let i = start2; i < start2 + count; i++) {
                const parsed = this.getParsed(i);
                const vpixels =
                    reset || isNullOrUndef(parsed[vScale.axis])
                        ? { base, head: base }
                        : this._calculateBarValuePixels(i);
                const ipixels = this._calculateBarIndexPixels(i, ruler);
                const stack = (parsed._stacks || {})[vScale.axis];
                const properties = {
                    horizontal,
                    base: vpixels.base,
                    enableBorderRadius:
                        !stack ||
                        isFloatBar(parsed._custom) ||
                        index3 === stack._top ||
                        index3 === stack._bottom,
                    x: horizontal ? vpixels.head : ipixels.center,
                    y: horizontal ? ipixels.center : vpixels.head,
                    height: horizontal ? ipixels.size : Math.abs(vpixels.size),
                    width: horizontal ? Math.abs(vpixels.size) : ipixels.size,
                };
                if (includeOptions) {
                    properties.options =
                        sharedOptions ||
                        this.resolveDataElementOptions(
                            i,
                            bars[i].active ? 'active' : mode
                        );
                }
                const options = properties.options || bars[i].options;
                setBorderSkipped(properties, options, stack, index3);
                setInflateAmount(properties, options, ruler.ratio);
                this.updateElement(bars[i], i, properties, mode);
            }
        }
        _getStacks(last, dataIndex) {
            const { iScale } = this._cachedMeta;
            const metasets = iScale
                .getMatchingVisibleMetas(this._type)
                .filter((meta) => meta.controller.options.grouped);
            const stacked = iScale.options.stacked;
            const stacks = [];
            const skipNull = (meta) => {
                const parsed = meta.controller.getParsed(dataIndex);
                const val = parsed && parsed[meta.vScale.axis];
                if (isNullOrUndef(val) || isNaN(val)) {
                    return true;
                }
            };
            for (const meta of metasets) {
                if (dataIndex !== void 0 && skipNull(meta)) {
                    continue;
                }
                if (
                    stacked === false ||
                    stacks.indexOf(meta.stack) === -1 ||
                    (stacked === void 0 && meta.stack === void 0)
                ) {
                    stacks.push(meta.stack);
                }
                if (meta.index === last) {
                    break;
                }
            }
            if (!stacks.length) {
                stacks.push(void 0);
            }
            return stacks;
        }
        _getStackCount(index3) {
            return this._getStacks(void 0, index3).length;
        }
        _getStackIndex(datasetIndex, name, dataIndex) {
            const stacks = this._getStacks(datasetIndex, dataIndex);
            const index3 = name !== void 0 ? stacks.indexOf(name) : -1;
            return index3 === -1 ? stacks.length - 1 : index3;
        }
        _getRuler() {
            const opts = this.options;
            const meta = this._cachedMeta;
            const iScale = meta.iScale;
            const pixels = [];
            let i, ilen;
            for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
                pixels.push(
                    iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i)
                );
            }
            const barThickness = opts.barThickness;
            const min3 = barThickness || computeMinSampleSize(meta);
            return {
                min: min3,
                pixels,
                start: iScale._startPixel,
                end: iScale._endPixel,
                stackCount: this._getStackCount(),
                scale: iScale,
                grouped: opts.grouped,
                ratio: barThickness
                    ? 1
                    : opts.categoryPercentage * opts.barPercentage,
            };
        }
        _calculateBarValuePixels(index3) {
            const {
                _cachedMeta: { vScale, _stacked },
                options: { base: baseValue, minBarLength },
            } = this;
            const actualBase = baseValue || 0;
            const parsed = this.getParsed(index3);
            const custom = parsed._custom;
            const floating = isFloatBar(custom);
            let value = parsed[vScale.axis];
            let start2 = 0;
            let length = _stacked
                ? this.applyStack(vScale, parsed, _stacked)
                : value;
            let head, size;
            if (length !== value) {
                start2 = length - value;
                length = value;
            }
            if (floating) {
                value = custom.barStart;
                length = custom.barEnd - custom.barStart;
                if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
                    start2 = 0;
                }
                start2 += value;
            }
            const startValue =
                !isNullOrUndef(baseValue) && !floating ? baseValue : start2;
            let base = vScale.getPixelForValue(startValue);
            if (this.chart.getDataVisibility(index3)) {
                head = vScale.getPixelForValue(start2 + length);
            } else {
                head = base;
            }
            size = head - base;
            if (Math.abs(size) < minBarLength) {
                size = barSign(size, vScale, actualBase) * minBarLength;
                if (value === actualBase) {
                    base -= size / 2;
                }
                const startPixel = vScale.getPixelForDecimal(0);
                const endPixel = vScale.getPixelForDecimal(1);
                const min3 = Math.min(startPixel, endPixel);
                const max3 = Math.max(startPixel, endPixel);
                base = Math.max(Math.min(base, max3), min3);
                head = base + size;
            }
            if (base === vScale.getPixelForValue(actualBase)) {
                const halfGrid =
                    (sign(size) * vScale.getLineWidthForValue(actualBase)) / 2;
                base += halfGrid;
                size -= halfGrid;
            }
            return {
                size,
                base,
                head,
                center: head + size / 2,
            };
        }
        _calculateBarIndexPixels(index3, ruler) {
            const scale = ruler.scale;
            const options = this.options;
            const skipNull = options.skipNull;
            const maxBarThickness = valueOrDefault(
                options.maxBarThickness,
                Infinity
            );
            let center, size;
            if (ruler.grouped) {
                const stackCount = skipNull
                    ? this._getStackCount(index3)
                    : ruler.stackCount;
                const range =
                    options.barThickness === 'flex'
                        ? computeFlexCategoryTraits(
                              index3,
                              ruler,
                              options,
                              stackCount
                          )
                        : computeFitCategoryTraits(
                              index3,
                              ruler,
                              options,
                              stackCount
                          );
                const stackIndex = this._getStackIndex(
                    this.index,
                    this._cachedMeta.stack,
                    skipNull ? index3 : void 0
                );
                center =
                    range.start + range.chunk * stackIndex + range.chunk / 2;
                size = Math.min(maxBarThickness, range.chunk * range.ratio);
            } else {
                center = scale.getPixelForValue(
                    this.getParsed(index3)[scale.axis],
                    index3
                );
                size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
            }
            return {
                base: center - size / 2,
                head: center + size / 2,
                center,
                size,
            };
        }
        draw() {
            const meta = this._cachedMeta;
            const vScale = meta.vScale;
            const rects = meta.data;
            const ilen = rects.length;
            let i = 0;
            for (; i < ilen; ++i) {
                if (this.getParsed(i)[vScale.axis] !== null) {
                    rects[i].draw(this._ctx);
                }
            }
        }
    };
    BarController.id = 'bar';
    BarController.defaults = {
        datasetElementType: false,
        dataElementType: 'bar',
        categoryPercentage: 0.8,
        barPercentage: 0.9,
        grouped: true,
        animations: {
            numbers: {
                type: 'number',
                properties: ['x', 'y', 'base', 'width', 'height'],
            },
        },
    };
    BarController.overrides = {
        scales: {
            _index_: {
                type: 'category',
                offset: true,
                grid: {
                    offset: true,
                },
            },
            _value_: {
                type: 'linear',
                beginAtZero: true,
            },
        },
    };
    var BubbleController = class extends DatasetController {
        initialize() {
            this.enableOptionSharing = true;
            super.initialize();
        }
        parsePrimitiveData(meta, data, start2, count) {
            const parsed = super.parsePrimitiveData(meta, data, start2, count);
            for (let i = 0; i < parsed.length; i++) {
                parsed[i]._custom = this.resolveDataElementOptions(
                    i + start2
                ).radius;
            }
            return parsed;
        }
        parseArrayData(meta, data, start2, count) {
            const parsed = super.parseArrayData(meta, data, start2, count);
            for (let i = 0; i < parsed.length; i++) {
                const item = data[start2 + i];
                parsed[i]._custom = valueOrDefault(
                    item[2],
                    this.resolveDataElementOptions(i + start2).radius
                );
            }
            return parsed;
        }
        parseObjectData(meta, data, start2, count) {
            const parsed = super.parseObjectData(meta, data, start2, count);
            for (let i = 0; i < parsed.length; i++) {
                const item = data[start2 + i];
                parsed[i]._custom = valueOrDefault(
                    item && item.r && +item.r,
                    this.resolveDataElementOptions(i + start2).radius
                );
            }
            return parsed;
        }
        getMaxOverflow() {
            const data = this._cachedMeta.data;
            let max3 = 0;
            for (let i = data.length - 1; i >= 0; --i) {
                max3 = Math.max(
                    max3,
                    data[i].size(this.resolveDataElementOptions(i)) / 2
                );
            }
            return max3 > 0 && max3;
        }
        getLabelAndValue(index3) {
            const meta = this._cachedMeta;
            const { xScale, yScale } = meta;
            const parsed = this.getParsed(index3);
            const x = xScale.getLabelForValue(parsed.x);
            const y = yScale.getLabelForValue(parsed.y);
            const r = parsed._custom;
            return {
                label: meta.label,
                value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')',
            };
        }
        update(mode) {
            const points = this._cachedMeta.data;
            this.updateElements(points, 0, points.length, mode);
        }
        updateElements(points, start2, count, mode) {
            const reset = mode === 'reset';
            const { iScale, vScale } = this._cachedMeta;
            const { sharedOptions, includeOptions } = this._getSharedOptions(
                start2,
                mode
            );
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            for (let i = start2; i < start2 + count; i++) {
                const point = points[i];
                const parsed = !reset && this.getParsed(i);
                const properties = {};
                const iPixel = (properties[iAxis] = reset
                    ? iScale.getPixelForDecimal(0.5)
                    : iScale.getPixelForValue(parsed[iAxis]));
                const vPixel = (properties[vAxis] = reset
                    ? vScale.getBasePixel()
                    : vScale.getPixelForValue(parsed[vAxis]));
                properties.skip = isNaN(iPixel) || isNaN(vPixel);
                if (includeOptions) {
                    properties.options =
                        sharedOptions ||
                        this.resolveDataElementOptions(
                            i,
                            point.active ? 'active' : mode
                        );
                    if (reset) {
                        properties.options.radius = 0;
                    }
                }
                this.updateElement(point, i, properties, mode);
            }
        }
        resolveDataElementOptions(index3, mode) {
            const parsed = this.getParsed(index3);
            let values = super.resolveDataElementOptions(index3, mode);
            if (values.$shared) {
                values = Object.assign({}, values, { $shared: false });
            }
            const radius3 = values.radius;
            if (mode !== 'active') {
                values.radius = 0;
            }
            values.radius += valueOrDefault(parsed && parsed._custom, radius3);
            return values;
        }
    };
    BubbleController.id = 'bubble';
    BubbleController.defaults = {
        datasetElementType: false,
        dataElementType: 'point',
        animations: {
            numbers: {
                type: 'number',
                properties: ['x', 'y', 'borderWidth', 'radius'],
            },
        },
    };
    BubbleController.overrides = {
        scales: {
            x: {
                type: 'linear',
            },
            y: {
                type: 'linear',
            },
        },
        plugins: {
            tooltip: {
                callbacks: {
                    title() {
                        return '';
                    },
                },
            },
        },
    };
    function getRatioAndOffset(rotation, circumference, cutout) {
        let ratioX = 1;
        let ratioY = 1;
        let offsetX = 0;
        let offsetY = 0;
        if (circumference < TAU) {
            const startAngle = rotation;
            const endAngle = startAngle + circumference;
            const startX = Math.cos(startAngle);
            const startY = Math.sin(startAngle);
            const endX = Math.cos(endAngle);
            const endY = Math.sin(endAngle);
            const calcMax = (angle, a, b) =>
                _angleBetween(angle, startAngle, endAngle, true)
                    ? 1
                    : Math.max(a, a * cutout, b, b * cutout);
            const calcMin = (angle, a, b) =>
                _angleBetween(angle, startAngle, endAngle, true)
                    ? -1
                    : Math.min(a, a * cutout, b, b * cutout);
            const maxX = calcMax(0, startX, endX);
            const maxY = calcMax(HALF_PI, startY, endY);
            const minX = calcMin(PI, startX, endX);
            const minY = calcMin(PI + HALF_PI, startY, endY);
            ratioX = (maxX - minX) / 2;
            ratioY = (maxY - minY) / 2;
            offsetX = -(maxX + minX) / 2;
            offsetY = -(maxY + minY) / 2;
        }
        return { ratioX, ratioY, offsetX, offsetY };
    }
    var DoughnutController = class extends DatasetController {
        constructor(chart, datasetIndex) {
            super(chart, datasetIndex);
            this.enableOptionSharing = true;
            this.innerRadius = void 0;
            this.outerRadius = void 0;
            this.offsetX = void 0;
            this.offsetY = void 0;
        }
        linkScales() {}
        parse(start2, count) {
            const data = this.getDataset().data;
            const meta = this._cachedMeta;
            if (this._parsing === false) {
                meta._parsed = data;
            } else {
                let getter = (i2) => +data[i2];
                if (isObject(data[start2])) {
                    const { key = 'value' } = this._parsing;
                    getter = (i2) => +resolveObjectKey(data[i2], key);
                }
                let i, ilen;
                for (i = start2, ilen = start2 + count; i < ilen; ++i) {
                    meta._parsed[i] = getter(i);
                }
            }
        }
        _getRotation() {
            return toRadians(this.options.rotation - 90);
        }
        _getCircumference() {
            return toRadians(this.options.circumference);
        }
        _getRotationExtents() {
            let min3 = TAU;
            let max3 = -TAU;
            for (let i = 0; i < this.chart.data.datasets.length; ++i) {
                if (this.chart.isDatasetVisible(i)) {
                    const controller = this.chart.getDatasetMeta(i).controller;
                    const rotation = controller._getRotation();
                    const circumference = controller._getCircumference();
                    min3 = Math.min(min3, rotation);
                    max3 = Math.max(max3, rotation + circumference);
                }
            }
            return {
                rotation: min3,
                circumference: max3 - min3,
            };
        }
        update(mode) {
            const chart = this.chart;
            const { chartArea } = chart;
            const meta = this._cachedMeta;
            const arcs = meta.data;
            const spacing =
                this.getMaxBorderWidth() +
                this.getMaxOffset(arcs) +
                this.options.spacing;
            const maxSize = Math.max(
                (Math.min(chartArea.width, chartArea.height) - spacing) / 2,
                0
            );
            const cutout = Math.min(
                toPercentage(this.options.cutout, maxSize),
                1
            );
            const chartWeight = this._getRingWeight(this.index);
            const { circumference, rotation } = this._getRotationExtents();
            const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(
                rotation,
                circumference,
                cutout
            );
            const maxWidth = (chartArea.width - spacing) / ratioX;
            const maxHeight = (chartArea.height - spacing) / ratioY;
            const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
            const outerRadius = toDimension(this.options.radius, maxRadius);
            const innerRadius = Math.max(outerRadius * cutout, 0);
            const radiusLength =
                (outerRadius - innerRadius) /
                this._getVisibleDatasetWeightTotal();
            this.offsetX = offsetX * outerRadius;
            this.offsetY = offsetY * outerRadius;
            meta.total = this.calculateTotal();
            this.outerRadius =
                outerRadius -
                radiusLength * this._getRingWeightOffset(this.index);
            this.innerRadius = Math.max(
                this.outerRadius - radiusLength * chartWeight,
                0
            );
            this.updateElements(arcs, 0, arcs.length, mode);
        }
        _circumference(i, reset) {
            const opts = this.options;
            const meta = this._cachedMeta;
            const circumference = this._getCircumference();
            if (
                (reset && opts.animation.animateRotate) ||
                !this.chart.getDataVisibility(i) ||
                meta._parsed[i] === null ||
                meta.data[i].hidden
            ) {
                return 0;
            }
            return this.calculateCircumference(
                (meta._parsed[i] * circumference) / TAU
            );
        }
        updateElements(arcs, start2, count, mode) {
            const reset = mode === 'reset';
            const chart = this.chart;
            const chartArea = chart.chartArea;
            const opts = chart.options;
            const animationOpts = opts.animation;
            const centerX = (chartArea.left + chartArea.right) / 2;
            const centerY = (chartArea.top + chartArea.bottom) / 2;
            const animateScale = reset && animationOpts.animateScale;
            const innerRadius = animateScale ? 0 : this.innerRadius;
            const outerRadius = animateScale ? 0 : this.outerRadius;
            const { sharedOptions, includeOptions } = this._getSharedOptions(
                start2,
                mode
            );
            let startAngle = this._getRotation();
            let i;
            for (i = 0; i < start2; ++i) {
                startAngle += this._circumference(i, reset);
            }
            for (i = start2; i < start2 + count; ++i) {
                const circumference = this._circumference(i, reset);
                const arc = arcs[i];
                const properties = {
                    x: centerX + this.offsetX,
                    y: centerY + this.offsetY,
                    startAngle,
                    endAngle: startAngle + circumference,
                    circumference,
                    outerRadius,
                    innerRadius,
                };
                if (includeOptions) {
                    properties.options =
                        sharedOptions ||
                        this.resolveDataElementOptions(
                            i,
                            arc.active ? 'active' : mode
                        );
                }
                startAngle += circumference;
                this.updateElement(arc, i, properties, mode);
            }
        }
        calculateTotal() {
            const meta = this._cachedMeta;
            const metaData = meta.data;
            let total = 0;
            let i;
            for (i = 0; i < metaData.length; i++) {
                const value = meta._parsed[i];
                if (
                    value !== null &&
                    !isNaN(value) &&
                    this.chart.getDataVisibility(i) &&
                    !metaData[i].hidden
                ) {
                    total += Math.abs(value);
                }
            }
            return total;
        }
        calculateCircumference(value) {
            const total = this._cachedMeta.total;
            if (total > 0 && !isNaN(value)) {
                return TAU * (Math.abs(value) / total);
            }
            return 0;
        }
        getLabelAndValue(index3) {
            const meta = this._cachedMeta;
            const chart = this.chart;
            const labels = chart.data.labels || [];
            const value = formatNumber(
                meta._parsed[index3],
                chart.options.locale
            );
            return {
                label: labels[index3] || '',
                value,
            };
        }
        getMaxBorderWidth(arcs) {
            let max3 = 0;
            const chart = this.chart;
            let i, ilen, meta, controller, options;
            if (!arcs) {
                for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
                    if (chart.isDatasetVisible(i)) {
                        meta = chart.getDatasetMeta(i);
                        arcs = meta.data;
                        controller = meta.controller;
                        break;
                    }
                }
            }
            if (!arcs) {
                return 0;
            }
            for (i = 0, ilen = arcs.length; i < ilen; ++i) {
                options = controller.resolveDataElementOptions(i);
                if (options.borderAlign !== 'inner') {
                    max3 = Math.max(
                        max3,
                        options.borderWidth || 0,
                        options.hoverBorderWidth || 0
                    );
                }
            }
            return max3;
        }
        getMaxOffset(arcs) {
            let max3 = 0;
            for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
                const options = this.resolveDataElementOptions(i);
                max3 = Math.max(
                    max3,
                    options.offset || 0,
                    options.hoverOffset || 0
                );
            }
            return max3;
        }
        _getRingWeightOffset(datasetIndex) {
            let ringWeightOffset = 0;
            for (let i = 0; i < datasetIndex; ++i) {
                if (this.chart.isDatasetVisible(i)) {
                    ringWeightOffset += this._getRingWeight(i);
                }
            }
            return ringWeightOffset;
        }
        _getRingWeight(datasetIndex) {
            return Math.max(
                valueOrDefault(
                    this.chart.data.datasets[datasetIndex].weight,
                    1
                ),
                0
            );
        }
        _getVisibleDatasetWeightTotal() {
            return (
                this._getRingWeightOffset(this.chart.data.datasets.length) || 1
            );
        }
    };
    DoughnutController.id = 'doughnut';
    DoughnutController.defaults = {
        datasetElementType: false,
        dataElementType: 'arc',
        animation: {
            animateRotate: true,
            animateScale: false,
        },
        animations: {
            numbers: {
                type: 'number',
                properties: [
                    'circumference',
                    'endAngle',
                    'innerRadius',
                    'outerRadius',
                    'startAngle',
                    'x',
                    'y',
                    'offset',
                    'borderWidth',
                    'spacing',
                ],
            },
        },
        cutout: '50%',
        rotation: 0,
        circumference: 360,
        radius: '100%',
        spacing: 0,
        indexAxis: 'r',
    };
    DoughnutController.descriptors = {
        _scriptable: (name) => name !== 'spacing',
        _indexable: (name) => name !== 'spacing',
    };
    DoughnutController.overrides = {
        aspectRatio: 1,
        plugins: {
            legend: {
                labels: {
                    generateLabels(chart) {
                        const data = chart.data;
                        if (data.labels.length && data.datasets.length) {
                            const {
                                labels: { pointStyle },
                            } = chart.legend.options;
                            return data.labels.map((label, i) => {
                                const meta = chart.getDatasetMeta(0);
                                const style = meta.controller.getStyle(i);
                                return {
                                    text: label,
                                    fillStyle: style.backgroundColor,
                                    strokeStyle: style.borderColor,
                                    lineWidth: style.borderWidth,
                                    pointStyle,
                                    hidden: !chart.getDataVisibility(i),
                                    index: i,
                                };
                            });
                        }
                        return [];
                    },
                },
                onClick(e, legendItem, legend5) {
                    legend5.chart.toggleDataVisibility(legendItem.index);
                    legend5.chart.update();
                },
            },
            tooltip: {
                callbacks: {
                    title() {
                        return '';
                    },
                    label(tooltipItem) {
                        let dataLabel = tooltipItem.label;
                        const value = ': ' + tooltipItem.formattedValue;
                        if (isArray(dataLabel)) {
                            dataLabel = dataLabel.slice();
                            dataLabel[0] += value;
                        } else {
                            dataLabel += value;
                        }
                        return dataLabel;
                    },
                },
            },
        },
    };
    var LineController = class extends DatasetController {
        initialize() {
            this.enableOptionSharing = true;
            this.supportsDecimation = true;
            super.initialize();
        }
        update(mode) {
            const meta = this._cachedMeta;
            const { dataset: line, data: points = [], _dataset } = meta;
            const animationsDisabled = this.chart._animationsDisabled;
            let { start: start2, count } = _getStartAndCountOfVisiblePoints(
                meta,
                points,
                animationsDisabled
            );
            this._drawStart = start2;
            this._drawCount = count;
            if (_scaleRangesChanged(meta)) {
                start2 = 0;
                count = points.length;
            }
            line._chart = this.chart;
            line._datasetIndex = this.index;
            line._decimated = !!_dataset._decimated;
            line.points = points;
            const options = this.resolveDatasetElementOptions(mode);
            if (!this.options.showLine) {
                options.borderWidth = 0;
            }
            options.segment = this.options.segment;
            this.updateElement(
                line,
                void 0,
                {
                    animated: !animationsDisabled,
                    options,
                },
                mode
            );
            this.updateElements(points, start2, count, mode);
        }
        updateElements(points, start2, count, mode) {
            const reset = mode === 'reset';
            const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
            const { sharedOptions, includeOptions } = this._getSharedOptions(
                start2,
                mode
            );
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            const { spanGaps, segment } = this.options;
            const maxGapLength = isNumber(spanGaps)
                ? spanGaps
                : Number.POSITIVE_INFINITY;
            const directUpdate =
                this.chart._animationsDisabled || reset || mode === 'none';
            let prevParsed = start2 > 0 && this.getParsed(start2 - 1);
            for (let i = start2; i < start2 + count; ++i) {
                const point = points[i];
                const parsed = this.getParsed(i);
                const properties = directUpdate ? point : {};
                const nullData = isNullOrUndef(parsed[vAxis]);
                const iPixel = (properties[iAxis] = iScale.getPixelForValue(
                    parsed[iAxis],
                    i
                ));
                const vPixel = (properties[vAxis] =
                    reset || nullData
                        ? vScale.getBasePixel()
                        : vScale.getPixelForValue(
                              _stacked
                                  ? this.applyStack(vScale, parsed, _stacked)
                                  : parsed[vAxis],
                              i
                          ));
                properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
                properties.stop =
                    i > 0 &&
                    Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
                if (segment) {
                    properties.parsed = parsed;
                    properties.raw = _dataset.data[i];
                }
                if (includeOptions) {
                    properties.options =
                        sharedOptions ||
                        this.resolveDataElementOptions(
                            i,
                            point.active ? 'active' : mode
                        );
                }
                if (!directUpdate) {
                    this.updateElement(point, i, properties, mode);
                }
                prevParsed = parsed;
            }
        }
        getMaxOverflow() {
            const meta = this._cachedMeta;
            const dataset = meta.dataset;
            const border =
                (dataset.options && dataset.options.borderWidth) || 0;
            const data = meta.data || [];
            if (!data.length) {
                return border;
            }
            const firstPoint = data[0].size(this.resolveDataElementOptions(0));
            const lastPoint = data[data.length - 1].size(
                this.resolveDataElementOptions(data.length - 1)
            );
            return Math.max(border, firstPoint, lastPoint) / 2;
        }
        draw() {
            const meta = this._cachedMeta;
            meta.dataset.updateControlPoints(
                this.chart.chartArea,
                meta.iScale.axis
            );
            super.draw();
        }
    };
    LineController.id = 'line';
    LineController.defaults = {
        datasetElementType: 'line',
        dataElementType: 'point',
        showLine: true,
        spanGaps: false,
    };
    LineController.overrides = {
        scales: {
            _index_: {
                type: 'category',
            },
            _value_: {
                type: 'linear',
            },
        },
    };
    var PolarAreaController = class extends DatasetController {
        constructor(chart, datasetIndex) {
            super(chart, datasetIndex);
            this.innerRadius = void 0;
            this.outerRadius = void 0;
        }
        getLabelAndValue(index3) {
            const meta = this._cachedMeta;
            const chart = this.chart;
            const labels = chart.data.labels || [];
            const value = formatNumber(
                meta._parsed[index3].r,
                chart.options.locale
            );
            return {
                label: labels[index3] || '',
                value,
            };
        }
        parseObjectData(meta, data, start2, count) {
            return _parseObjectDataRadialScale.bind(this)(
                meta,
                data,
                start2,
                count
            );
        }
        update(mode) {
            const arcs = this._cachedMeta.data;
            this._updateRadius();
            this.updateElements(arcs, 0, arcs.length, mode);
        }
        getMinMax() {
            const meta = this._cachedMeta;
            const range = {
                min: Number.POSITIVE_INFINITY,
                max: Number.NEGATIVE_INFINITY,
            };
            meta.data.forEach((element, index3) => {
                const parsed = this.getParsed(index3).r;
                if (!isNaN(parsed) && this.chart.getDataVisibility(index3)) {
                    if (parsed < range.min) {
                        range.min = parsed;
                    }
                    if (parsed > range.max) {
                        range.max = parsed;
                    }
                }
            });
            return range;
        }
        _updateRadius() {
            const chart = this.chart;
            const chartArea = chart.chartArea;
            const opts = chart.options;
            const minSize = Math.min(
                chartArea.right - chartArea.left,
                chartArea.bottom - chartArea.top
            );
            const outerRadius = Math.max(minSize / 2, 0);
            const innerRadius = Math.max(
                opts.cutoutPercentage
                    ? (outerRadius / 100) * opts.cutoutPercentage
                    : 1,
                0
            );
            const radiusLength =
                (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
            this.outerRadius = outerRadius - radiusLength * this.index;
            this.innerRadius = this.outerRadius - radiusLength;
        }
        updateElements(arcs, start2, count, mode) {
            const reset = mode === 'reset';
            const chart = this.chart;
            const opts = chart.options;
            const animationOpts = opts.animation;
            const scale = this._cachedMeta.rScale;
            const centerX = scale.xCenter;
            const centerY = scale.yCenter;
            const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
            let angle = datasetStartAngle;
            let i;
            const defaultAngle = 360 / this.countVisibleElements();
            for (i = 0; i < start2; ++i) {
                angle += this._computeAngle(i, mode, defaultAngle);
            }
            for (i = start2; i < start2 + count; i++) {
                const arc = arcs[i];
                let startAngle = angle;
                let endAngle =
                    angle + this._computeAngle(i, mode, defaultAngle);
                let outerRadius = chart.getDataVisibility(i)
                    ? scale.getDistanceFromCenterForValue(this.getParsed(i).r)
                    : 0;
                angle = endAngle;
                if (reset) {
                    if (animationOpts.animateScale) {
                        outerRadius = 0;
                    }
                    if (animationOpts.animateRotate) {
                        startAngle = endAngle = datasetStartAngle;
                    }
                }
                const properties = {
                    x: centerX,
                    y: centerY,
                    innerRadius: 0,
                    outerRadius,
                    startAngle,
                    endAngle,
                    options: this.resolveDataElementOptions(
                        i,
                        arc.active ? 'active' : mode
                    ),
                };
                this.updateElement(arc, i, properties, mode);
            }
        }
        countVisibleElements() {
            const meta = this._cachedMeta;
            let count = 0;
            meta.data.forEach((element, index3) => {
                if (
                    !isNaN(this.getParsed(index3).r) &&
                    this.chart.getDataVisibility(index3)
                ) {
                    count++;
                }
            });
            return count;
        }
        _computeAngle(index3, mode, defaultAngle) {
            return this.chart.getDataVisibility(index3)
                ? toRadians(
                      this.resolveDataElementOptions(index3, mode).angle ||
                          defaultAngle
                  )
                : 0;
        }
    };
    PolarAreaController.id = 'polarArea';
    PolarAreaController.defaults = {
        dataElementType: 'arc',
        animation: {
            animateRotate: true,
            animateScale: true,
        },
        animations: {
            numbers: {
                type: 'number',
                properties: [
                    'x',
                    'y',
                    'startAngle',
                    'endAngle',
                    'innerRadius',
                    'outerRadius',
                ],
            },
        },
        indexAxis: 'r',
        startAngle: 0,
    };
    PolarAreaController.overrides = {
        aspectRatio: 1,
        plugins: {
            legend: {
                labels: {
                    generateLabels(chart) {
                        const data = chart.data;
                        if (data.labels.length && data.datasets.length) {
                            const {
                                labels: { pointStyle },
                            } = chart.legend.options;
                            return data.labels.map((label, i) => {
                                const meta = chart.getDatasetMeta(0);
                                const style = meta.controller.getStyle(i);
                                return {
                                    text: label,
                                    fillStyle: style.backgroundColor,
                                    strokeStyle: style.borderColor,
                                    lineWidth: style.borderWidth,
                                    pointStyle,
                                    hidden: !chart.getDataVisibility(i),
                                    index: i,
                                };
                            });
                        }
                        return [];
                    },
                },
                onClick(e, legendItem, legend5) {
                    legend5.chart.toggleDataVisibility(legendItem.index);
                    legend5.chart.update();
                },
            },
            tooltip: {
                callbacks: {
                    title() {
                        return '';
                    },
                    label(context) {
                        return (
                            context.chart.data.labels[context.dataIndex] +
                            ': ' +
                            context.formattedValue
                        );
                    },
                },
            },
        },
        scales: {
            r: {
                type: 'radialLinear',
                angleLines: {
                    display: false,
                },
                beginAtZero: true,
                grid: {
                    circular: true,
                },
                pointLabels: {
                    display: false,
                },
                startAngle: 0,
            },
        },
    };
    var PieController = class extends DoughnutController {};
    PieController.id = 'pie';
    PieController.defaults = {
        cutout: 0,
        rotation: 0,
        circumference: 360,
        radius: '100%',
    };
    var RadarController = class extends DatasetController {
        getLabelAndValue(index3) {
            const vScale = this._cachedMeta.vScale;
            const parsed = this.getParsed(index3);
            return {
                label: vScale.getLabels()[index3],
                value: '' + vScale.getLabelForValue(parsed[vScale.axis]),
            };
        }
        parseObjectData(meta, data, start2, count) {
            return _parseObjectDataRadialScale.bind(this)(
                meta,
                data,
                start2,
                count
            );
        }
        update(mode) {
            const meta = this._cachedMeta;
            const line = meta.dataset;
            const points = meta.data || [];
            const labels = meta.iScale.getLabels();
            line.points = points;
            if (mode !== 'resize') {
                const options = this.resolveDatasetElementOptions(mode);
                if (!this.options.showLine) {
                    options.borderWidth = 0;
                }
                const properties = {
                    _loop: true,
                    _fullLoop: labels.length === points.length,
                    options,
                };
                this.updateElement(line, void 0, properties, mode);
            }
            this.updateElements(points, 0, points.length, mode);
        }
        updateElements(points, start2, count, mode) {
            const scale = this._cachedMeta.rScale;
            const reset = mode === 'reset';
            for (let i = start2; i < start2 + count; i++) {
                const point = points[i];
                const options = this.resolveDataElementOptions(
                    i,
                    point.active ? 'active' : mode
                );
                const pointPosition = scale.getPointPositionForValue(
                    i,
                    this.getParsed(i).r
                );
                const x = reset ? scale.xCenter : pointPosition.x;
                const y = reset ? scale.yCenter : pointPosition.y;
                const properties = {
                    x,
                    y,
                    angle: pointPosition.angle,
                    skip: isNaN(x) || isNaN(y),
                    options,
                };
                this.updateElement(point, i, properties, mode);
            }
        }
    };
    RadarController.id = 'radar';
    RadarController.defaults = {
        datasetElementType: 'line',
        dataElementType: 'point',
        indexAxis: 'r',
        showLine: true,
        elements: {
            line: {
                fill: 'start',
            },
        },
    };
    RadarController.overrides = {
        aspectRatio: 1,
        scales: {
            r: {
                type: 'radialLinear',
            },
        },
    };
    var Element = class {
        constructor() {
            this.x = void 0;
            this.y = void 0;
            this.active = false;
            this.options = void 0;
            this.$animations = void 0;
        }
        tooltipPosition(useFinalPosition) {
            const { x, y } = this.getProps(['x', 'y'], useFinalPosition);
            return { x, y };
        }
        hasValue() {
            return isNumber(this.x) && isNumber(this.y);
        }
        getProps(props, final) {
            const anims = this.$animations;
            if (!final || !anims) {
                return this;
            }
            const ret = {};
            props.forEach((prop) => {
                ret[prop] =
                    anims[prop] && anims[prop].active()
                        ? anims[prop]._to
                        : this[prop];
            });
            return ret;
        }
    };
    Element.defaults = {};
    Element.defaultRoutes = void 0;
    var formatters = {
        values(value) {
            return isArray(value) ? value : '' + value;
        },
        numeric(tickValue, index3, ticks) {
            if (tickValue === 0) {
                return '0';
            }
            const locale2 = this.chart.options.locale;
            let notation;
            let delta = tickValue;
            if (ticks.length > 1) {
                const maxTick = Math.max(
                    Math.abs(ticks[0].value),
                    Math.abs(ticks[ticks.length - 1].value)
                );
                if (maxTick < 1e-4 || maxTick > 1e15) {
                    notation = 'scientific';
                }
                delta = calculateDelta(tickValue, ticks);
            }
            const logDelta = log10(Math.abs(delta));
            const numDecimal = Math.max(
                Math.min(-1 * Math.floor(logDelta), 20),
                0
            );
            const options = {
                notation,
                minimumFractionDigits: numDecimal,
                maximumFractionDigits: numDecimal,
            };
            Object.assign(options, this.options.ticks.format);
            return formatNumber(tickValue, locale2, options);
        },
        logarithmic(tickValue, index3, ticks) {
            if (tickValue === 0) {
                return '0';
            }
            const remain =
                tickValue / Math.pow(10, Math.floor(log10(tickValue)));
            if (remain === 1 || remain === 2 || remain === 5) {
                return formatters.numeric.call(this, tickValue, index3, ticks);
            }
            return '';
        },
    };
    function calculateDelta(tickValue, ticks) {
        let delta =
            ticks.length > 3
                ? ticks[2].value - ticks[1].value
                : ticks[1].value - ticks[0].value;
        if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
            delta = tickValue - Math.floor(tickValue);
        }
        return delta;
    }
    var Ticks = { formatters };
    defaults.set('scale', {
        display: true,
        offset: false,
        reverse: false,
        beginAtZero: false,
        bounds: 'ticks',
        grace: 0,
        grid: {
            display: true,
            lineWidth: 1,
            drawBorder: true,
            drawOnChartArea: true,
            drawTicks: true,
            tickLength: 8,
            tickWidth: (_ctx, options) => options.lineWidth,
            tickColor: (_ctx, options) => options.color,
            offset: false,
            borderDash: [],
            borderDashOffset: 0,
            borderWidth: 1,
        },
        title: {
            display: false,
            text: '',
            padding: {
                top: 4,
                bottom: 4,
            },
        },
        ticks: {
            minRotation: 0,
            maxRotation: 50,
            mirror: false,
            textStrokeWidth: 0,
            textStrokeColor: '',
            padding: 3,
            display: true,
            autoSkip: true,
            autoSkipPadding: 3,
            labelOffset: 0,
            callback: Ticks.formatters.values,
            minor: {},
            major: {},
            align: 'center',
            crossAlign: 'near',
            showLabelBackdrop: false,
            backdropColor: 'rgba(255, 255, 255, 0.75)',
            backdropPadding: 2,
        },
    });
    defaults.route('scale.ticks', 'color', '', 'color');
    defaults.route('scale.grid', 'color', '', 'borderColor');
    defaults.route('scale.grid', 'borderColor', '', 'borderColor');
    defaults.route('scale.title', 'color', '', 'color');
    defaults.describe('scale', {
        _fallback: false,
        _scriptable: (name) =>
            !name.startsWith('before') &&
            !name.startsWith('after') &&
            name !== 'callback' &&
            name !== 'parser',
        _indexable: (name) =>
            name !== 'borderDash' && name !== 'tickBorderDash',
    });
    defaults.describe('scales', {
        _fallback: 'scale',
    });
    defaults.describe('scale.ticks', {
        _scriptable: (name) =>
            name !== 'backdropPadding' && name !== 'callback',
        _indexable: (name) => name !== 'backdropPadding',
    });
    function autoSkip(scale, ticks) {
        const tickOpts = scale.options.ticks;
        const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);
        const majorIndices = tickOpts.major.enabled
            ? getMajorIndices(ticks)
            : [];
        const numMajorIndices = majorIndices.length;
        const first = majorIndices[0];
        const last = majorIndices[numMajorIndices - 1];
        const newTicks = [];
        if (numMajorIndices > ticksLimit) {
            skipMajors(
                ticks,
                newTicks,
                majorIndices,
                numMajorIndices / ticksLimit
            );
            return newTicks;
        }
        const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
        if (numMajorIndices > 0) {
            let i, ilen;
            const avgMajorSpacing =
                numMajorIndices > 1
                    ? Math.round((last - first) / (numMajorIndices - 1))
                    : null;
            skip(
                ticks,
                newTicks,
                spacing,
                isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing,
                first
            );
            for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
                skip(
                    ticks,
                    newTicks,
                    spacing,
                    majorIndices[i],
                    majorIndices[i + 1]
                );
            }
            skip(
                ticks,
                newTicks,
                spacing,
                last,
                isNullOrUndef(avgMajorSpacing)
                    ? ticks.length
                    : last + avgMajorSpacing
            );
            return newTicks;
        }
        skip(ticks, newTicks, spacing);
        return newTicks;
    }
    function determineMaxTicks(scale) {
        const offset = scale.options.offset;
        const tickLength = scale._tickSize();
        const maxScale = scale._length / tickLength + (offset ? 0 : 1);
        const maxChart = scale._maxLength / tickLength;
        return Math.floor(Math.min(maxScale, maxChart));
    }
    function calculateSpacing(majorIndices, ticks, ticksLimit) {
        const evenMajorSpacing = getEvenSpacing(majorIndices);
        const spacing = ticks.length / ticksLimit;
        if (!evenMajorSpacing) {
            return Math.max(spacing, 1);
        }
        const factors = _factorize(evenMajorSpacing);
        for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
            const factor = factors[i];
            if (factor > spacing) {
                return factor;
            }
        }
        return Math.max(spacing, 1);
    }
    function getMajorIndices(ticks) {
        const result = [];
        let i, ilen;
        for (i = 0, ilen = ticks.length; i < ilen; i++) {
            if (ticks[i].major) {
                result.push(i);
            }
        }
        return result;
    }
    function skipMajors(ticks, newTicks, majorIndices, spacing) {
        let count = 0;
        let next = majorIndices[0];
        let i;
        spacing = Math.ceil(spacing);
        for (i = 0; i < ticks.length; i++) {
            if (i === next) {
                newTicks.push(ticks[i]);
                count++;
                next = majorIndices[count * spacing];
            }
        }
    }
    function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
        const start2 = valueOrDefault(majorStart, 0);
        const end = Math.min(
            valueOrDefault(majorEnd, ticks.length),
            ticks.length
        );
        let count = 0;
        let length, i, next;
        spacing = Math.ceil(spacing);
        if (majorEnd) {
            length = majorEnd - majorStart;
            spacing = length / Math.floor(length / spacing);
        }
        next = start2;
        while (next < 0) {
            count++;
            next = Math.round(start2 + count * spacing);
        }
        for (i = Math.max(start2, 0); i < end; i++) {
            if (i === next) {
                newTicks.push(ticks[i]);
                count++;
                next = Math.round(start2 + count * spacing);
            }
        }
    }
    function getEvenSpacing(arr) {
        const len = arr.length;
        let i, diff;
        if (len < 2) {
            return false;
        }
        for (diff = arr[0], i = 1; i < len; ++i) {
            if (arr[i] - arr[i - 1] !== diff) {
                return false;
            }
        }
        return diff;
    }
    var reverseAlign = (align) =>
        align === 'left' ? 'right' : align === 'right' ? 'left' : align;
    var offsetFromEdge = (scale, edge, offset) =>
        edge === 'top' || edge === 'left'
            ? scale[edge] + offset
            : scale[edge] - offset;
    function sample(arr, numItems) {
        const result = [];
        const increment = arr.length / numItems;
        const len = arr.length;
        let i = 0;
        for (; i < len; i += increment) {
            result.push(arr[Math.floor(i)]);
        }
        return result;
    }
    function getPixelForGridLine(scale, index3, offsetGridLines) {
        const length = scale.ticks.length;
        const validIndex2 = Math.min(index3, length - 1);
        const start2 = scale._startPixel;
        const end = scale._endPixel;
        const epsilon = 1e-6;
        let lineValue = scale.getPixelForTick(validIndex2);
        let offset;
        if (offsetGridLines) {
            if (length === 1) {
                offset = Math.max(lineValue - start2, end - lineValue);
            } else if (index3 === 0) {
                offset = (scale.getPixelForTick(1) - lineValue) / 2;
            } else {
                offset =
                    (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
            }
            lineValue += validIndex2 < index3 ? offset : -offset;
            if (lineValue < start2 - epsilon || lineValue > end + epsilon) {
                return;
            }
        }
        return lineValue;
    }
    function garbageCollect(caches, length) {
        each(caches, (cache) => {
            const gc = cache.gc;
            const gcLen = gc.length / 2;
            let i;
            if (gcLen > length) {
                for (i = 0; i < gcLen; ++i) {
                    delete cache.data[gc[i]];
                }
                gc.splice(0, gcLen);
            }
        });
    }
    function getTickMarkLength(options) {
        return options.drawTicks ? options.tickLength : 0;
    }
    function getTitleHeight(options, fallback) {
        if (!options.display) {
            return 0;
        }
        const font = toFont(options.font, fallback);
        const padding = toPadding(options.padding);
        const lines = isArray(options.text) ? options.text.length : 1;
        return lines * font.lineHeight + padding.height;
    }
    function createScaleContext(parent, scale) {
        return createContext(parent, {
            scale,
            type: 'scale',
        });
    }
    function createTickContext(parent, index3, tick) {
        return createContext(parent, {
            tick,
            index: index3,
            type: 'tick',
        });
    }
    function titleAlign(align, position, reverse) {
        let ret = _toLeftRightCenter(align);
        if (
            (reverse && position !== 'right') ||
            (!reverse && position === 'right')
        ) {
            ret = reverseAlign(ret);
        }
        return ret;
    }
    function titleArgs(scale, offset, position, align) {
        const { top, left, bottom, right, chart } = scale;
        const { chartArea, scales: scales2 } = chart;
        let rotation = 0;
        let maxWidth, titleX, titleY;
        const height = bottom - top;
        const width = right - left;
        if (scale.isHorizontal()) {
            titleX = _alignStartEnd(align, left, right);
            if (isObject(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                titleY =
                    scales2[positionAxisID].getPixelForValue(value) +
                    height -
                    offset;
            } else if (position === 'center') {
                titleY =
                    (chartArea.bottom + chartArea.top) / 2 + height - offset;
            } else {
                titleY = offsetFromEdge(scale, position, offset);
            }
            maxWidth = right - left;
        } else {
            if (isObject(position)) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                titleX =
                    scales2[positionAxisID].getPixelForValue(value) -
                    width +
                    offset;
            } else if (position === 'center') {
                titleX =
                    (chartArea.left + chartArea.right) / 2 - width + offset;
            } else {
                titleX = offsetFromEdge(scale, position, offset);
            }
            titleY = _alignStartEnd(align, bottom, top);
            rotation = position === 'left' ? -HALF_PI : HALF_PI;
        }
        return { titleX, titleY, maxWidth, rotation };
    }
    var Scale = class _Scale extends Element {
        constructor(cfg) {
            super();
            this.id = cfg.id;
            this.type = cfg.type;
            this.options = void 0;
            this.ctx = cfg.ctx;
            this.chart = cfg.chart;
            this.top = void 0;
            this.bottom = void 0;
            this.left = void 0;
            this.right = void 0;
            this.width = void 0;
            this.height = void 0;
            this._margins = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0,
            };
            this.maxWidth = void 0;
            this.maxHeight = void 0;
            this.paddingTop = void 0;
            this.paddingBottom = void 0;
            this.paddingLeft = void 0;
            this.paddingRight = void 0;
            this.axis = void 0;
            this.labelRotation = void 0;
            this.min = void 0;
            this.max = void 0;
            this._range = void 0;
            this.ticks = [];
            this._gridLineItems = null;
            this._labelItems = null;
            this._labelSizes = null;
            this._length = 0;
            this._maxLength = 0;
            this._longestTextCache = {};
            this._startPixel = void 0;
            this._endPixel = void 0;
            this._reversePixels = false;
            this._userMax = void 0;
            this._userMin = void 0;
            this._suggestedMax = void 0;
            this._suggestedMin = void 0;
            this._ticksLength = 0;
            this._borderValue = 0;
            this._cache = {};
            this._dataLimitsCached = false;
            this.$context = void 0;
        }
        init(options) {
            this.options = options.setContext(this.getContext());
            this.axis = options.axis;
            this._userMin = this.parse(options.min);
            this._userMax = this.parse(options.max);
            this._suggestedMin = this.parse(options.suggestedMin);
            this._suggestedMax = this.parse(options.suggestedMax);
        }
        parse(raw, index3) {
            return raw;
        }
        getUserBounds() {
            let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
            _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
            _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
            _suggestedMin = finiteOrDefault(
                _suggestedMin,
                Number.POSITIVE_INFINITY
            );
            _suggestedMax = finiteOrDefault(
                _suggestedMax,
                Number.NEGATIVE_INFINITY
            );
            return {
                min: finiteOrDefault(_userMin, _suggestedMin),
                max: finiteOrDefault(_userMax, _suggestedMax),
                minDefined: isNumberFinite(_userMin),
                maxDefined: isNumberFinite(_userMax),
            };
        }
        getMinMax(canStack) {
            let {
                min: min3,
                max: max3,
                minDefined,
                maxDefined,
            } = this.getUserBounds();
            let range;
            if (minDefined && maxDefined) {
                return { min: min3, max: max3 };
            }
            const metas = this.getMatchingVisibleMetas();
            for (let i = 0, ilen = metas.length; i < ilen; ++i) {
                range = metas[i].controller.getMinMax(this, canStack);
                if (!minDefined) {
                    min3 = Math.min(min3, range.min);
                }
                if (!maxDefined) {
                    max3 = Math.max(max3, range.max);
                }
            }
            min3 = maxDefined && min3 > max3 ? max3 : min3;
            max3 = minDefined && min3 > max3 ? min3 : max3;
            return {
                min: finiteOrDefault(min3, finiteOrDefault(max3, min3)),
                max: finiteOrDefault(max3, finiteOrDefault(min3, max3)),
            };
        }
        getPadding() {
            return {
                left: this.paddingLeft || 0,
                top: this.paddingTop || 0,
                right: this.paddingRight || 0,
                bottom: this.paddingBottom || 0,
            };
        }
        getTicks() {
            return this.ticks;
        }
        getLabels() {
            const data = this.chart.data;
            return (
                this.options.labels ||
                (this.isHorizontal() ? data.xLabels : data.yLabels) ||
                data.labels ||
                []
            );
        }
        beforeLayout() {
            this._cache = {};
            this._dataLimitsCached = false;
        }
        beforeUpdate() {
            callback(this.options.beforeUpdate, [this]);
        }
        update(maxWidth, maxHeight, margins) {
            const { beginAtZero, grace, ticks: tickOpts } = this.options;
            const sampleSize = tickOpts.sampleSize;
            this.beforeUpdate();
            this.maxWidth = maxWidth;
            this.maxHeight = maxHeight;
            this._margins = margins = Object.assign(
                {
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0,
                },
                margins
            );
            this.ticks = null;
            this._labelSizes = null;
            this._gridLineItems = null;
            this._labelItems = null;
            this.beforeSetDimensions();
            this.setDimensions();
            this.afterSetDimensions();
            this._maxLength = this.isHorizontal()
                ? this.width + margins.left + margins.right
                : this.height + margins.top + margins.bottom;
            if (!this._dataLimitsCached) {
                this.beforeDataLimits();
                this.determineDataLimits();
                this.afterDataLimits();
                this._range = _addGrace(this, grace, beginAtZero);
                this._dataLimitsCached = true;
            }
            this.beforeBuildTicks();
            this.ticks = this.buildTicks() || [];
            this.afterBuildTicks();
            const samplingEnabled = sampleSize < this.ticks.length;
            this._convertTicksToLabels(
                samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks
            );
            this.configure();
            this.beforeCalculateLabelRotation();
            this.calculateLabelRotation();
            this.afterCalculateLabelRotation();
            if (
                tickOpts.display &&
                (tickOpts.autoSkip || tickOpts.source === 'auto')
            ) {
                this.ticks = autoSkip(this, this.ticks);
                this._labelSizes = null;
                this.afterAutoSkip();
            }
            if (samplingEnabled) {
                this._convertTicksToLabels(this.ticks);
            }
            this.beforeFit();
            this.fit();
            this.afterFit();
            this.afterUpdate();
        }
        configure() {
            let reversePixels = this.options.reverse;
            let startPixel, endPixel;
            if (this.isHorizontal()) {
                startPixel = this.left;
                endPixel = this.right;
            } else {
                startPixel = this.top;
                endPixel = this.bottom;
                reversePixels = !reversePixels;
            }
            this._startPixel = startPixel;
            this._endPixel = endPixel;
            this._reversePixels = reversePixels;
            this._length = endPixel - startPixel;
            this._alignToPixels = this.options.alignToPixels;
        }
        afterUpdate() {
            callback(this.options.afterUpdate, [this]);
        }
        beforeSetDimensions() {
            callback(this.options.beforeSetDimensions, [this]);
        }
        setDimensions() {
            if (this.isHorizontal()) {
                this.width = this.maxWidth;
                this.left = 0;
                this.right = this.width;
            } else {
                this.height = this.maxHeight;
                this.top = 0;
                this.bottom = this.height;
            }
            this.paddingLeft = 0;
            this.paddingTop = 0;
            this.paddingRight = 0;
            this.paddingBottom = 0;
        }
        afterSetDimensions() {
            callback(this.options.afterSetDimensions, [this]);
        }
        _callHooks(name) {
            this.chart.notifyPlugins(name, this.getContext());
            callback(this.options[name], [this]);
        }
        beforeDataLimits() {
            this._callHooks('beforeDataLimits');
        }
        determineDataLimits() {}
        afterDataLimits() {
            this._callHooks('afterDataLimits');
        }
        beforeBuildTicks() {
            this._callHooks('beforeBuildTicks');
        }
        buildTicks() {
            return [];
        }
        afterBuildTicks() {
            this._callHooks('afterBuildTicks');
        }
        beforeTickToLabelConversion() {
            callback(this.options.beforeTickToLabelConversion, [this]);
        }
        generateTickLabels(ticks) {
            const tickOpts = this.options.ticks;
            let i, ilen, tick;
            for (i = 0, ilen = ticks.length; i < ilen; i++) {
                tick = ticks[i];
                tick.label = callback(
                    tickOpts.callback,
                    [tick.value, i, ticks],
                    this
                );
            }
        }
        afterTickToLabelConversion() {
            callback(this.options.afterTickToLabelConversion, [this]);
        }
        beforeCalculateLabelRotation() {
            callback(this.options.beforeCalculateLabelRotation, [this]);
        }
        calculateLabelRotation() {
            const options = this.options;
            const tickOpts = options.ticks;
            const numTicks = this.ticks.length;
            const minRotation = tickOpts.minRotation || 0;
            const maxRotation = tickOpts.maxRotation;
            let labelRotation = minRotation;
            let tickWidth, maxHeight, maxLabelDiagonal;
            if (
                !this._isVisible() ||
                !tickOpts.display ||
                minRotation >= maxRotation ||
                numTicks <= 1 ||
                !this.isHorizontal()
            ) {
                this.labelRotation = minRotation;
                return;
            }
            const labelSizes = this._getLabelSizes();
            const maxLabelWidth = labelSizes.widest.width;
            const maxLabelHeight = labelSizes.highest.height;
            const maxWidth = _limitValue(
                this.chart.width - maxLabelWidth,
                0,
                this.maxWidth
            );
            tickWidth = options.offset
                ? this.maxWidth / numTicks
                : maxWidth / (numTicks - 1);
            if (maxLabelWidth + 6 > tickWidth) {
                tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
                maxHeight =
                    this.maxHeight -
                    getTickMarkLength(options.grid) -
                    tickOpts.padding -
                    getTitleHeight(options.title, this.chart.options.font);
                maxLabelDiagonal = Math.sqrt(
                    maxLabelWidth * maxLabelWidth +
                        maxLabelHeight * maxLabelHeight
                );
                labelRotation = toDegrees(
                    Math.min(
                        Math.asin(
                            _limitValue(
                                (labelSizes.highest.height + 6) / tickWidth,
                                -1,
                                1
                            )
                        ),
                        Math.asin(
                            _limitValue(maxHeight / maxLabelDiagonal, -1, 1)
                        ) -
                            Math.asin(
                                _limitValue(
                                    maxLabelHeight / maxLabelDiagonal,
                                    -1,
                                    1
                                )
                            )
                    )
                );
                labelRotation = Math.max(
                    minRotation,
                    Math.min(maxRotation, labelRotation)
                );
            }
            this.labelRotation = labelRotation;
        }
        afterCalculateLabelRotation() {
            callback(this.options.afterCalculateLabelRotation, [this]);
        }
        afterAutoSkip() {}
        beforeFit() {
            callback(this.options.beforeFit, [this]);
        }
        fit() {
            const minSize = {
                width: 0,
                height: 0,
            };
            const {
                chart,
                options: { ticks: tickOpts, title: titleOpts, grid: gridOpts },
            } = this;
            const display = this._isVisible();
            const isHorizontal = this.isHorizontal();
            if (display) {
                const titleHeight = getTitleHeight(
                    titleOpts,
                    chart.options.font
                );
                if (isHorizontal) {
                    minSize.width = this.maxWidth;
                    minSize.height = getTickMarkLength(gridOpts) + titleHeight;
                } else {
                    minSize.height = this.maxHeight;
                    minSize.width = getTickMarkLength(gridOpts) + titleHeight;
                }
                if (tickOpts.display && this.ticks.length) {
                    const { first, last, widest, highest } =
                        this._getLabelSizes();
                    const tickPadding = tickOpts.padding * 2;
                    const angleRadians = toRadians(this.labelRotation);
                    const cos = Math.cos(angleRadians);
                    const sin = Math.sin(angleRadians);
                    if (isHorizontal) {
                        const labelHeight = tickOpts.mirror
                            ? 0
                            : sin * widest.width + cos * highest.height;
                        minSize.height = Math.min(
                            this.maxHeight,
                            minSize.height + labelHeight + tickPadding
                        );
                    } else {
                        const labelWidth = tickOpts.mirror
                            ? 0
                            : cos * widest.width + sin * highest.height;
                        minSize.width = Math.min(
                            this.maxWidth,
                            minSize.width + labelWidth + tickPadding
                        );
                    }
                    this._calculatePadding(first, last, sin, cos);
                }
            }
            this._handleMargins();
            if (isHorizontal) {
                this.width = this._length =
                    chart.width - this._margins.left - this._margins.right;
                this.height = minSize.height;
            } else {
                this.width = minSize.width;
                this.height = this._length =
                    chart.height - this._margins.top - this._margins.bottom;
            }
        }
        _calculatePadding(first, last, sin, cos) {
            const {
                ticks: { align, padding },
                position,
            } = this.options;
            const isRotated = this.labelRotation !== 0;
            const labelsBelowTicks = position !== 'top' && this.axis === 'x';
            if (this.isHorizontal()) {
                const offsetLeft = this.getPixelForTick(0) - this.left;
                const offsetRight =
                    this.right - this.getPixelForTick(this.ticks.length - 1);
                let paddingLeft = 0;
                let paddingRight = 0;
                if (isRotated) {
                    if (labelsBelowTicks) {
                        paddingLeft = cos * first.width;
                        paddingRight = sin * last.height;
                    } else {
                        paddingLeft = sin * first.height;
                        paddingRight = cos * last.width;
                    }
                } else if (align === 'start') {
                    paddingRight = last.width;
                } else if (align === 'end') {
                    paddingLeft = first.width;
                } else if (align !== 'inner') {
                    paddingLeft = first.width / 2;
                    paddingRight = last.width / 2;
                }
                this.paddingLeft = Math.max(
                    ((paddingLeft - offsetLeft + padding) * this.width) /
                        (this.width - offsetLeft),
                    0
                );
                this.paddingRight = Math.max(
                    ((paddingRight - offsetRight + padding) * this.width) /
                        (this.width - offsetRight),
                    0
                );
            } else {
                let paddingTop = last.height / 2;
                let paddingBottom = first.height / 2;
                if (align === 'start') {
                    paddingTop = 0;
                    paddingBottom = first.height;
                } else if (align === 'end') {
                    paddingTop = last.height;
                    paddingBottom = 0;
                }
                this.paddingTop = paddingTop + padding;
                this.paddingBottom = paddingBottom + padding;
            }
        }
        _handleMargins() {
            if (this._margins) {
                this._margins.left = Math.max(
                    this.paddingLeft,
                    this._margins.left
                );
                this._margins.top = Math.max(
                    this.paddingTop,
                    this._margins.top
                );
                this._margins.right = Math.max(
                    this.paddingRight,
                    this._margins.right
                );
                this._margins.bottom = Math.max(
                    this.paddingBottom,
                    this._margins.bottom
                );
            }
        }
        afterFit() {
            callback(this.options.afterFit, [this]);
        }
        isHorizontal() {
            const { axis, position } = this.options;
            return position === 'top' || position === 'bottom' || axis === 'x';
        }
        isFullSize() {
            return this.options.fullSize;
        }
        _convertTicksToLabels(ticks) {
            this.beforeTickToLabelConversion();
            this.generateTickLabels(ticks);
            let i, ilen;
            for (i = 0, ilen = ticks.length; i < ilen; i++) {
                if (isNullOrUndef(ticks[i].label)) {
                    ticks.splice(i, 1);
                    ilen--;
                    i--;
                }
            }
            this.afterTickToLabelConversion();
        }
        _getLabelSizes() {
            let labelSizes = this._labelSizes;
            if (!labelSizes) {
                const sampleSize = this.options.ticks.sampleSize;
                let ticks = this.ticks;
                if (sampleSize < ticks.length) {
                    ticks = sample(ticks, sampleSize);
                }
                this._labelSizes = labelSizes = this._computeLabelSizes(
                    ticks,
                    ticks.length
                );
            }
            return labelSizes;
        }
        _computeLabelSizes(ticks, length) {
            const { ctx, _longestTextCache: caches } = this;
            const widths = [];
            const heights = [];
            let widestLabelSize = 0;
            let highestLabelSize = 0;
            let i,
                j,
                jlen,
                label,
                tickFont,
                fontString2,
                cache,
                lineHeight,
                width,
                height,
                nestedLabel;
            for (i = 0; i < length; ++i) {
                label = ticks[i].label;
                tickFont = this._resolveTickFontOptions(i);
                ctx.font = fontString2 = tickFont.string;
                cache = caches[fontString2] = caches[fontString2] || {
                    data: {},
                    gc: [],
                };
                lineHeight = tickFont.lineHeight;
                width = height = 0;
                if (!isNullOrUndef(label) && !isArray(label)) {
                    width = _measureText(
                        ctx,
                        cache.data,
                        cache.gc,
                        width,
                        label
                    );
                    height = lineHeight;
                } else if (isArray(label)) {
                    for (j = 0, jlen = label.length; j < jlen; ++j) {
                        nestedLabel = label[j];
                        if (
                            !isNullOrUndef(nestedLabel) &&
                            !isArray(nestedLabel)
                        ) {
                            width = _measureText(
                                ctx,
                                cache.data,
                                cache.gc,
                                width,
                                nestedLabel
                            );
                            height += lineHeight;
                        }
                    }
                }
                widths.push(width);
                heights.push(height);
                widestLabelSize = Math.max(width, widestLabelSize);
                highestLabelSize = Math.max(height, highestLabelSize);
            }
            garbageCollect(caches, length);
            const widest = widths.indexOf(widestLabelSize);
            const highest = heights.indexOf(highestLabelSize);
            const valueAt = (idx) => ({
                width: widths[idx] || 0,
                height: heights[idx] || 0,
            });
            return {
                first: valueAt(0),
                last: valueAt(length - 1),
                widest: valueAt(widest),
                highest: valueAt(highest),
                widths,
                heights,
            };
        }
        getLabelForValue(value) {
            return value;
        }
        getPixelForValue(value, index3) {
            return NaN;
        }
        getValueForPixel(pixel) {}
        getPixelForTick(index3) {
            const ticks = this.ticks;
            if (index3 < 0 || index3 > ticks.length - 1) {
                return null;
            }
            return this.getPixelForValue(ticks[index3].value);
        }
        getPixelForDecimal(decimal) {
            if (this._reversePixels) {
                decimal = 1 - decimal;
            }
            const pixel = this._startPixel + decimal * this._length;
            return _int16Range(
                this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel
            );
        }
        getDecimalForPixel(pixel) {
            const decimal = (pixel - this._startPixel) / this._length;
            return this._reversePixels ? 1 - decimal : decimal;
        }
        getBasePixel() {
            return this.getPixelForValue(this.getBaseValue());
        }
        getBaseValue() {
            const { min: min3, max: max3 } = this;
            return min3 < 0 && max3 < 0
                ? max3
                : min3 > 0 && max3 > 0
                ? min3
                : 0;
        }
        getContext(index3) {
            const ticks = this.ticks || [];
            if (index3 >= 0 && index3 < ticks.length) {
                const tick = ticks[index3];
                return (
                    tick.$context ||
                    (tick.$context = createTickContext(
                        this.getContext(),
                        index3,
                        tick
                    ))
                );
            }
            return (
                this.$context ||
                (this.$context = createScaleContext(
                    this.chart.getContext(),
                    this
                ))
            );
        }
        _tickSize() {
            const optionTicks = this.options.ticks;
            const rot = toRadians(this.labelRotation);
            const cos = Math.abs(Math.cos(rot));
            const sin = Math.abs(Math.sin(rot));
            const labelSizes = this._getLabelSizes();
            const padding = optionTicks.autoSkipPadding || 0;
            const w = labelSizes ? labelSizes.widest.width + padding : 0;
            const h = labelSizes ? labelSizes.highest.height + padding : 0;
            return this.isHorizontal()
                ? h * cos > w * sin
                    ? w / cos
                    : h / sin
                : h * sin < w * cos
                ? h / cos
                : w / sin;
        }
        _isVisible() {
            const display = this.options.display;
            if (display !== 'auto') {
                return !!display;
            }
            return this.getMatchingVisibleMetas().length > 0;
        }
        _computeGridLineItems(chartArea) {
            const axis = this.axis;
            const chart = this.chart;
            const options = this.options;
            const { grid, position } = options;
            const offset = grid.offset;
            const isHorizontal = this.isHorizontal();
            const ticks = this.ticks;
            const ticksLength = ticks.length + (offset ? 1 : 0);
            const tl = getTickMarkLength(grid);
            const items = [];
            const borderOpts = grid.setContext(this.getContext());
            const axisWidth = borderOpts.drawBorder
                ? borderOpts.borderWidth
                : 0;
            const axisHalfWidth = axisWidth / 2;
            const alignBorderValue = function (pixel) {
                return _alignPixel(chart, pixel, axisWidth);
            };
            let borderValue, i, lineValue, alignedLineValue;
            let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
            if (position === 'top') {
                borderValue = alignBorderValue(this.bottom);
                ty1 = this.bottom - tl;
                ty2 = borderValue - axisHalfWidth;
                y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
                y2 = chartArea.bottom;
            } else if (position === 'bottom') {
                borderValue = alignBorderValue(this.top);
                y1 = chartArea.top;
                y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
                ty1 = borderValue + axisHalfWidth;
                ty2 = this.top + tl;
            } else if (position === 'left') {
                borderValue = alignBorderValue(this.right);
                tx1 = this.right - tl;
                tx2 = borderValue - axisHalfWidth;
                x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
                x2 = chartArea.right;
            } else if (position === 'right') {
                borderValue = alignBorderValue(this.left);
                x1 = chartArea.left;
                x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
                tx1 = borderValue + axisHalfWidth;
                tx2 = this.left + tl;
            } else if (axis === 'x') {
                if (position === 'center') {
                    borderValue = alignBorderValue(
                        (chartArea.top + chartArea.bottom) / 2 + 0.5
                    );
                } else if (isObject(position)) {
                    const positionAxisID = Object.keys(position)[0];
                    const value = position[positionAxisID];
                    borderValue = alignBorderValue(
                        this.chart.scales[positionAxisID].getPixelForValue(
                            value
                        )
                    );
                }
                y1 = chartArea.top;
                y2 = chartArea.bottom;
                ty1 = borderValue + axisHalfWidth;
                ty2 = ty1 + tl;
            } else if (axis === 'y') {
                if (position === 'center') {
                    borderValue = alignBorderValue(
                        (chartArea.left + chartArea.right) / 2
                    );
                } else if (isObject(position)) {
                    const positionAxisID = Object.keys(position)[0];
                    const value = position[positionAxisID];
                    borderValue = alignBorderValue(
                        this.chart.scales[positionAxisID].getPixelForValue(
                            value
                        )
                    );
                }
                tx1 = borderValue - axisHalfWidth;
                tx2 = tx1 - tl;
                x1 = chartArea.left;
                x2 = chartArea.right;
            }
            const limit = valueOrDefault(
                options.ticks.maxTicksLimit,
                ticksLength
            );
            const step = Math.max(1, Math.ceil(ticksLength / limit));
            for (i = 0; i < ticksLength; i += step) {
                const optsAtIndex = grid.setContext(this.getContext(i));
                const lineWidth = optsAtIndex.lineWidth;
                const lineColor = optsAtIndex.color;
                const borderDash = optsAtIndex.borderDash || [];
                const borderDashOffset = optsAtIndex.borderDashOffset;
                const tickWidth = optsAtIndex.tickWidth;
                const tickColor = optsAtIndex.tickColor;
                const tickBorderDash = optsAtIndex.tickBorderDash || [];
                const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
                lineValue = getPixelForGridLine(this, i, offset);
                if (lineValue === void 0) {
                    continue;
                }
                alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
                if (isHorizontal) {
                    tx1 = tx2 = x1 = x2 = alignedLineValue;
                } else {
                    ty1 = ty2 = y1 = y2 = alignedLineValue;
                }
                items.push({
                    tx1,
                    ty1,
                    tx2,
                    ty2,
                    x1,
                    y1,
                    x2,
                    y2,
                    width: lineWidth,
                    color: lineColor,
                    borderDash,
                    borderDashOffset,
                    tickWidth,
                    tickColor,
                    tickBorderDash,
                    tickBorderDashOffset,
                });
            }
            this._ticksLength = ticksLength;
            this._borderValue = borderValue;
            return items;
        }
        _computeLabelItems(chartArea) {
            const axis = this.axis;
            const options = this.options;
            const { position, ticks: optionTicks } = options;
            const isHorizontal = this.isHorizontal();
            const ticks = this.ticks;
            const { align, crossAlign, padding, mirror } = optionTicks;
            const tl = getTickMarkLength(options.grid);
            const tickAndPadding = tl + padding;
            const hTickAndPadding = mirror ? -padding : tickAndPadding;
            const rotation = -toRadians(this.labelRotation);
            const items = [];
            let i,
                ilen,
                tick,
                label,
                x,
                y,
                textAlign,
                pixel,
                font,
                lineHeight,
                lineCount,
                textOffset;
            let textBaseline = 'middle';
            if (position === 'top') {
                y = this.bottom - hTickAndPadding;
                textAlign = this._getXAxisLabelAlignment();
            } else if (position === 'bottom') {
                y = this.top + hTickAndPadding;
                textAlign = this._getXAxisLabelAlignment();
            } else if (position === 'left') {
                const ret = this._getYAxisLabelAlignment(tl);
                textAlign = ret.textAlign;
                x = ret.x;
            } else if (position === 'right') {
                const ret = this._getYAxisLabelAlignment(tl);
                textAlign = ret.textAlign;
                x = ret.x;
            } else if (axis === 'x') {
                if (position === 'center') {
                    y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
                } else if (isObject(position)) {
                    const positionAxisID = Object.keys(position)[0];
                    const value = position[positionAxisID];
                    y =
                        this.chart.scales[positionAxisID].getPixelForValue(
                            value
                        ) + tickAndPadding;
                }
                textAlign = this._getXAxisLabelAlignment();
            } else if (axis === 'y') {
                if (position === 'center') {
                    x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
                } else if (isObject(position)) {
                    const positionAxisID = Object.keys(position)[0];
                    const value = position[positionAxisID];
                    x =
                        this.chart.scales[positionAxisID].getPixelForValue(
                            value
                        );
                }
                textAlign = this._getYAxisLabelAlignment(tl).textAlign;
            }
            if (axis === 'y') {
                if (align === 'start') {
                    textBaseline = 'top';
                } else if (align === 'end') {
                    textBaseline = 'bottom';
                }
            }
            const labelSizes = this._getLabelSizes();
            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
                tick = ticks[i];
                label = tick.label;
                const optsAtIndex = optionTicks.setContext(this.getContext(i));
                pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
                font = this._resolveTickFontOptions(i);
                lineHeight = font.lineHeight;
                lineCount = isArray(label) ? label.length : 1;
                const halfCount = lineCount / 2;
                const color3 = optsAtIndex.color;
                const strokeColor = optsAtIndex.textStrokeColor;
                const strokeWidth = optsAtIndex.textStrokeWidth;
                let tickTextAlign = textAlign;
                if (isHorizontal) {
                    x = pixel;
                    if (textAlign === 'inner') {
                        if (i === ilen - 1) {
                            tickTextAlign = !this.options.reverse
                                ? 'right'
                                : 'left';
                        } else if (i === 0) {
                            tickTextAlign = !this.options.reverse
                                ? 'left'
                                : 'right';
                        } else {
                            tickTextAlign = 'center';
                        }
                    }
                    if (position === 'top') {
                        if (crossAlign === 'near' || rotation !== 0) {
                            textOffset =
                                -lineCount * lineHeight + lineHeight / 2;
                        } else if (crossAlign === 'center') {
                            textOffset =
                                -labelSizes.highest.height / 2 -
                                halfCount * lineHeight +
                                lineHeight;
                        } else {
                            textOffset =
                                -labelSizes.highest.height + lineHeight / 2;
                        }
                    } else {
                        if (crossAlign === 'near' || rotation !== 0) {
                            textOffset = lineHeight / 2;
                        } else if (crossAlign === 'center') {
                            textOffset =
                                labelSizes.highest.height / 2 -
                                halfCount * lineHeight;
                        } else {
                            textOffset =
                                labelSizes.highest.height -
                                lineCount * lineHeight;
                        }
                    }
                    if (mirror) {
                        textOffset *= -1;
                    }
                } else {
                    y = pixel;
                    textOffset = ((1 - lineCount) * lineHeight) / 2;
                }
                let backdrop;
                if (optsAtIndex.showLabelBackdrop) {
                    const labelPadding = toPadding(optsAtIndex.backdropPadding);
                    const height = labelSizes.heights[i];
                    const width = labelSizes.widths[i];
                    let top = y + textOffset - labelPadding.top;
                    let left = x - labelPadding.left;
                    switch (textBaseline) {
                        case 'middle':
                            top -= height / 2;
                            break;
                        case 'bottom':
                            top -= height;
                            break;
                    }
                    switch (textAlign) {
                        case 'center':
                            left -= width / 2;
                            break;
                        case 'right':
                            left -= width;
                            break;
                    }
                    backdrop = {
                        left,
                        top,
                        width: width + labelPadding.width,
                        height: height + labelPadding.height,
                        color: optsAtIndex.backdropColor,
                    };
                }
                items.push({
                    rotation,
                    label,
                    font,
                    color: color3,
                    strokeColor,
                    strokeWidth,
                    textOffset,
                    textAlign: tickTextAlign,
                    textBaseline,
                    translation: [x, y],
                    backdrop,
                });
            }
            return items;
        }
        _getXAxisLabelAlignment() {
            const { position, ticks } = this.options;
            const rotation = -toRadians(this.labelRotation);
            if (rotation) {
                return position === 'top' ? 'left' : 'right';
            }
            let align = 'center';
            if (ticks.align === 'start') {
                align = 'left';
            } else if (ticks.align === 'end') {
                align = 'right';
            } else if (ticks.align === 'inner') {
                align = 'inner';
            }
            return align;
        }
        _getYAxisLabelAlignment(tl) {
            const {
                position,
                ticks: { crossAlign, mirror, padding },
            } = this.options;
            const labelSizes = this._getLabelSizes();
            const tickAndPadding = tl + padding;
            const widest = labelSizes.widest.width;
            let textAlign;
            let x;
            if (position === 'left') {
                if (mirror) {
                    x = this.right + padding;
                    if (crossAlign === 'near') {
                        textAlign = 'left';
                    } else if (crossAlign === 'center') {
                        textAlign = 'center';
                        x += widest / 2;
                    } else {
                        textAlign = 'right';
                        x += widest;
                    }
                } else {
                    x = this.right - tickAndPadding;
                    if (crossAlign === 'near') {
                        textAlign = 'right';
                    } else if (crossAlign === 'center') {
                        textAlign = 'center';
                        x -= widest / 2;
                    } else {
                        textAlign = 'left';
                        x = this.left;
                    }
                }
            } else if (position === 'right') {
                if (mirror) {
                    x = this.left + padding;
                    if (crossAlign === 'near') {
                        textAlign = 'right';
                    } else if (crossAlign === 'center') {
                        textAlign = 'center';
                        x -= widest / 2;
                    } else {
                        textAlign = 'left';
                        x -= widest;
                    }
                } else {
                    x = this.left + tickAndPadding;
                    if (crossAlign === 'near') {
                        textAlign = 'left';
                    } else if (crossAlign === 'center') {
                        textAlign = 'center';
                        x += widest / 2;
                    } else {
                        textAlign = 'right';
                        x = this.right;
                    }
                }
            } else {
                textAlign = 'right';
            }
            return { textAlign, x };
        }
        _computeLabelArea() {
            if (this.options.ticks.mirror) {
                return;
            }
            const chart = this.chart;
            const position = this.options.position;
            if (position === 'left' || position === 'right') {
                return {
                    top: 0,
                    left: this.left,
                    bottom: chart.height,
                    right: this.right,
                };
            }
            if (position === 'top' || position === 'bottom') {
                return {
                    top: this.top,
                    left: 0,
                    bottom: this.bottom,
                    right: chart.width,
                };
            }
        }
        drawBackground() {
            const {
                ctx,
                options: { backgroundColor: backgroundColor4 },
                left,
                top,
                width,
                height,
            } = this;
            if (backgroundColor4) {
                ctx.save();
                ctx.fillStyle = backgroundColor4;
                ctx.fillRect(left, top, width, height);
                ctx.restore();
            }
        }
        getLineWidthForValue(value) {
            const grid = this.options.grid;
            if (!this._isVisible() || !grid.display) {
                return 0;
            }
            const ticks = this.ticks;
            const index3 = ticks.findIndex((t) => t.value === value);
            if (index3 >= 0) {
                const opts = grid.setContext(this.getContext(index3));
                return opts.lineWidth;
            }
            return 0;
        }
        drawGrid(chartArea) {
            const grid = this.options.grid;
            const ctx = this.ctx;
            const items =
                this._gridLineItems ||
                (this._gridLineItems = this._computeGridLineItems(chartArea));
            let i, ilen;
            const drawLine = (p1, p2, style) => {
                if (!style.width || !style.color) {
                    return;
                }
                ctx.save();
                ctx.lineWidth = style.width;
                ctx.strokeStyle = style.color;
                ctx.setLineDash(style.borderDash || []);
                ctx.lineDashOffset = style.borderDashOffset;
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
                ctx.restore();
            };
            if (grid.display) {
                for (i = 0, ilen = items.length; i < ilen; ++i) {
                    const item = items[i];
                    if (grid.drawOnChartArea) {
                        drawLine(
                            { x: item.x1, y: item.y1 },
                            { x: item.x2, y: item.y2 },
                            item
                        );
                    }
                    if (grid.drawTicks) {
                        drawLine(
                            { x: item.tx1, y: item.ty1 },
                            { x: item.tx2, y: item.ty2 },
                            {
                                color: item.tickColor,
                                width: item.tickWidth,
                                borderDash: item.tickBorderDash,
                                borderDashOffset: item.tickBorderDashOffset,
                            }
                        );
                    }
                }
            }
        }
        drawBorder() {
            const {
                chart,
                ctx,
                options: { grid },
            } = this;
            const borderOpts = grid.setContext(this.getContext());
            const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;
            if (!axisWidth) {
                return;
            }
            const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
            const borderValue = this._borderValue;
            let x1, x2, y1, y2;
            if (this.isHorizontal()) {
                x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
                x2 =
                    _alignPixel(chart, this.right, lastLineWidth) +
                    lastLineWidth / 2;
                y1 = y2 = borderValue;
            } else {
                y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
                y2 =
                    _alignPixel(chart, this.bottom, lastLineWidth) +
                    lastLineWidth / 2;
                x1 = x2 = borderValue;
            }
            ctx.save();
            ctx.lineWidth = borderOpts.borderWidth;
            ctx.strokeStyle = borderOpts.borderColor;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            ctx.restore();
        }
        drawLabels(chartArea) {
            const optionTicks = this.options.ticks;
            if (!optionTicks.display) {
                return;
            }
            const ctx = this.ctx;
            const area = this._computeLabelArea();
            if (area) {
                clipArea(ctx, area);
            }
            const items =
                this._labelItems ||
                (this._labelItems = this._computeLabelItems(chartArea));
            let i, ilen;
            for (i = 0, ilen = items.length; i < ilen; ++i) {
                const item = items[i];
                const tickFont = item.font;
                const label = item.label;
                if (item.backdrop) {
                    ctx.fillStyle = item.backdrop.color;
                    ctx.fillRect(
                        item.backdrop.left,
                        item.backdrop.top,
                        item.backdrop.width,
                        item.backdrop.height
                    );
                }
                let y = item.textOffset;
                renderText(ctx, label, 0, y, tickFont, item);
            }
            if (area) {
                unclipArea(ctx);
            }
        }
        drawTitle() {
            const {
                ctx,
                options: { position, title: title4, reverse },
            } = this;
            if (!title4.display) {
                return;
            }
            const font = toFont(title4.font);
            const padding = toPadding(title4.padding);
            const align = title4.align;
            let offset = font.lineHeight / 2;
            if (
                position === 'bottom' ||
                position === 'center' ||
                isObject(position)
            ) {
                offset += padding.bottom;
                if (isArray(title4.text)) {
                    offset += font.lineHeight * (title4.text.length - 1);
                }
            } else {
                offset += padding.top;
            }
            const { titleX, titleY, maxWidth, rotation } = titleArgs(
                this,
                offset,
                position,
                align
            );
            renderText(ctx, title4.text, 0, 0, font, {
                color: title4.color,
                maxWidth,
                rotation,
                textAlign: titleAlign(align, position, reverse),
                textBaseline: 'middle',
                translation: [titleX, titleY],
            });
        }
        draw(chartArea) {
            if (!this._isVisible()) {
                return;
            }
            this.drawBackground();
            this.drawGrid(chartArea);
            this.drawBorder();
            this.drawTitle();
            this.drawLabels(chartArea);
        }
        _layers() {
            const opts = this.options;
            const tz = (opts.ticks && opts.ticks.z) || 0;
            const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
            if (!this._isVisible() || this.draw !== _Scale.prototype.draw) {
                return [
                    {
                        z: tz,
                        draw: (chartArea) => {
                            this.draw(chartArea);
                        },
                    },
                ];
            }
            return [
                {
                    z: gz,
                    draw: (chartArea) => {
                        this.drawBackground();
                        this.drawGrid(chartArea);
                        this.drawTitle();
                    },
                },
                {
                    z: gz + 1,
                    draw: () => {
                        this.drawBorder();
                    },
                },
                {
                    z: tz,
                    draw: (chartArea) => {
                        this.drawLabels(chartArea);
                    },
                },
            ];
        }
        getMatchingVisibleMetas(type2) {
            const metas = this.chart.getSortedVisibleDatasetMetas();
            const axisID = this.axis + 'AxisID';
            const result = [];
            let i, ilen;
            for (i = 0, ilen = metas.length; i < ilen; ++i) {
                const meta = metas[i];
                if (
                    meta[axisID] === this.id &&
                    (!type2 || meta.type === type2)
                ) {
                    result.push(meta);
                }
            }
            return result;
        }
        _resolveTickFontOptions(index3) {
            const opts = this.options.ticks.setContext(this.getContext(index3));
            return toFont(opts.font);
        }
        _maxDigits() {
            const fontSize = this._resolveTickFontOptions(0).lineHeight;
            return (this.isHorizontal() ? this.width : this.height) / fontSize;
        }
    };
    var TypedRegistry = class {
        constructor(type2, scope, override) {
            this.type = type2;
            this.scope = scope;
            this.override = override;
            this.items = /* @__PURE__ */ Object.create(null);
        }
        isForType(type2) {
            return Object.prototype.isPrototypeOf.call(
                this.type.prototype,
                type2.prototype
            );
        }
        register(item) {
            const proto = Object.getPrototypeOf(item);
            let parentScope;
            if (isIChartComponent(proto)) {
                parentScope = this.register(proto);
            }
            const items = this.items;
            const id2 = item.id;
            const scope = this.scope + '.' + id2;
            if (!id2) {
                throw new Error('class does not have id: ' + item);
            }
            if (id2 in items) {
                return scope;
            }
            items[id2] = item;
            registerDefaults(item, scope, parentScope);
            if (this.override) {
                defaults.override(item.id, item.overrides);
            }
            return scope;
        }
        get(id2) {
            return this.items[id2];
        }
        unregister(item) {
            const items = this.items;
            const id2 = item.id;
            const scope = this.scope;
            if (id2 in items) {
                delete items[id2];
            }
            if (scope && id2 in defaults[scope]) {
                delete defaults[scope][id2];
                if (this.override) {
                    delete overrides[id2];
                }
            }
        }
    };
    function registerDefaults(item, scope, parentScope) {
        const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
            parentScope ? defaults.get(parentScope) : {},
            defaults.get(scope),
            item.defaults,
        ]);
        defaults.set(scope, itemDefaults);
        if (item.defaultRoutes) {
            routeDefaults(scope, item.defaultRoutes);
        }
        if (item.descriptors) {
            defaults.describe(scope, item.descriptors);
        }
    }
    function routeDefaults(scope, routes) {
        Object.keys(routes).forEach((property) => {
            const propertyParts = property.split('.');
            const sourceName = propertyParts.pop();
            const sourceScope = [scope].concat(propertyParts).join('.');
            const parts = routes[property].split('.');
            const targetName = parts.pop();
            const targetScope = parts.join('.');
            defaults.route(sourceScope, sourceName, targetScope, targetName);
        });
    }
    function isIChartComponent(proto) {
        return 'id' in proto && 'defaults' in proto;
    }
    var Registry = class {
        constructor() {
            this.controllers = new TypedRegistry(
                DatasetController,
                'datasets',
                true
            );
            this.elements = new TypedRegistry(Element, 'elements');
            this.plugins = new TypedRegistry(Object, 'plugins');
            this.scales = new TypedRegistry(Scale, 'scales');
            this._typedRegistries = [
                this.controllers,
                this.scales,
                this.elements,
            ];
        }
        add(...args) {
            this._each('register', args);
        }
        remove(...args) {
            this._each('unregister', args);
        }
        addControllers(...args) {
            this._each('register', args, this.controllers);
        }
        addElements(...args) {
            this._each('register', args, this.elements);
        }
        addPlugins(...args) {
            this._each('register', args, this.plugins);
        }
        addScales(...args) {
            this._each('register', args, this.scales);
        }
        getController(id2) {
            return this._get(id2, this.controllers, 'controller');
        }
        getElement(id2) {
            return this._get(id2, this.elements, 'element');
        }
        getPlugin(id2) {
            return this._get(id2, this.plugins, 'plugin');
        }
        getScale(id2) {
            return this._get(id2, this.scales, 'scale');
        }
        removeControllers(...args) {
            this._each('unregister', args, this.controllers);
        }
        removeElements(...args) {
            this._each('unregister', args, this.elements);
        }
        removePlugins(...args) {
            this._each('unregister', args, this.plugins);
        }
        removeScales(...args) {
            this._each('unregister', args, this.scales);
        }
        _each(method, args, typedRegistry) {
            [...args].forEach((arg) => {
                const reg = typedRegistry || this._getRegistryForType(arg);
                if (
                    typedRegistry ||
                    reg.isForType(arg) ||
                    (reg === this.plugins && arg.id)
                ) {
                    this._exec(method, reg, arg);
                } else {
                    each(arg, (item) => {
                        const itemReg =
                            typedRegistry || this._getRegistryForType(item);
                        this._exec(method, itemReg, item);
                    });
                }
            });
        }
        _exec(method, registry2, component) {
            const camelMethod = _capitalize(method);
            callback(component['before' + camelMethod], [], component);
            registry2[method](component);
            callback(component['after' + camelMethod], [], component);
        }
        _getRegistryForType(type2) {
            for (let i = 0; i < this._typedRegistries.length; i++) {
                const reg = this._typedRegistries[i];
                if (reg.isForType(type2)) {
                    return reg;
                }
            }
            return this.plugins;
        }
        _get(id2, typedRegistry, type2) {
            const item = typedRegistry.get(id2);
            if (item === void 0) {
                throw new Error(
                    '"' + id2 + '" is not a registered ' + type2 + '.'
                );
            }
            return item;
        }
    };
    var registry = new Registry();
    var ScatterController = class extends DatasetController {
        update(mode) {
            const meta = this._cachedMeta;
            const { data: points = [] } = meta;
            const animationsDisabled = this.chart._animationsDisabled;
            let { start: start2, count } = _getStartAndCountOfVisiblePoints(
                meta,
                points,
                animationsDisabled
            );
            this._drawStart = start2;
            this._drawCount = count;
            if (_scaleRangesChanged(meta)) {
                start2 = 0;
                count = points.length;
            }
            if (this.options.showLine) {
                const { dataset: line, _dataset } = meta;
                line._chart = this.chart;
                line._datasetIndex = this.index;
                line._decimated = !!_dataset._decimated;
                line.points = points;
                const options = this.resolveDatasetElementOptions(mode);
                options.segment = this.options.segment;
                this.updateElement(
                    line,
                    void 0,
                    {
                        animated: !animationsDisabled,
                        options,
                    },
                    mode
                );
            }
            this.updateElements(points, start2, count, mode);
        }
        addElements() {
            const { showLine } = this.options;
            if (!this.datasetElementType && showLine) {
                this.datasetElementType = registry.getElement('line');
            }
            super.addElements();
        }
        updateElements(points, start2, count, mode) {
            const reset = mode === 'reset';
            const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
            const firstOpts = this.resolveDataElementOptions(start2, mode);
            const sharedOptions = this.getSharedOptions(firstOpts);
            const includeOptions = this.includeOptions(mode, sharedOptions);
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            const { spanGaps, segment } = this.options;
            const maxGapLength = isNumber(spanGaps)
                ? spanGaps
                : Number.POSITIVE_INFINITY;
            const directUpdate =
                this.chart._animationsDisabled || reset || mode === 'none';
            let prevParsed = start2 > 0 && this.getParsed(start2 - 1);
            for (let i = start2; i < start2 + count; ++i) {
                const point = points[i];
                const parsed = this.getParsed(i);
                const properties = directUpdate ? point : {};
                const nullData = isNullOrUndef(parsed[vAxis]);
                const iPixel = (properties[iAxis] = iScale.getPixelForValue(
                    parsed[iAxis],
                    i
                ));
                const vPixel = (properties[vAxis] =
                    reset || nullData
                        ? vScale.getBasePixel()
                        : vScale.getPixelForValue(
                              _stacked
                                  ? this.applyStack(vScale, parsed, _stacked)
                                  : parsed[vAxis],
                              i
                          ));
                properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
                properties.stop =
                    i > 0 &&
                    Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
                if (segment) {
                    properties.parsed = parsed;
                    properties.raw = _dataset.data[i];
                }
                if (includeOptions) {
                    properties.options =
                        sharedOptions ||
                        this.resolveDataElementOptions(
                            i,
                            point.active ? 'active' : mode
                        );
                }
                if (!directUpdate) {
                    this.updateElement(point, i, properties, mode);
                }
                prevParsed = parsed;
            }
            this.updateSharedOptions(sharedOptions, mode, firstOpts);
        }
        getMaxOverflow() {
            const meta = this._cachedMeta;
            const data = meta.data || [];
            if (!this.options.showLine) {
                let max3 = 0;
                for (let i = data.length - 1; i >= 0; --i) {
                    max3 = Math.max(
                        max3,
                        data[i].size(this.resolveDataElementOptions(i)) / 2
                    );
                }
                return max3 > 0 && max3;
            }
            const dataset = meta.dataset;
            const border =
                (dataset.options && dataset.options.borderWidth) || 0;
            if (!data.length) {
                return border;
            }
            const firstPoint = data[0].size(this.resolveDataElementOptions(0));
            const lastPoint = data[data.length - 1].size(
                this.resolveDataElementOptions(data.length - 1)
            );
            return Math.max(border, firstPoint, lastPoint) / 2;
        }
    };
    ScatterController.id = 'scatter';
    ScatterController.defaults = {
        datasetElementType: false,
        dataElementType: 'point',
        showLine: false,
        fill: false,
    };
    ScatterController.overrides = {
        interaction: {
            mode: 'point',
        },
        plugins: {
            tooltip: {
                callbacks: {
                    title() {
                        return '';
                    },
                    label(item) {
                        return (
                            '(' + item.label + ', ' + item.formattedValue + ')'
                        );
                    },
                },
            },
        },
        scales: {
            x: {
                type: 'linear',
            },
            y: {
                type: 'linear',
            },
        },
    };
    var controllers = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        BarController,
        BubbleController,
        DoughnutController,
        LineController,
        PolarAreaController,
        PieController,
        RadarController,
        ScatterController,
    });
    function abstract() {
        throw new Error(
            'This method is not implemented: Check that a complete date adapter is provided.'
        );
    }
    var DateAdapter = class {
        constructor(options) {
            this.options = options || {};
        }
        init(chartOptions) {}
        formats() {
            return abstract();
        }
        parse(value, format2) {
            return abstract();
        }
        format(timestamp, format2) {
            return abstract();
        }
        add(timestamp, amount, unit) {
            return abstract();
        }
        diff(a, b, unit) {
            return abstract();
        }
        startOf(timestamp, unit, weekday) {
            return abstract();
        }
        endOf(timestamp, unit) {
            return abstract();
        }
    };
    DateAdapter.override = function (members) {
        Object.assign(DateAdapter.prototype, members);
    };
    var adapters = {
        _date: DateAdapter,
    };
    function binarySearch(metaset, axis, value, intersect) {
        const { controller, data, _sorted } = metaset;
        const iScale = controller._cachedMeta.iScale;
        if (
            iScale &&
            axis === iScale.axis &&
            axis !== 'r' &&
            _sorted &&
            data.length
        ) {
            const lookupMethod = iScale._reversePixels
                ? _rlookupByKey
                : _lookupByKey;
            if (!intersect) {
                return lookupMethod(data, axis, value);
            } else if (controller._sharedOptions) {
                const el = data[0];
                const range =
                    typeof el.getRange === 'function' && el.getRange(axis);
                if (range) {
                    const start2 = lookupMethod(data, axis, value - range);
                    const end = lookupMethod(data, axis, value + range);
                    return { lo: start2.lo, hi: end.hi };
                }
            }
        }
        return { lo: 0, hi: data.length - 1 };
    }
    function evaluateInteractionItems(
        chart,
        axis,
        position,
        handler,
        intersect
    ) {
        const metasets = chart.getSortedVisibleDatasetMetas();
        const value = position[axis];
        for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
            const { index: index3, data } = metasets[i];
            const { lo, hi } = binarySearch(
                metasets[i],
                axis,
                value,
                intersect
            );
            for (let j = lo; j <= hi; ++j) {
                const element = data[j];
                if (!element.skip) {
                    handler(element, index3, j);
                }
            }
        }
    }
    function getDistanceMetricForAxis(axis) {
        const useX = axis.indexOf('x') !== -1;
        const useY = axis.indexOf('y') !== -1;
        return function (pt1, pt2) {
            const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
            const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
            return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
        };
    }
    function getIntersectItems(
        chart,
        position,
        axis,
        useFinalPosition,
        includeInvisible
    ) {
        const items = [];
        if (!includeInvisible && !chart.isPointInArea(position)) {
            return items;
        }
        const evaluationFunc = function (element, datasetIndex, index3) {
            if (
                !includeInvisible &&
                !_isPointInArea(element, chart.chartArea, 0)
            ) {
                return;
            }
            if (element.inRange(position.x, position.y, useFinalPosition)) {
                items.push({ element, datasetIndex, index: index3 });
            }
        };
        evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
        return items;
    }
    function getNearestRadialItems(chart, position, axis, useFinalPosition) {
        let items = [];
        function evaluationFunc(element, datasetIndex, index3) {
            const { startAngle, endAngle } = element.getProps(
                ['startAngle', 'endAngle'],
                useFinalPosition
            );
            const { angle } = getAngleFromPoint(element, {
                x: position.x,
                y: position.y,
            });
            if (_angleBetween(angle, startAngle, endAngle)) {
                items.push({ element, datasetIndex, index: index3 });
            }
        }
        evaluateInteractionItems(chart, axis, position, evaluationFunc);
        return items;
    }
    function getNearestCartesianItems(
        chart,
        position,
        axis,
        intersect,
        useFinalPosition,
        includeInvisible
    ) {
        let items = [];
        const distanceMetric = getDistanceMetricForAxis(axis);
        let minDistance = Number.POSITIVE_INFINITY;
        function evaluationFunc(element, datasetIndex, index3) {
            const inRange2 = element.inRange(
                position.x,
                position.y,
                useFinalPosition
            );
            if (intersect && !inRange2) {
                return;
            }
            const center = element.getCenterPoint(useFinalPosition);
            const pointInArea =
                !!includeInvisible || chart.isPointInArea(center);
            if (!pointInArea && !inRange2) {
                return;
            }
            const distance = distanceMetric(position, center);
            if (distance < minDistance) {
                items = [{ element, datasetIndex, index: index3 }];
                minDistance = distance;
            } else if (distance === minDistance) {
                items.push({ element, datasetIndex, index: index3 });
            }
        }
        evaluateInteractionItems(chart, axis, position, evaluationFunc);
        return items;
    }
    function getNearestItems(
        chart,
        position,
        axis,
        intersect,
        useFinalPosition,
        includeInvisible
    ) {
        if (!includeInvisible && !chart.isPointInArea(position)) {
            return [];
        }
        return axis === 'r' && !intersect
            ? getNearestRadialItems(chart, position, axis, useFinalPosition)
            : getNearestCartesianItems(
                  chart,
                  position,
                  axis,
                  intersect,
                  useFinalPosition,
                  includeInvisible
              );
    }
    function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
        const items = [];
        const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';
        let intersectsItem = false;
        evaluateInteractionItems(
            chart,
            axis,
            position,
            (element, datasetIndex, index3) => {
                if (element[rangeMethod](position[axis], useFinalPosition)) {
                    items.push({ element, datasetIndex, index: index3 });
                    intersectsItem =
                        intersectsItem ||
                        element.inRange(
                            position.x,
                            position.y,
                            useFinalPosition
                        );
                }
            }
        );
        if (intersect && !intersectsItem) {
            return [];
        }
        return items;
    }
    var Interaction = {
        evaluateInteractionItems,
        modes: {
            index(chart, e, options, useFinalPosition) {
                const position = getRelativePosition(e, chart);
                const axis = options.axis || 'x';
                const includeInvisible = options.includeInvisible || false;
                const items = options.intersect
                    ? getIntersectItems(
                          chart,
                          position,
                          axis,
                          useFinalPosition,
                          includeInvisible
                      )
                    : getNearestItems(
                          chart,
                          position,
                          axis,
                          false,
                          useFinalPosition,
                          includeInvisible
                      );
                const elements2 = [];
                if (!items.length) {
                    return [];
                }
                chart.getSortedVisibleDatasetMetas().forEach((meta) => {
                    const index3 = items[0].index;
                    const element = meta.data[index3];
                    if (element && !element.skip) {
                        elements2.push({
                            element,
                            datasetIndex: meta.index,
                            index: index3,
                        });
                    }
                });
                return elements2;
            },
            dataset(chart, e, options, useFinalPosition) {
                const position = getRelativePosition(e, chart);
                const axis = options.axis || 'xy';
                const includeInvisible = options.includeInvisible || false;
                let items = options.intersect
                    ? getIntersectItems(
                          chart,
                          position,
                          axis,
                          useFinalPosition,
                          includeInvisible
                      )
                    : getNearestItems(
                          chart,
                          position,
                          axis,
                          false,
                          useFinalPosition,
                          includeInvisible
                      );
                if (items.length > 0) {
                    const datasetIndex = items[0].datasetIndex;
                    const data = chart.getDatasetMeta(datasetIndex).data;
                    items = [];
                    for (let i = 0; i < data.length; ++i) {
                        items.push({
                            element: data[i],
                            datasetIndex,
                            index: i,
                        });
                    }
                }
                return items;
            },
            point(chart, e, options, useFinalPosition) {
                const position = getRelativePosition(e, chart);
                const axis = options.axis || 'xy';
                const includeInvisible = options.includeInvisible || false;
                return getIntersectItems(
                    chart,
                    position,
                    axis,
                    useFinalPosition,
                    includeInvisible
                );
            },
            nearest(chart, e, options, useFinalPosition) {
                const position = getRelativePosition(e, chart);
                const axis = options.axis || 'xy';
                const includeInvisible = options.includeInvisible || false;
                return getNearestItems(
                    chart,
                    position,
                    axis,
                    options.intersect,
                    useFinalPosition,
                    includeInvisible
                );
            },
            x(chart, e, options, useFinalPosition) {
                const position = getRelativePosition(e, chart);
                return getAxisItems(
                    chart,
                    position,
                    'x',
                    options.intersect,
                    useFinalPosition
                );
            },
            y(chart, e, options, useFinalPosition) {
                const position = getRelativePosition(e, chart);
                return getAxisItems(
                    chart,
                    position,
                    'y',
                    options.intersect,
                    useFinalPosition
                );
            },
        },
    };
    var STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];
    function filterByPosition(array2, position) {
        return array2.filter((v) => v.pos === position);
    }
    function filterDynamicPositionByAxis(array2, axis) {
        return array2.filter(
            (v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis
        );
    }
    function sortByWeight(array2, reverse) {
        return array2.sort((a, b) => {
            const v0 = reverse ? b : a;
            const v1 = reverse ? a : b;
            return v0.weight === v1.weight
                ? v0.index - v1.index
                : v0.weight - v1.weight;
        });
    }
    function wrapBoxes(boxes) {
        const layoutBoxes = [];
        let i, ilen, box, pos, stack, stackWeight;
        for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
            box = boxes[i];
            ({
                position: pos,
                options: { stack, stackWeight = 1 },
            } = box);
            layoutBoxes.push({
                index: i,
                box,
                pos,
                horizontal: box.isHorizontal(),
                weight: box.weight,
                stack: stack && pos + stack,
                stackWeight,
            });
        }
        return layoutBoxes;
    }
    function buildStacks(layouts2) {
        const stacks = {};
        for (const wrap of layouts2) {
            const { stack, pos, stackWeight } = wrap;
            if (!stack || !STATIC_POSITIONS.includes(pos)) {
                continue;
            }
            const _stack =
                stacks[stack] ||
                (stacks[stack] = { count: 0, placed: 0, weight: 0, size: 0 });
            _stack.count++;
            _stack.weight += stackWeight;
        }
        return stacks;
    }
    function setLayoutDims(layouts2, params) {
        const stacks = buildStacks(layouts2);
        const { vBoxMaxWidth, hBoxMaxHeight } = params;
        let i, ilen, layout2;
        for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
            layout2 = layouts2[i];
            const { fullSize } = layout2.box;
            const stack = stacks[layout2.stack];
            const factor = stack && layout2.stackWeight / stack.weight;
            if (layout2.horizontal) {
                layout2.width = factor
                    ? factor * vBoxMaxWidth
                    : fullSize && params.availableWidth;
                layout2.height = hBoxMaxHeight;
            } else {
                layout2.width = vBoxMaxWidth;
                layout2.height = factor
                    ? factor * hBoxMaxHeight
                    : fullSize && params.availableHeight;
            }
        }
        return stacks;
    }
    function buildLayoutBoxes(boxes) {
        const layoutBoxes = wrapBoxes(boxes);
        const fullSize = sortByWeight(
            layoutBoxes.filter((wrap) => wrap.box.fullSize),
            true
        );
        const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);
        const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));
        const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);
        const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));
        const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');
        const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');
        return {
            fullSize,
            leftAndTop: left.concat(top),
            rightAndBottom: right
                .concat(centerVertical)
                .concat(bottom)
                .concat(centerHorizontal),
            chartArea: filterByPosition(layoutBoxes, 'chartArea'),
            vertical: left.concat(right).concat(centerVertical),
            horizontal: top.concat(bottom).concat(centerHorizontal),
        };
    }
    function getCombinedMax(maxPadding, chartArea, a, b) {
        return (
            Math.max(maxPadding[a], chartArea[a]) +
            Math.max(maxPadding[b], chartArea[b])
        );
    }
    function updateMaxPadding(maxPadding, boxPadding) {
        maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
        maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
        maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
        maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
    }
    function updateDims(chartArea, params, layout2, stacks) {
        const { pos, box } = layout2;
        const maxPadding = chartArea.maxPadding;
        if (!isObject(pos)) {
            if (layout2.size) {
                chartArea[pos] -= layout2.size;
            }
            const stack = stacks[layout2.stack] || { size: 0, count: 1 };
            stack.size = Math.max(
                stack.size,
                layout2.horizontal ? box.height : box.width
            );
            layout2.size = stack.size / stack.count;
            chartArea[pos] += layout2.size;
        }
        if (box.getPadding) {
            updateMaxPadding(maxPadding, box.getPadding());
        }
        const newWidth = Math.max(
            0,
            params.outerWidth -
                getCombinedMax(maxPadding, chartArea, 'left', 'right')
        );
        const newHeight = Math.max(
            0,
            params.outerHeight -
                getCombinedMax(maxPadding, chartArea, 'top', 'bottom')
        );
        const widthChanged = newWidth !== chartArea.w;
        const heightChanged = newHeight !== chartArea.h;
        chartArea.w = newWidth;
        chartArea.h = newHeight;
        return layout2.horizontal
            ? { same: widthChanged, other: heightChanged }
            : { same: heightChanged, other: widthChanged };
    }
    function handleMaxPadding(chartArea) {
        const maxPadding = chartArea.maxPadding;
        function updatePos(pos) {
            const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
            chartArea[pos] += change;
            return change;
        }
        chartArea.y += updatePos('top');
        chartArea.x += updatePos('left');
        updatePos('right');
        updatePos('bottom');
    }
    function getMargins(horizontal, chartArea) {
        const maxPadding = chartArea.maxPadding;
        function marginForPositions(positions3) {
            const margin = { left: 0, top: 0, right: 0, bottom: 0 };
            positions3.forEach((pos) => {
                margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
            });
            return margin;
        }
        return horizontal
            ? marginForPositions(['left', 'right'])
            : marginForPositions(['top', 'bottom']);
    }
    function fitBoxes(boxes, chartArea, params, stacks) {
        const refitBoxes = [];
        let i, ilen, layout2, box, refit, changed;
        for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
            layout2 = boxes[i];
            box = layout2.box;
            box.update(
                layout2.width || chartArea.w,
                layout2.height || chartArea.h,
                getMargins(layout2.horizontal, chartArea)
            );
            const { same, other } = updateDims(
                chartArea,
                params,
                layout2,
                stacks
            );
            refit |= same && refitBoxes.length;
            changed = changed || other;
            if (!box.fullSize) {
                refitBoxes.push(layout2);
            }
        }
        return (
            (refit && fitBoxes(refitBoxes, chartArea, params, stacks)) ||
            changed
        );
    }
    function setBoxDims(box, left, top, width, height) {
        box.top = top;
        box.left = left;
        box.right = left + width;
        box.bottom = top + height;
        box.width = width;
        box.height = height;
    }
    function placeBoxes(boxes, chartArea, params, stacks) {
        const userPadding = params.padding;
        let { x, y } = chartArea;
        for (const layout2 of boxes) {
            const box = layout2.box;
            const stack = stacks[layout2.stack] || {
                count: 1,
                placed: 0,
                weight: 1,
            };
            const weight = layout2.stackWeight / stack.weight || 1;
            if (layout2.horizontal) {
                const width = chartArea.w * weight;
                const height = stack.size || box.height;
                if (defined(stack.start)) {
                    y = stack.start;
                }
                if (box.fullSize) {
                    setBoxDims(
                        box,
                        userPadding.left,
                        y,
                        params.outerWidth -
                            userPadding.right -
                            userPadding.left,
                        height
                    );
                } else {
                    setBoxDims(
                        box,
                        chartArea.left + stack.placed,
                        y,
                        width,
                        height
                    );
                }
                stack.start = y;
                stack.placed += width;
                y = box.bottom;
            } else {
                const height = chartArea.h * weight;
                const width = stack.size || box.width;
                if (defined(stack.start)) {
                    x = stack.start;
                }
                if (box.fullSize) {
                    setBoxDims(
                        box,
                        x,
                        userPadding.top,
                        width,
                        params.outerHeight -
                            userPadding.bottom -
                            userPadding.top
                    );
                } else {
                    setBoxDims(
                        box,
                        x,
                        chartArea.top + stack.placed,
                        width,
                        height
                    );
                }
                stack.start = x;
                stack.placed += height;
                x = box.right;
            }
        }
        chartArea.x = x;
        chartArea.y = y;
    }
    defaults.set('layout', {
        autoPadding: true,
        padding: {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0,
        },
    });
    var layouts = {
        addBox(chart, item) {
            if (!chart.boxes) {
                chart.boxes = [];
            }
            item.fullSize = item.fullSize || false;
            item.position = item.position || 'top';
            item.weight = item.weight || 0;
            item._layers =
                item._layers ||
                function () {
                    return [
                        {
                            z: 0,
                            draw(chartArea) {
                                item.draw(chartArea);
                            },
                        },
                    ];
                };
            chart.boxes.push(item);
        },
        removeBox(chart, layoutItem) {
            const index3 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
            if (index3 !== -1) {
                chart.boxes.splice(index3, 1);
            }
        },
        configure(chart, item, options) {
            item.fullSize = options.fullSize;
            item.position = options.position;
            item.weight = options.weight;
        },
        update(chart, width, height, minPadding) {
            if (!chart) {
                return;
            }
            const padding = toPadding(chart.options.layout.padding);
            const availableWidth = Math.max(width - padding.width, 0);
            const availableHeight = Math.max(height - padding.height, 0);
            const boxes = buildLayoutBoxes(chart.boxes);
            const verticalBoxes = boxes.vertical;
            const horizontalBoxes = boxes.horizontal;
            each(chart.boxes, (box) => {
                if (typeof box.beforeLayout === 'function') {
                    box.beforeLayout();
                }
            });
            const visibleVerticalBoxCount =
                verticalBoxes.reduce(
                    (total, wrap) =>
                        wrap.box.options && wrap.box.options.display === false
                            ? total
                            : total + 1,
                    0
                ) || 1;
            const params = Object.freeze({
                outerWidth: width,
                outerHeight: height,
                padding,
                availableWidth,
                availableHeight,
                vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
                hBoxMaxHeight: availableHeight / 2,
            });
            const maxPadding = Object.assign({}, padding);
            updateMaxPadding(maxPadding, toPadding(minPadding));
            const chartArea = Object.assign(
                {
                    maxPadding,
                    w: availableWidth,
                    h: availableHeight,
                    x: padding.left,
                    y: padding.top,
                },
                padding
            );
            const stacks = setLayoutDims(
                verticalBoxes.concat(horizontalBoxes),
                params
            );
            fitBoxes(boxes.fullSize, chartArea, params, stacks);
            fitBoxes(verticalBoxes, chartArea, params, stacks);
            if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
                fitBoxes(verticalBoxes, chartArea, params, stacks);
            }
            handleMaxPadding(chartArea);
            placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
            chartArea.x += chartArea.w;
            chartArea.y += chartArea.h;
            placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
            chart.chartArea = {
                left: chartArea.left,
                top: chartArea.top,
                right: chartArea.left + chartArea.w,
                bottom: chartArea.top + chartArea.h,
                height: chartArea.h,
                width: chartArea.w,
            };
            each(boxes.chartArea, (layout2) => {
                const box = layout2.box;
                Object.assign(box, chart.chartArea);
                box.update(chartArea.w, chartArea.h, {
                    left: 0,
                    top: 0,
                    right: 0,
                    bottom: 0,
                });
            });
        },
    };
    var BasePlatform = class {
        acquireContext(canvas, aspectRatio) {}
        releaseContext(context) {
            return false;
        }
        addEventListener(chart, type2, listener) {}
        removeEventListener(chart, type2, listener) {}
        getDevicePixelRatio() {
            return 1;
        }
        getMaximumSize(element, width, height, aspectRatio) {
            width = Math.max(0, width || element.width);
            height = height || element.height;
            return {
                width,
                height: Math.max(
                    0,
                    aspectRatio ? Math.floor(width / aspectRatio) : height
                ),
            };
        }
        isAttached(canvas) {
            return true;
        }
        updateConfig(config) {}
    };
    var BasicPlatform = class extends BasePlatform {
        acquireContext(item) {
            return (item && item.getContext && item.getContext('2d')) || null;
        }
        updateConfig(config) {
            config.options.animation = false;
        }
    };
    var EXPANDO_KEY = '$chartjs';
    var EVENT_TYPES = {
        touchstart: 'mousedown',
        touchmove: 'mousemove',
        touchend: 'mouseup',
        pointerenter: 'mouseenter',
        pointerdown: 'mousedown',
        pointermove: 'mousemove',
        pointerup: 'mouseup',
        pointerleave: 'mouseout',
        pointerout: 'mouseout',
    };
    var isNullOrEmpty = (value) => value === null || value === '';
    function initCanvas(canvas, aspectRatio) {
        const style = canvas.style;
        const renderHeight = canvas.getAttribute('height');
        const renderWidth = canvas.getAttribute('width');
        canvas[EXPANDO_KEY] = {
            initial: {
                height: renderHeight,
                width: renderWidth,
                style: {
                    display: style.display,
                    height: style.height,
                    width: style.width,
                },
            },
        };
        style.display = style.display || 'block';
        style.boxSizing = style.boxSizing || 'border-box';
        if (isNullOrEmpty(renderWidth)) {
            const displayWidth = readUsedSize(canvas, 'width');
            if (displayWidth !== void 0) {
                canvas.width = displayWidth;
            }
        }
        if (isNullOrEmpty(renderHeight)) {
            if (canvas.style.height === '') {
                canvas.height = canvas.width / (aspectRatio || 2);
            } else {
                const displayHeight = readUsedSize(canvas, 'height');
                if (displayHeight !== void 0) {
                    canvas.height = displayHeight;
                }
            }
        }
        return canvas;
    }
    var eventListenerOptions = supportsEventListenerOptions
        ? { passive: true }
        : false;
    function addListener(node, type2, listener) {
        node.addEventListener(type2, listener, eventListenerOptions);
    }
    function removeListener(chart, type2, listener) {
        chart.canvas.removeEventListener(type2, listener, eventListenerOptions);
    }
    function fromNativeEvent(event, chart) {
        const type2 = EVENT_TYPES[event.type] || event.type;
        const { x, y } = getRelativePosition(event, chart);
        return {
            type: type2,
            chart,
            native: event,
            x: x !== void 0 ? x : null,
            y: y !== void 0 ? y : null,
        };
    }
    function nodeListContains(nodeList, canvas) {
        for (const node of nodeList) {
            if (node === canvas || node.contains(canvas)) {
                return true;
            }
        }
    }
    function createAttachObserver(chart, type2, listener) {
        const canvas = chart.canvas;
        const observer = new MutationObserver((entries) => {
            let trigger = false;
            for (const entry of entries) {
                trigger = trigger || nodeListContains(entry.addedNodes, canvas);
                trigger =
                    trigger && !nodeListContains(entry.removedNodes, canvas);
            }
            if (trigger) {
                listener();
            }
        });
        observer.observe(document, { childList: true, subtree: true });
        return observer;
    }
    function createDetachObserver(chart, type2, listener) {
        const canvas = chart.canvas;
        const observer = new MutationObserver((entries) => {
            let trigger = false;
            for (const entry of entries) {
                trigger =
                    trigger || nodeListContains(entry.removedNodes, canvas);
                trigger =
                    trigger && !nodeListContains(entry.addedNodes, canvas);
            }
            if (trigger) {
                listener();
            }
        });
        observer.observe(document, { childList: true, subtree: true });
        return observer;
    }
    var drpListeningCharts = /* @__PURE__ */ new Map();
    var oldDevicePixelRatio = 0;
    function onWindowResize() {
        const dpr = window.devicePixelRatio;
        if (dpr === oldDevicePixelRatio) {
            return;
        }
        oldDevicePixelRatio = dpr;
        drpListeningCharts.forEach((resize, chart) => {
            if (chart.currentDevicePixelRatio !== dpr) {
                resize();
            }
        });
    }
    function listenDevicePixelRatioChanges(chart, resize) {
        if (!drpListeningCharts.size) {
            window.addEventListener('resize', onWindowResize);
        }
        drpListeningCharts.set(chart, resize);
    }
    function unlistenDevicePixelRatioChanges(chart) {
        drpListeningCharts.delete(chart);
        if (!drpListeningCharts.size) {
            window.removeEventListener('resize', onWindowResize);
        }
    }
    function createResizeObserver(chart, type2, listener) {
        const canvas = chart.canvas;
        const container = canvas && _getParentNode(canvas);
        if (!container) {
            return;
        }
        const resize = throttled((width, height) => {
            const w = container.clientWidth;
            listener(width, height);
            if (w < container.clientWidth) {
                listener();
            }
        }, window);
        const observer = new ResizeObserver((entries) => {
            const entry = entries[0];
            const width = entry.contentRect.width;
            const height = entry.contentRect.height;
            if (width === 0 && height === 0) {
                return;
            }
            resize(width, height);
        });
        observer.observe(container);
        listenDevicePixelRatioChanges(chart, resize);
        return observer;
    }
    function releaseObserver(chart, type2, observer) {
        if (observer) {
            observer.disconnect();
        }
        if (type2 === 'resize') {
            unlistenDevicePixelRatioChanges(chart);
        }
    }
    function createProxyAndListen(chart, type2, listener) {
        const canvas = chart.canvas;
        const proxy = throttled(
            (event) => {
                if (chart.ctx !== null) {
                    listener(fromNativeEvent(event, chart));
                }
            },
            chart,
            (args) => {
                const event = args[0];
                return [event, event.offsetX, event.offsetY];
            }
        );
        addListener(canvas, type2, proxy);
        return proxy;
    }
    var DomPlatform = class extends BasePlatform {
        acquireContext(canvas, aspectRatio) {
            const context =
                canvas && canvas.getContext && canvas.getContext('2d');
            if (context && context.canvas === canvas) {
                initCanvas(canvas, aspectRatio);
                return context;
            }
            return null;
        }
        releaseContext(context) {
            const canvas = context.canvas;
            if (!canvas[EXPANDO_KEY]) {
                return false;
            }
            const initial = canvas[EXPANDO_KEY].initial;
            ['height', 'width'].forEach((prop) => {
                const value = initial[prop];
                if (isNullOrUndef(value)) {
                    canvas.removeAttribute(prop);
                } else {
                    canvas.setAttribute(prop, value);
                }
            });
            const style = initial.style || {};
            Object.keys(style).forEach((key) => {
                canvas.style[key] = style[key];
            });
            canvas.width = canvas.width;
            delete canvas[EXPANDO_KEY];
            return true;
        }
        addEventListener(chart, type2, listener) {
            this.removeEventListener(chart, type2);
            const proxies = chart.$proxies || (chart.$proxies = {});
            const handlers = {
                attach: createAttachObserver,
                detach: createDetachObserver,
                resize: createResizeObserver,
            };
            const handler = handlers[type2] || createProxyAndListen;
            proxies[type2] = handler(chart, type2, listener);
        }
        removeEventListener(chart, type2) {
            const proxies = chart.$proxies || (chart.$proxies = {});
            const proxy = proxies[type2];
            if (!proxy) {
                return;
            }
            const handlers = {
                attach: releaseObserver,
                detach: releaseObserver,
                resize: releaseObserver,
            };
            const handler = handlers[type2] || removeListener;
            handler(chart, type2, proxy);
            proxies[type2] = void 0;
        }
        getDevicePixelRatio() {
            return window.devicePixelRatio;
        }
        getMaximumSize(canvas, width, height, aspectRatio) {
            return getMaximumSize(canvas, width, height, aspectRatio);
        }
        isAttached(canvas) {
            const container = _getParentNode(canvas);
            return !!(container && container.isConnected);
        }
    };
    function _detectPlatform(canvas) {
        if (
            !_isDomSupported() ||
            (typeof OffscreenCanvas !== 'undefined' &&
                canvas instanceof OffscreenCanvas)
        ) {
            return BasicPlatform;
        }
        return DomPlatform;
    }
    var PluginService = class {
        constructor() {
            this._init = [];
        }
        notify(chart, hook, args, filter2) {
            if (hook === 'beforeInit') {
                this._init = this._createDescriptors(chart, true);
                this._notify(this._init, chart, 'install');
            }
            const descriptors2 = filter2
                ? this._descriptors(chart).filter(filter2)
                : this._descriptors(chart);
            const result = this._notify(descriptors2, chart, hook, args);
            if (hook === 'afterDestroy') {
                this._notify(descriptors2, chart, 'stop');
                this._notify(this._init, chart, 'uninstall');
            }
            return result;
        }
        _notify(descriptors2, chart, hook, args) {
            args = args || {};
            for (const descriptor of descriptors2) {
                const plugin2 = descriptor.plugin;
                const method = plugin2[hook];
                const params = [chart, args, descriptor.options];
                if (
                    callback(method, params, plugin2) === false &&
                    args.cancelable
                ) {
                    return false;
                }
            }
            return true;
        }
        invalidate() {
            if (!isNullOrUndef(this._cache)) {
                this._oldCache = this._cache;
                this._cache = void 0;
            }
        }
        _descriptors(chart) {
            if (this._cache) {
                return this._cache;
            }
            const descriptors2 = (this._cache = this._createDescriptors(chart));
            this._notifyStateChanges(chart);
            return descriptors2;
        }
        _createDescriptors(chart, all) {
            const config = chart && chart.config;
            const options = valueOrDefault(
                config.options && config.options.plugins,
                {}
            );
            const plugins2 = allPlugins(config);
            return options === false && !all
                ? []
                : createDescriptors(chart, plugins2, options, all);
        }
        _notifyStateChanges(chart) {
            const previousDescriptors = this._oldCache || [];
            const descriptors2 = this._cache;
            const diff = (a, b) =>
                a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
            this._notify(
                diff(previousDescriptors, descriptors2),
                chart,
                'stop'
            );
            this._notify(
                diff(descriptors2, previousDescriptors),
                chart,
                'start'
            );
        }
    };
    function allPlugins(config) {
        const localIds = {};
        const plugins2 = [];
        const keys = Object.keys(registry.plugins.items);
        for (let i = 0; i < keys.length; i++) {
            plugins2.push(registry.getPlugin(keys[i]));
        }
        const local = config.plugins || [];
        for (let i = 0; i < local.length; i++) {
            const plugin2 = local[i];
            if (plugins2.indexOf(plugin2) === -1) {
                plugins2.push(plugin2);
                localIds[plugin2.id] = true;
            }
        }
        return { plugins: plugins2, localIds };
    }
    function getOpts(options, all) {
        if (!all && options === false) {
            return null;
        }
        if (options === true) {
            return {};
        }
        return options;
    }
    function createDescriptors(
        chart,
        { plugins: plugins2, localIds },
        options,
        all
    ) {
        const result = [];
        const context = chart.getContext();
        for (const plugin2 of plugins2) {
            const id2 = plugin2.id;
            const opts = getOpts(options[id2], all);
            if (opts === null) {
                continue;
            }
            result.push({
                plugin: plugin2,
                options: pluginOpts(
                    chart.config,
                    { plugin: plugin2, local: localIds[id2] },
                    opts,
                    context
                ),
            });
        }
        return result;
    }
    function pluginOpts(config, { plugin: plugin2, local }, opts, context) {
        const keys = config.pluginScopeKeys(plugin2);
        const scopes = config.getOptionScopes(opts, keys);
        if (local && plugin2.defaults) {
            scopes.push(plugin2.defaults);
        }
        return config.createResolver(scopes, context, [''], {
            scriptable: false,
            indexable: false,
            allKeys: true,
        });
    }
    function getIndexAxis(type2, options) {
        const datasetDefaults = defaults.datasets[type2] || {};
        const datasetOptions = (options.datasets || {})[type2] || {};
        return (
            datasetOptions.indexAxis ||
            options.indexAxis ||
            datasetDefaults.indexAxis ||
            'x'
        );
    }
    function getAxisFromDefaultScaleID(id2, indexAxis) {
        let axis = id2;
        if (id2 === '_index_') {
            axis = indexAxis;
        } else if (id2 === '_value_') {
            axis = indexAxis === 'x' ? 'y' : 'x';
        }
        return axis;
    }
    function getDefaultScaleIDFromAxis(axis, indexAxis) {
        return axis === indexAxis ? '_index_' : '_value_';
    }
    function axisFromPosition(position) {
        if (position === 'top' || position === 'bottom') {
            return 'x';
        }
        if (position === 'left' || position === 'right') {
            return 'y';
        }
    }
    function determineAxis(id2, scaleOptions) {
        if (id2 === 'x' || id2 === 'y') {
            return id2;
        }
        return (
            scaleOptions.axis ||
            axisFromPosition(scaleOptions.position) ||
            id2.charAt(0).toLowerCase()
        );
    }
    function mergeScaleConfig(config, options) {
        const chartDefaults = overrides[config.type] || { scales: {} };
        const configScales = options.scales || {};
        const chartIndexAxis = getIndexAxis(config.type, options);
        const firstIDs = /* @__PURE__ */ Object.create(null);
        const scales2 = /* @__PURE__ */ Object.create(null);
        Object.keys(configScales).forEach((id2) => {
            const scaleConf = configScales[id2];
            if (!isObject(scaleConf)) {
                return console.error(
                    `Invalid scale configuration for scale: ${id2}`
                );
            }
            if (scaleConf._proxy) {
                return console.warn(
                    `Ignoring resolver passed as options for scale: ${id2}`
                );
            }
            const axis = determineAxis(id2, scaleConf);
            const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
            const defaultScaleOptions = chartDefaults.scales || {};
            firstIDs[axis] = firstIDs[axis] || id2;
            scales2[id2] = mergeIf(/* @__PURE__ */ Object.create(null), [
                { axis },
                scaleConf,
                defaultScaleOptions[axis],
                defaultScaleOptions[defaultId],
            ]);
        });
        config.data.datasets.forEach((dataset) => {
            const type2 = dataset.type || config.type;
            const indexAxis = dataset.indexAxis || getIndexAxis(type2, options);
            const datasetDefaults = overrides[type2] || {};
            const defaultScaleOptions = datasetDefaults.scales || {};
            Object.keys(defaultScaleOptions).forEach((defaultID) => {
                const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
                const id2 = dataset[axis + 'AxisID'] || firstIDs[axis] || axis;
                scales2[id2] =
                    scales2[id2] || /* @__PURE__ */ Object.create(null);
                mergeIf(scales2[id2], [
                    { axis },
                    configScales[id2],
                    defaultScaleOptions[defaultID],
                ]);
            });
        });
        Object.keys(scales2).forEach((key) => {
            const scale = scales2[key];
            mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);
        });
        return scales2;
    }
    function initOptions(config) {
        const options = config.options || (config.options = {});
        options.plugins = valueOrDefault(options.plugins, {});
        options.scales = mergeScaleConfig(config, options);
    }
    function initData(data) {
        data = data || {};
        data.datasets = data.datasets || [];
        data.labels = data.labels || [];
        return data;
    }
    function initConfig(config) {
        config = config || {};
        config.data = initData(config.data);
        initOptions(config);
        return config;
    }
    var keyCache = /* @__PURE__ */ new Map();
    var keysCached = /* @__PURE__ */ new Set();
    function cachedKeys(cacheKey, generate) {
        let keys = keyCache.get(cacheKey);
        if (!keys) {
            keys = generate();
            keyCache.set(cacheKey, keys);
            keysCached.add(keys);
        }
        return keys;
    }
    var addIfFound = (set4, obj, key) => {
        const opts = resolveObjectKey(obj, key);
        if (opts !== void 0) {
            set4.add(opts);
        }
    };
    var Config = class {
        constructor(config) {
            this._config = initConfig(config);
            this._scopeCache = /* @__PURE__ */ new Map();
            this._resolverCache = /* @__PURE__ */ new Map();
        }
        get platform() {
            return this._config.platform;
        }
        get type() {
            return this._config.type;
        }
        set type(type2) {
            this._config.type = type2;
        }
        get data() {
            return this._config.data;
        }
        set data(data) {
            this._config.data = initData(data);
        }
        get options() {
            return this._config.options;
        }
        set options(options) {
            this._config.options = options;
        }
        get plugins() {
            return this._config.plugins;
        }
        update() {
            const config = this._config;
            this.clearCache();
            initOptions(config);
        }
        clearCache() {
            this._scopeCache.clear();
            this._resolverCache.clear();
        }
        datasetScopeKeys(datasetType) {
            return cachedKeys(datasetType, () => [
                [`datasets.${datasetType}`, ''],
            ]);
        }
        datasetAnimationScopeKeys(datasetType, transition2) {
            return cachedKeys(
                `${datasetType}.transition.${transition2}`,
                () => [
                    [
                        `datasets.${datasetType}.transitions.${transition2}`,
                        `transitions.${transition2}`,
                    ],
                    [`datasets.${datasetType}`, ''],
                ]
            );
        }
        datasetElementScopeKeys(datasetType, elementType) {
            return cachedKeys(`${datasetType}-${elementType}`, () => [
                [
                    `datasets.${datasetType}.elements.${elementType}`,
                    `datasets.${datasetType}`,
                    `elements.${elementType}`,
                    '',
                ],
            ]);
        }
        pluginScopeKeys(plugin2) {
            const id2 = plugin2.id;
            const type2 = this.type;
            return cachedKeys(`${type2}-plugin-${id2}`, () => [
                [`plugins.${id2}`, ...(plugin2.additionalOptionScopes || [])],
            ]);
        }
        _cachedScopes(mainScope, resetCache) {
            const _scopeCache = this._scopeCache;
            let cache = _scopeCache.get(mainScope);
            if (!cache || resetCache) {
                cache = /* @__PURE__ */ new Map();
                _scopeCache.set(mainScope, cache);
            }
            return cache;
        }
        getOptionScopes(mainScope, keyLists, resetCache) {
            const { options, type: type2 } = this;
            const cache = this._cachedScopes(mainScope, resetCache);
            const cached = cache.get(keyLists);
            if (cached) {
                return cached;
            }
            const scopes = /* @__PURE__ */ new Set();
            keyLists.forEach((keys) => {
                if (mainScope) {
                    scopes.add(mainScope);
                    keys.forEach((key) => addIfFound(scopes, mainScope, key));
                }
                keys.forEach((key) => addIfFound(scopes, options, key));
                keys.forEach((key) =>
                    addIfFound(scopes, overrides[type2] || {}, key)
                );
                keys.forEach((key) => addIfFound(scopes, defaults, key));
                keys.forEach((key) => addIfFound(scopes, descriptors, key));
            });
            const array2 = Array.from(scopes);
            if (array2.length === 0) {
                array2.push(/* @__PURE__ */ Object.create(null));
            }
            if (keysCached.has(keyLists)) {
                cache.set(keyLists, array2);
            }
            return array2;
        }
        chartOptionScopes() {
            const { options, type: type2 } = this;
            return [
                options,
                overrides[type2] || {},
                defaults.datasets[type2] || {},
                { type: type2 },
                defaults,
                descriptors,
            ];
        }
        resolveNamedOptions(scopes, names2, context, prefixes2 = ['']) {
            const result = { $shared: true };
            const { resolver, subPrefixes } = getResolver(
                this._resolverCache,
                scopes,
                prefixes2
            );
            let options = resolver;
            if (needContext(resolver, names2)) {
                result.$shared = false;
                context = isFunction(context) ? context() : context;
                const subResolver = this.createResolver(
                    scopes,
                    context,
                    subPrefixes
                );
                options = _attachContext(resolver, context, subResolver);
            }
            for (const prop of names2) {
                result[prop] = options[prop];
            }
            return result;
        }
        createResolver(scopes, context, prefixes2 = [''], descriptorDefaults) {
            const { resolver } = getResolver(
                this._resolverCache,
                scopes,
                prefixes2
            );
            return isObject(context)
                ? _attachContext(resolver, context, void 0, descriptorDefaults)
                : resolver;
        }
    };
    function getResolver(resolverCache, scopes, prefixes2) {
        let cache = resolverCache.get(scopes);
        if (!cache) {
            cache = /* @__PURE__ */ new Map();
            resolverCache.set(scopes, cache);
        }
        const cacheKey = prefixes2.join();
        let cached = cache.get(cacheKey);
        if (!cached) {
            const resolver = _createResolver(scopes, prefixes2);
            cached = {
                resolver,
                subPrefixes: prefixes2.filter(
                    (p) => !p.toLowerCase().includes('hover')
                ),
            };
            cache.set(cacheKey, cached);
        }
        return cached;
    }
    var hasFunction = (value) =>
        isObject(value) &&
        Object.getOwnPropertyNames(value).reduce(
            (acc, key) => acc || isFunction(value[key]),
            false
        );
    function needContext(proxy, names2) {
        const { isScriptable, isIndexable } = _descriptors(proxy);
        for (const prop of names2) {
            const scriptable = isScriptable(prop);
            const indexable = isIndexable(prop);
            const value = (indexable || scriptable) && proxy[prop];
            if (
                (scriptable && (isFunction(value) || hasFunction(value))) ||
                (indexable && isArray(value))
            ) {
                return true;
            }
        }
        return false;
    }
    var version = '3.9.1';
    var KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];
    function positionIsHorizontal(position, axis) {
        return (
            position === 'top' ||
            position === 'bottom' ||
            (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x')
        );
    }
    function compare2Level(l1, l2) {
        return function (a, b) {
            return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
        };
    }
    function onAnimationsComplete(context) {
        const chart = context.chart;
        const animationOptions2 = chart.options.animation;
        chart.notifyPlugins('afterRender');
        callback(
            animationOptions2 && animationOptions2.onComplete,
            [context],
            chart
        );
    }
    function onAnimationProgress(context) {
        const chart = context.chart;
        const animationOptions2 = chart.options.animation;
        callback(
            animationOptions2 && animationOptions2.onProgress,
            [context],
            chart
        );
    }
    function getCanvas(item) {
        if (_isDomSupported() && typeof item === 'string') {
            item = document.getElementById(item);
        } else if (item && item.length) {
            item = item[0];
        }
        if (item && item.canvas) {
            item = item.canvas;
        }
        return item;
    }
    var instances = {};
    var getChart = (key) => {
        const canvas = getCanvas(key);
        return Object.values(instances)
            .filter((c) => c.canvas === canvas)
            .pop();
    };
    function moveNumericKeys(obj, start2, move) {
        const keys = Object.keys(obj);
        for (const key of keys) {
            const intKey = +key;
            if (intKey >= start2) {
                const value = obj[key];
                delete obj[key];
                if (move > 0 || intKey > start2) {
                    obj[intKey + move] = value;
                }
            }
        }
    }
    function determineLastEvent(e, lastEvent, inChartArea, isClick) {
        if (!inChartArea || e.type === 'mouseout') {
            return null;
        }
        if (isClick) {
            return lastEvent;
        }
        return e;
    }
    var Chart = class {
        constructor(item, userConfig) {
            const config = (this.config = new Config(userConfig));
            const initialCanvas = getCanvas(item);
            const existingChart = getChart(initialCanvas);
            if (existingChart) {
                throw new Error(
                    "Canvas is already in use. Chart with ID '" +
                        existingChart.id +
                        "' must be destroyed before the canvas with ID '" +
                        existingChart.canvas.id +
                        "' can be reused."
                );
            }
            const options = config.createResolver(
                config.chartOptionScopes(),
                this.getContext()
            );
            this.platform = new (config.platform ||
                _detectPlatform(initialCanvas))();
            this.platform.updateConfig(config);
            const context = this.platform.acquireContext(
                initialCanvas,
                options.aspectRatio
            );
            const canvas = context && context.canvas;
            const height = canvas && canvas.height;
            const width = canvas && canvas.width;
            this.id = uid();
            this.ctx = context;
            this.canvas = canvas;
            this.width = width;
            this.height = height;
            this._options = options;
            this._aspectRatio = this.aspectRatio;
            this._layers = [];
            this._metasets = [];
            this._stacks = void 0;
            this.boxes = [];
            this.currentDevicePixelRatio = void 0;
            this.chartArea = void 0;
            this._active = [];
            this._lastEvent = void 0;
            this._listeners = {};
            this._responsiveListeners = void 0;
            this._sortedMetasets = [];
            this.scales = {};
            this._plugins = new PluginService();
            this.$proxies = {};
            this._hiddenIndices = {};
            this.attached = false;
            this._animationsDisabled = void 0;
            this.$context = void 0;
            this._doResize = debounce(
                (mode) => this.update(mode),
                options.resizeDelay || 0
            );
            this._dataChanges = [];
            instances[this.id] = this;
            if (!context || !canvas) {
                console.error(
                    "Failed to create chart: can't acquire context from the given item"
                );
                return;
            }
            animator.listen(this, 'complete', onAnimationsComplete);
            animator.listen(this, 'progress', onAnimationProgress);
            this._initialize();
            if (this.attached) {
                this.update();
            }
        }
        get aspectRatio() {
            const {
                options: { aspectRatio, maintainAspectRatio },
                width,
                height,
                _aspectRatio,
            } = this;
            if (!isNullOrUndef(aspectRatio)) {
                return aspectRatio;
            }
            if (maintainAspectRatio && _aspectRatio) {
                return _aspectRatio;
            }
            return height ? width / height : null;
        }
        get data() {
            return this.config.data;
        }
        set data(data) {
            this.config.data = data;
        }
        get options() {
            return this._options;
        }
        set options(options) {
            this.config.options = options;
        }
        _initialize() {
            this.notifyPlugins('beforeInit');
            if (this.options.responsive) {
                this.resize();
            } else {
                retinaScale(this, this.options.devicePixelRatio);
            }
            this.bindEvents();
            this.notifyPlugins('afterInit');
            return this;
        }
        clear() {
            clearCanvas(this.canvas, this.ctx);
            return this;
        }
        stop() {
            animator.stop(this);
            return this;
        }
        resize(width, height) {
            if (!animator.running(this)) {
                this._resize(width, height);
            } else {
                this._resizeBeforeDraw = { width, height };
            }
        }
        _resize(width, height) {
            const options = this.options;
            const canvas = this.canvas;
            const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
            const newSize = this.platform.getMaximumSize(
                canvas,
                width,
                height,
                aspectRatio
            );
            const newRatio =
                options.devicePixelRatio || this.platform.getDevicePixelRatio();
            const mode = this.width ? 'resize' : 'attach';
            this.width = newSize.width;
            this.height = newSize.height;
            this._aspectRatio = this.aspectRatio;
            if (!retinaScale(this, newRatio, true)) {
                return;
            }
            this.notifyPlugins('resize', { size: newSize });
            callback(options.onResize, [this, newSize], this);
            if (this.attached) {
                if (this._doResize(mode)) {
                    this.render();
                }
            }
        }
        ensureScalesHaveIDs() {
            const options = this.options;
            const scalesOptions = options.scales || {};
            each(scalesOptions, (axisOptions, axisID) => {
                axisOptions.id = axisID;
            });
        }
        buildOrUpdateScales() {
            const options = this.options;
            const scaleOpts = options.scales;
            const scales2 = this.scales;
            const updated = Object.keys(scales2).reduce((obj, id2) => {
                obj[id2] = false;
                return obj;
            }, {});
            let items = [];
            if (scaleOpts) {
                items = items.concat(
                    Object.keys(scaleOpts).map((id2) => {
                        const scaleOptions = scaleOpts[id2];
                        const axis = determineAxis(id2, scaleOptions);
                        const isRadial = axis === 'r';
                        const isHorizontal = axis === 'x';
                        return {
                            options: scaleOptions,
                            dposition: isRadial
                                ? 'chartArea'
                                : isHorizontal
                                ? 'bottom'
                                : 'left',
                            dtype: isRadial
                                ? 'radialLinear'
                                : isHorizontal
                                ? 'category'
                                : 'linear',
                        };
                    })
                );
            }
            each(items, (item) => {
                const scaleOptions = item.options;
                const id2 = scaleOptions.id;
                const axis = determineAxis(id2, scaleOptions);
                const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
                if (
                    scaleOptions.position === void 0 ||
                    positionIsHorizontal(scaleOptions.position, axis) !==
                        positionIsHorizontal(item.dposition)
                ) {
                    scaleOptions.position = item.dposition;
                }
                updated[id2] = true;
                let scale = null;
                if (id2 in scales2 && scales2[id2].type === scaleType) {
                    scale = scales2[id2];
                } else {
                    const scaleClass = registry.getScale(scaleType);
                    scale = new scaleClass({
                        id: id2,
                        type: scaleType,
                        ctx: this.ctx,
                        chart: this,
                    });
                    scales2[scale.id] = scale;
                }
                scale.init(scaleOptions, options);
            });
            each(updated, (hasUpdated, id2) => {
                if (!hasUpdated) {
                    delete scales2[id2];
                }
            });
            each(scales2, (scale) => {
                layouts.configure(this, scale, scale.options);
                layouts.addBox(this, scale);
            });
        }
        _updateMetasets() {
            const metasets = this._metasets;
            const numData = this.data.datasets.length;
            const numMeta = metasets.length;
            metasets.sort((a, b) => a.index - b.index);
            if (numMeta > numData) {
                for (let i = numData; i < numMeta; ++i) {
                    this._destroyDatasetMeta(i);
                }
                metasets.splice(numData, numMeta - numData);
            }
            this._sortedMetasets = metasets
                .slice(0)
                .sort(compare2Level('order', 'index'));
        }
        _removeUnreferencedMetasets() {
            const {
                _metasets: metasets,
                data: { datasets },
            } = this;
            if (metasets.length > datasets.length) {
                delete this._stacks;
            }
            metasets.forEach((meta, index3) => {
                if (datasets.filter((x) => x === meta._dataset).length === 0) {
                    this._destroyDatasetMeta(index3);
                }
            });
        }
        buildOrUpdateControllers() {
            const newControllers = [];
            const datasets = this.data.datasets;
            let i, ilen;
            this._removeUnreferencedMetasets();
            for (i = 0, ilen = datasets.length; i < ilen; i++) {
                const dataset = datasets[i];
                let meta = this.getDatasetMeta(i);
                const type2 = dataset.type || this.config.type;
                if (meta.type && meta.type !== type2) {
                    this._destroyDatasetMeta(i);
                    meta = this.getDatasetMeta(i);
                }
                meta.type = type2;
                meta.indexAxis =
                    dataset.indexAxis || getIndexAxis(type2, this.options);
                meta.order = dataset.order || 0;
                meta.index = i;
                meta.label = '' + dataset.label;
                meta.visible = this.isDatasetVisible(i);
                if (meta.controller) {
                    meta.controller.updateIndex(i);
                    meta.controller.linkScales();
                } else {
                    const ControllerClass = registry.getController(type2);
                    const { datasetElementType, dataElementType } =
                        defaults.datasets[type2];
                    Object.assign(ControllerClass.prototype, {
                        dataElementType: registry.getElement(dataElementType),
                        datasetElementType:
                            datasetElementType &&
                            registry.getElement(datasetElementType),
                    });
                    meta.controller = new ControllerClass(this, i);
                    newControllers.push(meta.controller);
                }
            }
            this._updateMetasets();
            return newControllers;
        }
        _resetElements() {
            each(
                this.data.datasets,
                (dataset, datasetIndex) => {
                    this.getDatasetMeta(datasetIndex).controller.reset();
                },
                this
            );
        }
        reset() {
            this._resetElements();
            this.notifyPlugins('reset');
        }
        update(mode) {
            const config = this.config;
            config.update();
            const options = (this._options = config.createResolver(
                config.chartOptionScopes(),
                this.getContext()
            ));
            const animsDisabled = (this._animationsDisabled =
                !options.animation);
            this._updateScales();
            this._checkEventBindings();
            this._updateHiddenIndices();
            this._plugins.invalidate();
            if (
                this.notifyPlugins('beforeUpdate', {
                    mode,
                    cancelable: true,
                }) === false
            ) {
                return;
            }
            const newControllers = this.buildOrUpdateControllers();
            this.notifyPlugins('beforeElementsUpdate');
            let minPadding = 0;
            for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
                const { controller } = this.getDatasetMeta(i);
                const reset =
                    !animsDisabled && newControllers.indexOf(controller) === -1;
                controller.buildOrUpdateElements(reset);
                minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
            }
            minPadding = this._minPadding = options.layout.autoPadding
                ? minPadding
                : 0;
            this._updateLayout(minPadding);
            if (!animsDisabled) {
                each(newControllers, (controller) => {
                    controller.reset();
                });
            }
            this._updateDatasets(mode);
            this.notifyPlugins('afterUpdate', { mode });
            this._layers.sort(compare2Level('z', '_idx'));
            const { _active, _lastEvent } = this;
            if (_lastEvent) {
                this._eventHandler(_lastEvent, true);
            } else if (_active.length) {
                this._updateHoverStyles(_active, _active, true);
            }
            this.render();
        }
        _updateScales() {
            each(this.scales, (scale) => {
                layouts.removeBox(this, scale);
            });
            this.ensureScalesHaveIDs();
            this.buildOrUpdateScales();
        }
        _checkEventBindings() {
            const options = this.options;
            const existingEvents = new Set(Object.keys(this._listeners));
            const newEvents = new Set(options.events);
            if (
                !setsEqual(existingEvents, newEvents) ||
                !!this._responsiveListeners !== options.responsive
            ) {
                this.unbindEvents();
                this.bindEvents();
            }
        }
        _updateHiddenIndices() {
            const { _hiddenIndices } = this;
            const changes = this._getUniformDataChanges() || [];
            for (const { method, start: start2, count } of changes) {
                const move = method === '_removeElements' ? -count : count;
                moveNumericKeys(_hiddenIndices, start2, move);
            }
        }
        _getUniformDataChanges() {
            const _dataChanges = this._dataChanges;
            if (!_dataChanges || !_dataChanges.length) {
                return;
            }
            this._dataChanges = [];
            const datasetCount = this.data.datasets.length;
            const makeSet = (idx) =>
                new Set(
                    _dataChanges
                        .filter((c) => c[0] === idx)
                        .map((c, i) => i + ',' + c.splice(1).join(','))
                );
            const changeSet = makeSet(0);
            for (let i = 1; i < datasetCount; i++) {
                if (!setsEqual(changeSet, makeSet(i))) {
                    return;
                }
            }
            return Array.from(changeSet)
                .map((c) => c.split(','))
                .map((a) => ({ method: a[1], start: +a[2], count: +a[3] }));
        }
        _updateLayout(minPadding) {
            if (
                this.notifyPlugins('beforeLayout', { cancelable: true }) ===
                false
            ) {
                return;
            }
            layouts.update(this, this.width, this.height, minPadding);
            const area = this.chartArea;
            const noArea = area.width <= 0 || area.height <= 0;
            this._layers = [];
            each(
                this.boxes,
                (box) => {
                    if (noArea && box.position === 'chartArea') {
                        return;
                    }
                    if (box.configure) {
                        box.configure();
                    }
                    this._layers.push(...box._layers());
                },
                this
            );
            this._layers.forEach((item, index3) => {
                item._idx = index3;
            });
            this.notifyPlugins('afterLayout');
        }
        _updateDatasets(mode) {
            if (
                this.notifyPlugins('beforeDatasetsUpdate', {
                    mode,
                    cancelable: true,
                }) === false
            ) {
                return;
            }
            for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
                this.getDatasetMeta(i).controller.configure();
            }
            for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
                this._updateDataset(
                    i,
                    isFunction(mode) ? mode({ datasetIndex: i }) : mode
                );
            }
            this.notifyPlugins('afterDatasetsUpdate', { mode });
        }
        _updateDataset(index3, mode) {
            const meta = this.getDatasetMeta(index3);
            const args = { meta, index: index3, mode, cancelable: true };
            if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {
                return;
            }
            meta.controller._update(mode);
            args.cancelable = false;
            this.notifyPlugins('afterDatasetUpdate', args);
        }
        render() {
            if (
                this.notifyPlugins('beforeRender', { cancelable: true }) ===
                false
            ) {
                return;
            }
            if (animator.has(this)) {
                if (this.attached && !animator.running(this)) {
                    animator.start(this);
                }
            } else {
                this.draw();
                onAnimationsComplete({ chart: this });
            }
        }
        draw() {
            let i;
            if (this._resizeBeforeDraw) {
                const { width, height } = this._resizeBeforeDraw;
                this._resize(width, height);
                this._resizeBeforeDraw = null;
            }
            this.clear();
            if (this.width <= 0 || this.height <= 0) {
                return;
            }
            if (
                this.notifyPlugins('beforeDraw', { cancelable: true }) === false
            ) {
                return;
            }
            const layers = this._layers;
            for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
                layers[i].draw(this.chartArea);
            }
            this._drawDatasets();
            for (; i < layers.length; ++i) {
                layers[i].draw(this.chartArea);
            }
            this.notifyPlugins('afterDraw');
        }
        _getSortedDatasetMetas(filterVisible) {
            const metasets = this._sortedMetasets;
            const result = [];
            let i, ilen;
            for (i = 0, ilen = metasets.length; i < ilen; ++i) {
                const meta = metasets[i];
                if (!filterVisible || meta.visible) {
                    result.push(meta);
                }
            }
            return result;
        }
        getSortedVisibleDatasetMetas() {
            return this._getSortedDatasetMetas(true);
        }
        _drawDatasets() {
            if (
                this.notifyPlugins('beforeDatasetsDraw', {
                    cancelable: true,
                }) === false
            ) {
                return;
            }
            const metasets = this.getSortedVisibleDatasetMetas();
            for (let i = metasets.length - 1; i >= 0; --i) {
                this._drawDataset(metasets[i]);
            }
            this.notifyPlugins('afterDatasetsDraw');
        }
        _drawDataset(meta) {
            const ctx = this.ctx;
            const clip = meta._clip;
            const useClip = !clip.disabled;
            const area = this.chartArea;
            const args = {
                meta,
                index: meta.index,
                cancelable: true,
            };
            if (this.notifyPlugins('beforeDatasetDraw', args) === false) {
                return;
            }
            if (useClip) {
                clipArea(ctx, {
                    left: clip.left === false ? 0 : area.left - clip.left,
                    right:
                        clip.right === false
                            ? this.width
                            : area.right + clip.right,
                    top: clip.top === false ? 0 : area.top - clip.top,
                    bottom:
                        clip.bottom === false
                            ? this.height
                            : area.bottom + clip.bottom,
                });
            }
            meta.controller.draw();
            if (useClip) {
                unclipArea(ctx);
            }
            args.cancelable = false;
            this.notifyPlugins('afterDatasetDraw', args);
        }
        isPointInArea(point) {
            return _isPointInArea(point, this.chartArea, this._minPadding);
        }
        getElementsAtEventForMode(e, mode, options, useFinalPosition) {
            const method = Interaction.modes[mode];
            if (typeof method === 'function') {
                return method(this, e, options, useFinalPosition);
            }
            return [];
        }
        getDatasetMeta(datasetIndex) {
            const dataset = this.data.datasets[datasetIndex];
            const metasets = this._metasets;
            let meta = metasets
                .filter((x) => x && x._dataset === dataset)
                .pop();
            if (!meta) {
                meta = {
                    type: null,
                    data: [],
                    dataset: null,
                    controller: null,
                    hidden: null,
                    xAxisID: null,
                    yAxisID: null,
                    order: (dataset && dataset.order) || 0,
                    index: datasetIndex,
                    _dataset: dataset,
                    _parsed: [],
                    _sorted: false,
                };
                metasets.push(meta);
            }
            return meta;
        }
        getContext() {
            return (
                this.$context ||
                (this.$context = createContext(null, {
                    chart: this,
                    type: 'chart',
                }))
            );
        }
        getVisibleDatasetCount() {
            return this.getSortedVisibleDatasetMetas().length;
        }
        isDatasetVisible(datasetIndex) {
            const dataset = this.data.datasets[datasetIndex];
            if (!dataset) {
                return false;
            }
            const meta = this.getDatasetMeta(datasetIndex);
            return typeof meta.hidden === 'boolean'
                ? !meta.hidden
                : !dataset.hidden;
        }
        setDatasetVisibility(datasetIndex, visible) {
            const meta = this.getDatasetMeta(datasetIndex);
            meta.hidden = !visible;
        }
        toggleDataVisibility(index3) {
            this._hiddenIndices[index3] = !this._hiddenIndices[index3];
        }
        getDataVisibility(index3) {
            return !this._hiddenIndices[index3];
        }
        _updateVisibility(datasetIndex, dataIndex, visible) {
            const mode = visible ? 'show' : 'hide';
            const meta = this.getDatasetMeta(datasetIndex);
            const anims = meta.controller._resolveAnimations(void 0, mode);
            if (defined(dataIndex)) {
                meta.data[dataIndex].hidden = !visible;
                this.update();
            } else {
                this.setDatasetVisibility(datasetIndex, visible);
                anims.update(meta, { visible });
                this.update((ctx) =>
                    ctx.datasetIndex === datasetIndex ? mode : void 0
                );
            }
        }
        hide(datasetIndex, dataIndex) {
            this._updateVisibility(datasetIndex, dataIndex, false);
        }
        show(datasetIndex, dataIndex) {
            this._updateVisibility(datasetIndex, dataIndex, true);
        }
        _destroyDatasetMeta(datasetIndex) {
            const meta = this._metasets[datasetIndex];
            if (meta && meta.controller) {
                meta.controller._destroy();
            }
            delete this._metasets[datasetIndex];
        }
        _stop() {
            let i, ilen;
            this.stop();
            animator.remove(this);
            for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
                this._destroyDatasetMeta(i);
            }
        }
        destroy() {
            this.notifyPlugins('beforeDestroy');
            const { canvas, ctx } = this;
            this._stop();
            this.config.clearCache();
            if (canvas) {
                this.unbindEvents();
                clearCanvas(canvas, ctx);
                this.platform.releaseContext(ctx);
                this.canvas = null;
                this.ctx = null;
            }
            this.notifyPlugins('destroy');
            delete instances[this.id];
            this.notifyPlugins('afterDestroy');
        }
        toBase64Image(...args) {
            return this.canvas.toDataURL(...args);
        }
        bindEvents() {
            this.bindUserEvents();
            if (this.options.responsive) {
                this.bindResponsiveEvents();
            } else {
                this.attached = true;
            }
        }
        bindUserEvents() {
            const listeners = this._listeners;
            const platform = this.platform;
            const _add = (type2, listener2) => {
                platform.addEventListener(this, type2, listener2);
                listeners[type2] = listener2;
            };
            const listener = (e, x, y) => {
                e.offsetX = x;
                e.offsetY = y;
                this._eventHandler(e);
            };
            each(this.options.events, (type2) => _add(type2, listener));
        }
        bindResponsiveEvents() {
            if (!this._responsiveListeners) {
                this._responsiveListeners = {};
            }
            const listeners = this._responsiveListeners;
            const platform = this.platform;
            const _add = (type2, listener2) => {
                platform.addEventListener(this, type2, listener2);
                listeners[type2] = listener2;
            };
            const _remove = (type2, listener2) => {
                if (listeners[type2]) {
                    platform.removeEventListener(this, type2, listener2);
                    delete listeners[type2];
                }
            };
            const listener = (width, height) => {
                if (this.canvas) {
                    this.resize(width, height);
                }
            };
            let detached;
            const attached = () => {
                _remove('attach', attached);
                this.attached = true;
                this.resize();
                _add('resize', listener);
                _add('detach', detached);
            };
            detached = () => {
                this.attached = false;
                _remove('resize', listener);
                this._stop();
                this._resize(0, 0);
                _add('attach', attached);
            };
            if (platform.isAttached(this.canvas)) {
                attached();
            } else {
                detached();
            }
        }
        unbindEvents() {
            each(this._listeners, (listener, type2) => {
                this.platform.removeEventListener(this, type2, listener);
            });
            this._listeners = {};
            each(this._responsiveListeners, (listener, type2) => {
                this.platform.removeEventListener(this, type2, listener);
            });
            this._responsiveListeners = void 0;
        }
        updateHoverStyle(items, mode, enabled) {
            const prefix = enabled ? 'set' : 'remove';
            let meta, item, i, ilen;
            if (mode === 'dataset') {
                meta = this.getDatasetMeta(items[0].datasetIndex);
                meta.controller['_' + prefix + 'DatasetHoverStyle']();
            }
            for (i = 0, ilen = items.length; i < ilen; ++i) {
                item = items[i];
                const controller =
                    item && this.getDatasetMeta(item.datasetIndex).controller;
                if (controller) {
                    controller[prefix + 'HoverStyle'](
                        item.element,
                        item.datasetIndex,
                        item.index
                    );
                }
            }
        }
        getActiveElements() {
            return this._active || [];
        }
        setActiveElements(activeElements) {
            const lastActive = this._active || [];
            const active = activeElements.map(
                ({ datasetIndex, index: index3 }) => {
                    const meta = this.getDatasetMeta(datasetIndex);
                    if (!meta) {
                        throw new Error(
                            'No dataset found at index ' + datasetIndex
                        );
                    }
                    return {
                        datasetIndex,
                        element: meta.data[index3],
                        index: index3,
                    };
                }
            );
            const changed = !_elementsEqual(active, lastActive);
            if (changed) {
                this._active = active;
                this._lastEvent = null;
                this._updateHoverStyles(active, lastActive);
            }
        }
        notifyPlugins(hook, args, filter2) {
            return this._plugins.notify(this, hook, args, filter2);
        }
        _updateHoverStyles(active, lastActive, replay) {
            const hoverOptions = this.options.hover;
            const diff = (a, b) =>
                a.filter(
                    (x) =>
                        !b.some(
                            (y) =>
                                x.datasetIndex === y.datasetIndex &&
                                x.index === y.index
                        )
                );
            const deactivated = diff(lastActive, active);
            const activated = replay ? active : diff(active, lastActive);
            if (deactivated.length) {
                this.updateHoverStyle(deactivated, hoverOptions.mode, false);
            }
            if (activated.length && hoverOptions.mode) {
                this.updateHoverStyle(activated, hoverOptions.mode, true);
            }
        }
        _eventHandler(e, replay) {
            const args = {
                event: e,
                replay,
                cancelable: true,
                inChartArea: this.isPointInArea(e),
            };
            const eventFilter = (plugin2) =>
                (plugin2.options.events || this.options.events).includes(
                    e.native.type
                );
            if (
                this.notifyPlugins('beforeEvent', args, eventFilter) === false
            ) {
                return;
            }
            const changed = this._handleEvent(e, replay, args.inChartArea);
            args.cancelable = false;
            this.notifyPlugins('afterEvent', args, eventFilter);
            if (changed || args.changed) {
                this.render();
            }
            return this;
        }
        _handleEvent(e, replay, inChartArea) {
            const { _active: lastActive = [], options } = this;
            const useFinalPosition = replay;
            const active = this._getActiveElements(
                e,
                lastActive,
                inChartArea,
                useFinalPosition
            );
            const isClick = _isClickEvent(e);
            const lastEvent = determineLastEvent(
                e,
                this._lastEvent,
                inChartArea,
                isClick
            );
            if (inChartArea) {
                this._lastEvent = null;
                callback(options.onHover, [e, active, this], this);
                if (isClick) {
                    callback(options.onClick, [e, active, this], this);
                }
            }
            const changed = !_elementsEqual(active, lastActive);
            if (changed || replay) {
                this._active = active;
                this._updateHoverStyles(active, lastActive, replay);
            }
            this._lastEvent = lastEvent;
            return changed;
        }
        _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
            if (e.type === 'mouseout') {
                return [];
            }
            if (!inChartArea) {
                return lastActive;
            }
            const hoverOptions = this.options.hover;
            return this.getElementsAtEventForMode(
                e,
                hoverOptions.mode,
                hoverOptions,
                useFinalPosition
            );
        }
    };
    var invalidatePlugins = () =>
        each(Chart.instances, (chart) => chart._plugins.invalidate());
    var enumerable = true;
    Object.defineProperties(Chart, {
        defaults: {
            enumerable,
            value: defaults,
        },
        instances: {
            enumerable,
            value: instances,
        },
        overrides: {
            enumerable,
            value: overrides,
        },
        registry: {
            enumerable,
            value: registry,
        },
        version: {
            enumerable,
            value: version,
        },
        getChart: {
            enumerable,
            value: getChart,
        },
        register: {
            enumerable,
            value: (...items) => {
                registry.add(...items);
                invalidatePlugins();
            },
        },
        unregister: {
            enumerable,
            value: (...items) => {
                registry.remove(...items);
                invalidatePlugins();
            },
        },
    });
    function clipArc(ctx, element, endAngle) {
        const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } =
            element;
        let angleMargin = pixelMargin / outerRadius;
        ctx.beginPath();
        ctx.arc(
            x,
            y,
            outerRadius,
            startAngle - angleMargin,
            endAngle + angleMargin
        );
        if (innerRadius > pixelMargin) {
            angleMargin = pixelMargin / innerRadius;
            ctx.arc(
                x,
                y,
                innerRadius,
                endAngle + angleMargin,
                startAngle - angleMargin,
                true
            );
        } else {
            ctx.arc(
                x,
                y,
                pixelMargin,
                endAngle + HALF_PI,
                startAngle - HALF_PI
            );
        }
        ctx.closePath();
        ctx.clip();
    }
    function toRadiusCorners(value) {
        return _readValueToProps(value, [
            'outerStart',
            'outerEnd',
            'innerStart',
            'innerEnd',
        ]);
    }
    function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
        const o = toRadiusCorners(arc.options.borderRadius);
        const halfThickness = (outerRadius - innerRadius) / 2;
        const innerLimit = Math.min(
            halfThickness,
            (angleDelta * innerRadius) / 2
        );
        const computeOuterLimit = (val) => {
            const outerArcLimit =
                ((outerRadius - Math.min(halfThickness, val)) * angleDelta) / 2;
            return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
        };
        return {
            outerStart: computeOuterLimit(o.outerStart),
            outerEnd: computeOuterLimit(o.outerEnd),
            innerStart: _limitValue(o.innerStart, 0, innerLimit),
            innerEnd: _limitValue(o.innerEnd, 0, innerLimit),
        };
    }
    function rThetaToXY(r, theta, x, y) {
        return {
            x: x + r * Math.cos(theta),
            y: y + r * Math.sin(theta),
        };
    }
    function pathArc(ctx, element, offset, spacing, end, circular) {
        const {
            x,
            y,
            startAngle: start2,
            pixelMargin,
            innerRadius: innerR,
        } = element;
        const outerRadius = Math.max(
            element.outerRadius + spacing + offset - pixelMargin,
            0
        );
        const innerRadius =
            innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
        let spacingOffset = 0;
        const alpha2 = end - start2;
        if (spacing) {
            const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
            const noSpacingOuterRadius =
                outerRadius > 0 ? outerRadius - spacing : 0;
            const avNogSpacingRadius =
                (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
            const adjustedAngle =
                avNogSpacingRadius !== 0
                    ? (alpha2 * avNogSpacingRadius) /
                      (avNogSpacingRadius + spacing)
                    : alpha2;
            spacingOffset = (alpha2 - adjustedAngle) / 2;
        }
        const beta =
            Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
        const angleOffset = (alpha2 - beta) / 2;
        const startAngle = start2 + angleOffset + spacingOffset;
        const endAngle = end - angleOffset - spacingOffset;
        const { outerStart, outerEnd, innerStart, innerEnd } =
            parseBorderRadius$1(
                element,
                innerRadius,
                outerRadius,
                endAngle - startAngle
            );
        const outerStartAdjustedRadius = outerRadius - outerStart;
        const outerEndAdjustedRadius = outerRadius - outerEnd;
        const outerStartAdjustedAngle =
            startAngle + outerStart / outerStartAdjustedRadius;
        const outerEndAdjustedAngle =
            endAngle - outerEnd / outerEndAdjustedRadius;
        const innerStartAdjustedRadius = innerRadius + innerStart;
        const innerEndAdjustedRadius = innerRadius + innerEnd;
        const innerStartAdjustedAngle =
            startAngle + innerStart / innerStartAdjustedRadius;
        const innerEndAdjustedAngle =
            endAngle - innerEnd / innerEndAdjustedRadius;
        ctx.beginPath();
        if (circular) {
            ctx.arc(
                x,
                y,
                outerRadius,
                outerStartAdjustedAngle,
                outerEndAdjustedAngle
            );
            if (outerEnd > 0) {
                const pCenter = rThetaToXY(
                    outerEndAdjustedRadius,
                    outerEndAdjustedAngle,
                    x,
                    y
                );
                ctx.arc(
                    pCenter.x,
                    pCenter.y,
                    outerEnd,
                    outerEndAdjustedAngle,
                    endAngle + HALF_PI
                );
            }
            const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
            ctx.lineTo(p4.x, p4.y);
            if (innerEnd > 0) {
                const pCenter = rThetaToXY(
                    innerEndAdjustedRadius,
                    innerEndAdjustedAngle,
                    x,
                    y
                );
                ctx.arc(
                    pCenter.x,
                    pCenter.y,
                    innerEnd,
                    endAngle + HALF_PI,
                    innerEndAdjustedAngle + Math.PI
                );
            }
            ctx.arc(
                x,
                y,
                innerRadius,
                endAngle - innerEnd / innerRadius,
                startAngle + innerStart / innerRadius,
                true
            );
            if (innerStart > 0) {
                const pCenter = rThetaToXY(
                    innerStartAdjustedRadius,
                    innerStartAdjustedAngle,
                    x,
                    y
                );
                ctx.arc(
                    pCenter.x,
                    pCenter.y,
                    innerStart,
                    innerStartAdjustedAngle + Math.PI,
                    startAngle - HALF_PI
                );
            }
            const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
            ctx.lineTo(p8.x, p8.y);
            if (outerStart > 0) {
                const pCenter = rThetaToXY(
                    outerStartAdjustedRadius,
                    outerStartAdjustedAngle,
                    x,
                    y
                );
                ctx.arc(
                    pCenter.x,
                    pCenter.y,
                    outerStart,
                    startAngle - HALF_PI,
                    outerStartAdjustedAngle
                );
            }
        } else {
            ctx.moveTo(x, y);
            const outerStartX =
                Math.cos(outerStartAdjustedAngle) * outerRadius + x;
            const outerStartY =
                Math.sin(outerStartAdjustedAngle) * outerRadius + y;
            ctx.lineTo(outerStartX, outerStartY);
            const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
            const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
            ctx.lineTo(outerEndX, outerEndY);
        }
        ctx.closePath();
    }
    function drawArc(ctx, element, offset, spacing, circular) {
        const { fullCircles, startAngle, circumference } = element;
        let endAngle = element.endAngle;
        if (fullCircles) {
            pathArc(ctx, element, offset, spacing, startAngle + TAU, circular);
            for (let i = 0; i < fullCircles; ++i) {
                ctx.fill();
            }
            if (!isNaN(circumference)) {
                endAngle = startAngle + (circumference % TAU);
                if (circumference % TAU === 0) {
                    endAngle += TAU;
                }
            }
        }
        pathArc(ctx, element, offset, spacing, endAngle, circular);
        ctx.fill();
        return endAngle;
    }
    function drawFullCircleBorders(ctx, element, inner) {
        const { x, y, startAngle, pixelMargin, fullCircles } = element;
        const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);
        const innerRadius = element.innerRadius + pixelMargin;
        let i;
        if (inner) {
            clipArc(ctx, element, startAngle + TAU);
        }
        ctx.beginPath();
        ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);
        for (i = 0; i < fullCircles; ++i) {
            ctx.stroke();
        }
        ctx.beginPath();
        ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);
        for (i = 0; i < fullCircles; ++i) {
            ctx.stroke();
        }
    }
    function drawBorder(ctx, element, offset, spacing, endAngle, circular) {
        const { options } = element;
        const { borderWidth: borderWidth3, borderJoinStyle } = options;
        const inner = options.borderAlign === 'inner';
        if (!borderWidth3) {
            return;
        }
        if (inner) {
            ctx.lineWidth = borderWidth3 * 2;
            ctx.lineJoin = borderJoinStyle || 'round';
        } else {
            ctx.lineWidth = borderWidth3;
            ctx.lineJoin = borderJoinStyle || 'bevel';
        }
        if (element.fullCircles) {
            drawFullCircleBorders(ctx, element, inner);
        }
        if (inner) {
            clipArc(ctx, element, endAngle);
        }
        pathArc(ctx, element, offset, spacing, endAngle, circular);
        ctx.stroke();
    }
    var ArcElement = class extends Element {
        constructor(cfg) {
            super();
            this.options = void 0;
            this.circumference = void 0;
            this.startAngle = void 0;
            this.endAngle = void 0;
            this.innerRadius = void 0;
            this.outerRadius = void 0;
            this.pixelMargin = 0;
            this.fullCircles = 0;
            if (cfg) {
                Object.assign(this, cfg);
            }
        }
        inRange(chartX, chartY, useFinalPosition) {
            const point = this.getProps(['x', 'y'], useFinalPosition);
            const { angle, distance } = getAngleFromPoint(point, {
                x: chartX,
                y: chartY,
            });
            const {
                startAngle,
                endAngle,
                innerRadius,
                outerRadius,
                circumference,
            } = this.getProps(
                [
                    'startAngle',
                    'endAngle',
                    'innerRadius',
                    'outerRadius',
                    'circumference',
                ],
                useFinalPosition
            );
            const rAdjust = this.options.spacing / 2;
            const _circumference = valueOrDefault(
                circumference,
                endAngle - startAngle
            );
            const betweenAngles =
                _circumference >= TAU ||
                _angleBetween(angle, startAngle, endAngle);
            const withinRadius = _isBetween(
                distance,
                innerRadius + rAdjust,
                outerRadius + rAdjust
            );
            return betweenAngles && withinRadius;
        }
        getCenterPoint(useFinalPosition) {
            const { x, y, startAngle, endAngle, innerRadius, outerRadius } =
                this.getProps(
                    [
                        'x',
                        'y',
                        'startAngle',
                        'endAngle',
                        'innerRadius',
                        'outerRadius',
                        'circumference',
                    ],
                    useFinalPosition
                );
            const { offset, spacing } = this.options;
            const halfAngle = (startAngle + endAngle) / 2;
            const halfRadius =
                (innerRadius + outerRadius + spacing + offset) / 2;
            return {
                x: x + Math.cos(halfAngle) * halfRadius,
                y: y + Math.sin(halfAngle) * halfRadius,
            };
        }
        tooltipPosition(useFinalPosition) {
            return this.getCenterPoint(useFinalPosition);
        }
        draw(ctx) {
            const { options, circumference } = this;
            const offset = (options.offset || 0) / 2;
            const spacing = (options.spacing || 0) / 2;
            const circular = options.circular;
            this.pixelMargin = options.borderAlign === 'inner' ? 0.33 : 0;
            this.fullCircles =
                circumference > TAU ? Math.floor(circumference / TAU) : 0;
            if (
                circumference === 0 ||
                this.innerRadius < 0 ||
                this.outerRadius < 0
            ) {
                return;
            }
            ctx.save();
            let radiusOffset = 0;
            if (offset) {
                radiusOffset = offset / 2;
                const halfAngle = (this.startAngle + this.endAngle) / 2;
                ctx.translate(
                    Math.cos(halfAngle) * radiusOffset,
                    Math.sin(halfAngle) * radiusOffset
                );
                if (this.circumference >= PI) {
                    radiusOffset = offset;
                }
            }
            ctx.fillStyle = options.backgroundColor;
            ctx.strokeStyle = options.borderColor;
            const endAngle = drawArc(
                ctx,
                this,
                radiusOffset,
                spacing,
                circular
            );
            drawBorder(ctx, this, radiusOffset, spacing, endAngle, circular);
            ctx.restore();
        }
    };
    ArcElement.id = 'arc';
    ArcElement.defaults = {
        borderAlign: 'center',
        borderColor: '#fff',
        borderJoinStyle: void 0,
        borderRadius: 0,
        borderWidth: 2,
        offset: 0,
        spacing: 0,
        angle: void 0,
        circular: true,
    };
    ArcElement.defaultRoutes = {
        backgroundColor: 'backgroundColor',
    };
    function setStyle(ctx, options, style = options) {
        ctx.lineCap = valueOrDefault(
            style.borderCapStyle,
            options.borderCapStyle
        );
        ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
        ctx.lineDashOffset = valueOrDefault(
            style.borderDashOffset,
            options.borderDashOffset
        );
        ctx.lineJoin = valueOrDefault(
            style.borderJoinStyle,
            options.borderJoinStyle
        );
        ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
        ctx.strokeStyle = valueOrDefault(
            style.borderColor,
            options.borderColor
        );
    }
    function lineTo(ctx, previous, target) {
        ctx.lineTo(target.x, target.y);
    }
    function getLineMethod(options) {
        if (options.stepped) {
            return _steppedLineTo;
        }
        if (options.tension || options.cubicInterpolationMode === 'monotone') {
            return _bezierCurveTo;
        }
        return lineTo;
    }
    function pathVars(points, segment, params = {}) {
        const count = points.length;
        const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
        const { start: segmentStart, end: segmentEnd } = segment;
        const start2 = Math.max(paramsStart, segmentStart);
        const end = Math.min(paramsEnd, segmentEnd);
        const outside =
            (paramsStart < segmentStart && paramsEnd < segmentStart) ||
            (paramsStart > segmentEnd && paramsEnd > segmentEnd);
        return {
            count,
            start: start2,
            loop: segment.loop,
            ilen:
                end < start2 && !outside ? count + end - start2 : end - start2,
        };
    }
    function pathSegment(ctx, line, segment, params) {
        const { points, options } = line;
        const {
            count,
            start: start2,
            loop,
            ilen,
        } = pathVars(points, segment, params);
        const lineMethod = getLineMethod(options);
        let { move = true, reverse } = params || {};
        let i, point, prev;
        for (i = 0; i <= ilen; ++i) {
            point = points[(start2 + (reverse ? ilen - i : i)) % count];
            if (point.skip) {
                continue;
            } else if (move) {
                ctx.moveTo(point.x, point.y);
                move = false;
            } else {
                lineMethod(ctx, prev, point, reverse, options.stepped);
            }
            prev = point;
        }
        if (loop) {
            point = points[(start2 + (reverse ? ilen : 0)) % count];
            lineMethod(ctx, prev, point, reverse, options.stepped);
        }
        return !!loop;
    }
    function fastPathSegment(ctx, line, segment, params) {
        const points = line.points;
        const {
            count,
            start: start2,
            ilen,
        } = pathVars(points, segment, params);
        const { move = true, reverse } = params || {};
        let avgX = 0;
        let countX = 0;
        let i, point, prevX, minY, maxY, lastY;
        const pointIndex = (index3) =>
            (start2 + (reverse ? ilen - index3 : index3)) % count;
        const drawX = () => {
            if (minY !== maxY) {
                ctx.lineTo(avgX, maxY);
                ctx.lineTo(avgX, minY);
                ctx.lineTo(avgX, lastY);
            }
        };
        if (move) {
            point = points[pointIndex(0)];
            ctx.moveTo(point.x, point.y);
        }
        for (i = 0; i <= ilen; ++i) {
            point = points[pointIndex(i)];
            if (point.skip) {
                continue;
            }
            const x = point.x;
            const y = point.y;
            const truncX = x | 0;
            if (truncX === prevX) {
                if (y < minY) {
                    minY = y;
                } else if (y > maxY) {
                    maxY = y;
                }
                avgX = (countX * avgX + x) / ++countX;
            } else {
                drawX();
                ctx.lineTo(x, y);
                prevX = truncX;
                countX = 0;
                minY = maxY = y;
            }
            lastY = y;
        }
        drawX();
    }
    function _getSegmentMethod(line) {
        const opts = line.options;
        const borderDash = opts.borderDash && opts.borderDash.length;
        const useFastPath =
            !line._decimated &&
            !line._loop &&
            !opts.tension &&
            opts.cubicInterpolationMode !== 'monotone' &&
            !opts.stepped &&
            !borderDash;
        return useFastPath ? fastPathSegment : pathSegment;
    }
    function _getInterpolationMethod(options) {
        if (options.stepped) {
            return _steppedInterpolation;
        }
        if (options.tension || options.cubicInterpolationMode === 'monotone') {
            return _bezierInterpolation;
        }
        return _pointInLine;
    }
    function strokePathWithCache(ctx, line, start2, count) {
        let path = line._path;
        if (!path) {
            path = line._path = new Path2D();
            if (line.path(path, start2, count)) {
                path.closePath();
            }
        }
        setStyle(ctx, line.options);
        ctx.stroke(path);
    }
    function strokePathDirect(ctx, line, start2, count) {
        const { segments, options } = line;
        const segmentMethod = _getSegmentMethod(line);
        for (const segment of segments) {
            setStyle(ctx, options, segment.style);
            ctx.beginPath();
            if (
                segmentMethod(ctx, line, segment, {
                    start: start2,
                    end: start2 + count - 1,
                })
            ) {
                ctx.closePath();
            }
            ctx.stroke();
        }
    }
    var usePath2D = typeof Path2D === 'function';
    function draw(ctx, line, start2, count) {
        if (usePath2D && !line.options.segment) {
            strokePathWithCache(ctx, line, start2, count);
        } else {
            strokePathDirect(ctx, line, start2, count);
        }
    }
    var LineElement = class extends Element {
        constructor(cfg) {
            super();
            this.animated = true;
            this.options = void 0;
            this._chart = void 0;
            this._loop = void 0;
            this._fullLoop = void 0;
            this._path = void 0;
            this._points = void 0;
            this._segments = void 0;
            this._decimated = false;
            this._pointsUpdated = false;
            this._datasetIndex = void 0;
            if (cfg) {
                Object.assign(this, cfg);
            }
        }
        updateControlPoints(chartArea, indexAxis) {
            const options = this.options;
            if (
                (options.tension ||
                    options.cubicInterpolationMode === 'monotone') &&
                !options.stepped &&
                !this._pointsUpdated
            ) {
                const loop = options.spanGaps ? this._loop : this._fullLoop;
                _updateBezierControlPoints(
                    this._points,
                    options,
                    chartArea,
                    loop,
                    indexAxis
                );
                this._pointsUpdated = true;
            }
        }
        set points(points) {
            this._points = points;
            delete this._segments;
            delete this._path;
            this._pointsUpdated = false;
        }
        get points() {
            return this._points;
        }
        get segments() {
            return (
                this._segments ||
                (this._segments = _computeSegments(this, this.options.segment))
            );
        }
        first() {
            const segments = this.segments;
            const points = this.points;
            return segments.length && points[segments[0].start];
        }
        last() {
            const segments = this.segments;
            const points = this.points;
            const count = segments.length;
            return count && points[segments[count - 1].end];
        }
        interpolate(point, property) {
            const options = this.options;
            const value = point[property];
            const points = this.points;
            const segments = _boundSegments(this, {
                property,
                start: value,
                end: value,
            });
            if (!segments.length) {
                return;
            }
            const result = [];
            const _interpolate = _getInterpolationMethod(options);
            let i, ilen;
            for (i = 0, ilen = segments.length; i < ilen; ++i) {
                const { start: start2, end } = segments[i];
                const p1 = points[start2];
                const p2 = points[end];
                if (p1 === p2) {
                    result.push(p1);
                    continue;
                }
                const t = Math.abs(
                    (value - p1[property]) / (p2[property] - p1[property])
                );
                const interpolated = _interpolate(p1, p2, t, options.stepped);
                interpolated[property] = point[property];
                result.push(interpolated);
            }
            return result.length === 1 ? result[0] : result;
        }
        pathSegment(ctx, segment, params) {
            const segmentMethod = _getSegmentMethod(this);
            return segmentMethod(ctx, this, segment, params);
        }
        path(ctx, start2, count) {
            const segments = this.segments;
            const segmentMethod = _getSegmentMethod(this);
            let loop = this._loop;
            start2 = start2 || 0;
            count = count || this.points.length - start2;
            for (const segment of segments) {
                loop &= segmentMethod(ctx, this, segment, {
                    start: start2,
                    end: start2 + count - 1,
                });
            }
            return !!loop;
        }
        draw(ctx, chartArea, start2, count) {
            const options = this.options || {};
            const points = this.points || [];
            if (points.length && options.borderWidth) {
                ctx.save();
                draw(ctx, this, start2, count);
                ctx.restore();
            }
            if (this.animated) {
                this._pointsUpdated = false;
                this._path = void 0;
            }
        }
    };
    LineElement.id = 'line';
    LineElement.defaults = {
        borderCapStyle: 'butt',
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: 'miter',
        borderWidth: 3,
        capBezierPoints: true,
        cubicInterpolationMode: 'default',
        fill: false,
        spanGaps: false,
        stepped: false,
        tension: 0,
    };
    LineElement.defaultRoutes = {
        backgroundColor: 'backgroundColor',
        borderColor: 'borderColor',
    };
    LineElement.descriptors = {
        _scriptable: true,
        _indexable: (name) => name !== 'borderDash' && name !== 'fill',
    };
    function inRange$1(el, pos, axis, useFinalPosition) {
        const options = el.options;
        const { [axis]: value } = el.getProps([axis], useFinalPosition);
        return Math.abs(pos - value) < options.radius + options.hitRadius;
    }
    var PointElement = class extends Element {
        constructor(cfg) {
            super();
            this.options = void 0;
            this.parsed = void 0;
            this.skip = void 0;
            this.stop = void 0;
            if (cfg) {
                Object.assign(this, cfg);
            }
        }
        inRange(mouseX, mouseY, useFinalPosition) {
            const options = this.options;
            const { x, y } = this.getProps(['x', 'y'], useFinalPosition);
            return (
                Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) <
                Math.pow(options.hitRadius + options.radius, 2)
            );
        }
        inXRange(mouseX, useFinalPosition) {
            return inRange$1(this, mouseX, 'x', useFinalPosition);
        }
        inYRange(mouseY, useFinalPosition) {
            return inRange$1(this, mouseY, 'y', useFinalPosition);
        }
        getCenterPoint(useFinalPosition) {
            const { x, y } = this.getProps(['x', 'y'], useFinalPosition);
            return { x, y };
        }
        size(options) {
            options = options || this.options || {};
            let radius3 = options.radius || 0;
            radius3 = Math.max(radius3, (radius3 && options.hoverRadius) || 0);
            const borderWidth3 = (radius3 && options.borderWidth) || 0;
            return (radius3 + borderWidth3) * 2;
        }
        draw(ctx, area) {
            const options = this.options;
            if (
                this.skip ||
                options.radius < 0.1 ||
                !_isPointInArea(this, area, this.size(options) / 2)
            ) {
                return;
            }
            ctx.strokeStyle = options.borderColor;
            ctx.lineWidth = options.borderWidth;
            ctx.fillStyle = options.backgroundColor;
            drawPoint(ctx, options, this.x, this.y);
        }
        getRange() {
            const options = this.options || {};
            return options.radius + options.hitRadius;
        }
    };
    PointElement.id = 'point';
    PointElement.defaults = {
        borderWidth: 1,
        hitRadius: 1,
        hoverBorderWidth: 1,
        hoverRadius: 4,
        pointStyle: 'circle',
        radius: 3,
        rotation: 0,
    };
    PointElement.defaultRoutes = {
        backgroundColor: 'backgroundColor',
        borderColor: 'borderColor',
    };
    function getBarBounds(bar, useFinalPosition) {
        const { x, y, base, width, height } = bar.getProps(
            ['x', 'y', 'base', 'width', 'height'],
            useFinalPosition
        );
        let left, right, top, bottom, half;
        if (bar.horizontal) {
            half = height / 2;
            left = Math.min(x, base);
            right = Math.max(x, base);
            top = y - half;
            bottom = y + half;
        } else {
            half = width / 2;
            left = x - half;
            right = x + half;
            top = Math.min(y, base);
            bottom = Math.max(y, base);
        }
        return { left, top, right, bottom };
    }
    function skipOrLimit(skip2, value, min3, max3) {
        return skip2 ? 0 : _limitValue(value, min3, max3);
    }
    function parseBorderWidth(bar, maxW, maxH) {
        const value = bar.options.borderWidth;
        const skip2 = bar.borderSkipped;
        const o = toTRBL(value);
        return {
            t: skipOrLimit(skip2.top, o.top, 0, maxH),
            r: skipOrLimit(skip2.right, o.right, 0, maxW),
            b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
            l: skipOrLimit(skip2.left, o.left, 0, maxW),
        };
    }
    function parseBorderRadius(bar, maxW, maxH) {
        const { enableBorderRadius } = bar.getProps(['enableBorderRadius']);
        const value = bar.options.borderRadius;
        const o = toTRBLCorners(value);
        const maxR = Math.min(maxW, maxH);
        const skip2 = bar.borderSkipped;
        const enableBorder = enableBorderRadius || isObject(value);
        return {
            topLeft: skipOrLimit(
                !enableBorder || skip2.top || skip2.left,
                o.topLeft,
                0,
                maxR
            ),
            topRight: skipOrLimit(
                !enableBorder || skip2.top || skip2.right,
                o.topRight,
                0,
                maxR
            ),
            bottomLeft: skipOrLimit(
                !enableBorder || skip2.bottom || skip2.left,
                o.bottomLeft,
                0,
                maxR
            ),
            bottomRight: skipOrLimit(
                !enableBorder || skip2.bottom || skip2.right,
                o.bottomRight,
                0,
                maxR
            ),
        };
    }
    function boundingRects(bar) {
        const bounds = getBarBounds(bar);
        const width = bounds.right - bounds.left;
        const height = bounds.bottom - bounds.top;
        const border = parseBorderWidth(bar, width / 2, height / 2);
        const radius3 = parseBorderRadius(bar, width / 2, height / 2);
        return {
            outer: {
                x: bounds.left,
                y: bounds.top,
                w: width,
                h: height,
                radius: radius3,
            },
            inner: {
                x: bounds.left + border.l,
                y: bounds.top + border.t,
                w: width - border.l - border.r,
                h: height - border.t - border.b,
                radius: {
                    topLeft: Math.max(
                        0,
                        radius3.topLeft - Math.max(border.t, border.l)
                    ),
                    topRight: Math.max(
                        0,
                        radius3.topRight - Math.max(border.t, border.r)
                    ),
                    bottomLeft: Math.max(
                        0,
                        radius3.bottomLeft - Math.max(border.b, border.l)
                    ),
                    bottomRight: Math.max(
                        0,
                        radius3.bottomRight - Math.max(border.b, border.r)
                    ),
                },
            },
        };
    }
    function inRange(bar, x, y, useFinalPosition) {
        const skipX = x === null;
        const skipY = y === null;
        const skipBoth = skipX && skipY;
        const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
        return (
            bounds &&
            (skipX || _isBetween(x, bounds.left, bounds.right)) &&
            (skipY || _isBetween(y, bounds.top, bounds.bottom))
        );
    }
    function hasRadius(radius3) {
        return (
            radius3.topLeft ||
            radius3.topRight ||
            radius3.bottomLeft ||
            radius3.bottomRight
        );
    }
    function addNormalRectPath(ctx, rect) {
        ctx.rect(rect.x, rect.y, rect.w, rect.h);
    }
    function inflateRect(rect, amount, refRect = {}) {
        const x = rect.x !== refRect.x ? -amount : 0;
        const y = rect.y !== refRect.y ? -amount : 0;
        const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
        const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
        return {
            x: rect.x + x,
            y: rect.y + y,
            w: rect.w + w,
            h: rect.h + h,
            radius: rect.radius,
        };
    }
    var BarElement = class extends Element {
        constructor(cfg) {
            super();
            this.options = void 0;
            this.horizontal = void 0;
            this.base = void 0;
            this.width = void 0;
            this.height = void 0;
            this.inflateAmount = void 0;
            if (cfg) {
                Object.assign(this, cfg);
            }
        }
        draw(ctx) {
            const {
                inflateAmount,
                options: {
                    borderColor: borderColor4,
                    backgroundColor: backgroundColor4,
                },
            } = this;
            const { inner, outer } = boundingRects(this);
            const addRectPath = hasRadius(outer.radius)
                ? addRoundedRectPath
                : addNormalRectPath;
            ctx.save();
            if (outer.w !== inner.w || outer.h !== inner.h) {
                ctx.beginPath();
                addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
                ctx.clip();
                addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
                ctx.fillStyle = borderColor4;
                ctx.fill('evenodd');
            }
            ctx.beginPath();
            addRectPath(ctx, inflateRect(inner, inflateAmount));
            ctx.fillStyle = backgroundColor4;
            ctx.fill();
            ctx.restore();
        }
        inRange(mouseX, mouseY, useFinalPosition) {
            return inRange(this, mouseX, mouseY, useFinalPosition);
        }
        inXRange(mouseX, useFinalPosition) {
            return inRange(this, mouseX, null, useFinalPosition);
        }
        inYRange(mouseY, useFinalPosition) {
            return inRange(this, null, mouseY, useFinalPosition);
        }
        getCenterPoint(useFinalPosition) {
            const { x, y, base, horizontal } = this.getProps(
                ['x', 'y', 'base', 'horizontal'],
                useFinalPosition
            );
            return {
                x: horizontal ? (x + base) / 2 : x,
                y: horizontal ? y : (y + base) / 2,
            };
        }
        getRange(axis) {
            return axis === 'x' ? this.width / 2 : this.height / 2;
        }
    };
    BarElement.id = 'bar';
    BarElement.defaults = {
        borderSkipped: 'start',
        borderWidth: 0,
        borderRadius: 0,
        inflateAmount: 'auto',
        pointStyle: void 0,
    };
    BarElement.defaultRoutes = {
        backgroundColor: 'backgroundColor',
        borderColor: 'borderColor',
    };
    var elements = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        ArcElement,
        LineElement,
        PointElement,
        BarElement,
    });
    function lttbDecimation(data, start2, count, availableWidth, options) {
        const samples = options.samples || availableWidth;
        if (samples >= count) {
            return data.slice(start2, start2 + count);
        }
        const decimated = [];
        const bucketWidth = (count - 2) / (samples - 2);
        let sampledIndex = 0;
        const endIndex = start2 + count - 1;
        let a = start2;
        let i, maxAreaPoint, maxArea, area, nextA;
        decimated[sampledIndex++] = data[a];
        for (i = 0; i < samples - 2; i++) {
            let avgX = 0;
            let avgY = 0;
            let j;
            const avgRangeStart =
                Math.floor((i + 1) * bucketWidth) + 1 + start2;
            const avgRangeEnd =
                Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start2;
            const avgRangeLength = avgRangeEnd - avgRangeStart;
            for (j = avgRangeStart; j < avgRangeEnd; j++) {
                avgX += data[j].x;
                avgY += data[j].y;
            }
            avgX /= avgRangeLength;
            avgY /= avgRangeLength;
            const rangeOffs = Math.floor(i * bucketWidth) + 1 + start2;
            const rangeTo =
                Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start2;
            const { x: pointAx, y: pointAy } = data[a];
            maxArea = area = -1;
            for (j = rangeOffs; j < rangeTo; j++) {
                area =
                    0.5 *
                    Math.abs(
                        (pointAx - avgX) * (data[j].y - pointAy) -
                            (pointAx - data[j].x) * (avgY - pointAy)
                    );
                if (area > maxArea) {
                    maxArea = area;
                    maxAreaPoint = data[j];
                    nextA = j;
                }
            }
            decimated[sampledIndex++] = maxAreaPoint;
            a = nextA;
        }
        decimated[sampledIndex++] = data[endIndex];
        return decimated;
    }
    function minMaxDecimation(data, start2, count, availableWidth) {
        let avgX = 0;
        let countX = 0;
        let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
        const decimated = [];
        const endIndex = start2 + count - 1;
        const xMin = data[start2].x;
        const xMax = data[endIndex].x;
        const dx = xMax - xMin;
        for (i = start2; i < start2 + count; ++i) {
            point = data[i];
            x = ((point.x - xMin) / dx) * availableWidth;
            y = point.y;
            const truncX = x | 0;
            if (truncX === prevX) {
                if (y < minY) {
                    minY = y;
                    minIndex = i;
                } else if (y > maxY) {
                    maxY = y;
                    maxIndex = i;
                }
                avgX = (countX * avgX + point.x) / ++countX;
            } else {
                const lastIndex = i - 1;
                if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
                    const intermediateIndex1 = Math.min(minIndex, maxIndex);
                    const intermediateIndex2 = Math.max(minIndex, maxIndex);
                    if (
                        intermediateIndex1 !== startIndex &&
                        intermediateIndex1 !== lastIndex
                    ) {
                        decimated.push({
                            ...data[intermediateIndex1],
                            x: avgX,
                        });
                    }
                    if (
                        intermediateIndex2 !== startIndex &&
                        intermediateIndex2 !== lastIndex
                    ) {
                        decimated.push({
                            ...data[intermediateIndex2],
                            x: avgX,
                        });
                    }
                }
                if (i > 0 && lastIndex !== startIndex) {
                    decimated.push(data[lastIndex]);
                }
                decimated.push(point);
                prevX = truncX;
                countX = 0;
                minY = maxY = y;
                minIndex = maxIndex = startIndex = i;
            }
        }
        return decimated;
    }
    function cleanDecimatedDataset(dataset) {
        if (dataset._decimated) {
            const data = dataset._data;
            delete dataset._decimated;
            delete dataset._data;
            Object.defineProperty(dataset, 'data', { value: data });
        }
    }
    function cleanDecimatedData(chart) {
        chart.data.datasets.forEach((dataset) => {
            cleanDecimatedDataset(dataset);
        });
    }
    function getStartAndCountOfVisiblePointsSimplified(meta, points) {
        const pointCount = points.length;
        let start2 = 0;
        let count;
        const { iScale } = meta;
        const {
            min: min3,
            max: max3,
            minDefined,
            maxDefined,
        } = iScale.getUserBounds();
        if (minDefined) {
            start2 = _limitValue(
                _lookupByKey(points, iScale.axis, min3).lo,
                0,
                pointCount - 1
            );
        }
        if (maxDefined) {
            count =
                _limitValue(
                    _lookupByKey(points, iScale.axis, max3).hi + 1,
                    start2,
                    pointCount
                ) - start2;
        } else {
            count = pointCount - start2;
        }
        return { start: start2, count };
    }
    var plugin_decimation = {
        id: 'decimation',
        defaults: {
            algorithm: 'min-max',
            enabled: false,
        },
        beforeElementsUpdate: (chart, args, options) => {
            if (!options.enabled) {
                cleanDecimatedData(chart);
                return;
            }
            const availableWidth = chart.width;
            chart.data.datasets.forEach((dataset, datasetIndex) => {
                const { _data, indexAxis } = dataset;
                const meta = chart.getDatasetMeta(datasetIndex);
                const data = _data || dataset.data;
                if (resolve([indexAxis, chart.options.indexAxis]) === 'y') {
                    return;
                }
                if (!meta.controller.supportsDecimation) {
                    return;
                }
                const xAxis = chart.scales[meta.xAxisID];
                if (xAxis.type !== 'linear' && xAxis.type !== 'time') {
                    return;
                }
                if (chart.options.parsing) {
                    return;
                }
                let { start: start2, count } =
                    getStartAndCountOfVisiblePointsSimplified(meta, data);
                const threshold = options.threshold || 4 * availableWidth;
                if (count <= threshold) {
                    cleanDecimatedDataset(dataset);
                    return;
                }
                if (isNullOrUndef(_data)) {
                    dataset._data = data;
                    delete dataset.data;
                    Object.defineProperty(dataset, 'data', {
                        configurable: true,
                        enumerable: true,
                        get: function () {
                            return this._decimated;
                        },
                        set: function (d) {
                            this._data = d;
                        },
                    });
                }
                let decimated;
                switch (options.algorithm) {
                    case 'lttb':
                        decimated = lttbDecimation(
                            data,
                            start2,
                            count,
                            availableWidth,
                            options
                        );
                        break;
                    case 'min-max':
                        decimated = minMaxDecimation(
                            data,
                            start2,
                            count,
                            availableWidth
                        );
                        break;
                    default:
                        throw new Error(
                            `Unsupported decimation algorithm '${options.algorithm}'`
                        );
                }
                dataset._decimated = decimated;
            });
        },
        destroy(chart) {
            cleanDecimatedData(chart);
        },
    };
    function _segments(line, target, property) {
        const segments = line.segments;
        const points = line.points;
        const tpoints = target.points;
        const parts = [];
        for (const segment of segments) {
            let { start: start2, end } = segment;
            end = _findSegmentEnd(start2, end, points);
            const bounds = _getBounds(
                property,
                points[start2],
                points[end],
                segment.loop
            );
            if (!target.segments) {
                parts.push({
                    source: segment,
                    target: bounds,
                    start: points[start2],
                    end: points[end],
                });
                continue;
            }
            const targetSegments = _boundSegments(target, bounds);
            for (const tgt of targetSegments) {
                const subBounds = _getBounds(
                    property,
                    tpoints[tgt.start],
                    tpoints[tgt.end],
                    tgt.loop
                );
                const fillSources = _boundSegment(segment, points, subBounds);
                for (const fillSource of fillSources) {
                    parts.push({
                        source: fillSource,
                        target: tgt,
                        start: {
                            [property]: _getEdge(
                                bounds,
                                subBounds,
                                'start',
                                Math.max
                            ),
                        },
                        end: {
                            [property]: _getEdge(
                                bounds,
                                subBounds,
                                'end',
                                Math.min
                            ),
                        },
                    });
                }
            }
        }
        return parts;
    }
    function _getBounds(property, first, last, loop) {
        if (loop) {
            return;
        }
        let start2 = first[property];
        let end = last[property];
        if (property === 'angle') {
            start2 = _normalizeAngle(start2);
            end = _normalizeAngle(end);
        }
        return { property, start: start2, end };
    }
    function _pointsFromSegments(boundary, line) {
        const { x = null, y = null } = boundary || {};
        const linePoints = line.points;
        const points = [];
        line.segments.forEach(({ start: start2, end }) => {
            end = _findSegmentEnd(start2, end, linePoints);
            const first = linePoints[start2];
            const last = linePoints[end];
            if (y !== null) {
                points.push({ x: first.x, y });
                points.push({ x: last.x, y });
            } else if (x !== null) {
                points.push({ x, y: first.y });
                points.push({ x, y: last.y });
            }
        });
        return points;
    }
    function _findSegmentEnd(start2, end, points) {
        for (; end > start2; end--) {
            const point = points[end];
            if (!isNaN(point.x) && !isNaN(point.y)) {
                break;
            }
        }
        return end;
    }
    function _getEdge(a, b, prop, fn) {
        if (a && b) {
            return fn(a[prop], b[prop]);
        }
        return a ? a[prop] : b ? b[prop] : 0;
    }
    function _createBoundaryLine(boundary, line) {
        let points = [];
        let _loop = false;
        if (isArray(boundary)) {
            _loop = true;
            points = boundary;
        } else {
            points = _pointsFromSegments(boundary, line);
        }
        return points.length
            ? new LineElement({
                  points,
                  options: { tension: 0 },
                  _loop,
                  _fullLoop: _loop,
              })
            : null;
    }
    function _shouldApplyFill(source) {
        return source && source.fill !== false;
    }
    function _resolveTarget(sources, index3, propagate) {
        const source = sources[index3];
        let fill2 = source.fill;
        const visited = [index3];
        let target;
        if (!propagate) {
            return fill2;
        }
        while (fill2 !== false && visited.indexOf(fill2) === -1) {
            if (!isNumberFinite(fill2)) {
                return fill2;
            }
            target = sources[fill2];
            if (!target) {
                return false;
            }
            if (target.visible) {
                return fill2;
            }
            visited.push(fill2);
            fill2 = target.fill;
        }
        return false;
    }
    function _decodeFill(line, index3, count) {
        const fill2 = parseFillOption(line);
        if (isObject(fill2)) {
            return isNaN(fill2.value) ? false : fill2;
        }
        let target = parseFloat(fill2);
        if (isNumberFinite(target) && Math.floor(target) === target) {
            return decodeTargetIndex(fill2[0], index3, target, count);
        }
        return (
            ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill2) >= 0 &&
            fill2
        );
    }
    function decodeTargetIndex(firstCh, index3, target, count) {
        if (firstCh === '-' || firstCh === '+') {
            target = index3 + target;
        }
        if (target === index3 || target < 0 || target >= count) {
            return false;
        }
        return target;
    }
    function _getTargetPixel(fill2, scale) {
        let pixel = null;
        if (fill2 === 'start') {
            pixel = scale.bottom;
        } else if (fill2 === 'end') {
            pixel = scale.top;
        } else if (isObject(fill2)) {
            pixel = scale.getPixelForValue(fill2.value);
        } else if (scale.getBasePixel) {
            pixel = scale.getBasePixel();
        }
        return pixel;
    }
    function _getTargetValue(fill2, scale, startValue) {
        let value;
        if (fill2 === 'start') {
            value = startValue;
        } else if (fill2 === 'end') {
            value = scale.options.reverse ? scale.min : scale.max;
        } else if (isObject(fill2)) {
            value = fill2.value;
        } else {
            value = scale.getBaseValue();
        }
        return value;
    }
    function parseFillOption(line) {
        const options = line.options;
        const fillOption = options.fill;
        let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
        if (fill2 === void 0) {
            fill2 = !!options.backgroundColor;
        }
        if (fill2 === false || fill2 === null) {
            return false;
        }
        if (fill2 === true) {
            return 'origin';
        }
        return fill2;
    }
    function _buildStackLine(source) {
        const { scale, index: index3, line } = source;
        const points = [];
        const segments = line.segments;
        const sourcePoints = line.points;
        const linesBelow = getLinesBelow(scale, index3);
        linesBelow.push(
            _createBoundaryLine({ x: null, y: scale.bottom }, line)
        );
        for (let i = 0; i < segments.length; i++) {
            const segment = segments[i];
            for (let j = segment.start; j <= segment.end; j++) {
                addPointsBelow(points, sourcePoints[j], linesBelow);
            }
        }
        return new LineElement({ points, options: {} });
    }
    function getLinesBelow(scale, index3) {
        const below = [];
        const metas = scale.getMatchingVisibleMetas('line');
        for (let i = 0; i < metas.length; i++) {
            const meta = metas[i];
            if (meta.index === index3) {
                break;
            }
            if (!meta.hidden) {
                below.unshift(meta.dataset);
            }
        }
        return below;
    }
    function addPointsBelow(points, sourcePoint, linesBelow) {
        const postponed = [];
        for (let j = 0; j < linesBelow.length; j++) {
            const line = linesBelow[j];
            const { first, last, point } = findPoint(line, sourcePoint, 'x');
            if (!point || (first && last)) {
                continue;
            }
            if (first) {
                postponed.unshift(point);
            } else {
                points.push(point);
                if (!last) {
                    break;
                }
            }
        }
        points.push(...postponed);
    }
    function findPoint(line, sourcePoint, property) {
        const point = line.interpolate(sourcePoint, property);
        if (!point) {
            return {};
        }
        const pointValue = point[property];
        const segments = line.segments;
        const linePoints = line.points;
        let first = false;
        let last = false;
        for (let i = 0; i < segments.length; i++) {
            const segment = segments[i];
            const firstValue = linePoints[segment.start][property];
            const lastValue = linePoints[segment.end][property];
            if (_isBetween(pointValue, firstValue, lastValue)) {
                first = pointValue === firstValue;
                last = pointValue === lastValue;
                break;
            }
        }
        return { first, last, point };
    }
    var simpleArc = class {
        constructor(opts) {
            this.x = opts.x;
            this.y = opts.y;
            this.radius = opts.radius;
        }
        pathSegment(ctx, bounds, opts) {
            const { x, y, radius: radius3 } = this;
            bounds = bounds || { start: 0, end: TAU };
            ctx.arc(x, y, radius3, bounds.end, bounds.start, true);
            return !opts.bounds;
        }
        interpolate(point) {
            const { x, y, radius: radius3 } = this;
            const angle = point.angle;
            return {
                x: x + Math.cos(angle) * radius3,
                y: y + Math.sin(angle) * radius3,
                angle,
            };
        }
    };
    function _getTarget(source) {
        const { chart, fill: fill2, line } = source;
        if (isNumberFinite(fill2)) {
            return getLineByIndex(chart, fill2);
        }
        if (fill2 === 'stack') {
            return _buildStackLine(source);
        }
        if (fill2 === 'shape') {
            return true;
        }
        const boundary = computeBoundary(source);
        if (boundary instanceof simpleArc) {
            return boundary;
        }
        return _createBoundaryLine(boundary, line);
    }
    function getLineByIndex(chart, index3) {
        const meta = chart.getDatasetMeta(index3);
        const visible = meta && chart.isDatasetVisible(index3);
        return visible ? meta.dataset : null;
    }
    function computeBoundary(source) {
        const scale = source.scale || {};
        if (scale.getPointPositionForValue) {
            return computeCircularBoundary(source);
        }
        return computeLinearBoundary(source);
    }
    function computeLinearBoundary(source) {
        const { scale = {}, fill: fill2 } = source;
        const pixel = _getTargetPixel(fill2, scale);
        if (isNumberFinite(pixel)) {
            const horizontal = scale.isHorizontal();
            return {
                x: horizontal ? pixel : null,
                y: horizontal ? null : pixel,
            };
        }
        return null;
    }
    function computeCircularBoundary(source) {
        const { scale, fill: fill2 } = source;
        const options = scale.options;
        const length = scale.getLabels().length;
        const start2 = options.reverse ? scale.max : scale.min;
        const value = _getTargetValue(fill2, scale, start2);
        const target = [];
        if (options.grid.circular) {
            const center = scale.getPointPositionForValue(0, start2);
            return new simpleArc({
                x: center.x,
                y: center.y,
                radius: scale.getDistanceFromCenterForValue(value),
            });
        }
        for (let i = 0; i < length; ++i) {
            target.push(scale.getPointPositionForValue(i, value));
        }
        return target;
    }
    function _drawfill(ctx, source, area) {
        const target = _getTarget(source);
        const { line, scale, axis } = source;
        const lineOpts = line.options;
        const fillOption = lineOpts.fill;
        const color3 = lineOpts.backgroundColor;
        const { above = color3, below = color3 } = fillOption || {};
        if (target && line.points.length) {
            clipArea(ctx, area);
            doFill(ctx, { line, target, above, below, area, scale, axis });
            unclipArea(ctx);
        }
    }
    function doFill(ctx, cfg) {
        const { line, target, above, below, area, scale } = cfg;
        const property = line._loop ? 'angle' : cfg.axis;
        ctx.save();
        if (property === 'x' && below !== above) {
            clipVertical(ctx, target, area.top);
            fill(ctx, { line, target, color: above, scale, property });
            ctx.restore();
            ctx.save();
            clipVertical(ctx, target, area.bottom);
        }
        fill(ctx, { line, target, color: below, scale, property });
        ctx.restore();
    }
    function clipVertical(ctx, target, clipY) {
        const { segments, points } = target;
        let first = true;
        let lineLoop = false;
        ctx.beginPath();
        for (const segment of segments) {
            const { start: start2, end } = segment;
            const firstPoint = points[start2];
            const lastPoint = points[_findSegmentEnd(start2, end, points)];
            if (first) {
                ctx.moveTo(firstPoint.x, firstPoint.y);
                first = false;
            } else {
                ctx.lineTo(firstPoint.x, clipY);
                ctx.lineTo(firstPoint.x, firstPoint.y);
            }
            lineLoop = !!target.pathSegment(ctx, segment, { move: lineLoop });
            if (lineLoop) {
                ctx.closePath();
            } else {
                ctx.lineTo(lastPoint.x, clipY);
            }
        }
        ctx.lineTo(target.first().x, clipY);
        ctx.closePath();
        ctx.clip();
    }
    function fill(ctx, cfg) {
        const { line, target, property, color: color3, scale } = cfg;
        const segments = _segments(line, target, property);
        for (const {
            source: src,
            target: tgt,
            start: start2,
            end,
        } of segments) {
            const {
                style: { backgroundColor: backgroundColor4 = color3 } = {},
            } = src;
            const notShape = target !== true;
            ctx.save();
            ctx.fillStyle = backgroundColor4;
            clipBounds(
                ctx,
                scale,
                notShape && _getBounds(property, start2, end)
            );
            ctx.beginPath();
            const lineLoop = !!line.pathSegment(ctx, src);
            let loop;
            if (notShape) {
                if (lineLoop) {
                    ctx.closePath();
                } else {
                    interpolatedLineTo(ctx, target, end, property);
                }
                const targetLoop = !!target.pathSegment(ctx, tgt, {
                    move: lineLoop,
                    reverse: true,
                });
                loop = lineLoop && targetLoop;
                if (!loop) {
                    interpolatedLineTo(ctx, target, start2, property);
                }
            }
            ctx.closePath();
            ctx.fill(loop ? 'evenodd' : 'nonzero');
            ctx.restore();
        }
    }
    function clipBounds(ctx, scale, bounds) {
        const { top, bottom } = scale.chart.chartArea;
        const { property, start: start2, end } = bounds || {};
        if (property === 'x') {
            ctx.beginPath();
            ctx.rect(start2, top, end - start2, bottom - top);
            ctx.clip();
        }
    }
    function interpolatedLineTo(ctx, target, point, property) {
        const interpolatedPoint = target.interpolate(point, property);
        if (interpolatedPoint) {
            ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
        }
    }
    var index = {
        id: 'filler',
        afterDatasetsUpdate(chart, _args, options) {
            const count = (chart.data.datasets || []).length;
            const sources = [];
            let meta, i, line, source;
            for (i = 0; i < count; ++i) {
                meta = chart.getDatasetMeta(i);
                line = meta.dataset;
                source = null;
                if (line && line.options && line instanceof LineElement) {
                    source = {
                        visible: chart.isDatasetVisible(i),
                        index: i,
                        fill: _decodeFill(line, i, count),
                        chart,
                        axis: meta.controller.options.indexAxis,
                        scale: meta.vScale,
                        line,
                    };
                }
                meta.$filler = source;
                sources.push(source);
            }
            for (i = 0; i < count; ++i) {
                source = sources[i];
                if (!source || source.fill === false) {
                    continue;
                }
                source.fill = _resolveTarget(sources, i, options.propagate);
            }
        },
        beforeDraw(chart, _args, options) {
            const draw3 = options.drawTime === 'beforeDraw';
            const metasets = chart.getSortedVisibleDatasetMetas();
            const area = chart.chartArea;
            for (let i = metasets.length - 1; i >= 0; --i) {
                const source = metasets[i].$filler;
                if (!source) {
                    continue;
                }
                source.line.updateControlPoints(area, source.axis);
                if (draw3 && source.fill) {
                    _drawfill(chart.ctx, source, area);
                }
            }
        },
        beforeDatasetsDraw(chart, _args, options) {
            if (options.drawTime !== 'beforeDatasetsDraw') {
                return;
            }
            const metasets = chart.getSortedVisibleDatasetMetas();
            for (let i = metasets.length - 1; i >= 0; --i) {
                const source = metasets[i].$filler;
                if (_shouldApplyFill(source)) {
                    _drawfill(chart.ctx, source, chart.chartArea);
                }
            }
        },
        beforeDatasetDraw(chart, args, options) {
            const source = args.meta.$filler;
            if (
                !_shouldApplyFill(source) ||
                options.drawTime !== 'beforeDatasetDraw'
            ) {
                return;
            }
            _drawfill(chart.ctx, source, chart.chartArea);
        },
        defaults: {
            propagate: true,
            drawTime: 'beforeDatasetDraw',
        },
    };
    var getBoxSize = (labelOpts, fontSize) => {
        let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
        if (labelOpts.usePointStyle) {
            boxHeight = Math.min(boxHeight, fontSize);
            boxWidth =
                labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
        }
        return {
            boxWidth,
            boxHeight,
            itemHeight: Math.max(fontSize, boxHeight),
        };
    };
    var itemsEqual = (a, b) =>
        a !== null &&
        b !== null &&
        a.datasetIndex === b.datasetIndex &&
        a.index === b.index;
    var Legend = class extends Element {
        constructor(config) {
            super();
            this._added = false;
            this.legendHitBoxes = [];
            this._hoveredItem = null;
            this.doughnutMode = false;
            this.chart = config.chart;
            this.options = config.options;
            this.ctx = config.ctx;
            this.legendItems = void 0;
            this.columnSizes = void 0;
            this.lineWidths = void 0;
            this.maxHeight = void 0;
            this.maxWidth = void 0;
            this.top = void 0;
            this.bottom = void 0;
            this.left = void 0;
            this.right = void 0;
            this.height = void 0;
            this.width = void 0;
            this._margins = void 0;
            this.position = void 0;
            this.weight = void 0;
            this.fullSize = void 0;
        }
        update(maxWidth, maxHeight, margins) {
            this.maxWidth = maxWidth;
            this.maxHeight = maxHeight;
            this._margins = margins;
            this.setDimensions();
            this.buildLabels();
            this.fit();
        }
        setDimensions() {
            if (this.isHorizontal()) {
                this.width = this.maxWidth;
                this.left = this._margins.left;
                this.right = this.width;
            } else {
                this.height = this.maxHeight;
                this.top = this._margins.top;
                this.bottom = this.height;
            }
        }
        buildLabels() {
            const labelOpts = this.options.labels || {};
            let legendItems =
                callback(labelOpts.generateLabels, [this.chart], this) || [];
            if (labelOpts.filter) {
                legendItems = legendItems.filter((item) =>
                    labelOpts.filter(item, this.chart.data)
                );
            }
            if (labelOpts.sort) {
                legendItems = legendItems.sort((a, b) =>
                    labelOpts.sort(a, b, this.chart.data)
                );
            }
            if (this.options.reverse) {
                legendItems.reverse();
            }
            this.legendItems = legendItems;
        }
        fit() {
            const { options, ctx } = this;
            if (!options.display) {
                this.width = this.height = 0;
                return;
            }
            const labelOpts = options.labels;
            const labelFont = toFont(labelOpts.font);
            const fontSize = labelFont.size;
            const titleHeight = this._computeTitleHeight();
            const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
            let width, height;
            ctx.font = labelFont.string;
            if (this.isHorizontal()) {
                width = this.maxWidth;
                height =
                    this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) +
                    10;
            } else {
                height = this.maxHeight;
                width =
                    this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) +
                    10;
            }
            this.width = Math.min(width, options.maxWidth || this.maxWidth);
            this.height = Math.min(height, options.maxHeight || this.maxHeight);
        }
        _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
            const {
                ctx,
                maxWidth,
                options: {
                    labels: { padding },
                },
            } = this;
            const hitboxes = (this.legendHitBoxes = []);
            const lineWidths = (this.lineWidths = [0]);
            const lineHeight = itemHeight + padding;
            let totalHeight = titleHeight;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            let row = -1;
            let top = -lineHeight;
            this.legendItems.forEach((legendItem, i) => {
                const itemWidth =
                    boxWidth +
                    fontSize / 2 +
                    ctx.measureText(legendItem.text).width;
                if (
                    i === 0 ||
                    lineWidths[lineWidths.length - 1] +
                        itemWidth +
                        2 * padding >
                        maxWidth
                ) {
                    totalHeight += lineHeight;
                    lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
                    top += lineHeight;
                    row++;
                }
                hitboxes[i] = {
                    left: 0,
                    top,
                    row,
                    width: itemWidth,
                    height: itemHeight,
                };
                lineWidths[lineWidths.length - 1] += itemWidth + padding;
            });
            return totalHeight;
        }
        _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {
            const {
                ctx,
                maxHeight,
                options: {
                    labels: { padding },
                },
            } = this;
            const hitboxes = (this.legendHitBoxes = []);
            const columnSizes = (this.columnSizes = []);
            const heightLimit = maxHeight - titleHeight;
            let totalWidth = padding;
            let currentColWidth = 0;
            let currentColHeight = 0;
            let left = 0;
            let col = 0;
            this.legendItems.forEach((legendItem, i) => {
                const itemWidth =
                    boxWidth +
                    fontSize / 2 +
                    ctx.measureText(legendItem.text).width;
                if (
                    i > 0 &&
                    currentColHeight + itemHeight + 2 * padding > heightLimit
                ) {
                    totalWidth += currentColWidth + padding;
                    columnSizes.push({
                        width: currentColWidth,
                        height: currentColHeight,
                    });
                    left += currentColWidth + padding;
                    col++;
                    currentColWidth = currentColHeight = 0;
                }
                hitboxes[i] = {
                    left,
                    top: currentColHeight,
                    col,
                    width: itemWidth,
                    height: itemHeight,
                };
                currentColWidth = Math.max(currentColWidth, itemWidth);
                currentColHeight += itemHeight + padding;
            });
            totalWidth += currentColWidth;
            columnSizes.push({
                width: currentColWidth,
                height: currentColHeight,
            });
            return totalWidth;
        }
        adjustHitBoxes() {
            if (!this.options.display) {
                return;
            }
            const titleHeight = this._computeTitleHeight();
            const {
                legendHitBoxes: hitboxes,
                options: {
                    align,
                    labels: { padding },
                    rtl,
                },
            } = this;
            const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
            if (this.isHorizontal()) {
                let row = 0;
                let left = _alignStartEnd(
                    align,
                    this.left + padding,
                    this.right - this.lineWidths[row]
                );
                for (const hitbox of hitboxes) {
                    if (row !== hitbox.row) {
                        row = hitbox.row;
                        left = _alignStartEnd(
                            align,
                            this.left + padding,
                            this.right - this.lineWidths[row]
                        );
                    }
                    hitbox.top += this.top + titleHeight + padding;
                    hitbox.left = rtlHelper.leftForLtr(
                        rtlHelper.x(left),
                        hitbox.width
                    );
                    left += hitbox.width + padding;
                }
            } else {
                let col = 0;
                let top = _alignStartEnd(
                    align,
                    this.top + titleHeight + padding,
                    this.bottom - this.columnSizes[col].height
                );
                for (const hitbox of hitboxes) {
                    if (hitbox.col !== col) {
                        col = hitbox.col;
                        top = _alignStartEnd(
                            align,
                            this.top + titleHeight + padding,
                            this.bottom - this.columnSizes[col].height
                        );
                    }
                    hitbox.top = top;
                    hitbox.left += this.left + padding;
                    hitbox.left = rtlHelper.leftForLtr(
                        rtlHelper.x(hitbox.left),
                        hitbox.width
                    );
                    top += hitbox.height + padding;
                }
            }
        }
        isHorizontal() {
            return (
                this.options.position === 'top' ||
                this.options.position === 'bottom'
            );
        }
        draw() {
            if (this.options.display) {
                const ctx = this.ctx;
                clipArea(ctx, this);
                this._draw();
                unclipArea(ctx);
            }
        }
        _draw() {
            const { options: opts, columnSizes, lineWidths, ctx } = this;
            const { align, labels: labelOpts } = opts;
            const defaultColor = defaults.color;
            const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
            const labelFont = toFont(labelOpts.font);
            const { color: fontColor, padding } = labelOpts;
            const fontSize = labelFont.size;
            const halfFontSize = fontSize / 2;
            let cursor;
            this.drawTitle();
            ctx.textAlign = rtlHelper.textAlign('left');
            ctx.textBaseline = 'middle';
            ctx.lineWidth = 0.5;
            ctx.font = labelFont.string;
            const { boxWidth, boxHeight, itemHeight } = getBoxSize(
                labelOpts,
                fontSize
            );
            const drawLegendBox = function (x, y, legendItem) {
                if (
                    isNaN(boxWidth) ||
                    boxWidth <= 0 ||
                    isNaN(boxHeight) ||
                    boxHeight < 0
                ) {
                    return;
                }
                ctx.save();
                const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
                ctx.fillStyle = valueOrDefault(
                    legendItem.fillStyle,
                    defaultColor
                );
                ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');
                ctx.lineDashOffset = valueOrDefault(
                    legendItem.lineDashOffset,
                    0
                );
                ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');
                ctx.lineWidth = lineWidth;
                ctx.strokeStyle = valueOrDefault(
                    legendItem.strokeStyle,
                    defaultColor
                );
                ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
                if (labelOpts.usePointStyle) {
                    const drawOptions = {
                        radius: (boxHeight * Math.SQRT2) / 2,
                        pointStyle: legendItem.pointStyle,
                        rotation: legendItem.rotation,
                        borderWidth: lineWidth,
                    };
                    const centerX = rtlHelper.xPlus(x, boxWidth / 2);
                    const centerY = y + halfFontSize;
                    drawPointLegend(
                        ctx,
                        drawOptions,
                        centerX,
                        centerY,
                        labelOpts.pointStyleWidth && boxWidth
                    );
                } else {
                    const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
                    const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
                    const borderRadius = toTRBLCorners(legendItem.borderRadius);
                    ctx.beginPath();
                    if (Object.values(borderRadius).some((v) => v !== 0)) {
                        addRoundedRectPath(ctx, {
                            x: xBoxLeft,
                            y: yBoxTop,
                            w: boxWidth,
                            h: boxHeight,
                            radius: borderRadius,
                        });
                    } else {
                        ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
                    }
                    ctx.fill();
                    if (lineWidth !== 0) {
                        ctx.stroke();
                    }
                }
                ctx.restore();
            };
            const fillText = function (x, y, legendItem) {
                renderText(
                    ctx,
                    legendItem.text,
                    x,
                    y + itemHeight / 2,
                    labelFont,
                    {
                        strikethrough: legendItem.hidden,
                        textAlign: rtlHelper.textAlign(legendItem.textAlign),
                    }
                );
            };
            const isHorizontal = this.isHorizontal();
            const titleHeight = this._computeTitleHeight();
            if (isHorizontal) {
                cursor = {
                    x: _alignStartEnd(
                        align,
                        this.left + padding,
                        this.right - lineWidths[0]
                    ),
                    y: this.top + padding + titleHeight,
                    line: 0,
                };
            } else {
                cursor = {
                    x: this.left + padding,
                    y: _alignStartEnd(
                        align,
                        this.top + titleHeight + padding,
                        this.bottom - columnSizes[0].height
                    ),
                    line: 0,
                };
            }
            overrideTextDirection(this.ctx, opts.textDirection);
            const lineHeight = itemHeight + padding;
            this.legendItems.forEach((legendItem, i) => {
                ctx.strokeStyle = legendItem.fontColor || fontColor;
                ctx.fillStyle = legendItem.fontColor || fontColor;
                const textWidth = ctx.measureText(legendItem.text).width;
                const textAlign = rtlHelper.textAlign(
                    legendItem.textAlign ||
                        (legendItem.textAlign = labelOpts.textAlign)
                );
                const width = boxWidth + halfFontSize + textWidth;
                let x = cursor.x;
                let y = cursor.y;
                rtlHelper.setWidth(this.width);
                if (isHorizontal) {
                    if (i > 0 && x + width + padding > this.right) {
                        y = cursor.y += lineHeight;
                        cursor.line++;
                        x = cursor.x = _alignStartEnd(
                            align,
                            this.left + padding,
                            this.right - lineWidths[cursor.line]
                        );
                    }
                } else if (i > 0 && y + lineHeight > this.bottom) {
                    x = cursor.x = x + columnSizes[cursor.line].width + padding;
                    cursor.line++;
                    y = cursor.y = _alignStartEnd(
                        align,
                        this.top + titleHeight + padding,
                        this.bottom - columnSizes[cursor.line].height
                    );
                }
                const realX = rtlHelper.x(x);
                drawLegendBox(realX, y, legendItem);
                x = _textX(
                    textAlign,
                    x + boxWidth + halfFontSize,
                    isHorizontal ? x + width : this.right,
                    opts.rtl
                );
                fillText(rtlHelper.x(x), y, legendItem);
                if (isHorizontal) {
                    cursor.x += width + padding;
                } else {
                    cursor.y += lineHeight;
                }
            });
            restoreTextDirection(this.ctx, opts.textDirection);
        }
        drawTitle() {
            const opts = this.options;
            const titleOpts = opts.title;
            const titleFont = toFont(titleOpts.font);
            const titlePadding = toPadding(titleOpts.padding);
            if (!titleOpts.display) {
                return;
            }
            const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
            const ctx = this.ctx;
            const position = titleOpts.position;
            const halfFontSize = titleFont.size / 2;
            const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
            let y;
            let left = this.left;
            let maxWidth = this.width;
            if (this.isHorizontal()) {
                maxWidth = Math.max(...this.lineWidths);
                y = this.top + topPaddingPlusHalfFontSize;
                left = _alignStartEnd(opts.align, left, this.right - maxWidth);
            } else {
                const maxHeight = this.columnSizes.reduce(
                    (acc, size) => Math.max(acc, size.height),
                    0
                );
                y =
                    topPaddingPlusHalfFontSize +
                    _alignStartEnd(
                        opts.align,
                        this.top,
                        this.bottom -
                            maxHeight -
                            opts.labels.padding -
                            this._computeTitleHeight()
                    );
            }
            const x = _alignStartEnd(position, left, left + maxWidth);
            ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
            ctx.textBaseline = 'middle';
            ctx.strokeStyle = titleOpts.color;
            ctx.fillStyle = titleOpts.color;
            ctx.font = titleFont.string;
            renderText(ctx, titleOpts.text, x, y, titleFont);
        }
        _computeTitleHeight() {
            const titleOpts = this.options.title;
            const titleFont = toFont(titleOpts.font);
            const titlePadding = toPadding(titleOpts.padding);
            return titleOpts.display
                ? titleFont.lineHeight + titlePadding.height
                : 0;
        }
        _getLegendItemAt(x, y) {
            let i, hitBox, lh;
            if (
                _isBetween(x, this.left, this.right) &&
                _isBetween(y, this.top, this.bottom)
            ) {
                lh = this.legendHitBoxes;
                for (i = 0; i < lh.length; ++i) {
                    hitBox = lh[i];
                    if (
                        _isBetween(
                            x,
                            hitBox.left,
                            hitBox.left + hitBox.width
                        ) &&
                        _isBetween(y, hitBox.top, hitBox.top + hitBox.height)
                    ) {
                        return this.legendItems[i];
                    }
                }
            }
            return null;
        }
        handleEvent(e) {
            const opts = this.options;
            if (!isListened(e.type, opts)) {
                return;
            }
            const hoveredItem = this._getLegendItemAt(e.x, e.y);
            if (e.type === 'mousemove' || e.type === 'mouseout') {
                const previous = this._hoveredItem;
                const sameItem = itemsEqual(previous, hoveredItem);
                if (previous && !sameItem) {
                    callback(opts.onLeave, [e, previous, this], this);
                }
                this._hoveredItem = hoveredItem;
                if (hoveredItem && !sameItem) {
                    callback(opts.onHover, [e, hoveredItem, this], this);
                }
            } else if (hoveredItem) {
                callback(opts.onClick, [e, hoveredItem, this], this);
            }
        }
    };
    function isListened(type2, opts) {
        if (
            (type2 === 'mousemove' || type2 === 'mouseout') &&
            (opts.onHover || opts.onLeave)
        ) {
            return true;
        }
        if (opts.onClick && (type2 === 'click' || type2 === 'mouseup')) {
            return true;
        }
        return false;
    }
    var plugin_legend = {
        id: 'legend',
        _element: Legend,
        start(chart, _args, options) {
            const legend5 = (chart.legend = new Legend({
                ctx: chart.ctx,
                options,
                chart,
            }));
            layouts.configure(chart, legend5, options);
            layouts.addBox(chart, legend5);
        },
        stop(chart) {
            layouts.removeBox(chart, chart.legend);
            delete chart.legend;
        },
        beforeUpdate(chart, _args, options) {
            const legend5 = chart.legend;
            layouts.configure(chart, legend5, options);
            legend5.options = options;
        },
        afterUpdate(chart) {
            const legend5 = chart.legend;
            legend5.buildLabels();
            legend5.adjustHitBoxes();
        },
        afterEvent(chart, args) {
            if (!args.replay) {
                chart.legend.handleEvent(args.event);
            }
        },
        defaults: {
            display: true,
            position: 'top',
            align: 'center',
            fullSize: true,
            reverse: false,
            weight: 1e3,
            onClick(e, legendItem, legend5) {
                const index3 = legendItem.datasetIndex;
                const ci = legend5.chart;
                if (ci.isDatasetVisible(index3)) {
                    ci.hide(index3);
                    legendItem.hidden = true;
                } else {
                    ci.show(index3);
                    legendItem.hidden = false;
                }
            },
            onHover: null,
            onLeave: null,
            labels: {
                color: (ctx) => ctx.chart.options.color,
                boxWidth: 40,
                padding: 10,
                generateLabels(chart) {
                    const datasets = chart.data.datasets;
                    const {
                        labels: {
                            usePointStyle,
                            pointStyle,
                            textAlign,
                            color: color3,
                        },
                    } = chart.legend.options;
                    return chart._getSortedDatasetMetas().map((meta) => {
                        const style = meta.controller.getStyle(
                            usePointStyle ? 0 : void 0
                        );
                        const borderWidth3 = toPadding(style.borderWidth);
                        return {
                            text: datasets[meta.index].label,
                            fillStyle: style.backgroundColor,
                            fontColor: color3,
                            hidden: !meta.visible,
                            lineCap: style.borderCapStyle,
                            lineDash: style.borderDash,
                            lineDashOffset: style.borderDashOffset,
                            lineJoin: style.borderJoinStyle,
                            lineWidth:
                                (borderWidth3.width + borderWidth3.height) / 4,
                            strokeStyle: style.borderColor,
                            pointStyle: pointStyle || style.pointStyle,
                            rotation: style.rotation,
                            textAlign: textAlign || style.textAlign,
                            borderRadius: 0,
                            datasetIndex: meta.index,
                        };
                    }, this);
                },
            },
            title: {
                color: (ctx) => ctx.chart.options.color,
                display: false,
                position: 'center',
                text: '',
            },
        },
        descriptors: {
            _scriptable: (name) => !name.startsWith('on'),
            labels: {
                _scriptable: (name) =>
                    !['generateLabels', 'filter', 'sort'].includes(name),
            },
        },
    };
    var Title = class extends Element {
        constructor(config) {
            super();
            this.chart = config.chart;
            this.options = config.options;
            this.ctx = config.ctx;
            this._padding = void 0;
            this.top = void 0;
            this.bottom = void 0;
            this.left = void 0;
            this.right = void 0;
            this.width = void 0;
            this.height = void 0;
            this.position = void 0;
            this.weight = void 0;
            this.fullSize = void 0;
        }
        update(maxWidth, maxHeight) {
            const opts = this.options;
            this.left = 0;
            this.top = 0;
            if (!opts.display) {
                this.width = this.height = this.right = this.bottom = 0;
                return;
            }
            this.width = this.right = maxWidth;
            this.height = this.bottom = maxHeight;
            const lineCount = isArray(opts.text) ? opts.text.length : 1;
            this._padding = toPadding(opts.padding);
            const textSize =
                lineCount * toFont(opts.font).lineHeight + this._padding.height;
            if (this.isHorizontal()) {
                this.height = textSize;
            } else {
                this.width = textSize;
            }
        }
        isHorizontal() {
            const pos = this.options.position;
            return pos === 'top' || pos === 'bottom';
        }
        _drawArgs(offset) {
            const { top, left, bottom, right, options } = this;
            const align = options.align;
            let rotation = 0;
            let maxWidth, titleX, titleY;
            if (this.isHorizontal()) {
                titleX = _alignStartEnd(align, left, right);
                titleY = top + offset;
                maxWidth = right - left;
            } else {
                if (options.position === 'left') {
                    titleX = left + offset;
                    titleY = _alignStartEnd(align, bottom, top);
                    rotation = PI * -0.5;
                } else {
                    titleX = right - offset;
                    titleY = _alignStartEnd(align, top, bottom);
                    rotation = PI * 0.5;
                }
                maxWidth = bottom - top;
            }
            return { titleX, titleY, maxWidth, rotation };
        }
        draw() {
            const ctx = this.ctx;
            const opts = this.options;
            if (!opts.display) {
                return;
            }
            const fontOpts = toFont(opts.font);
            const lineHeight = fontOpts.lineHeight;
            const offset = lineHeight / 2 + this._padding.top;
            const { titleX, titleY, maxWidth, rotation } =
                this._drawArgs(offset);
            renderText(ctx, opts.text, 0, 0, fontOpts, {
                color: opts.color,
                maxWidth,
                rotation,
                textAlign: _toLeftRightCenter(opts.align),
                textBaseline: 'middle',
                translation: [titleX, titleY],
            });
        }
    };
    function createTitle(chart, titleOpts) {
        const title4 = new Title({
            ctx: chart.ctx,
            options: titleOpts,
            chart,
        });
        layouts.configure(chart, title4, titleOpts);
        layouts.addBox(chart, title4);
        chart.titleBlock = title4;
    }
    var plugin_title = {
        id: 'title',
        _element: Title,
        start(chart, _args, options) {
            createTitle(chart, options);
        },
        stop(chart) {
            const titleBlock = chart.titleBlock;
            layouts.removeBox(chart, titleBlock);
            delete chart.titleBlock;
        },
        beforeUpdate(chart, _args, options) {
            const title4 = chart.titleBlock;
            layouts.configure(chart, title4, options);
            title4.options = options;
        },
        defaults: {
            align: 'center',
            display: false,
            font: {
                weight: 'bold',
            },
            fullSize: true,
            padding: 10,
            position: 'top',
            text: '',
            weight: 2e3,
        },
        defaultRoutes: {
            color: 'color',
        },
        descriptors: {
            _scriptable: true,
            _indexable: false,
        },
    };
    var map2 = /* @__PURE__ */ new WeakMap();
    var plugin_subtitle = {
        id: 'subtitle',
        start(chart, _args, options) {
            const title4 = new Title({
                ctx: chart.ctx,
                options,
                chart,
            });
            layouts.configure(chart, title4, options);
            layouts.addBox(chart, title4);
            map2.set(chart, title4);
        },
        stop(chart) {
            layouts.removeBox(chart, map2.get(chart));
            map2.delete(chart);
        },
        beforeUpdate(chart, _args, options) {
            const title4 = map2.get(chart);
            layouts.configure(chart, title4, options);
            title4.options = options;
        },
        defaults: {
            align: 'center',
            display: false,
            font: {
                weight: 'normal',
            },
            fullSize: true,
            padding: 0,
            position: 'top',
            text: '',
            weight: 1500,
        },
        defaultRoutes: {
            color: 'color',
        },
        descriptors: {
            _scriptable: true,
            _indexable: false,
        },
    };
    var positioners = {
        average(items) {
            if (!items.length) {
                return false;
            }
            let i, len;
            let x = 0;
            let y = 0;
            let count = 0;
            for (i = 0, len = items.length; i < len; ++i) {
                const el = items[i].element;
                if (el && el.hasValue()) {
                    const pos = el.tooltipPosition();
                    x += pos.x;
                    y += pos.y;
                    ++count;
                }
            }
            return {
                x: x / count,
                y: y / count,
            };
        },
        nearest(items, eventPosition) {
            if (!items.length) {
                return false;
            }
            let x = eventPosition.x;
            let y = eventPosition.y;
            let minDistance = Number.POSITIVE_INFINITY;
            let i, len, nearestElement;
            for (i = 0, len = items.length; i < len; ++i) {
                const el = items[i].element;
                if (el && el.hasValue()) {
                    const center = el.getCenterPoint();
                    const d = distanceBetweenPoints(eventPosition, center);
                    if (d < minDistance) {
                        minDistance = d;
                        nearestElement = el;
                    }
                }
            }
            if (nearestElement) {
                const tp = nearestElement.tooltipPosition();
                x = tp.x;
                y = tp.y;
            }
            return {
                x,
                y,
            };
        },
    };
    function pushOrConcat(base, toPush) {
        if (toPush) {
            if (isArray(toPush)) {
                Array.prototype.push.apply(base, toPush);
            } else {
                base.push(toPush);
            }
        }
        return base;
    }
    function splitNewlines(str) {
        if (
            (typeof str === 'string' || str instanceof String) &&
            str.indexOf('\n') > -1
        ) {
            return str.split('\n');
        }
        return str;
    }
    function createTooltipItem(chart, item) {
        const { element, datasetIndex, index: index3 } = item;
        const controller = chart.getDatasetMeta(datasetIndex).controller;
        const { label, value } = controller.getLabelAndValue(index3);
        return {
            chart,
            label,
            parsed: controller.getParsed(index3),
            raw: chart.data.datasets[datasetIndex].data[index3],
            formattedValue: value,
            dataset: controller.getDataset(),
            dataIndex: index3,
            datasetIndex,
            element,
        };
    }
    function getTooltipSize(tooltip5, options) {
        const ctx = tooltip5.chart.ctx;
        const { body, footer, title: title4 } = tooltip5;
        const { boxWidth, boxHeight } = options;
        const bodyFont = toFont(options.bodyFont);
        const titleFont = toFont(options.titleFont);
        const footerFont = toFont(options.footerFont);
        const titleLineCount = title4.length;
        const footerLineCount = footer.length;
        const bodyLineItemCount = body.length;
        const padding = toPadding(options.padding);
        let height = padding.height;
        let width = 0;
        let combinedBodyLength = body.reduce(
            (count, bodyItem) =>
                count +
                bodyItem.before.length +
                bodyItem.lines.length +
                bodyItem.after.length,
            0
        );
        combinedBodyLength +=
            tooltip5.beforeBody.length + tooltip5.afterBody.length;
        if (titleLineCount) {
            height +=
                titleLineCount * titleFont.lineHeight +
                (titleLineCount - 1) * options.titleSpacing +
                options.titleMarginBottom;
        }
        if (combinedBodyLength) {
            const bodyLineHeight = options.displayColors
                ? Math.max(boxHeight, bodyFont.lineHeight)
                : bodyFont.lineHeight;
            height +=
                bodyLineItemCount * bodyLineHeight +
                (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight +
                (combinedBodyLength - 1) * options.bodySpacing;
        }
        if (footerLineCount) {
            height +=
                options.footerMarginTop +
                footerLineCount * footerFont.lineHeight +
                (footerLineCount - 1) * options.footerSpacing;
        }
        let widthPadding = 0;
        const maxLineWidth = function (line) {
            width = Math.max(width, ctx.measureText(line).width + widthPadding);
        };
        ctx.save();
        ctx.font = titleFont.string;
        each(tooltip5.title, maxLineWidth);
        ctx.font = bodyFont.string;
        each(tooltip5.beforeBody.concat(tooltip5.afterBody), maxLineWidth);
        widthPadding = options.displayColors
            ? boxWidth + 2 + options.boxPadding
            : 0;
        each(body, (bodyItem) => {
            each(bodyItem.before, maxLineWidth);
            each(bodyItem.lines, maxLineWidth);
            each(bodyItem.after, maxLineWidth);
        });
        widthPadding = 0;
        ctx.font = footerFont.string;
        each(tooltip5.footer, maxLineWidth);
        ctx.restore();
        width += padding.width;
        return { width, height };
    }
    function determineYAlign(chart, size) {
        const { y, height } = size;
        if (y < height / 2) {
            return 'top';
        } else if (y > chart.height - height / 2) {
            return 'bottom';
        }
        return 'center';
    }
    function doesNotFitWithAlign(xAlign, chart, options, size) {
        const { x, width } = size;
        const caret = options.caretSize + options.caretPadding;
        if (xAlign === 'left' && x + width + caret > chart.width) {
            return true;
        }
        if (xAlign === 'right' && x - width - caret < 0) {
            return true;
        }
    }
    function determineXAlign(chart, options, size, yAlign) {
        const { x, width } = size;
        const {
            width: chartWidth,
            chartArea: { left, right },
        } = chart;
        let xAlign = 'center';
        if (yAlign === 'center') {
            xAlign = x <= (left + right) / 2 ? 'left' : 'right';
        } else if (x <= width / 2) {
            xAlign = 'left';
        } else if (x >= chartWidth - width / 2) {
            xAlign = 'right';
        }
        if (doesNotFitWithAlign(xAlign, chart, options, size)) {
            xAlign = 'center';
        }
        return xAlign;
    }
    function determineAlignment(chart, options, size) {
        const yAlign =
            size.yAlign || options.yAlign || determineYAlign(chart, size);
        return {
            xAlign:
                size.xAlign ||
                options.xAlign ||
                determineXAlign(chart, options, size, yAlign),
            yAlign,
        };
    }
    function alignX(size, xAlign) {
        let { x, width } = size;
        if (xAlign === 'right') {
            x -= width;
        } else if (xAlign === 'center') {
            x -= width / 2;
        }
        return x;
    }
    function alignY(size, yAlign, paddingAndSize) {
        let { y, height } = size;
        if (yAlign === 'top') {
            y += paddingAndSize;
        } else if (yAlign === 'bottom') {
            y -= height + paddingAndSize;
        } else {
            y -= height / 2;
        }
        return y;
    }
    function getBackgroundPoint(options, size, alignment, chart) {
        const { caretSize, caretPadding, cornerRadius } = options;
        const { xAlign, yAlign } = alignment;
        const paddingAndSize = caretSize + caretPadding;
        const { topLeft, topRight, bottomLeft, bottomRight } =
            toTRBLCorners(cornerRadius);
        let x = alignX(size, xAlign);
        const y = alignY(size, yAlign, paddingAndSize);
        if (yAlign === 'center') {
            if (xAlign === 'left') {
                x += paddingAndSize;
            } else if (xAlign === 'right') {
                x -= paddingAndSize;
            }
        } else if (xAlign === 'left') {
            x -= Math.max(topLeft, bottomLeft) + caretSize;
        } else if (xAlign === 'right') {
            x += Math.max(topRight, bottomRight) + caretSize;
        }
        return {
            x: _limitValue(x, 0, chart.width - size.width),
            y: _limitValue(y, 0, chart.height - size.height),
        };
    }
    function getAlignedX(tooltip5, align, options) {
        const padding = toPadding(options.padding);
        return align === 'center'
            ? tooltip5.x + tooltip5.width / 2
            : align === 'right'
            ? tooltip5.x + tooltip5.width - padding.right
            : tooltip5.x + padding.left;
    }
    function getBeforeAfterBodyLines(callback2) {
        return pushOrConcat([], splitNewlines(callback2));
    }
    function createTooltipContext(parent, tooltip5, tooltipItems) {
        return createContext(parent, {
            tooltip: tooltip5,
            tooltipItems,
            type: 'tooltip',
        });
    }
    function overrideCallbacks(callbacks, context) {
        const override =
            context &&
            context.dataset &&
            context.dataset.tooltip &&
            context.dataset.tooltip.callbacks;
        return override ? callbacks.override(override) : callbacks;
    }
    var Tooltip = class extends Element {
        constructor(config) {
            super();
            this.opacity = 0;
            this._active = [];
            this._eventPosition = void 0;
            this._size = void 0;
            this._cachedAnimations = void 0;
            this._tooltipItems = [];
            this.$animations = void 0;
            this.$context = void 0;
            this.chart = config.chart || config._chart;
            this._chart = this.chart;
            this.options = config.options;
            this.dataPoints = void 0;
            this.title = void 0;
            this.beforeBody = void 0;
            this.body = void 0;
            this.afterBody = void 0;
            this.footer = void 0;
            this.xAlign = void 0;
            this.yAlign = void 0;
            this.x = void 0;
            this.y = void 0;
            this.height = void 0;
            this.width = void 0;
            this.caretX = void 0;
            this.caretY = void 0;
            this.labelColors = void 0;
            this.labelPointStyles = void 0;
            this.labelTextColors = void 0;
        }
        initialize(options) {
            this.options = options;
            this._cachedAnimations = void 0;
            this.$context = void 0;
        }
        _resolveAnimations() {
            const cached = this._cachedAnimations;
            if (cached) {
                return cached;
            }
            const chart = this.chart;
            const options = this.options.setContext(this.getContext());
            const opts =
                options.enabled &&
                chart.options.animation &&
                options.animations;
            const animations = new Animations(this.chart, opts);
            if (opts._cacheable) {
                this._cachedAnimations = Object.freeze(animations);
            }
            return animations;
        }
        getContext() {
            return (
                this.$context ||
                (this.$context = createTooltipContext(
                    this.chart.getContext(),
                    this,
                    this._tooltipItems
                ))
            );
        }
        getTitle(context, options) {
            const { callbacks } = options;
            const beforeTitle = callbacks.beforeTitle.apply(this, [context]);
            const title4 = callbacks.title.apply(this, [context]);
            const afterTitle = callbacks.afterTitle.apply(this, [context]);
            let lines = [];
            lines = pushOrConcat(lines, splitNewlines(beforeTitle));
            lines = pushOrConcat(lines, splitNewlines(title4));
            lines = pushOrConcat(lines, splitNewlines(afterTitle));
            return lines;
        }
        getBeforeBody(tooltipItems, options) {
            return getBeforeAfterBodyLines(
                options.callbacks.beforeBody.apply(this, [tooltipItems])
            );
        }
        getBody(tooltipItems, options) {
            const { callbacks } = options;
            const bodyItems = [];
            each(tooltipItems, (context) => {
                const bodyItem = {
                    before: [],
                    lines: [],
                    after: [],
                };
                const scoped = overrideCallbacks(callbacks, context);
                pushOrConcat(
                    bodyItem.before,
                    splitNewlines(scoped.beforeLabel.call(this, context))
                );
                pushOrConcat(bodyItem.lines, scoped.label.call(this, context));
                pushOrConcat(
                    bodyItem.after,
                    splitNewlines(scoped.afterLabel.call(this, context))
                );
                bodyItems.push(bodyItem);
            });
            return bodyItems;
        }
        getAfterBody(tooltipItems, options) {
            return getBeforeAfterBodyLines(
                options.callbacks.afterBody.apply(this, [tooltipItems])
            );
        }
        getFooter(tooltipItems, options) {
            const { callbacks } = options;
            const beforeFooter = callbacks.beforeFooter.apply(this, [
                tooltipItems,
            ]);
            const footer = callbacks.footer.apply(this, [tooltipItems]);
            const afterFooter = callbacks.afterFooter.apply(this, [
                tooltipItems,
            ]);
            let lines = [];
            lines = pushOrConcat(lines, splitNewlines(beforeFooter));
            lines = pushOrConcat(lines, splitNewlines(footer));
            lines = pushOrConcat(lines, splitNewlines(afterFooter));
            return lines;
        }
        _createItems(options) {
            const active = this._active;
            const data = this.chart.data;
            const labelColors = [];
            const labelPointStyles = [];
            const labelTextColors = [];
            let tooltipItems = [];
            let i, len;
            for (i = 0, len = active.length; i < len; ++i) {
                tooltipItems.push(createTooltipItem(this.chart, active[i]));
            }
            if (options.filter) {
                tooltipItems = tooltipItems.filter((element, index3, array2) =>
                    options.filter(element, index3, array2, data)
                );
            }
            if (options.itemSort) {
                tooltipItems = tooltipItems.sort((a, b) =>
                    options.itemSort(a, b, data)
                );
            }
            each(tooltipItems, (context) => {
                const scoped = overrideCallbacks(options.callbacks, context);
                labelColors.push(scoped.labelColor.call(this, context));
                labelPointStyles.push(
                    scoped.labelPointStyle.call(this, context)
                );
                labelTextColors.push(scoped.labelTextColor.call(this, context));
            });
            this.labelColors = labelColors;
            this.labelPointStyles = labelPointStyles;
            this.labelTextColors = labelTextColors;
            this.dataPoints = tooltipItems;
            return tooltipItems;
        }
        update(changed, replay) {
            const options = this.options.setContext(this.getContext());
            const active = this._active;
            let properties;
            let tooltipItems = [];
            if (!active.length) {
                if (this.opacity !== 0) {
                    properties = {
                        opacity: 0,
                    };
                }
            } else {
                const position = positioners[options.position].call(
                    this,
                    active,
                    this._eventPosition
                );
                tooltipItems = this._createItems(options);
                this.title = this.getTitle(tooltipItems, options);
                this.beforeBody = this.getBeforeBody(tooltipItems, options);
                this.body = this.getBody(tooltipItems, options);
                this.afterBody = this.getAfterBody(tooltipItems, options);
                this.footer = this.getFooter(tooltipItems, options);
                const size = (this._size = getTooltipSize(this, options));
                const positionAndSize = Object.assign({}, position, size);
                const alignment = determineAlignment(
                    this.chart,
                    options,
                    positionAndSize
                );
                const backgroundPoint = getBackgroundPoint(
                    options,
                    positionAndSize,
                    alignment,
                    this.chart
                );
                this.xAlign = alignment.xAlign;
                this.yAlign = alignment.yAlign;
                properties = {
                    opacity: 1,
                    x: backgroundPoint.x,
                    y: backgroundPoint.y,
                    width: size.width,
                    height: size.height,
                    caretX: position.x,
                    caretY: position.y,
                };
            }
            this._tooltipItems = tooltipItems;
            this.$context = void 0;
            if (properties) {
                this._resolveAnimations().update(this, properties);
            }
            if (changed && options.external) {
                options.external.call(this, {
                    chart: this.chart,
                    tooltip: this,
                    replay,
                });
            }
        }
        drawCaret(tooltipPoint, ctx, size, options) {
            const caretPosition = this.getCaretPosition(
                tooltipPoint,
                size,
                options
            );
            ctx.lineTo(caretPosition.x1, caretPosition.y1);
            ctx.lineTo(caretPosition.x2, caretPosition.y2);
            ctx.lineTo(caretPosition.x3, caretPosition.y3);
        }
        getCaretPosition(tooltipPoint, size, options) {
            const { xAlign, yAlign } = this;
            const { caretSize, cornerRadius } = options;
            const { topLeft, topRight, bottomLeft, bottomRight } =
                toTRBLCorners(cornerRadius);
            const { x: ptX, y: ptY } = tooltipPoint;
            const { width, height } = size;
            let x1, x2, x3, y1, y2, y3;
            if (yAlign === 'center') {
                y2 = ptY + height / 2;
                if (xAlign === 'left') {
                    x1 = ptX;
                    x2 = x1 - caretSize;
                    y1 = y2 + caretSize;
                    y3 = y2 - caretSize;
                } else {
                    x1 = ptX + width;
                    x2 = x1 + caretSize;
                    y1 = y2 - caretSize;
                    y3 = y2 + caretSize;
                }
                x3 = x1;
            } else {
                if (xAlign === 'left') {
                    x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
                } else if (xAlign === 'right') {
                    x2 =
                        ptX +
                        width -
                        Math.max(topRight, bottomRight) -
                        caretSize;
                } else {
                    x2 = this.caretX;
                }
                if (yAlign === 'top') {
                    y1 = ptY;
                    y2 = y1 - caretSize;
                    x1 = x2 - caretSize;
                    x3 = x2 + caretSize;
                } else {
                    y1 = ptY + height;
                    y2 = y1 + caretSize;
                    x1 = x2 + caretSize;
                    x3 = x2 - caretSize;
                }
                y3 = y1;
            }
            return { x1, x2, x3, y1, y2, y3 };
        }
        drawTitle(pt, ctx, options) {
            const title4 = this.title;
            const length = title4.length;
            let titleFont, titleSpacing, i;
            if (length) {
                const rtlHelper = getRtlAdapter(
                    options.rtl,
                    this.x,
                    this.width
                );
                pt.x = getAlignedX(this, options.titleAlign, options);
                ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
                ctx.textBaseline = 'middle';
                titleFont = toFont(options.titleFont);
                titleSpacing = options.titleSpacing;
                ctx.fillStyle = options.titleColor;
                ctx.font = titleFont.string;
                for (i = 0; i < length; ++i) {
                    ctx.fillText(
                        title4[i],
                        rtlHelper.x(pt.x),
                        pt.y + titleFont.lineHeight / 2
                    );
                    pt.y += titleFont.lineHeight + titleSpacing;
                    if (i + 1 === length) {
                        pt.y += options.titleMarginBottom - titleSpacing;
                    }
                }
            }
        }
        _drawColorBox(ctx, pt, i, rtlHelper, options) {
            const labelColors = this.labelColors[i];
            const labelPointStyle = this.labelPointStyles[i];
            const { boxHeight, boxWidth, boxPadding } = options;
            const bodyFont = toFont(options.bodyFont);
            const colorX = getAlignedX(this, 'left', options);
            const rtlColorX = rtlHelper.x(colorX);
            const yOffSet =
                boxHeight < bodyFont.lineHeight
                    ? (bodyFont.lineHeight - boxHeight) / 2
                    : 0;
            const colorY = pt.y + yOffSet;
            if (options.usePointStyle) {
                const drawOptions = {
                    radius: Math.min(boxWidth, boxHeight) / 2,
                    pointStyle: labelPointStyle.pointStyle,
                    rotation: labelPointStyle.rotation,
                    borderWidth: 1,
                };
                const centerX =
                    rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
                const centerY = colorY + boxHeight / 2;
                ctx.strokeStyle = options.multiKeyBackground;
                ctx.fillStyle = options.multiKeyBackground;
                drawPoint(ctx, drawOptions, centerX, centerY);
                ctx.strokeStyle = labelColors.borderColor;
                ctx.fillStyle = labelColors.backgroundColor;
                drawPoint(ctx, drawOptions, centerX, centerY);
            } else {
                ctx.lineWidth = isObject(labelColors.borderWidth)
                    ? Math.max(...Object.values(labelColors.borderWidth))
                    : labelColors.borderWidth || 1;
                ctx.strokeStyle = labelColors.borderColor;
                ctx.setLineDash(labelColors.borderDash || []);
                ctx.lineDashOffset = labelColors.borderDashOffset || 0;
                const outerX = rtlHelper.leftForLtr(
                    rtlColorX,
                    boxWidth - boxPadding
                );
                const innerX = rtlHelper.leftForLtr(
                    rtlHelper.xPlus(rtlColorX, 1),
                    boxWidth - boxPadding - 2
                );
                const borderRadius = toTRBLCorners(labelColors.borderRadius);
                if (Object.values(borderRadius).some((v) => v !== 0)) {
                    ctx.beginPath();
                    ctx.fillStyle = options.multiKeyBackground;
                    addRoundedRectPath(ctx, {
                        x: outerX,
                        y: colorY,
                        w: boxWidth,
                        h: boxHeight,
                        radius: borderRadius,
                    });
                    ctx.fill();
                    ctx.stroke();
                    ctx.fillStyle = labelColors.backgroundColor;
                    ctx.beginPath();
                    addRoundedRectPath(ctx, {
                        x: innerX,
                        y: colorY + 1,
                        w: boxWidth - 2,
                        h: boxHeight - 2,
                        radius: borderRadius,
                    });
                    ctx.fill();
                } else {
                    ctx.fillStyle = options.multiKeyBackground;
                    ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
                    ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
                    ctx.fillStyle = labelColors.backgroundColor;
                    ctx.fillRect(
                        innerX,
                        colorY + 1,
                        boxWidth - 2,
                        boxHeight - 2
                    );
                }
            }
            ctx.fillStyle = this.labelTextColors[i];
        }
        drawBody(pt, ctx, options) {
            const { body } = this;
            const {
                bodySpacing,
                bodyAlign,
                displayColors,
                boxHeight,
                boxWidth,
                boxPadding,
            } = options;
            const bodyFont = toFont(options.bodyFont);
            let bodyLineHeight = bodyFont.lineHeight;
            let xLinePadding = 0;
            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
            const fillLineOfText = function (line) {
                ctx.fillText(
                    line,
                    rtlHelper.x(pt.x + xLinePadding),
                    pt.y + bodyLineHeight / 2
                );
                pt.y += bodyLineHeight + bodySpacing;
            };
            const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
            let bodyItem, textColor, lines, i, j, ilen, jlen;
            ctx.textAlign = bodyAlign;
            ctx.textBaseline = 'middle';
            ctx.font = bodyFont.string;
            pt.x = getAlignedX(this, bodyAlignForCalculation, options);
            ctx.fillStyle = options.bodyColor;
            each(this.beforeBody, fillLineOfText);
            xLinePadding =
                displayColors && bodyAlignForCalculation !== 'right'
                    ? bodyAlign === 'center'
                        ? boxWidth / 2 + boxPadding
                        : boxWidth + 2 + boxPadding
                    : 0;
            for (i = 0, ilen = body.length; i < ilen; ++i) {
                bodyItem = body[i];
                textColor = this.labelTextColors[i];
                ctx.fillStyle = textColor;
                each(bodyItem.before, fillLineOfText);
                lines = bodyItem.lines;
                if (displayColors && lines.length) {
                    this._drawColorBox(ctx, pt, i, rtlHelper, options);
                    bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
                }
                for (j = 0, jlen = lines.length; j < jlen; ++j) {
                    fillLineOfText(lines[j]);
                    bodyLineHeight = bodyFont.lineHeight;
                }
                each(bodyItem.after, fillLineOfText);
            }
            xLinePadding = 0;
            bodyLineHeight = bodyFont.lineHeight;
            each(this.afterBody, fillLineOfText);
            pt.y -= bodySpacing;
        }
        drawFooter(pt, ctx, options) {
            const footer = this.footer;
            const length = footer.length;
            let footerFont, i;
            if (length) {
                const rtlHelper = getRtlAdapter(
                    options.rtl,
                    this.x,
                    this.width
                );
                pt.x = getAlignedX(this, options.footerAlign, options);
                pt.y += options.footerMarginTop;
                ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
                ctx.textBaseline = 'middle';
                footerFont = toFont(options.footerFont);
                ctx.fillStyle = options.footerColor;
                ctx.font = footerFont.string;
                for (i = 0; i < length; ++i) {
                    ctx.fillText(
                        footer[i],
                        rtlHelper.x(pt.x),
                        pt.y + footerFont.lineHeight / 2
                    );
                    pt.y += footerFont.lineHeight + options.footerSpacing;
                }
            }
        }
        drawBackground(pt, ctx, tooltipSize, options) {
            const { xAlign, yAlign } = this;
            const { x, y } = pt;
            const { width, height } = tooltipSize;
            const { topLeft, topRight, bottomLeft, bottomRight } =
                toTRBLCorners(options.cornerRadius);
            ctx.fillStyle = options.backgroundColor;
            ctx.strokeStyle = options.borderColor;
            ctx.lineWidth = options.borderWidth;
            ctx.beginPath();
            ctx.moveTo(x + topLeft, y);
            if (yAlign === 'top') {
                this.drawCaret(pt, ctx, tooltipSize, options);
            }
            ctx.lineTo(x + width - topRight, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
            if (yAlign === 'center' && xAlign === 'right') {
                this.drawCaret(pt, ctx, tooltipSize, options);
            }
            ctx.lineTo(x + width, y + height - bottomRight);
            ctx.quadraticCurveTo(
                x + width,
                y + height,
                x + width - bottomRight,
                y + height
            );
            if (yAlign === 'bottom') {
                this.drawCaret(pt, ctx, tooltipSize, options);
            }
            ctx.lineTo(x + bottomLeft, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
            if (yAlign === 'center' && xAlign === 'left') {
                this.drawCaret(pt, ctx, tooltipSize, options);
            }
            ctx.lineTo(x, y + topLeft);
            ctx.quadraticCurveTo(x, y, x + topLeft, y);
            ctx.closePath();
            ctx.fill();
            if (options.borderWidth > 0) {
                ctx.stroke();
            }
        }
        _updateAnimationTarget(options) {
            const chart = this.chart;
            const anims = this.$animations;
            const animX = anims && anims.x;
            const animY = anims && anims.y;
            if (animX || animY) {
                const position = positioners[options.position].call(
                    this,
                    this._active,
                    this._eventPosition
                );
                if (!position) {
                    return;
                }
                const size = (this._size = getTooltipSize(this, options));
                const positionAndSize = Object.assign({}, position, this._size);
                const alignment = determineAlignment(
                    chart,
                    options,
                    positionAndSize
                );
                const point = getBackgroundPoint(
                    options,
                    positionAndSize,
                    alignment,
                    chart
                );
                if (animX._to !== point.x || animY._to !== point.y) {
                    this.xAlign = alignment.xAlign;
                    this.yAlign = alignment.yAlign;
                    this.width = size.width;
                    this.height = size.height;
                    this.caretX = position.x;
                    this.caretY = position.y;
                    this._resolveAnimations().update(this, point);
                }
            }
        }
        _willRender() {
            return !!this.opacity;
        }
        draw(ctx) {
            const options = this.options.setContext(this.getContext());
            let opacity = this.opacity;
            if (!opacity) {
                return;
            }
            this._updateAnimationTarget(options);
            const tooltipSize = {
                width: this.width,
                height: this.height,
            };
            const pt = {
                x: this.x,
                y: this.y,
            };
            opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
            const padding = toPadding(options.padding);
            const hasTooltipContent =
                this.title.length ||
                this.beforeBody.length ||
                this.body.length ||
                this.afterBody.length ||
                this.footer.length;
            if (options.enabled && hasTooltipContent) {
                ctx.save();
                ctx.globalAlpha = opacity;
                this.drawBackground(pt, ctx, tooltipSize, options);
                overrideTextDirection(ctx, options.textDirection);
                pt.y += padding.top;
                this.drawTitle(pt, ctx, options);
                this.drawBody(pt, ctx, options);
                this.drawFooter(pt, ctx, options);
                restoreTextDirection(ctx, options.textDirection);
                ctx.restore();
            }
        }
        getActiveElements() {
            return this._active || [];
        }
        setActiveElements(activeElements, eventPosition) {
            const lastActive = this._active;
            const active = activeElements.map(
                ({ datasetIndex, index: index3 }) => {
                    const meta = this.chart.getDatasetMeta(datasetIndex);
                    if (!meta) {
                        throw new Error(
                            'Cannot find a dataset at index ' + datasetIndex
                        );
                    }
                    return {
                        datasetIndex,
                        element: meta.data[index3],
                        index: index3,
                    };
                }
            );
            const changed = !_elementsEqual(lastActive, active);
            const positionChanged = this._positionChanged(
                active,
                eventPosition
            );
            if (changed || positionChanged) {
                this._active = active;
                this._eventPosition = eventPosition;
                this._ignoreReplayEvents = true;
                this.update(true);
            }
        }
        handleEvent(e, replay, inChartArea = true) {
            if (replay && this._ignoreReplayEvents) {
                return false;
            }
            this._ignoreReplayEvents = false;
            const options = this.options;
            const lastActive = this._active || [];
            const active = this._getActiveElements(
                e,
                lastActive,
                replay,
                inChartArea
            );
            const positionChanged = this._positionChanged(active, e);
            const changed =
                replay ||
                !_elementsEqual(active, lastActive) ||
                positionChanged;
            if (changed) {
                this._active = active;
                if (options.enabled || options.external) {
                    this._eventPosition = {
                        x: e.x,
                        y: e.y,
                    };
                    this.update(true, replay);
                }
            }
            return changed;
        }
        _getActiveElements(e, lastActive, replay, inChartArea) {
            const options = this.options;
            if (e.type === 'mouseout') {
                return [];
            }
            if (!inChartArea) {
                return lastActive;
            }
            const active = this.chart.getElementsAtEventForMode(
                e,
                options.mode,
                options,
                replay
            );
            if (options.reverse) {
                active.reverse();
            }
            return active;
        }
        _positionChanged(active, e) {
            const { caretX, caretY, options } = this;
            const position = positioners[options.position].call(
                this,
                active,
                e
            );
            return (
                position !== false &&
                (caretX !== position.x || caretY !== position.y)
            );
        }
    };
    Tooltip.positioners = positioners;
    var plugin_tooltip = {
        id: 'tooltip',
        _element: Tooltip,
        positioners,
        afterInit(chart, _args, options) {
            if (options) {
                chart.tooltip = new Tooltip({ chart, options });
            }
        },
        beforeUpdate(chart, _args, options) {
            if (chart.tooltip) {
                chart.tooltip.initialize(options);
            }
        },
        reset(chart, _args, options) {
            if (chart.tooltip) {
                chart.tooltip.initialize(options);
            }
        },
        afterDraw(chart) {
            const tooltip5 = chart.tooltip;
            if (tooltip5 && tooltip5._willRender()) {
                const args = {
                    tooltip: tooltip5,
                };
                if (chart.notifyPlugins('beforeTooltipDraw', args) === false) {
                    return;
                }
                tooltip5.draw(chart.ctx);
                chart.notifyPlugins('afterTooltipDraw', args);
            }
        },
        afterEvent(chart, args) {
            if (chart.tooltip) {
                const useFinalPosition = args.replay;
                if (
                    chart.tooltip.handleEvent(
                        args.event,
                        useFinalPosition,
                        args.inChartArea
                    )
                ) {
                    args.changed = true;
                }
            }
        },
        defaults: {
            enabled: true,
            external: null,
            position: 'average',
            backgroundColor: 'rgba(0,0,0,0.8)',
            titleColor: '#fff',
            titleFont: {
                weight: 'bold',
            },
            titleSpacing: 2,
            titleMarginBottom: 6,
            titleAlign: 'left',
            bodyColor: '#fff',
            bodySpacing: 2,
            bodyFont: {},
            bodyAlign: 'left',
            footerColor: '#fff',
            footerSpacing: 2,
            footerMarginTop: 6,
            footerFont: {
                weight: 'bold',
            },
            footerAlign: 'left',
            padding: 6,
            caretPadding: 2,
            caretSize: 5,
            cornerRadius: 6,
            boxHeight: (ctx, opts) => opts.bodyFont.size,
            boxWidth: (ctx, opts) => opts.bodyFont.size,
            multiKeyBackground: '#fff',
            displayColors: true,
            boxPadding: 0,
            borderColor: 'rgba(0,0,0,0)',
            borderWidth: 0,
            animation: {
                duration: 400,
                easing: 'easeOutQuart',
            },
            animations: {
                numbers: {
                    type: 'number',
                    properties: [
                        'x',
                        'y',
                        'width',
                        'height',
                        'caretX',
                        'caretY',
                    ],
                },
                opacity: {
                    easing: 'linear',
                    duration: 200,
                },
            },
            callbacks: {
                beforeTitle: noop,
                title(tooltipItems) {
                    if (tooltipItems.length > 0) {
                        const item = tooltipItems[0];
                        const labels = item.chart.data.labels;
                        const labelCount = labels ? labels.length : 0;
                        if (
                            this &&
                            this.options &&
                            this.options.mode === 'dataset'
                        ) {
                            return item.dataset.label || '';
                        } else if (item.label) {
                            return item.label;
                        } else if (
                            labelCount > 0 &&
                            item.dataIndex < labelCount
                        ) {
                            return labels[item.dataIndex];
                        }
                    }
                    return '';
                },
                afterTitle: noop,
                beforeBody: noop,
                beforeLabel: noop,
                label(tooltipItem) {
                    if (
                        this &&
                        this.options &&
                        this.options.mode === 'dataset'
                    ) {
                        return (
                            tooltipItem.label +
                                ': ' +
                                tooltipItem.formattedValue ||
                            tooltipItem.formattedValue
                        );
                    }
                    let label = tooltipItem.dataset.label || '';
                    if (label) {
                        label += ': ';
                    }
                    const value = tooltipItem.formattedValue;
                    if (!isNullOrUndef(value)) {
                        label += value;
                    }
                    return label;
                },
                labelColor(tooltipItem) {
                    const meta = tooltipItem.chart.getDatasetMeta(
                        tooltipItem.datasetIndex
                    );
                    const options = meta.controller.getStyle(
                        tooltipItem.dataIndex
                    );
                    return {
                        borderColor: options.borderColor,
                        backgroundColor: options.backgroundColor,
                        borderWidth: options.borderWidth,
                        borderDash: options.borderDash,
                        borderDashOffset: options.borderDashOffset,
                        borderRadius: 0,
                    };
                },
                labelTextColor() {
                    return this.options.bodyColor;
                },
                labelPointStyle(tooltipItem) {
                    const meta = tooltipItem.chart.getDatasetMeta(
                        tooltipItem.datasetIndex
                    );
                    const options = meta.controller.getStyle(
                        tooltipItem.dataIndex
                    );
                    return {
                        pointStyle: options.pointStyle,
                        rotation: options.rotation,
                    };
                },
                afterLabel: noop,
                afterBody: noop,
                beforeFooter: noop,
                footer: noop,
                afterFooter: noop,
            },
        },
        defaultRoutes: {
            bodyFont: 'font',
            footerFont: 'font',
            titleFont: 'font',
        },
        descriptors: {
            _scriptable: (name) =>
                name !== 'filter' && name !== 'itemSort' && name !== 'external',
            _indexable: false,
            callbacks: {
                _scriptable: false,
                _indexable: false,
            },
            animation: {
                _fallback: false,
            },
            animations: {
                _fallback: 'animation',
            },
        },
        additionalOptionScopes: ['interaction'],
    };
    var plugins = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        Decimation: plugin_decimation,
        Filler: index,
        Legend: plugin_legend,
        SubTitle: plugin_subtitle,
        Title: plugin_title,
        Tooltip: plugin_tooltip,
    });
    var addIfString = (labels, raw, index3, addedLabels) => {
        if (typeof raw === 'string') {
            index3 = labels.push(raw) - 1;
            addedLabels.unshift({ index: index3, label: raw });
        } else if (isNaN(raw)) {
            index3 = null;
        }
        return index3;
    };
    function findOrAddLabel(labels, raw, index3, addedLabels) {
        const first = labels.indexOf(raw);
        if (first === -1) {
            return addIfString(labels, raw, index3, addedLabels);
        }
        const last = labels.lastIndexOf(raw);
        return first !== last ? index3 : first;
    }
    var validIndex = (index3, max3) =>
        index3 === null ? null : _limitValue(Math.round(index3), 0, max3);
    var CategoryScale = class extends Scale {
        constructor(cfg) {
            super(cfg);
            this._startValue = void 0;
            this._valueRange = 0;
            this._addedLabels = [];
        }
        init(scaleOptions) {
            const added = this._addedLabels;
            if (added.length) {
                const labels = this.getLabels();
                for (const { index: index3, label } of added) {
                    if (labels[index3] === label) {
                        labels.splice(index3, 1);
                    }
                }
                this._addedLabels = [];
            }
            super.init(scaleOptions);
        }
        parse(raw, index3) {
            if (isNullOrUndef(raw)) {
                return null;
            }
            const labels = this.getLabels();
            index3 =
                isFinite(index3) && labels[index3] === raw
                    ? index3
                    : findOrAddLabel(
                          labels,
                          raw,
                          valueOrDefault(index3, raw),
                          this._addedLabels
                      );
            return validIndex(index3, labels.length - 1);
        }
        determineDataLimits() {
            const { minDefined, maxDefined } = this.getUserBounds();
            let { min: min3, max: max3 } = this.getMinMax(true);
            if (this.options.bounds === 'ticks') {
                if (!minDefined) {
                    min3 = 0;
                }
                if (!maxDefined) {
                    max3 = this.getLabels().length - 1;
                }
            }
            this.min = min3;
            this.max = max3;
        }
        buildTicks() {
            const min3 = this.min;
            const max3 = this.max;
            const offset = this.options.offset;
            const ticks = [];
            let labels = this.getLabels();
            labels =
                min3 === 0 && max3 === labels.length - 1
                    ? labels
                    : labels.slice(min3, max3 + 1);
            this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
            this._startValue = this.min - (offset ? 0.5 : 0);
            for (let value = min3; value <= max3; value++) {
                ticks.push({ value });
            }
            return ticks;
        }
        getLabelForValue(value) {
            const labels = this.getLabels();
            if (value >= 0 && value < labels.length) {
                return labels[value];
            }
            return value;
        }
        configure() {
            super.configure();
            if (!this.isHorizontal()) {
                this._reversePixels = !this._reversePixels;
            }
        }
        getPixelForValue(value) {
            if (typeof value !== 'number') {
                value = this.parse(value);
            }
            return value === null
                ? NaN
                : this.getPixelForDecimal(
                      (value - this._startValue) / this._valueRange
                  );
        }
        getPixelForTick(index3) {
            const ticks = this.ticks;
            if (index3 < 0 || index3 > ticks.length - 1) {
                return null;
            }
            return this.getPixelForValue(ticks[index3].value);
        }
        getValueForPixel(pixel) {
            return Math.round(
                this._startValue +
                    this.getDecimalForPixel(pixel) * this._valueRange
            );
        }
        getBasePixel() {
            return this.bottom;
        }
    };
    CategoryScale.id = 'category';
    CategoryScale.defaults = {
        ticks: {
            callback: CategoryScale.prototype.getLabelForValue,
        },
    };
    function generateTicks$1(generationOptions, dataRange) {
        const ticks = [];
        const MIN_SPACING = 1e-14;
        const {
            bounds,
            step,
            min: min3,
            max: max3,
            precision,
            count,
            maxTicks,
            maxDigits,
            includeBounds,
        } = generationOptions;
        const unit = step || 1;
        const maxSpaces = maxTicks - 1;
        const { min: rmin, max: rmax } = dataRange;
        const minDefined = !isNullOrUndef(min3);
        const maxDefined = !isNullOrUndef(max3);
        const countDefined = !isNullOrUndef(count);
        const minSpacing = (rmax - rmin) / (maxDigits + 1);
        let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
        let factor, niceMin, niceMax, numSpaces;
        if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
            return [{ value: rmin }, { value: rmax }];
        }
        numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
        if (numSpaces > maxSpaces) {
            spacing = niceNum((numSpaces * spacing) / maxSpaces / unit) * unit;
        }
        if (!isNullOrUndef(precision)) {
            factor = Math.pow(10, precision);
            spacing = Math.ceil(spacing * factor) / factor;
        }
        if (bounds === 'ticks') {
            niceMin = Math.floor(rmin / spacing) * spacing;
            niceMax = Math.ceil(rmax / spacing) * spacing;
        } else {
            niceMin = rmin;
            niceMax = rmax;
        }
        if (
            minDefined &&
            maxDefined &&
            step &&
            almostWhole((max3 - min3) / step, spacing / 1e3)
        ) {
            numSpaces = Math.round(Math.min((max3 - min3) / spacing, maxTicks));
            spacing = (max3 - min3) / numSpaces;
            niceMin = min3;
            niceMax = max3;
        } else if (countDefined) {
            niceMin = minDefined ? min3 : niceMin;
            niceMax = maxDefined ? max3 : niceMax;
            numSpaces = count - 1;
            spacing = (niceMax - niceMin) / numSpaces;
        } else {
            numSpaces = (niceMax - niceMin) / spacing;
            if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
                numSpaces = Math.round(numSpaces);
            } else {
                numSpaces = Math.ceil(numSpaces);
            }
        }
        const decimalPlaces = Math.max(
            _decimalPlaces(spacing),
            _decimalPlaces(niceMin)
        );
        factor = Math.pow(
            10,
            isNullOrUndef(precision) ? decimalPlaces : precision
        );
        niceMin = Math.round(niceMin * factor) / factor;
        niceMax = Math.round(niceMax * factor) / factor;
        let j = 0;
        if (minDefined) {
            if (includeBounds && niceMin !== min3) {
                ticks.push({ value: min3 });
                if (niceMin < min3) {
                    j++;
                }
                if (
                    almostEquals(
                        Math.round((niceMin + j * spacing) * factor) / factor,
                        min3,
                        relativeLabelSize(min3, minSpacing, generationOptions)
                    )
                ) {
                    j++;
                }
            } else if (niceMin < min3) {
                j++;
            }
        }
        for (; j < numSpaces; ++j) {
            ticks.push({
                value: Math.round((niceMin + j * spacing) * factor) / factor,
            });
        }
        if (maxDefined && includeBounds && niceMax !== max3) {
            if (
                ticks.length &&
                almostEquals(
                    ticks[ticks.length - 1].value,
                    max3,
                    relativeLabelSize(max3, minSpacing, generationOptions)
                )
            ) {
                ticks[ticks.length - 1].value = max3;
            } else {
                ticks.push({ value: max3 });
            }
        } else if (!maxDefined || niceMax === max3) {
            ticks.push({ value: niceMax });
        }
        return ticks;
    }
    function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
        const rad = toRadians(minRotation);
        const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
        const length = 0.75 * minSpacing * ('' + value).length;
        return Math.min(minSpacing / ratio, length);
    }
    var LinearScaleBase = class extends Scale {
        constructor(cfg) {
            super(cfg);
            this.start = void 0;
            this.end = void 0;
            this._startValue = void 0;
            this._endValue = void 0;
            this._valueRange = 0;
        }
        parse(raw, index3) {
            if (isNullOrUndef(raw)) {
                return null;
            }
            if (
                (typeof raw === 'number' || raw instanceof Number) &&
                !isFinite(+raw)
            ) {
                return null;
            }
            return +raw;
        }
        handleTickRangeOptions() {
            const { beginAtZero } = this.options;
            const { minDefined, maxDefined } = this.getUserBounds();
            let { min: min3, max: max3 } = this;
            const setMin = (v) => (min3 = minDefined ? min3 : v);
            const setMax = (v) => (max3 = maxDefined ? max3 : v);
            if (beginAtZero) {
                const minSign = sign(min3);
                const maxSign = sign(max3);
                if (minSign < 0 && maxSign < 0) {
                    setMax(0);
                } else if (minSign > 0 && maxSign > 0) {
                    setMin(0);
                }
            }
            if (min3 === max3) {
                let offset = 1;
                if (
                    max3 >= Number.MAX_SAFE_INTEGER ||
                    min3 <= Number.MIN_SAFE_INTEGER
                ) {
                    offset = Math.abs(max3 * 0.05);
                }
                setMax(max3 + offset);
                if (!beginAtZero) {
                    setMin(min3 - offset);
                }
            }
            this.min = min3;
            this.max = max3;
        }
        getTickLimit() {
            const tickOpts = this.options.ticks;
            let { maxTicksLimit, stepSize } = tickOpts;
            let maxTicks;
            if (stepSize) {
                maxTicks =
                    Math.ceil(this.max / stepSize) -
                    Math.floor(this.min / stepSize) +
                    1;
                if (maxTicks > 1e3) {
                    console.warn(
                        `scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`
                    );
                    maxTicks = 1e3;
                }
            } else {
                maxTicks = this.computeTickLimit();
                maxTicksLimit = maxTicksLimit || 11;
            }
            if (maxTicksLimit) {
                maxTicks = Math.min(maxTicksLimit, maxTicks);
            }
            return maxTicks;
        }
        computeTickLimit() {
            return Number.POSITIVE_INFINITY;
        }
        buildTicks() {
            const opts = this.options;
            const tickOpts = opts.ticks;
            let maxTicks = this.getTickLimit();
            maxTicks = Math.max(2, maxTicks);
            const numericGeneratorOptions = {
                maxTicks,
                bounds: opts.bounds,
                min: opts.min,
                max: opts.max,
                precision: tickOpts.precision,
                step: tickOpts.stepSize,
                count: tickOpts.count,
                maxDigits: this._maxDigits(),
                horizontal: this.isHorizontal(),
                minRotation: tickOpts.minRotation || 0,
                includeBounds: tickOpts.includeBounds !== false,
            };
            const dataRange = this._range || this;
            const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
            if (opts.bounds === 'ticks') {
                _setMinAndMaxByKey(ticks, this, 'value');
            }
            if (opts.reverse) {
                ticks.reverse();
                this.start = this.max;
                this.end = this.min;
            } else {
                this.start = this.min;
                this.end = this.max;
            }
            return ticks;
        }
        configure() {
            const ticks = this.ticks;
            let start2 = this.min;
            let end = this.max;
            super.configure();
            if (this.options.offset && ticks.length) {
                const offset =
                    (end - start2) / Math.max(ticks.length - 1, 1) / 2;
                start2 -= offset;
                end += offset;
            }
            this._startValue = start2;
            this._endValue = end;
            this._valueRange = end - start2;
        }
        getLabelForValue(value) {
            return formatNumber(
                value,
                this.chart.options.locale,
                this.options.ticks.format
            );
        }
    };
    var LinearScale = class extends LinearScaleBase {
        determineDataLimits() {
            const { min: min3, max: max3 } = this.getMinMax(true);
            this.min = isNumberFinite(min3) ? min3 : 0;
            this.max = isNumberFinite(max3) ? max3 : 1;
            this.handleTickRangeOptions();
        }
        computeTickLimit() {
            const horizontal = this.isHorizontal();
            const length = horizontal ? this.width : this.height;
            const minRotation = toRadians(this.options.ticks.minRotation);
            const ratio =
                (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) ||
                1e-3;
            const tickFont = this._resolveTickFontOptions(0);
            return Math.ceil(
                length / Math.min(40, tickFont.lineHeight / ratio)
            );
        }
        getPixelForValue(value) {
            return value === null
                ? NaN
                : this.getPixelForDecimal(
                      (value - this._startValue) / this._valueRange
                  );
        }
        getValueForPixel(pixel) {
            return (
                this._startValue +
                this.getDecimalForPixel(pixel) * this._valueRange
            );
        }
    };
    LinearScale.id = 'linear';
    LinearScale.defaults = {
        ticks: {
            callback: Ticks.formatters.numeric,
        },
    };
    function isMajor(tickVal) {
        const remain = tickVal / Math.pow(10, Math.floor(log10(tickVal)));
        return remain === 1;
    }
    function generateTicks(generationOptions, dataRange) {
        const endExp = Math.floor(log10(dataRange.max));
        const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
        const ticks = [];
        let tickVal = finiteOrDefault(
            generationOptions.min,
            Math.pow(10, Math.floor(log10(dataRange.min)))
        );
        let exp = Math.floor(log10(tickVal));
        let significand = Math.floor(tickVal / Math.pow(10, exp));
        let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
        do {
            ticks.push({ value: tickVal, major: isMajor(tickVal) });
            ++significand;
            if (significand === 10) {
                significand = 1;
                ++exp;
                precision = exp >= 0 ? 1 : precision;
            }
            tickVal =
                Math.round(significand * Math.pow(10, exp) * precision) /
                precision;
        } while (
            exp < endExp ||
            (exp === endExp && significand < endSignificand)
        );
        const lastTick = finiteOrDefault(generationOptions.max, tickVal);
        ticks.push({ value: lastTick, major: isMajor(tickVal) });
        return ticks;
    }
    var LogarithmicScale = class extends Scale {
        constructor(cfg) {
            super(cfg);
            this.start = void 0;
            this.end = void 0;
            this._startValue = void 0;
            this._valueRange = 0;
        }
        parse(raw, index3) {
            const value = LinearScaleBase.prototype.parse.apply(this, [
                raw,
                index3,
            ]);
            if (value === 0) {
                this._zero = true;
                return void 0;
            }
            return isNumberFinite(value) && value > 0 ? value : null;
        }
        determineDataLimits() {
            const { min: min3, max: max3 } = this.getMinMax(true);
            this.min = isNumberFinite(min3) ? Math.max(0, min3) : null;
            this.max = isNumberFinite(max3) ? Math.max(0, max3) : null;
            if (this.options.beginAtZero) {
                this._zero = true;
            }
            this.handleTickRangeOptions();
        }
        handleTickRangeOptions() {
            const { minDefined, maxDefined } = this.getUserBounds();
            let min3 = this.min;
            let max3 = this.max;
            const setMin = (v) => (min3 = minDefined ? min3 : v);
            const setMax = (v) => (max3 = maxDefined ? max3 : v);
            const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);
            if (min3 === max3) {
                if (min3 <= 0) {
                    setMin(1);
                    setMax(10);
                } else {
                    setMin(exp(min3, -1));
                    setMax(exp(max3, 1));
                }
            }
            if (min3 <= 0) {
                setMin(exp(max3, -1));
            }
            if (max3 <= 0) {
                setMax(exp(min3, 1));
            }
            if (
                this._zero &&
                this.min !== this._suggestedMin &&
                min3 === exp(this.min, 0)
            ) {
                setMin(exp(min3, -1));
            }
            this.min = min3;
            this.max = max3;
        }
        buildTicks() {
            const opts = this.options;
            const generationOptions = {
                min: this._userMin,
                max: this._userMax,
            };
            const ticks = generateTicks(generationOptions, this);
            if (opts.bounds === 'ticks') {
                _setMinAndMaxByKey(ticks, this, 'value');
            }
            if (opts.reverse) {
                ticks.reverse();
                this.start = this.max;
                this.end = this.min;
            } else {
                this.start = this.min;
                this.end = this.max;
            }
            return ticks;
        }
        getLabelForValue(value) {
            return value === void 0
                ? '0'
                : formatNumber(
                      value,
                      this.chart.options.locale,
                      this.options.ticks.format
                  );
        }
        configure() {
            const start2 = this.min;
            super.configure();
            this._startValue = log10(start2);
            this._valueRange = log10(this.max) - log10(start2);
        }
        getPixelForValue(value) {
            if (value === void 0 || value === 0) {
                value = this.min;
            }
            if (value === null || isNaN(value)) {
                return NaN;
            }
            return this.getPixelForDecimal(
                value === this.min
                    ? 0
                    : (log10(value) - this._startValue) / this._valueRange
            );
        }
        getValueForPixel(pixel) {
            const decimal = this.getDecimalForPixel(pixel);
            return Math.pow(10, this._startValue + decimal * this._valueRange);
        }
    };
    LogarithmicScale.id = 'logarithmic';
    LogarithmicScale.defaults = {
        ticks: {
            callback: Ticks.formatters.logarithmic,
            major: {
                enabled: true,
            },
        },
    };
    function getTickBackdropHeight(opts) {
        const tickOpts = opts.ticks;
        if (tickOpts.display && opts.display) {
            const padding = toPadding(tickOpts.backdropPadding);
            return (
                valueOrDefault(
                    tickOpts.font && tickOpts.font.size,
                    defaults.font.size
                ) + padding.height
            );
        }
        return 0;
    }
    function measureLabelSize(ctx, font, label) {
        label = isArray(label) ? label : [label];
        return {
            w: _longestText(ctx, font.string, label),
            h: label.length * font.lineHeight,
        };
    }
    function determineLimits(angle, pos, size, min3, max3) {
        if (angle === min3 || angle === max3) {
            return {
                start: pos - size / 2,
                end: pos + size / 2,
            };
        } else if (angle < min3 || angle > max3) {
            return {
                start: pos - size,
                end: pos,
            };
        }
        return {
            start: pos,
            end: pos + size,
        };
    }
    function fitWithPointLabels(scale) {
        const orig = {
            l: scale.left + scale._padding.left,
            r: scale.right - scale._padding.right,
            t: scale.top + scale._padding.top,
            b: scale.bottom - scale._padding.bottom,
        };
        const limits = Object.assign({}, orig);
        const labelSizes = [];
        const padding = [];
        const valueCount = scale._pointLabels.length;
        const pointLabelOpts = scale.options.pointLabels;
        const additionalAngle = pointLabelOpts.centerPointLabels
            ? PI / valueCount
            : 0;
        for (let i = 0; i < valueCount; i++) {
            const opts = pointLabelOpts.setContext(
                scale.getPointLabelContext(i)
            );
            padding[i] = opts.padding;
            const pointPosition = scale.getPointPosition(
                i,
                scale.drawingArea + padding[i],
                additionalAngle
            );
            const plFont = toFont(opts.font);
            const textSize = measureLabelSize(
                scale.ctx,
                plFont,
                scale._pointLabels[i]
            );
            labelSizes[i] = textSize;
            const angleRadians = _normalizeAngle(
                scale.getIndexAngle(i) + additionalAngle
            );
            const angle = Math.round(toDegrees(angleRadians));
            const hLimits = determineLimits(
                angle,
                pointPosition.x,
                textSize.w,
                0,
                180
            );
            const vLimits = determineLimits(
                angle,
                pointPosition.y,
                textSize.h,
                90,
                270
            );
            updateLimits(limits, orig, angleRadians, hLimits, vLimits);
        }
        scale.setCenterPoint(
            orig.l - limits.l,
            limits.r - orig.r,
            orig.t - limits.t,
            limits.b - orig.b
        );
        scale._pointLabelItems = buildPointLabelItems(
            scale,
            labelSizes,
            padding
        );
    }
    function updateLimits(limits, orig, angle, hLimits, vLimits) {
        const sin = Math.abs(Math.sin(angle));
        const cos = Math.abs(Math.cos(angle));
        let x = 0;
        let y = 0;
        if (hLimits.start < orig.l) {
            x = (orig.l - hLimits.start) / sin;
            limits.l = Math.min(limits.l, orig.l - x);
        } else if (hLimits.end > orig.r) {
            x = (hLimits.end - orig.r) / sin;
            limits.r = Math.max(limits.r, orig.r + x);
        }
        if (vLimits.start < orig.t) {
            y = (orig.t - vLimits.start) / cos;
            limits.t = Math.min(limits.t, orig.t - y);
        } else if (vLimits.end > orig.b) {
            y = (vLimits.end - orig.b) / cos;
            limits.b = Math.max(limits.b, orig.b + y);
        }
    }
    function buildPointLabelItems(scale, labelSizes, padding) {
        const items = [];
        const valueCount = scale._pointLabels.length;
        const opts = scale.options;
        const extra = getTickBackdropHeight(opts) / 2;
        const outerDistance = scale.drawingArea;
        const additionalAngle = opts.pointLabels.centerPointLabels
            ? PI / valueCount
            : 0;
        for (let i = 0; i < valueCount; i++) {
            const pointLabelPosition = scale.getPointPosition(
                i,
                outerDistance + extra + padding[i],
                additionalAngle
            );
            const angle = Math.round(
                toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI))
            );
            const size = labelSizes[i];
            const y = yForAngle(pointLabelPosition.y, size.h, angle);
            const textAlign = getTextAlignForAngle(angle);
            const left = leftForTextAlign(
                pointLabelPosition.x,
                size.w,
                textAlign
            );
            items.push({
                x: pointLabelPosition.x,
                y,
                textAlign,
                left,
                top: y,
                right: left + size.w,
                bottom: y + size.h,
            });
        }
        return items;
    }
    function getTextAlignForAngle(angle) {
        if (angle === 0 || angle === 180) {
            return 'center';
        } else if (angle < 180) {
            return 'left';
        }
        return 'right';
    }
    function leftForTextAlign(x, w, align) {
        if (align === 'right') {
            x -= w;
        } else if (align === 'center') {
            x -= w / 2;
        }
        return x;
    }
    function yForAngle(y, h, angle) {
        if (angle === 90 || angle === 270) {
            y -= h / 2;
        } else if (angle > 270 || angle < 90) {
            y -= h;
        }
        return y;
    }
    function drawPointLabels(scale, labelCount) {
        const {
            ctx,
            options: { pointLabels },
        } = scale;
        for (let i = labelCount - 1; i >= 0; i--) {
            const optsAtIndex = pointLabels.setContext(
                scale.getPointLabelContext(i)
            );
            const plFont = toFont(optsAtIndex.font);
            const { x, y, textAlign, left, top, right, bottom } =
                scale._pointLabelItems[i];
            const { backdropColor } = optsAtIndex;
            if (!isNullOrUndef(backdropColor)) {
                const borderRadius = toTRBLCorners(optsAtIndex.borderRadius);
                const padding = toPadding(optsAtIndex.backdropPadding);
                ctx.fillStyle = backdropColor;
                const backdropLeft = left - padding.left;
                const backdropTop = top - padding.top;
                const backdropWidth = right - left + padding.width;
                const backdropHeight = bottom - top + padding.height;
                if (Object.values(borderRadius).some((v) => v !== 0)) {
                    ctx.beginPath();
                    addRoundedRectPath(ctx, {
                        x: backdropLeft,
                        y: backdropTop,
                        w: backdropWidth,
                        h: backdropHeight,
                        radius: borderRadius,
                    });
                    ctx.fill();
                } else {
                    ctx.fillRect(
                        backdropLeft,
                        backdropTop,
                        backdropWidth,
                        backdropHeight
                    );
                }
            }
            renderText(
                ctx,
                scale._pointLabels[i],
                x,
                y + plFont.lineHeight / 2,
                plFont,
                {
                    color: optsAtIndex.color,
                    textAlign,
                    textBaseline: 'middle',
                }
            );
        }
    }
    function pathRadiusLine(scale, radius3, circular, labelCount) {
        const { ctx } = scale;
        if (circular) {
            ctx.arc(scale.xCenter, scale.yCenter, radius3, 0, TAU);
        } else {
            let pointPosition = scale.getPointPosition(0, radius3);
            ctx.moveTo(pointPosition.x, pointPosition.y);
            for (let i = 1; i < labelCount; i++) {
                pointPosition = scale.getPointPosition(i, radius3);
                ctx.lineTo(pointPosition.x, pointPosition.y);
            }
        }
    }
    function drawRadiusLine(scale, gridLineOpts, radius3, labelCount) {
        const ctx = scale.ctx;
        const circular = gridLineOpts.circular;
        const { color: color3, lineWidth } = gridLineOpts;
        if (
            (!circular && !labelCount) ||
            !color3 ||
            !lineWidth ||
            radius3 < 0
        ) {
            return;
        }
        ctx.save();
        ctx.strokeStyle = color3;
        ctx.lineWidth = lineWidth;
        ctx.setLineDash(gridLineOpts.borderDash);
        ctx.lineDashOffset = gridLineOpts.borderDashOffset;
        ctx.beginPath();
        pathRadiusLine(scale, radius3, circular, labelCount);
        ctx.closePath();
        ctx.stroke();
        ctx.restore();
    }
    function createPointLabelContext(parent, index3, label) {
        return createContext(parent, {
            label,
            index: index3,
            type: 'pointLabel',
        });
    }
    var RadialLinearScale = class extends LinearScaleBase {
        constructor(cfg) {
            super(cfg);
            this.xCenter = void 0;
            this.yCenter = void 0;
            this.drawingArea = void 0;
            this._pointLabels = [];
            this._pointLabelItems = [];
        }
        setDimensions() {
            const padding = (this._padding = toPadding(
                getTickBackdropHeight(this.options) / 2
            ));
            const w = (this.width = this.maxWidth - padding.width);
            const h = (this.height = this.maxHeight - padding.height);
            this.xCenter = Math.floor(this.left + w / 2 + padding.left);
            this.yCenter = Math.floor(this.top + h / 2 + padding.top);
            this.drawingArea = Math.floor(Math.min(w, h) / 2);
        }
        determineDataLimits() {
            const { min: min3, max: max3 } = this.getMinMax(false);
            this.min = isNumberFinite(min3) && !isNaN(min3) ? min3 : 0;
            this.max = isNumberFinite(max3) && !isNaN(max3) ? max3 : 0;
            this.handleTickRangeOptions();
        }
        computeTickLimit() {
            return Math.ceil(
                this.drawingArea / getTickBackdropHeight(this.options)
            );
        }
        generateTickLabels(ticks) {
            LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
            this._pointLabels = this.getLabels()
                .map((value, index3) => {
                    const label = callback(
                        this.options.pointLabels.callback,
                        [value, index3],
                        this
                    );
                    return label || label === 0 ? label : '';
                })
                .filter((v, i) => this.chart.getDataVisibility(i));
        }
        fit() {
            const opts = this.options;
            if (opts.display && opts.pointLabels.display) {
                fitWithPointLabels(this);
            } else {
                this.setCenterPoint(0, 0, 0, 0);
            }
        }
        setCenterPoint(
            leftMovement,
            rightMovement,
            topMovement,
            bottomMovement
        ) {
            this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
            this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
            this.drawingArea -= Math.min(
                this.drawingArea / 2,
                Math.max(
                    leftMovement,
                    rightMovement,
                    topMovement,
                    bottomMovement
                )
            );
        }
        getIndexAngle(index3) {
            const angleMultiplier = TAU / (this._pointLabels.length || 1);
            const startAngle = this.options.startAngle || 0;
            return _normalizeAngle(
                index3 * angleMultiplier + toRadians(startAngle)
            );
        }
        getDistanceFromCenterForValue(value) {
            if (isNullOrUndef(value)) {
                return NaN;
            }
            const scalingFactor = this.drawingArea / (this.max - this.min);
            if (this.options.reverse) {
                return (this.max - value) * scalingFactor;
            }
            return (value - this.min) * scalingFactor;
        }
        getValueForDistanceFromCenter(distance) {
            if (isNullOrUndef(distance)) {
                return NaN;
            }
            const scaledDistance =
                distance / (this.drawingArea / (this.max - this.min));
            return this.options.reverse
                ? this.max - scaledDistance
                : this.min + scaledDistance;
        }
        getPointLabelContext(index3) {
            const pointLabels = this._pointLabels || [];
            if (index3 >= 0 && index3 < pointLabels.length) {
                const pointLabel = pointLabels[index3];
                return createPointLabelContext(
                    this.getContext(),
                    index3,
                    pointLabel
                );
            }
        }
        getPointPosition(index3, distanceFromCenter, additionalAngle = 0) {
            const angle =
                this.getIndexAngle(index3) - HALF_PI + additionalAngle;
            return {
                x: Math.cos(angle) * distanceFromCenter + this.xCenter,
                y: Math.sin(angle) * distanceFromCenter + this.yCenter,
                angle,
            };
        }
        getPointPositionForValue(index3, value) {
            return this.getPointPosition(
                index3,
                this.getDistanceFromCenterForValue(value)
            );
        }
        getBasePosition(index3) {
            return this.getPointPositionForValue(
                index3 || 0,
                this.getBaseValue()
            );
        }
        getPointLabelPosition(index3) {
            const { left, top, right, bottom } = this._pointLabelItems[index3];
            return {
                left,
                top,
                right,
                bottom,
            };
        }
        drawBackground() {
            const {
                backgroundColor: backgroundColor4,
                grid: { circular },
            } = this.options;
            if (backgroundColor4) {
                const ctx = this.ctx;
                ctx.save();
                ctx.beginPath();
                pathRadiusLine(
                    this,
                    this.getDistanceFromCenterForValue(this._endValue),
                    circular,
                    this._pointLabels.length
                );
                ctx.closePath();
                ctx.fillStyle = backgroundColor4;
                ctx.fill();
                ctx.restore();
            }
        }
        drawGrid() {
            const ctx = this.ctx;
            const opts = this.options;
            const { angleLines, grid } = opts;
            const labelCount = this._pointLabels.length;
            let i, offset, position;
            if (opts.pointLabels.display) {
                drawPointLabels(this, labelCount);
            }
            if (grid.display) {
                this.ticks.forEach((tick, index3) => {
                    if (index3 !== 0) {
                        offset = this.getDistanceFromCenterForValue(tick.value);
                        const optsAtIndex = grid.setContext(
                            this.getContext(index3 - 1)
                        );
                        drawRadiusLine(this, optsAtIndex, offset, labelCount);
                    }
                });
            }
            if (angleLines.display) {
                ctx.save();
                for (i = labelCount - 1; i >= 0; i--) {
                    const optsAtIndex = angleLines.setContext(
                        this.getPointLabelContext(i)
                    );
                    const { color: color3, lineWidth } = optsAtIndex;
                    if (!lineWidth || !color3) {
                        continue;
                    }
                    ctx.lineWidth = lineWidth;
                    ctx.strokeStyle = color3;
                    ctx.setLineDash(optsAtIndex.borderDash);
                    ctx.lineDashOffset = optsAtIndex.borderDashOffset;
                    offset = this.getDistanceFromCenterForValue(
                        opts.ticks.reverse ? this.min : this.max
                    );
                    position = this.getPointPosition(i, offset);
                    ctx.beginPath();
                    ctx.moveTo(this.xCenter, this.yCenter);
                    ctx.lineTo(position.x, position.y);
                    ctx.stroke();
                }
                ctx.restore();
            }
        }
        drawBorder() {}
        drawLabels() {
            const ctx = this.ctx;
            const opts = this.options;
            const tickOpts = opts.ticks;
            if (!tickOpts.display) {
                return;
            }
            const startAngle = this.getIndexAngle(0);
            let offset, width;
            ctx.save();
            ctx.translate(this.xCenter, this.yCenter);
            ctx.rotate(startAngle);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            this.ticks.forEach((tick, index3) => {
                if (index3 === 0 && !opts.reverse) {
                    return;
                }
                const optsAtIndex = tickOpts.setContext(
                    this.getContext(index3)
                );
                const tickFont = toFont(optsAtIndex.font);
                offset = this.getDistanceFromCenterForValue(
                    this.ticks[index3].value
                );
                if (optsAtIndex.showLabelBackdrop) {
                    ctx.font = tickFont.string;
                    width = ctx.measureText(tick.label).width;
                    ctx.fillStyle = optsAtIndex.backdropColor;
                    const padding = toPadding(optsAtIndex.backdropPadding);
                    ctx.fillRect(
                        -width / 2 - padding.left,
                        -offset - tickFont.size / 2 - padding.top,
                        width + padding.width,
                        tickFont.size + padding.height
                    );
                }
                renderText(ctx, tick.label, 0, -offset, tickFont, {
                    color: optsAtIndex.color,
                });
            });
            ctx.restore();
        }
        drawTitle() {}
    };
    RadialLinearScale.id = 'radialLinear';
    RadialLinearScale.defaults = {
        display: true,
        animate: true,
        position: 'chartArea',
        angleLines: {
            display: true,
            lineWidth: 1,
            borderDash: [],
            borderDashOffset: 0,
        },
        grid: {
            circular: false,
        },
        startAngle: 0,
        ticks: {
            showLabelBackdrop: true,
            callback: Ticks.formatters.numeric,
        },
        pointLabels: {
            backdropColor: void 0,
            backdropPadding: 2,
            display: true,
            font: {
                size: 10,
            },
            callback(label) {
                return label;
            },
            padding: 5,
            centerPointLabels: false,
        },
    };
    RadialLinearScale.defaultRoutes = {
        'angleLines.color': 'borderColor',
        'pointLabels.color': 'color',
        'ticks.color': 'color',
    };
    RadialLinearScale.descriptors = {
        angleLines: {
            _fallback: 'grid',
        },
    };
    var INTERVALS = {
        millisecond: { common: true, size: 1, steps: 1e3 },
        second: { common: true, size: 1e3, steps: 60 },
        minute: { common: true, size: 6e4, steps: 60 },
        hour: { common: true, size: 36e5, steps: 24 },
        day: { common: true, size: 864e5, steps: 30 },
        week: { common: false, size: 6048e5, steps: 4 },
        month: { common: true, size: 2628e6, steps: 12 },
        quarter: { common: false, size: 7884e6, steps: 4 },
        year: { common: true, size: 3154e7 },
    };
    var UNITS = Object.keys(INTERVALS);
    function sorter(a, b) {
        return a - b;
    }
    function parse(scale, input) {
        if (isNullOrUndef(input)) {
            return null;
        }
        const adapter = scale._adapter;
        const { parser, round: round2, isoWeekday } = scale._parseOpts;
        let value = input;
        if (typeof parser === 'function') {
            value = parser(value);
        }
        if (!isNumberFinite(value)) {
            value =
                typeof parser === 'string'
                    ? adapter.parse(value, parser)
                    : adapter.parse(value);
        }
        if (value === null) {
            return null;
        }
        if (round2) {
            value =
                round2 === 'week' &&
                (isNumber(isoWeekday) || isoWeekday === true)
                    ? adapter.startOf(value, 'isoWeek', isoWeekday)
                    : adapter.startOf(value, round2);
        }
        return +value;
    }
    function determineUnitForAutoTicks(minUnit, min3, max3, capacity) {
        const ilen = UNITS.length;
        for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
            const interval2 = INTERVALS[UNITS[i]];
            const factor = interval2.steps
                ? interval2.steps
                : Number.MAX_SAFE_INTEGER;
            if (
                interval2.common &&
                Math.ceil((max3 - min3) / (factor * interval2.size)) <= capacity
            ) {
                return UNITS[i];
            }
        }
        return UNITS[ilen - 1];
    }
    function determineUnitForFormatting(scale, numTicks, minUnit, min3, max3) {
        for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
            const unit = UNITS[i];
            if (
                INTERVALS[unit].common &&
                scale._adapter.diff(max3, min3, unit) >= numTicks - 1
            ) {
                return unit;
            }
        }
        return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
    }
    function determineMajorUnit(unit) {
        for (
            let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length;
            i < ilen;
            ++i
        ) {
            if (INTERVALS[UNITS[i]].common) {
                return UNITS[i];
            }
        }
    }
    function addTick(ticks, time, timestamps) {
        if (!timestamps) {
            ticks[time] = true;
        } else if (timestamps.length) {
            const { lo, hi } = _lookup(timestamps, time);
            const timestamp =
                timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
            ticks[timestamp] = true;
        }
    }
    function setMajorTicks(scale, ticks, map4, majorUnit) {
        const adapter = scale._adapter;
        const first = +adapter.startOf(ticks[0].value, majorUnit);
        const last = ticks[ticks.length - 1].value;
        let major, index3;
        for (
            major = first;
            major <= last;
            major = +adapter.add(major, 1, majorUnit)
        ) {
            index3 = map4[major];
            if (index3 >= 0) {
                ticks[index3].major = true;
            }
        }
        return ticks;
    }
    function ticksFromTimestamps(scale, values, majorUnit) {
        const ticks = [];
        const map4 = {};
        const ilen = values.length;
        let i, value;
        for (i = 0; i < ilen; ++i) {
            value = values[i];
            map4[value] = i;
            ticks.push({
                value,
                major: false,
            });
        }
        return ilen === 0 || !majorUnit
            ? ticks
            : setMajorTicks(scale, ticks, map4, majorUnit);
    }
    var TimeScale = class extends Scale {
        constructor(props) {
            super(props);
            this._cache = {
                data: [],
                labels: [],
                all: [],
            };
            this._unit = 'day';
            this._majorUnit = void 0;
            this._offsets = {};
            this._normalized = false;
            this._parseOpts = void 0;
        }
        init(scaleOpts, opts) {
            const time = scaleOpts.time || (scaleOpts.time = {});
            const adapter = (this._adapter = new adapters._date(
                scaleOpts.adapters.date
            ));
            adapter.init(opts);
            mergeIf(time.displayFormats, adapter.formats());
            this._parseOpts = {
                parser: time.parser,
                round: time.round,
                isoWeekday: time.isoWeekday,
            };
            super.init(scaleOpts);
            this._normalized = opts.normalized;
        }
        parse(raw, index3) {
            if (raw === void 0) {
                return null;
            }
            return parse(this, raw);
        }
        beforeLayout() {
            super.beforeLayout();
            this._cache = {
                data: [],
                labels: [],
                all: [],
            };
        }
        determineDataLimits() {
            const options = this.options;
            const adapter = this._adapter;
            const unit = options.time.unit || 'day';
            let {
                min: min3,
                max: max3,
                minDefined,
                maxDefined,
            } = this.getUserBounds();
            function _applyBounds(bounds) {
                if (!minDefined && !isNaN(bounds.min)) {
                    min3 = Math.min(min3, bounds.min);
                }
                if (!maxDefined && !isNaN(bounds.max)) {
                    max3 = Math.max(max3, bounds.max);
                }
            }
            if (!minDefined || !maxDefined) {
                _applyBounds(this._getLabelBounds());
                if (
                    options.bounds !== 'ticks' ||
                    options.ticks.source !== 'labels'
                ) {
                    _applyBounds(this.getMinMax(false));
                }
            }
            min3 =
                isNumberFinite(min3) && !isNaN(min3)
                    ? min3
                    : +adapter.startOf(Date.now(), unit);
            max3 =
                isNumberFinite(max3) && !isNaN(max3)
                    ? max3
                    : +adapter.endOf(Date.now(), unit) + 1;
            this.min = Math.min(min3, max3 - 1);
            this.max = Math.max(min3 + 1, max3);
        }
        _getLabelBounds() {
            const arr = this.getLabelTimestamps();
            let min3 = Number.POSITIVE_INFINITY;
            let max3 = Number.NEGATIVE_INFINITY;
            if (arr.length) {
                min3 = arr[0];
                max3 = arr[arr.length - 1];
            }
            return { min: min3, max: max3 };
        }
        buildTicks() {
            const options = this.options;
            const timeOpts = options.time;
            const tickOpts = options.ticks;
            const timestamps =
                tickOpts.source === 'labels'
                    ? this.getLabelTimestamps()
                    : this._generate();
            if (options.bounds === 'ticks' && timestamps.length) {
                this.min = this._userMin || timestamps[0];
                this.max = this._userMax || timestamps[timestamps.length - 1];
            }
            const min3 = this.min;
            const max3 = this.max;
            const ticks = _filterBetween(timestamps, min3, max3);
            this._unit =
                timeOpts.unit ||
                (tickOpts.autoSkip
                    ? determineUnitForAutoTicks(
                          timeOpts.minUnit,
                          this.min,
                          this.max,
                          this._getLabelCapacity(min3)
                      )
                    : determineUnitForFormatting(
                          this,
                          ticks.length,
                          timeOpts.minUnit,
                          this.min,
                          this.max
                      ));
            this._majorUnit =
                !tickOpts.major.enabled || this._unit === 'year'
                    ? void 0
                    : determineMajorUnit(this._unit);
            this.initOffsets(timestamps);
            if (options.reverse) {
                ticks.reverse();
            }
            return ticksFromTimestamps(this, ticks, this._majorUnit);
        }
        afterAutoSkip() {
            if (this.options.offsetAfterAutoskip) {
                this.initOffsets(this.ticks.map((tick) => +tick.value));
            }
        }
        initOffsets(timestamps) {
            let start2 = 0;
            let end = 0;
            let first, last;
            if (this.options.offset && timestamps.length) {
                first = this.getDecimalForValue(timestamps[0]);
                if (timestamps.length === 1) {
                    start2 = 1 - first;
                } else {
                    start2 =
                        (this.getDecimalForValue(timestamps[1]) - first) / 2;
                }
                last = this.getDecimalForValue(
                    timestamps[timestamps.length - 1]
                );
                if (timestamps.length === 1) {
                    end = last;
                } else {
                    end =
                        (last -
                            this.getDecimalForValue(
                                timestamps[timestamps.length - 2]
                            )) /
                        2;
                }
            }
            const limit = timestamps.length < 3 ? 0.5 : 0.25;
            start2 = _limitValue(start2, 0, limit);
            end = _limitValue(end, 0, limit);
            this._offsets = {
                start: start2,
                end,
                factor: 1 / (start2 + 1 + end),
            };
        }
        _generate() {
            const adapter = this._adapter;
            const min3 = this.min;
            const max3 = this.max;
            const options = this.options;
            const timeOpts = options.time;
            const minor =
                timeOpts.unit ||
                determineUnitForAutoTicks(
                    timeOpts.minUnit,
                    min3,
                    max3,
                    this._getLabelCapacity(min3)
                );
            const stepSize = valueOrDefault(timeOpts.stepSize, 1);
            const weekday = minor === 'week' ? timeOpts.isoWeekday : false;
            const hasWeekday = isNumber(weekday) || weekday === true;
            const ticks = {};
            let first = min3;
            let time, count;
            if (hasWeekday) {
                first = +adapter.startOf(first, 'isoWeek', weekday);
            }
            first = +adapter.startOf(first, hasWeekday ? 'day' : minor);
            if (adapter.diff(max3, min3, minor) > 1e5 * stepSize) {
                throw new Error(
                    min3 +
                        ' and ' +
                        max3 +
                        ' are too far apart with stepSize of ' +
                        stepSize +
                        ' ' +
                        minor
                );
            }
            const timestamps =
                options.ticks.source === 'data' && this.getDataTimestamps();
            for (
                time = first, count = 0;
                time < max3;
                time = +adapter.add(time, stepSize, minor), count++
            ) {
                addTick(ticks, time, timestamps);
            }
            if (time === max3 || options.bounds === 'ticks' || count === 1) {
                addTick(ticks, time, timestamps);
            }
            return Object.keys(ticks)
                .sort((a, b) => a - b)
                .map((x) => +x);
        }
        getLabelForValue(value) {
            const adapter = this._adapter;
            const timeOpts = this.options.time;
            if (timeOpts.tooltipFormat) {
                return adapter.format(value, timeOpts.tooltipFormat);
            }
            return adapter.format(value, timeOpts.displayFormats.datetime);
        }
        _tickFormatFunction(time, index3, ticks, format2) {
            const options = this.options;
            const formats = options.time.displayFormats;
            const unit = this._unit;
            const majorUnit = this._majorUnit;
            const minorFormat = unit && formats[unit];
            const majorFormat = majorUnit && formats[majorUnit];
            const tick = ticks[index3];
            const major = majorUnit && majorFormat && tick && tick.major;
            const label = this._adapter.format(
                time,
                format2 || (major ? majorFormat : minorFormat)
            );
            const formatter2 = options.ticks.callback;
            return formatter2
                ? callback(formatter2, [label, index3, ticks], this)
                : label;
        }
        generateTickLabels(ticks) {
            let i, ilen, tick;
            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
                tick = ticks[i];
                tick.label = this._tickFormatFunction(tick.value, i, ticks);
            }
        }
        getDecimalForValue(value) {
            return value === null
                ? NaN
                : (value - this.min) / (this.max - this.min);
        }
        getPixelForValue(value) {
            const offsets = this._offsets;
            const pos = this.getDecimalForValue(value);
            return this.getPixelForDecimal(
                (offsets.start + pos) * offsets.factor
            );
        }
        getValueForPixel(pixel) {
            const offsets = this._offsets;
            const pos =
                this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
            return this.min + pos * (this.max - this.min);
        }
        _getLabelSize(label) {
            const ticksOpts = this.options.ticks;
            const tickLabelWidth = this.ctx.measureText(label).width;
            const angle = toRadians(
                this.isHorizontal()
                    ? ticksOpts.maxRotation
                    : ticksOpts.minRotation
            );
            const cosRotation = Math.cos(angle);
            const sinRotation = Math.sin(angle);
            const tickFontSize = this._resolveTickFontOptions(0).size;
            return {
                w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
                h: tickLabelWidth * sinRotation + tickFontSize * cosRotation,
            };
        }
        _getLabelCapacity(exampleTime) {
            const timeOpts = this.options.time;
            const displayFormats = timeOpts.displayFormats;
            const format2 =
                displayFormats[timeOpts.unit] || displayFormats.millisecond;
            const exampleLabel = this._tickFormatFunction(
                exampleTime,
                0,
                ticksFromTimestamps(this, [exampleTime], this._majorUnit),
                format2
            );
            const size = this._getLabelSize(exampleLabel);
            const capacity =
                Math.floor(
                    this.isHorizontal()
                        ? this.width / size.w
                        : this.height / size.h
                ) - 1;
            return capacity > 0 ? capacity : 1;
        }
        getDataTimestamps() {
            let timestamps = this._cache.data || [];
            let i, ilen;
            if (timestamps.length) {
                return timestamps;
            }
            const metas = this.getMatchingVisibleMetas();
            if (this._normalized && metas.length) {
                return (this._cache.data =
                    metas[0].controller.getAllParsedValues(this));
            }
            for (i = 0, ilen = metas.length; i < ilen; ++i) {
                timestamps = timestamps.concat(
                    metas[i].controller.getAllParsedValues(this)
                );
            }
            return (this._cache.data = this.normalize(timestamps));
        }
        getLabelTimestamps() {
            const timestamps = this._cache.labels || [];
            let i, ilen;
            if (timestamps.length) {
                return timestamps;
            }
            const labels = this.getLabels();
            for (i = 0, ilen = labels.length; i < ilen; ++i) {
                timestamps.push(parse(this, labels[i]));
            }
            return (this._cache.labels = this._normalized
                ? timestamps
                : this.normalize(timestamps));
        }
        normalize(values) {
            return _arrayUnique(values.sort(sorter));
        }
    };
    TimeScale.id = 'time';
    TimeScale.defaults = {
        bounds: 'data',
        adapters: {},
        time: {
            parser: false,
            unit: false,
            round: false,
            isoWeekday: false,
            minUnit: 'millisecond',
            displayFormats: {},
        },
        ticks: {
            source: 'auto',
            major: {
                enabled: false,
            },
        },
    };
    function interpolate2(table, val, reverse) {
        let lo = 0;
        let hi = table.length - 1;
        let prevSource, nextSource, prevTarget, nextTarget;
        if (reverse) {
            if (val >= table[lo].pos && val <= table[hi].pos) {
                ({ lo, hi } = _lookupByKey(table, 'pos', val));
            }
            ({ pos: prevSource, time: prevTarget } = table[lo]);
            ({ pos: nextSource, time: nextTarget } = table[hi]);
        } else {
            if (val >= table[lo].time && val <= table[hi].time) {
                ({ lo, hi } = _lookupByKey(table, 'time', val));
            }
            ({ time: prevSource, pos: prevTarget } = table[lo]);
            ({ time: nextSource, pos: nextTarget } = table[hi]);
        }
        const span = nextSource - prevSource;
        return span
            ? prevTarget +
                  ((nextTarget - prevTarget) * (val - prevSource)) / span
            : prevTarget;
    }
    var TimeSeriesScale = class extends TimeScale {
        constructor(props) {
            super(props);
            this._table = [];
            this._minPos = void 0;
            this._tableRange = void 0;
        }
        initOffsets() {
            const timestamps = this._getTimestampsForTable();
            const table = (this._table = this.buildLookupTable(timestamps));
            this._minPos = interpolate2(table, this.min);
            this._tableRange = interpolate2(table, this.max) - this._minPos;
            super.initOffsets(timestamps);
        }
        buildLookupTable(timestamps) {
            const { min: min3, max: max3 } = this;
            const items = [];
            const table = [];
            let i, ilen, prev, curr, next;
            for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
                curr = timestamps[i];
                if (curr >= min3 && curr <= max3) {
                    items.push(curr);
                }
            }
            if (items.length < 2) {
                return [
                    { time: min3, pos: 0 },
                    { time: max3, pos: 1 },
                ];
            }
            for (i = 0, ilen = items.length; i < ilen; ++i) {
                next = items[i + 1];
                prev = items[i - 1];
                curr = items[i];
                if (Math.round((next + prev) / 2) !== curr) {
                    table.push({ time: curr, pos: i / (ilen - 1) });
                }
            }
            return table;
        }
        _getTimestampsForTable() {
            let timestamps = this._cache.all || [];
            if (timestamps.length) {
                return timestamps;
            }
            const data = this.getDataTimestamps();
            const label = this.getLabelTimestamps();
            if (data.length && label.length) {
                timestamps = this.normalize(data.concat(label));
            } else {
                timestamps = data.length ? data : label;
            }
            timestamps = this._cache.all = timestamps;
            return timestamps;
        }
        getDecimalForValue(value) {
            return (
                (interpolate2(this._table, value) - this._minPos) /
                this._tableRange
            );
        }
        getValueForPixel(pixel) {
            const offsets = this._offsets;
            const decimal =
                this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
            return interpolate2(
                this._table,
                decimal * this._tableRange + this._minPos,
                true
            );
        }
    };
    TimeSeriesScale.id = 'timeseries';
    TimeSeriesScale.defaults = TimeScale.defaults;
    var scales = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        CategoryScale,
        LinearScale,
        LogarithmicScale,
        RadialLinearScale,
        TimeScale,
        TimeSeriesScale,
    });
    var registerables = [controllers, elements, plugins, scales];

    // node_modules/chartjs-plugin-annotation/dist/chartjs-plugin-annotation.esm.js
    var interaction = {
        modes: {
            /**
             * Point mode returns all elements that hit test based on the event position
             * @param {Object} state - the state of the plugin
             * @param {ChartEvent} event - the event we are find things at
             * @return {AnnotationElement[]} - elements that are found
             */
            point(state, event) {
                return filterElements(state, event, { intersect: true });
            },
            /**
             * Nearest mode returns the element closest to the event position
             * @param {Object} state - the state of the plugin
             * @param {ChartEvent} event - the event we are find things at
             * @param {Object} options - interaction options to use
             * @return {AnnotationElement[]} - elements that are found (only 1 element)
             */
            nearest(state, event, options) {
                return getNearestItem(state, event, options);
            },
            /**
             * x mode returns the elements that hit-test at the current x coordinate
             * @param {Object} state - the state of the plugin
             * @param {ChartEvent} event - the event we are find things at
             * @param {Object} options - interaction options to use
             * @return {AnnotationElement[]} - elements that are found
             */
            x(state, event, options) {
                return filterElements(state, event, {
                    intersect: options.intersect,
                    axis: 'x',
                });
            },
            /**
             * y mode returns the elements that hit-test at the current y coordinate
             * @param {Object} state - the state of the plugin
             * @param {ChartEvent} event - the event we are find things at
             * @param {Object} options - interaction options to use
             * @return {AnnotationElement[]} - elements that are found
             */
            y(state, event, options) {
                return filterElements(state, event, {
                    intersect: options.intersect,
                    axis: 'y',
                });
            },
        },
    };
    function getElements(state, event, options) {
        const mode =
            interaction.modes[options.mode] || interaction.modes.nearest;
        return mode(state, event, options);
    }
    function inRangeByAxis(element, event, axis) {
        if (axis !== 'x' && axis !== 'y') {
            return (
                element.inRange(event.x, event.y, 'x', true) ||
                element.inRange(event.x, event.y, 'y', true)
            );
        }
        return element.inRange(event.x, event.y, axis, true);
    }
    function getPointByAxis(event, center, axis) {
        if (axis === 'x') {
            return { x: event.x, y: center.y };
        } else if (axis === 'y') {
            return { x: center.x, y: event.y };
        }
        return center;
    }
    function filterElements(state, event, options) {
        return state.visibleElements.filter((element) =>
            options.intersect
                ? element.inRange(event.x, event.y)
                : inRangeByAxis(element, event, options.axis)
        );
    }
    function getNearestItem(state, event, options) {
        let minDistance = Number.POSITIVE_INFINITY;
        return filterElements(state, event, options)
            .reduce((nearestItems, element) => {
                const center = element.getCenterPoint();
                const evenPoint = getPointByAxis(event, center, options.axis);
                const distance = distanceBetweenPoints(event, evenPoint);
                if (distance < minDistance) {
                    nearestItems = [element];
                    minDistance = distance;
                } else if (distance === minDistance) {
                    nearestItems.push(element);
                }
                return nearestItems;
            }, [])
            .sort((a, b) => a._index - b._index)
            .slice(0, 1);
    }
    var moveHooks = ['enter', 'leave'];
    var hooks = moveHooks.concat('click');
    function updateListeners(chart, state, options) {
        state.listened = false;
        state.moveListened = false;
        state._getElements = getElements;
        hooks.forEach((hook) => {
            if (typeof options[hook] === 'function') {
                state.listened = true;
                state.listeners[hook] = options[hook];
            } else if (defined(state.listeners[hook])) {
                delete state.listeners[hook];
            }
        });
        moveHooks.forEach((hook) => {
            if (typeof options[hook] === 'function') {
                state.moveListened = true;
            }
        });
        if (!state.listened || !state.moveListened) {
            state.annotations.forEach((scope) => {
                if (!state.listened && typeof scope.click === 'function') {
                    state.listened = true;
                }
                if (!state.moveListened) {
                    moveHooks.forEach((hook) => {
                        if (typeof scope[hook] === 'function') {
                            state.listened = true;
                            state.moveListened = true;
                        }
                    });
                }
            });
        }
    }
    function handleEvent(state, event, options) {
        if (state.listened) {
            switch (event.type) {
                case 'mousemove':
                case 'mouseout':
                    return handleMoveEvents(state, event, options);
                case 'click':
                    return handleClickEvents(state, event, options);
            }
        }
    }
    function handleMoveEvents(state, event, options) {
        if (!state.moveListened) {
            return;
        }
        let elements2;
        if (event.type === 'mousemove') {
            elements2 = getElements(state, event, options.interaction);
        } else {
            elements2 = [];
        }
        const previous = state.hovered;
        state.hovered = elements2;
        const context = { state, event };
        let changed = dispatchMoveEvents(context, 'leave', previous, elements2);
        return (
            dispatchMoveEvents(context, 'enter', elements2, previous) || changed
        );
    }
    function dispatchMoveEvents(
        { state, event },
        hook,
        elements2,
        checkElements
    ) {
        let changed;
        for (const element of elements2) {
            if (checkElements.indexOf(element) < 0) {
                changed =
                    dispatchEvent(
                        element.options[hook] || state.listeners[hook],
                        element,
                        event
                    ) || changed;
            }
        }
        return changed;
    }
    function handleClickEvents(state, event, options) {
        const listeners = state.listeners;
        const elements2 = getElements(state, event, options.interaction);
        let changed;
        for (const element of elements2) {
            changed =
                dispatchEvent(
                    element.options.click || listeners.click,
                    element,
                    event
                ) || changed;
        }
        return changed;
    }
    function dispatchEvent(handler, element, event) {
        return callback(handler, [element.$context, event]) === true;
    }
    var isOlderPart = (act, req) =>
        req > act ||
        (act.length > req.length && act.slice(0, req.length) === req);
    var EPSILON2 = 1e-3;
    var clamp = (x, from2, to2) => Math.min(to2, Math.max(from2, x));
    function clampAll(obj, from2, to2) {
        for (const key of Object.keys(obj)) {
            obj[key] = clamp(obj[key], from2, to2);
        }
        return obj;
    }
    function inPointRange(point, center, radius3, borderWidth3) {
        if (!point || !center || radius3 <= 0) {
            return false;
        }
        const hBorderWidth = borderWidth3 / 2;
        return (
            Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2) <=
            Math.pow(radius3 + hBorderWidth, 2)
        );
    }
    function inBoxRange(point, { x, y, x2, y2 }, axis, borderWidth3) {
        const hBorderWidth = borderWidth3 / 2;
        const inRangeX =
            point.x >= x - hBorderWidth - EPSILON2 &&
            point.x <= x2 + hBorderWidth + EPSILON2;
        const inRangeY =
            point.y >= y - hBorderWidth - EPSILON2 &&
            point.y <= y2 + hBorderWidth + EPSILON2;
        if (axis === 'x') {
            return inRangeX;
        } else if (axis === 'y') {
            return inRangeY;
        }
        return inRangeX && inRangeY;
    }
    function getElementCenterPoint(element, useFinalPosition) {
        const { centerX, centerY } = element.getProps(
            ['centerX', 'centerY'],
            useFinalPosition
        );
        return { x: centerX, y: centerY };
    }
    function requireVersion(pkg, min3, ver, strict = true) {
        const parts = ver.split('.');
        let i = 0;
        for (const req of min3.split('.')) {
            const act = parts[i++];
            if (parseInt(req, 10) < parseInt(act, 10)) {
                break;
            }
            if (isOlderPart(act, req)) {
                if (strict) {
                    throw new Error(
                        `${pkg} v${ver} is not supported. v${min3} or newer is required.`
                    );
                } else {
                    return false;
                }
            }
        }
        return true;
    }
    var isPercentString = (s) => typeof s === 'string' && s.endsWith('%');
    var toPercent = (s) => clamp(parseFloat(s) / 100, 0, 1);
    function getRelativePosition2(size, position) {
        if (position === 'start') {
            return 0;
        }
        if (position === 'end') {
            return size;
        }
        if (isPercentString(position)) {
            return toPercent(position) * size;
        }
        return size / 2;
    }
    function getSize(size, value) {
        if (typeof value === 'number') {
            return value;
        } else if (isPercentString(value)) {
            return toPercent(value) * size;
        }
        return size;
    }
    function calculateTextAlignment(size, options) {
        const { x, width } = size;
        const textAlign = options.textAlign;
        if (textAlign === 'center') {
            return x + width / 2;
        } else if (textAlign === 'end' || textAlign === 'right') {
            return x + width;
        }
        return x;
    }
    function toPosition(value) {
        if (isObject(value)) {
            return {
                x: valueOrDefault(value.x, 'center'),
                y: valueOrDefault(value.y, 'center'),
            };
        }
        value = valueOrDefault(value, 'center');
        return {
            x: value,
            y: value,
        };
    }
    function isBoundToPoint(options) {
        return options && (defined(options.xValue) || defined(options.yValue));
    }
    var widthCache = /* @__PURE__ */ new Map();
    function isImageOrCanvas(content) {
        if (content && typeof content === 'object') {
            const type2 = content.toString();
            return (
                type2 === '[object HTMLImageElement]' ||
                type2 === '[object HTMLCanvasElement]'
            );
        }
    }
    function translate(ctx, { x, y }, rotation) {
        if (rotation) {
            ctx.translate(x, y);
            ctx.rotate(toRadians(rotation));
            ctx.translate(-x, -y);
        }
    }
    function setBorderStyle(ctx, options) {
        if (options && options.borderWidth) {
            ctx.lineCap = options.borderCapStyle;
            ctx.setLineDash(options.borderDash);
            ctx.lineDashOffset = options.borderDashOffset;
            ctx.lineJoin = options.borderJoinStyle;
            ctx.lineWidth = options.borderWidth;
            ctx.strokeStyle = options.borderColor;
            return true;
        }
    }
    function setShadowStyle(ctx, options) {
        ctx.shadowColor = options.backgroundShadowColor;
        ctx.shadowBlur = options.shadowBlur;
        ctx.shadowOffsetX = options.shadowOffsetX;
        ctx.shadowOffsetY = options.shadowOffsetY;
    }
    function measureLabelSize2(ctx, options) {
        const content = options.content;
        if (isImageOrCanvas(content)) {
            return {
                width: getSize(content.width, options.width),
                height: getSize(content.height, options.height),
            };
        }
        const font = toFont(options.font);
        const strokeWidth = options.textStrokeWidth;
        const lines = isArray(content) ? content : [content];
        const mapKey =
            lines.join() +
            font.string +
            strokeWidth +
            (ctx._measureText ? '-spriting' : '');
        if (!widthCache.has(mapKey)) {
            ctx.save();
            ctx.font = font.string;
            const count = lines.length;
            let width = 0;
            for (let i = 0; i < count; i++) {
                const text = lines[i];
                width = Math.max(
                    width,
                    ctx.measureText(text).width + strokeWidth
                );
            }
            ctx.restore();
            const height = count * font.lineHeight + strokeWidth;
            widthCache.set(mapKey, { width, height });
        }
        return widthCache.get(mapKey);
    }
    function drawBox(ctx, rect, options) {
        const { x, y, width, height } = rect;
        ctx.save();
        setShadowStyle(ctx, options);
        const stroke = setBorderStyle(ctx, options);
        ctx.fillStyle = options.backgroundColor;
        ctx.beginPath();
        addRoundedRectPath(ctx, {
            x,
            y,
            w: width,
            h: height,
            radius: clampAll(
                toTRBLCorners(options.borderRadius),
                0,
                Math.min(width, height) / 2
            ),
        });
        ctx.closePath();
        ctx.fill();
        if (stroke) {
            ctx.shadowColor = options.borderShadowColor;
            ctx.stroke();
        }
        ctx.restore();
    }
    function drawLabel(ctx, rect, options) {
        const content = options.content;
        if (isImageOrCanvas(content)) {
            ctx.drawImage(content, rect.x, rect.y, rect.width, rect.height);
            return;
        }
        const labels = isArray(content) ? content : [content];
        const font = toFont(options.font);
        const lh = font.lineHeight;
        const x = calculateTextAlignment(rect, options);
        const y = rect.y + lh / 2 + options.textStrokeWidth / 2;
        ctx.save();
        ctx.font = font.string;
        ctx.textBaseline = 'middle';
        ctx.textAlign = options.textAlign;
        if (setTextStrokeStyle(ctx, options)) {
            labels.forEach((l, i) => ctx.strokeText(l, x, y + i * lh));
        }
        ctx.fillStyle = options.color;
        labels.forEach((l, i) => ctx.fillText(l, x, y + i * lh));
        ctx.restore();
    }
    function setTextStrokeStyle(ctx, options) {
        if (options.textStrokeWidth > 0) {
            ctx.lineJoin = 'round';
            ctx.miterLimit = 2;
            ctx.lineWidth = options.textStrokeWidth;
            ctx.strokeStyle = options.textStrokeColor;
            return true;
        }
    }
    function scaleValue(scale, value, fallback) {
        value = typeof value === 'number' ? value : scale.parse(value);
        return isNumberFinite(value) ? scale.getPixelForValue(value) : fallback;
    }
    function retrieveScaleID(scales2, options, key) {
        const scaleID = options[key];
        if (scaleID || key === 'scaleID') {
            return scaleID;
        }
        const axis = key.charAt(0);
        const axes = Object.values(scales2).filter(
            (scale) => scale.axis && scale.axis === axis
        );
        if (axes.length) {
            return axes[0].id;
        }
        return axis;
    }
    function getDimensionByScale(scale, options) {
        if (scale) {
            const reverse = scale.options.reverse;
            const start2 = scaleValue(
                scale,
                options.min,
                reverse ? options.end : options.start
            );
            const end = scaleValue(
                scale,
                options.max,
                reverse ? options.start : options.end
            );
            return {
                start: start2,
                end,
            };
        }
    }
    function getChartPoint(chart, options) {
        const { chartArea, scales: scales2 } = chart;
        const xScale = scales2[retrieveScaleID(scales2, options, 'xScaleID')];
        const yScale = scales2[retrieveScaleID(scales2, options, 'yScaleID')];
        let x = chartArea.width / 2;
        let y = chartArea.height / 2;
        if (xScale) {
            x = scaleValue(
                xScale,
                options.xValue,
                xScale.left + xScale.width / 2
            );
        }
        if (yScale) {
            y = scaleValue(
                yScale,
                options.yValue,
                yScale.top + yScale.height / 2
            );
        }
        return { x, y };
    }
    function resolveBoxProperties(chart, options) {
        const scales2 = chart.scales;
        const xScale = scales2[retrieveScaleID(scales2, options, 'xScaleID')];
        const yScale = scales2[retrieveScaleID(scales2, options, 'yScaleID')];
        if (!xScale && !yScale) {
            return {};
        }
        let { left: x, right: x2 } = xScale || chart.chartArea;
        let { top: y, bottom: y2 } = yScale || chart.chartArea;
        const xDim = getChartDimensionByScale(xScale, {
            min: options.xMin,
            max: options.xMax,
            start: x,
            end: x2,
        });
        x = xDim.start;
        x2 = xDim.end;
        const yDim = getChartDimensionByScale(yScale, {
            min: options.yMin,
            max: options.yMax,
            start: y2,
            end: y,
        });
        y = yDim.start;
        y2 = yDim.end;
        return {
            x,
            y,
            x2,
            y2,
            width: x2 - x,
            height: y2 - y,
            centerX: x + (x2 - x) / 2,
            centerY: y + (y2 - y) / 2,
        };
    }
    function resolvePointProperties(chart, options) {
        if (!isBoundToPoint(options)) {
            const box = resolveBoxProperties(chart, options);
            let radius3 = options.radius;
            if (!radius3 || isNaN(radius3)) {
                radius3 = Math.min(box.width, box.height) / 2;
                options.radius = radius3;
            }
            const size = radius3 * 2;
            return {
                x: box.x + options.xAdjust,
                y: box.y + options.yAdjust,
                x2: box.x + size + options.xAdjust,
                y2: box.y + size + options.yAdjust,
                centerX: box.centerX + options.xAdjust,
                centerY: box.centerY + options.yAdjust,
                width: size,
                height: size,
            };
        }
        return getChartCircle(chart, options);
    }
    function getChartCircle(chart, options) {
        const point = getChartPoint(chart, options);
        const size = options.radius * 2;
        return {
            x: point.x - options.radius + options.xAdjust,
            y: point.y - options.radius + options.yAdjust,
            x2: point.x + options.radius + options.xAdjust,
            y2: point.y + options.radius + options.yAdjust,
            centerX: point.x + options.xAdjust,
            centerY: point.y + options.yAdjust,
            width: size,
            height: size,
        };
    }
    function getChartDimensionByScale(scale, options) {
        const result = getDimensionByScale(scale, options) || options;
        return {
            start: Math.min(result.start, result.end),
            end: Math.max(result.start, result.end),
        };
    }
    function rotated(point, center, angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const cx = center.x;
        const cy = center.y;
        return {
            x: cx + cos * (point.x - cx) - sin * (point.y - cy),
            y: cy + sin * (point.x - cx) + cos * (point.y - cy),
        };
    }
    function adjustScaleRange(chart, scale, annotations5) {
        const range = getScaleLimits(chart.scales, scale, annotations5);
        let changed = changeScaleLimit(scale, range, 'min', 'suggestedMin');
        changed =
            changeScaleLimit(scale, range, 'max', 'suggestedMax') || changed;
        if (changed && typeof scale.handleTickRangeOptions === 'function') {
            scale.handleTickRangeOptions();
        }
    }
    function verifyScaleOptions(annotations5, scales2) {
        for (const annotation2 of annotations5) {
            verifyScaleIDs(annotation2, scales2);
        }
    }
    function changeScaleLimit(scale, range, limit, suggestedLimit) {
        if (
            isNumberFinite(range[limit]) &&
            !scaleLimitDefined(scale.options, limit, suggestedLimit)
        ) {
            const changed = scale[limit] !== range[limit];
            scale[limit] = range[limit];
            return changed;
        }
    }
    function scaleLimitDefined(scaleOptions, limit, suggestedLimit) {
        return (
            defined(scaleOptions[limit]) ||
            defined(scaleOptions[suggestedLimit])
        );
    }
    function verifyScaleIDs(annotation2, scales2) {
        for (const key of ['scaleID', 'xScaleID', 'yScaleID']) {
            const scaleID = retrieveScaleID(scales2, annotation2, key);
            if (
                scaleID &&
                !scales2[scaleID] &&
                verifyProperties(annotation2, key)
            ) {
                console.warn(
                    `No scale found with id '${scaleID}' for annotation '${annotation2.id}'`
                );
            }
        }
    }
    function verifyProperties(annotation2, key) {
        if (key === 'scaleID') {
            return true;
        }
        const axis = key.charAt(0);
        for (const prop of ['Min', 'Max', 'Value']) {
            if (defined(annotation2[axis + prop])) {
                return true;
            }
        }
        return false;
    }
    function getScaleLimits(scales2, scale, annotations5) {
        const axis = scale.axis;
        const scaleID = scale.id;
        const scaleIDOption = axis + 'ScaleID';
        const limits = {
            min: valueOrDefault(scale.min, Number.NEGATIVE_INFINITY),
            max: valueOrDefault(scale.max, Number.POSITIVE_INFINITY),
        };
        for (const annotation2 of annotations5) {
            if (annotation2.scaleID === scaleID) {
                updateLimits2(
                    annotation2,
                    scale,
                    ['value', 'endValue'],
                    limits
                );
            } else if (
                retrieveScaleID(scales2, annotation2, scaleIDOption) === scaleID
            ) {
                updateLimits2(
                    annotation2,
                    scale,
                    [axis + 'Min', axis + 'Max', axis + 'Value'],
                    limits
                );
            }
        }
        return limits;
    }
    function updateLimits2(annotation2, scale, props, limits) {
        for (const prop of props) {
            const raw = annotation2[prop];
            if (defined(raw)) {
                const value = scale.parse(raw);
                limits.min = Math.min(limits.min, value);
                limits.max = Math.max(limits.max, value);
            }
        }
    }
    var BoxAnnotation = class extends Element {
        inRange(mouseX, mouseY, axis, useFinalPosition) {
            const { x, y } = rotated(
                { x: mouseX, y: mouseY },
                this.getCenterPoint(useFinalPosition),
                toRadians(-this.options.rotation)
            );
            return inBoxRange(
                { x, y },
                this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition),
                axis,
                this.options.borderWidth
            );
        }
        getCenterPoint(useFinalPosition) {
            return getElementCenterPoint(this, useFinalPosition);
        }
        draw(ctx) {
            ctx.save();
            translate(ctx, this.getCenterPoint(), this.options.rotation);
            drawBox(ctx, this, this.options);
            ctx.restore();
        }
        get label() {
            return this.elements && this.elements[0];
        }
        resolveElementProperties(chart, options) {
            const properties = resolveBoxProperties(chart, options);
            const { x, y } = properties;
            properties.elements = [
                {
                    type: 'label',
                    optionScope: 'label',
                    properties: resolveLabelElementProperties$1(
                        chart,
                        properties,
                        options
                    ),
                },
            ];
            properties.initProperties = { x, y };
            return properties;
        }
    };
    BoxAnnotation.id = 'boxAnnotation';
    BoxAnnotation.defaults = {
        adjustScaleRange: true,
        backgroundShadowColor: 'transparent',
        borderCapStyle: 'butt',
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: 'miter',
        borderRadius: 0,
        borderShadowColor: 'transparent',
        borderWidth: 1,
        display: true,
        label: {
            backgroundColor: 'transparent',
            borderWidth: 0,
            callout: {
                display: false,
            },
            color: 'black',
            content: null,
            display: false,
            drawTime: void 0,
            font: {
                family: void 0,
                lineHeight: void 0,
                size: void 0,
                style: void 0,
                weight: 'bold',
            },
            height: void 0,
            padding: 6,
            position: 'center',
            rotation: void 0,
            textAlign: 'start',
            textStrokeColor: void 0,
            textStrokeWidth: 0,
            width: void 0,
            xAdjust: 0,
            yAdjust: 0,
            z: void 0,
        },
        rotation: 0,
        shadowBlur: 0,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        xMax: void 0,
        xMin: void 0,
        xScaleID: void 0,
        yMax: void 0,
        yMin: void 0,
        yScaleID: void 0,
        z: 0,
    };
    BoxAnnotation.defaultRoutes = {
        borderColor: 'color',
        backgroundColor: 'color',
    };
    BoxAnnotation.descriptors = {
        label: {
            _fallback: true,
        },
    };
    function calculateX({ properties, options }, labelSize, position, padding) {
        const { x: start2, x2: end, width: size } = properties;
        return calculatePosition$1(
            { start: start2, end, size, borderWidth: options.borderWidth },
            {
                position: position.x,
                padding: { start: padding.left, end: padding.right },
                adjust: options.label.xAdjust,
                size: labelSize.width,
            }
        );
    }
    function calculateY({ properties, options }, labelSize, position, padding) {
        const { y: start2, y2: end, height: size } = properties;
        return calculatePosition$1(
            { start: start2, end, size, borderWidth: options.borderWidth },
            {
                position: position.y,
                padding: { start: padding.top, end: padding.bottom },
                adjust: options.label.yAdjust,
                size: labelSize.height,
            }
        );
    }
    function calculatePosition$1(boxOpts, labelOpts) {
        const { start: start2, end, borderWidth: borderWidth3 } = boxOpts;
        const {
            position,
            padding: { start: padStart, end: padEnd },
            adjust,
        } = labelOpts;
        const availableSize =
            end - borderWidth3 - start2 - padStart - padEnd - labelOpts.size;
        return (
            start2 +
            borderWidth3 / 2 +
            adjust +
            getRelativePosition2(availableSize, position)
        );
    }
    function resolveLabelElementProperties$1(chart, properties, options) {
        const label = options.label;
        label.backgroundColor = 'transparent';
        label.callout.display = false;
        const position = toPosition(label.position);
        const padding = toPadding(label.padding);
        const labelSize = measureLabelSize2(chart.ctx, label);
        const x = calculateX(
            { properties, options },
            labelSize,
            position,
            padding
        );
        const y = calculateY(
            { properties, options },
            labelSize,
            position,
            padding
        );
        const width = labelSize.width + padding.width;
        const height = labelSize.height + padding.height;
        return {
            x,
            y,
            x2: x + width,
            y2: y + height,
            width,
            height,
            centerX: x + width / 2,
            centerY: y + height / 2,
            rotation: label.rotation,
        };
    }
    var pointInLine = (p1, p2, t) => ({
        x: p1.x + t * (p2.x - p1.x),
        y: p1.y + t * (p2.y - p1.y),
    });
    var interpolateX = (y, p1, p2) =>
        pointInLine(p1, p2, Math.abs((y - p1.y) / (p2.y - p1.y))).x;
    var interpolateY = (x, p1, p2) =>
        pointInLine(p1, p2, Math.abs((x - p1.x) / (p2.x - p1.x))).y;
    var sqr = (v) => v * v;
    var rangeLimit = (mouseX, mouseY, { x, y, x2, y2 }, axis) =>
        axis === 'y'
            ? { start: Math.min(y, y2), end: Math.max(y, y2), value: mouseY }
            : { start: Math.min(x, x2), end: Math.max(x, x2), value: mouseX };
    var LineAnnotation = class extends Element {
        inRange(mouseX, mouseY, axis, useFinalPosition) {
            const hBorderWidth = this.options.borderWidth / 2;
            if (axis !== 'x' && axis !== 'y') {
                const epsilon = sqr(hBorderWidth);
                const point = { mouseX, mouseY };
                return (
                    intersects(this, point, epsilon, useFinalPosition) ||
                    isOnLabel(this, point, useFinalPosition)
                );
            }
            const limit = rangeLimit(
                mouseX,
                mouseY,
                this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition),
                axis
            );
            return (
                (limit.value >= limit.start - hBorderWidth &&
                    limit.value <= limit.end + hBorderWidth) ||
                isOnLabel(this, { mouseX, mouseY }, useFinalPosition, axis)
            );
        }
        getCenterPoint(useFinalPosition) {
            return getElementCenterPoint(this, useFinalPosition);
        }
        draw(ctx) {
            const { x, y, x2, y2, options } = this;
            ctx.save();
            if (!setBorderStyle(ctx, options)) {
                return ctx.restore();
            }
            setShadowStyle(ctx, options);
            const angle = Math.atan2(y2 - y, x2 - x);
            const length = Math.sqrt(Math.pow(x2 - x, 2) + Math.pow(y2 - y, 2));
            const { startOpts, endOpts, startAdjust, endAdjust } =
                getArrowHeads(this);
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.moveTo(0 + startAdjust, 0);
            ctx.lineTo(length - endAdjust, 0);
            ctx.shadowColor = options.borderShadowColor;
            ctx.stroke();
            drawArrowHead(ctx, 0, startAdjust, startOpts);
            drawArrowHead(ctx, length, -endAdjust, endOpts);
            ctx.restore();
        }
        get label() {
            return this.elements && this.elements[0];
        }
        resolveElementProperties(chart, options) {
            const { scales: scales2, chartArea } = chart;
            const scale = scales2[options.scaleID];
            const area = {
                x: chartArea.left,
                y: chartArea.top,
                x2: chartArea.right,
                y2: chartArea.bottom,
            };
            let min3, max3;
            if (scale) {
                min3 = scaleValue(scale, options.value, NaN);
                max3 = scaleValue(scale, options.endValue, min3);
                if (scale.isHorizontal()) {
                    area.x = min3;
                    area.x2 = max3;
                } else {
                    area.y = min3;
                    area.y2 = max3;
                }
            } else {
                const xScale =
                    scales2[retrieveScaleID(scales2, options, 'xScaleID')];
                const yScale =
                    scales2[retrieveScaleID(scales2, options, 'yScaleID')];
                if (xScale) {
                    applyScaleValueToDimension(area, xScale, {
                        min: options.xMin,
                        max: options.xMax,
                        start: xScale.left,
                        end: xScale.right,
                        startProp: 'x',
                        endProp: 'x2',
                    });
                }
                if (yScale) {
                    applyScaleValueToDimension(area, yScale, {
                        min: options.yMin,
                        max: options.yMax,
                        start: yScale.bottom,
                        end: yScale.top,
                        startProp: 'y',
                        endProp: 'y2',
                    });
                }
            }
            const { x, y, x2, y2 } = area;
            const inside = isLineInArea(area, chart.chartArea);
            const properties = inside
                ? limitLineToArea({ x, y }, { x: x2, y: y2 }, chart.chartArea)
                : {
                      x,
                      y,
                      x2,
                      y2,
                      width: Math.abs(x2 - x),
                      height: Math.abs(y2 - y),
                  };
            properties.centerX = (x2 + x) / 2;
            properties.centerY = (y2 + y) / 2;
            const labelProperties = resolveLabelElementProperties(
                chart,
                properties,
                options.label
            );
            labelProperties._visible = inside;
            properties.elements = [
                {
                    type: 'label',
                    optionScope: 'label',
                    properties: labelProperties,
                },
            ];
            return properties;
        }
    };
    LineAnnotation.id = 'lineAnnotation';
    var arrowHeadsDefaults = {
        backgroundColor: void 0,
        backgroundShadowColor: void 0,
        borderColor: void 0,
        borderDash: void 0,
        borderDashOffset: void 0,
        borderShadowColor: void 0,
        borderWidth: void 0,
        display: void 0,
        fill: void 0,
        length: void 0,
        shadowBlur: void 0,
        shadowOffsetX: void 0,
        shadowOffsetY: void 0,
        width: void 0,
    };
    LineAnnotation.defaults = {
        adjustScaleRange: true,
        arrowHeads: {
            display: false,
            end: Object.assign({}, arrowHeadsDefaults),
            fill: false,
            length: 12,
            start: Object.assign({}, arrowHeadsDefaults),
            width: 6,
        },
        borderDash: [],
        borderDashOffset: 0,
        borderShadowColor: 'transparent',
        borderWidth: 2,
        display: true,
        endValue: void 0,
        label: {
            backgroundColor: 'rgba(0,0,0,0.8)',
            backgroundShadowColor: 'transparent',
            borderCapStyle: 'butt',
            borderColor: 'black',
            borderDash: [],
            borderDashOffset: 0,
            borderJoinStyle: 'miter',
            borderRadius: 6,
            borderShadowColor: 'transparent',
            borderWidth: 0,
            callout: {
                display: false,
            },
            color: '#fff',
            content: null,
            display: false,
            drawTime: void 0,
            font: {
                family: void 0,
                lineHeight: void 0,
                size: void 0,
                style: void 0,
                weight: 'bold',
            },
            height: void 0,
            padding: 6,
            position: 'center',
            rotation: 0,
            shadowBlur: 0,
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            textAlign: 'center',
            textStrokeColor: void 0,
            textStrokeWidth: 0,
            width: void 0,
            xAdjust: 0,
            yAdjust: 0,
            z: void 0,
        },
        scaleID: void 0,
        shadowBlur: 0,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        value: void 0,
        xMax: void 0,
        xMin: void 0,
        xScaleID: void 0,
        yMax: void 0,
        yMin: void 0,
        yScaleID: void 0,
        z: 0,
    };
    LineAnnotation.descriptors = {
        arrowHeads: {
            start: {
                _fallback: true,
            },
            end: {
                _fallback: true,
            },
            _fallback: true,
        },
    };
    LineAnnotation.defaultRoutes = {
        borderColor: 'color',
    };
    function isLineInArea({ x, y, x2, y2 }, { top, right, bottom, left }) {
        return !(
            (x < left && x2 < left) ||
            (x > right && x2 > right) ||
            (y < top && y2 < top) ||
            (y > bottom && y2 > bottom)
        );
    }
    function limitPointToArea({ x, y }, p2, { top, right, bottom, left }) {
        if (x < left) {
            y = interpolateY(left, { x, y }, p2);
            x = left;
        }
        if (x > right) {
            y = interpolateY(right, { x, y }, p2);
            x = right;
        }
        if (y < top) {
            x = interpolateX(top, { x, y }, p2);
            y = top;
        }
        if (y > bottom) {
            x = interpolateX(bottom, { x, y }, p2);
            y = bottom;
        }
        return { x, y };
    }
    function limitLineToArea(p1, p2, area) {
        const { x, y } = limitPointToArea(p1, p2, area);
        const { x: x2, y: y2 } = limitPointToArea(p2, p1, area);
        return {
            x,
            y,
            x2,
            y2,
            width: Math.abs(x2 - x),
            height: Math.abs(y2 - y),
        };
    }
    function intersects(
        element,
        { mouseX, mouseY },
        epsilon = EPSILON2,
        useFinalPosition
    ) {
        const {
            x: x1,
            y: y1,
            x2,
            y2,
        } = element.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition);
        const dx = x2 - x1;
        const dy = y2 - y1;
        const lenSq = sqr(dx) + sqr(dy);
        const t =
            lenSq === 0
                ? -1
                : ((mouseX - x1) * dx + (mouseY - y1) * dy) / lenSq;
        let xx, yy;
        if (t < 0) {
            xx = x1;
            yy = y1;
        } else if (t > 1) {
            xx = x2;
            yy = y2;
        } else {
            xx = x1 + t * dx;
            yy = y1 + t * dy;
        }
        return sqr(mouseX - xx) + sqr(mouseY - yy) <= epsilon;
    }
    function isOnLabel(element, { mouseX, mouseY }, useFinalPosition, axis) {
        const label = element.label;
        return (
            label.options.display &&
            label.inRange(mouseX, mouseY, axis, useFinalPosition)
        );
    }
    function applyScaleValueToDimension(area, scale, options) {
        const dim = getDimensionByScale(scale, options);
        area[options.startProp] = dim.start;
        area[options.endProp] = dim.end;
    }
    function resolveLabelElementProperties(chart, properties, options) {
        options.callout.display = false;
        const borderWidth3 = options.borderWidth;
        const padding = toPadding(options.padding);
        const textSize = measureLabelSize2(chart.ctx, options);
        const width = textSize.width + padding.width + borderWidth3;
        const height = textSize.height + padding.height + borderWidth3;
        return calculateLabelPosition(
            properties,
            options,
            { width, height, padding },
            chart.chartArea
        );
    }
    function calculateAutoRotation(properties) {
        const { x, y, x2, y2 } = properties;
        const rotation = Math.atan2(y2 - y, x2 - x);
        return rotation > PI / 2
            ? rotation - PI
            : rotation < PI / -2
            ? rotation + PI
            : rotation;
    }
    function calculateLabelPosition(properties, label, sizes, chartArea) {
        const { width, height, padding } = sizes;
        const { xAdjust, yAdjust } = label;
        const p1 = { x: properties.x, y: properties.y };
        const p2 = { x: properties.x2, y: properties.y2 };
        const rotation =
            label.rotation === 'auto'
                ? calculateAutoRotation(properties)
                : toRadians(label.rotation);
        const size = rotatedSize(width, height, rotation);
        const t = calculateT(
            properties,
            label,
            { labelSize: size, padding },
            chartArea
        );
        const pt = pointInLine(p1, p2, t);
        const xCoordinateSizes = {
            size: size.w,
            min: chartArea.left,
            max: chartArea.right,
            padding: padding.left,
        };
        const yCoordinateSizes = {
            size: size.h,
            min: chartArea.top,
            max: chartArea.bottom,
            padding: padding.top,
        };
        const centerX = adjustLabelCoordinate(pt.x, xCoordinateSizes) + xAdjust;
        const centerY = adjustLabelCoordinate(pt.y, yCoordinateSizes) + yAdjust;
        return {
            x: centerX - width / 2,
            y: centerY - height / 2,
            x2: centerX + width / 2,
            y2: centerY + height / 2,
            centerX,
            centerY,
            width,
            height,
            rotation: toDegrees(rotation),
        };
    }
    function rotatedSize(width, height, rotation) {
        const cos = Math.cos(rotation);
        const sin = Math.sin(rotation);
        return {
            w: Math.abs(width * cos) + Math.abs(height * sin),
            h: Math.abs(width * sin) + Math.abs(height * cos),
        };
    }
    function calculateT(properties, label, sizes, chartArea) {
        let t;
        const space = spaceAround(properties, chartArea);
        if (label.position === 'start') {
            t = calculateTAdjust(
                {
                    w: properties.x2 - properties.x,
                    h: properties.y2 - properties.y,
                },
                sizes,
                label,
                space
            );
        } else if (label.position === 'end') {
            t =
                1 -
                calculateTAdjust(
                    {
                        w: properties.x - properties.x2,
                        h: properties.y - properties.y2,
                    },
                    sizes,
                    label,
                    space
                );
        } else {
            t = getRelativePosition2(1, label.position);
        }
        return t;
    }
    function calculateTAdjust(lineSize, sizes, label, space) {
        const { labelSize, padding } = sizes;
        const lineW = lineSize.w * space.dx;
        const lineH = lineSize.h * space.dy;
        const x =
            lineW > 0 && (labelSize.w / 2 + padding.left - space.x) / lineW;
        const y =
            lineH > 0 && (labelSize.h / 2 + padding.top - space.y) / lineH;
        return clamp(Math.max(x, y), 0, 0.25);
    }
    function spaceAround(properties, chartArea) {
        const { x, x2, y, y2 } = properties;
        const t = Math.min(y, y2) - chartArea.top;
        const l = Math.min(x, x2) - chartArea.left;
        const b = chartArea.bottom - Math.max(y, y2);
        const r = chartArea.right - Math.max(x, x2);
        return {
            x: Math.min(l, r),
            y: Math.min(t, b),
            dx: l <= r ? 1 : -1,
            dy: t <= b ? 1 : -1,
        };
    }
    function adjustLabelCoordinate(coordinate, labelSizes) {
        const { size, min: min3, max: max3, padding } = labelSizes;
        const halfSize = size / 2;
        if (size > max3 - min3) {
            return (max3 + min3) / 2;
        }
        if (min3 >= coordinate - padding - halfSize) {
            coordinate = min3 + padding + halfSize;
        }
        if (max3 <= coordinate + padding + halfSize) {
            coordinate = max3 - padding - halfSize;
        }
        return coordinate;
    }
    function getArrowHeads(line) {
        const options = line.options;
        const arrowStartOpts = options.arrowHeads && options.arrowHeads.start;
        const arrowEndOpts = options.arrowHeads && options.arrowHeads.end;
        return {
            startOpts: arrowStartOpts,
            endOpts: arrowEndOpts,
            startAdjust: getLineAdjust(line, arrowStartOpts),
            endAdjust: getLineAdjust(line, arrowEndOpts),
        };
    }
    function getLineAdjust(line, arrowOpts) {
        if (!arrowOpts || !arrowOpts.display) {
            return 0;
        }
        const { length, width } = arrowOpts;
        const adjust = line.options.borderWidth / 2;
        const p1 = { x: length, y: width + adjust };
        const p2 = { x: 0, y: adjust };
        return Math.abs(interpolateX(0, p1, p2));
    }
    function drawArrowHead(ctx, offset, adjust, arrowOpts) {
        if (!arrowOpts || !arrowOpts.display) {
            return;
        }
        const {
            length,
            width,
            fill: fill2,
            backgroundColor: backgroundColor4,
            borderColor: borderColor4,
        } = arrowOpts;
        const arrowOffsetX = Math.abs(offset - length) + adjust;
        ctx.beginPath();
        setShadowStyle(ctx, arrowOpts);
        setBorderStyle(ctx, arrowOpts);
        ctx.moveTo(arrowOffsetX, -width);
        ctx.lineTo(offset + adjust, 0);
        ctx.lineTo(arrowOffsetX, width);
        if (fill2 === true) {
            ctx.fillStyle = backgroundColor4 || borderColor4;
            ctx.closePath();
            ctx.fill();
            ctx.shadowColor = 'transparent';
        } else {
            ctx.shadowColor = arrowOpts.borderShadowColor;
        }
        ctx.stroke();
    }
    var EllipseAnnotation = class extends Element {
        inRange(mouseX, mouseY, axis, useFinalPosition) {
            const rotation = this.options.rotation;
            const borderWidth3 = this.options.borderWidth;
            if (axis !== 'x' && axis !== 'y') {
                return pointInEllipse(
                    { x: mouseX, y: mouseY },
                    this.getProps(
                        ['width', 'height', 'centerX', 'centerY'],
                        useFinalPosition
                    ),
                    rotation,
                    borderWidth3
                );
            }
            const { x, y, x2, y2 } = this.getProps(
                ['x', 'y', 'x2', 'y2'],
                useFinalPosition
            );
            const hBorderWidth = borderWidth3 / 2;
            const limit =
                axis === 'y' ? { start: y, end: y2 } : { start: x, end: x2 };
            const rotatedPoint = rotated(
                { x: mouseX, y: mouseY },
                this.getCenterPoint(useFinalPosition),
                toRadians(-rotation)
            );
            return (
                rotatedPoint[axis] >= limit.start - hBorderWidth - EPSILON2 &&
                rotatedPoint[axis] <= limit.end + hBorderWidth + EPSILON2
            );
        }
        getCenterPoint(useFinalPosition) {
            return getElementCenterPoint(this, useFinalPosition);
        }
        draw(ctx) {
            const { width, height, centerX, centerY, options } = this;
            ctx.save();
            translate(ctx, this.getCenterPoint(), options.rotation);
            setShadowStyle(ctx, this.options);
            ctx.beginPath();
            ctx.fillStyle = options.backgroundColor;
            const stroke = setBorderStyle(ctx, options);
            ctx.ellipse(
                centerX,
                centerY,
                height / 2,
                width / 2,
                PI / 2,
                0,
                2 * PI
            );
            ctx.fill();
            if (stroke) {
                ctx.shadowColor = options.borderShadowColor;
                ctx.stroke();
            }
            ctx.restore();
        }
        resolveElementProperties(chart, options) {
            return resolveBoxProperties(chart, options);
        }
    };
    EllipseAnnotation.id = 'ellipseAnnotation';
    EllipseAnnotation.defaults = {
        adjustScaleRange: true,
        backgroundShadowColor: 'transparent',
        borderDash: [],
        borderDashOffset: 0,
        borderShadowColor: 'transparent',
        borderWidth: 1,
        display: true,
        rotation: 0,
        shadowBlur: 0,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        xMax: void 0,
        xMin: void 0,
        xScaleID: void 0,
        yMax: void 0,
        yMin: void 0,
        yScaleID: void 0,
        z: 0,
    };
    EllipseAnnotation.defaultRoutes = {
        borderColor: 'color',
        backgroundColor: 'color',
    };
    function pointInEllipse(p, ellipse, rotation, borderWidth3) {
        const { width, height, centerX, centerY } = ellipse;
        const xRadius = width / 2;
        const yRadius = height / 2;
        if (xRadius <= 0 || yRadius <= 0) {
            return false;
        }
        const angle = toRadians(rotation || 0);
        const hBorderWidth = borderWidth3 / 2 || 0;
        const cosAngle = Math.cos(angle);
        const sinAngle = Math.sin(angle);
        const a = Math.pow(
            cosAngle * (p.x - centerX) + sinAngle * (p.y - centerY),
            2
        );
        const b = Math.pow(
            sinAngle * (p.x - centerX) - cosAngle * (p.y - centerY),
            2
        );
        return (
            a / Math.pow(xRadius + hBorderWidth, 2) +
                b / Math.pow(yRadius + hBorderWidth, 2) <=
            1.0001
        );
    }
    var positions2 = ['left', 'bottom', 'top', 'right'];
    var LabelAnnotation = class extends Element {
        inRange(mouseX, mouseY, axis, useFinalPosition) {
            const { x, y } = rotated(
                { x: mouseX, y: mouseY },
                this.getCenterPoint(useFinalPosition),
                toRadians(-this.rotation)
            );
            return inBoxRange(
                { x, y },
                this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition),
                axis,
                this.options.borderWidth
            );
        }
        getCenterPoint(useFinalPosition) {
            return getElementCenterPoint(this, useFinalPosition);
        }
        draw(ctx) {
            const options = this.options;
            const visible = !defined(this._visible) || this._visible;
            if (!options.display || !options.content || !visible) {
                return;
            }
            ctx.save();
            translate(ctx, this.getCenterPoint(), this.rotation);
            drawCallout(ctx, this);
            drawBox(ctx, this, options);
            drawLabel(ctx, getLabelSize(this), options);
            ctx.restore();
        }
        resolveElementProperties(chart, options) {
            let point;
            if (!isBoundToPoint(options)) {
                const { centerX, centerY } = resolveBoxProperties(
                    chart,
                    options
                );
                point = { x: centerX, y: centerY };
            } else {
                point = getChartPoint(chart, options);
            }
            const padding = toPadding(options.padding);
            const labelSize = measureLabelSize2(chart.ctx, options);
            const boxSize = measureRect(point, labelSize, options, padding);
            return {
                pointX: point.x,
                pointY: point.y,
                ...boxSize,
                rotation: options.rotation,
            };
        }
    };
    LabelAnnotation.id = 'labelAnnotation';
    LabelAnnotation.defaults = {
        adjustScaleRange: true,
        backgroundColor: 'transparent',
        backgroundShadowColor: 'transparent',
        borderCapStyle: 'butt',
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: 'miter',
        borderRadius: 0,
        borderShadowColor: 'transparent',
        borderWidth: 0,
        callout: {
            borderCapStyle: 'butt',
            borderColor: void 0,
            borderDash: [],
            borderDashOffset: 0,
            borderJoinStyle: 'miter',
            borderWidth: 1,
            display: false,
            margin: 5,
            position: 'auto',
            side: 5,
            start: '50%',
        },
        color: 'black',
        content: null,
        display: true,
        font: {
            family: void 0,
            lineHeight: void 0,
            size: void 0,
            style: void 0,
            weight: void 0,
        },
        height: void 0,
        padding: 6,
        position: 'center',
        rotation: 0,
        shadowBlur: 0,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        textAlign: 'center',
        textStrokeColor: void 0,
        textStrokeWidth: 0,
        width: void 0,
        xAdjust: 0,
        xMax: void 0,
        xMin: void 0,
        xScaleID: void 0,
        xValue: void 0,
        yAdjust: 0,
        yMax: void 0,
        yMin: void 0,
        yScaleID: void 0,
        yValue: void 0,
        z: 0,
    };
    LabelAnnotation.defaultRoutes = {
        borderColor: 'color',
    };
    function measureRect(point, size, options, padding) {
        const width = size.width + padding.width + options.borderWidth;
        const height = size.height + padding.height + options.borderWidth;
        const position = toPosition(options.position);
        const x = calculatePosition(
            point.x,
            width,
            options.xAdjust,
            position.x
        );
        const y = calculatePosition(
            point.y,
            height,
            options.yAdjust,
            position.y
        );
        return {
            x,
            y,
            x2: x + width,
            y2: y + height,
            width,
            height,
            centerX: x + width / 2,
            centerY: y + height / 2,
        };
    }
    function calculatePosition(start2, size, adjust = 0, position) {
        return start2 - getRelativePosition2(size, position) + adjust;
    }
    function drawCallout(ctx, element) {
        const { pointX, pointY, options } = element;
        const callout = options.callout;
        const calloutPosition =
            callout &&
            callout.display &&
            resolveCalloutPosition(element, callout);
        if (
            !calloutPosition ||
            isPointInRange(element, callout, calloutPosition)
        ) {
            return;
        }
        ctx.save();
        ctx.beginPath();
        const stroke = setBorderStyle(ctx, callout);
        if (!stroke) {
            return ctx.restore();
        }
        const { separatorStart, separatorEnd } = getCalloutSeparatorCoord(
            element,
            calloutPosition
        );
        const { sideStart, sideEnd } = getCalloutSideCoord(
            element,
            calloutPosition,
            separatorStart
        );
        if (callout.margin > 0 || options.borderWidth === 0) {
            ctx.moveTo(separatorStart.x, separatorStart.y);
            ctx.lineTo(separatorEnd.x, separatorEnd.y);
        }
        ctx.moveTo(sideStart.x, sideStart.y);
        ctx.lineTo(sideEnd.x, sideEnd.y);
        const rotatedPoint = rotated(
            { x: pointX, y: pointY },
            element.getCenterPoint(),
            toRadians(-element.rotation)
        );
        ctx.lineTo(rotatedPoint.x, rotatedPoint.y);
        ctx.stroke();
        ctx.restore();
    }
    function getCalloutSeparatorCoord(element, position) {
        const { x, y, x2, y2 } = element;
        const adjust = getCalloutSeparatorAdjust(element, position);
        let separatorStart, separatorEnd;
        if (position === 'left' || position === 'right') {
            separatorStart = { x: x + adjust, y };
            separatorEnd = { x: separatorStart.x, y: y2 };
        } else {
            separatorStart = { x, y: y + adjust };
            separatorEnd = { x: x2, y: separatorStart.y };
        }
        return { separatorStart, separatorEnd };
    }
    function getCalloutSeparatorAdjust(element, position) {
        const { width, height, options } = element;
        const adjust = options.callout.margin + options.borderWidth / 2;
        if (position === 'right') {
            return width + adjust;
        } else if (position === 'bottom') {
            return height + adjust;
        }
        return -adjust;
    }
    function getCalloutSideCoord(element, position, separatorStart) {
        const { y, width, height, options } = element;
        const start2 = options.callout.start;
        const side = getCalloutSideAdjust(position, options.callout);
        let sideStart, sideEnd;
        if (position === 'left' || position === 'right') {
            sideStart = { x: separatorStart.x, y: y + getSize(height, start2) };
            sideEnd = { x: sideStart.x + side, y: sideStart.y };
        } else {
            sideStart = {
                x: separatorStart.x + getSize(width, start2),
                y: separatorStart.y,
            };
            sideEnd = { x: sideStart.x, y: sideStart.y + side };
        }
        return { sideStart, sideEnd };
    }
    function getCalloutSideAdjust(position, options) {
        const side = options.side;
        if (position === 'left' || position === 'top') {
            return -side;
        }
        return side;
    }
    function resolveCalloutPosition(element, options) {
        const position = options.position;
        if (positions2.includes(position)) {
            return position;
        }
        return resolveCalloutAutoPosition(element, options);
    }
    function resolveCalloutAutoPosition(element, options) {
        const {
            x,
            y,
            x2,
            y2,
            width,
            height,
            pointX,
            pointY,
            centerX,
            centerY,
            rotation,
        } = element;
        const center = { x: centerX, y: centerY };
        const start2 = options.start;
        const xAdjust = getSize(width, start2);
        const yAdjust = getSize(height, start2);
        const xPoints = [x, x + xAdjust, x + xAdjust, x2];
        const yPoints = [y + yAdjust, y2, y, y2];
        const result = [];
        for (let index3 = 0; index3 < 4; index3++) {
            const rotatedPoint = rotated(
                { x: xPoints[index3], y: yPoints[index3] },
                center,
                toRadians(rotation)
            );
            result.push({
                position: positions2[index3],
                distance: distanceBetweenPoints(rotatedPoint, {
                    x: pointX,
                    y: pointY,
                }),
            });
        }
        return result.sort((a, b) => a.distance - b.distance)[0].position;
    }
    function getLabelSize({ x, y, width, height, options }) {
        const hBorderWidth = options.borderWidth / 2;
        const padding = toPadding(options.padding);
        return {
            x: x + padding.left + hBorderWidth,
            y: y + padding.top + hBorderWidth,
            width: width - padding.left - padding.right - options.borderWidth,
            height: height - padding.top - padding.bottom - options.borderWidth,
        };
    }
    function isPointInRange(element, callout, position) {
        const { pointX, pointY } = element;
        const margin = callout.margin;
        let x = pointX;
        let y = pointY;
        if (position === 'left') {
            x += margin;
        } else if (position === 'right') {
            x -= margin;
        } else if (position === 'top') {
            y += margin;
        } else if (position === 'bottom') {
            y -= margin;
        }
        return element.inRange(x, y);
    }
    var PointAnnotation = class extends Element {
        inRange(mouseX, mouseY, axis, useFinalPosition) {
            const { x, y, x2, y2, width } = this.getProps(
                ['x', 'y', 'x2', 'y2', 'width'],
                useFinalPosition
            );
            const borderWidth3 = this.options.borderWidth;
            if (axis !== 'x' && axis !== 'y') {
                return inPointRange(
                    { x: mouseX, y: mouseY },
                    this.getCenterPoint(useFinalPosition),
                    width / 2,
                    borderWidth3
                );
            }
            const hBorderWidth = borderWidth3 / 2;
            const limit =
                axis === 'y'
                    ? { start: y, end: y2, value: mouseY }
                    : { start: x, end: x2, value: mouseX };
            return (
                limit.value >= limit.start - hBorderWidth &&
                limit.value <= limit.end + hBorderWidth
            );
        }
        getCenterPoint(useFinalPosition) {
            return getElementCenterPoint(this, useFinalPosition);
        }
        draw(ctx) {
            const options = this.options;
            const borderWidth3 = options.borderWidth;
            if (options.radius < 0.1) {
                return;
            }
            ctx.save();
            ctx.fillStyle = options.backgroundColor;
            setShadowStyle(ctx, options);
            const stroke = setBorderStyle(ctx, options);
            options.borderWidth = 0;
            drawPoint(ctx, options, this.centerX, this.centerY);
            if (stroke && !isImageOrCanvas(options.pointStyle)) {
                ctx.shadowColor = options.borderShadowColor;
                ctx.stroke();
            }
            ctx.restore();
            options.borderWidth = borderWidth3;
        }
        resolveElementProperties(chart, options) {
            return resolvePointProperties(chart, options);
        }
    };
    PointAnnotation.id = 'pointAnnotation';
    PointAnnotation.defaults = {
        adjustScaleRange: true,
        backgroundShadowColor: 'transparent',
        borderDash: [],
        borderDashOffset: 0,
        borderShadowColor: 'transparent',
        borderWidth: 1,
        display: true,
        pointStyle: 'circle',
        radius: 10,
        rotation: 0,
        shadowBlur: 0,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        xAdjust: 0,
        xMax: void 0,
        xMin: void 0,
        xScaleID: void 0,
        xValue: void 0,
        yAdjust: 0,
        yMax: void 0,
        yMin: void 0,
        yScaleID: void 0,
        yValue: void 0,
        z: 0,
    };
    PointAnnotation.defaultRoutes = {
        borderColor: 'color',
        backgroundColor: 'color',
    };
    var PolygonAnnotation = class extends Element {
        inRange(mouseX, mouseY, axis, useFinalPosition) {
            if (axis !== 'x' && axis !== 'y') {
                return (
                    this.options.radius >= 0.1 &&
                    this.elements.length > 1 &&
                    pointIsInPolygon(
                        this.elements,
                        mouseX,
                        mouseY,
                        useFinalPosition
                    )
                );
            }
            const rotatedPoint = rotated(
                { x: mouseX, y: mouseY },
                this.getCenterPoint(useFinalPosition),
                toRadians(-this.options.rotation)
            );
            const axisPoints = this.elements.map((point) =>
                axis === 'y' ? point.bY : point.bX
            );
            const start2 = Math.min(...axisPoints);
            const end = Math.max(...axisPoints);
            return rotatedPoint[axis] >= start2 && rotatedPoint[axis] <= end;
        }
        getCenterPoint(useFinalPosition) {
            return getElementCenterPoint(this, useFinalPosition);
        }
        draw(ctx) {
            const { elements: elements2, options } = this;
            ctx.save();
            ctx.beginPath();
            ctx.fillStyle = options.backgroundColor;
            setShadowStyle(ctx, options);
            const stroke = setBorderStyle(ctx, options);
            let first = true;
            for (const el of elements2) {
                if (first) {
                    ctx.moveTo(el.x, el.y);
                    first = false;
                } else {
                    ctx.lineTo(el.x, el.y);
                }
            }
            ctx.closePath();
            ctx.fill();
            if (stroke) {
                ctx.shadowColor = options.borderShadowColor;
                ctx.stroke();
            }
            ctx.restore();
        }
        resolveElementProperties(chart, options) {
            const properties = resolvePointProperties(chart, options);
            const { x, y } = properties;
            const { sides, rotation } = options;
            const elements2 = [];
            const angle = (2 * PI) / sides;
            let rad = rotation * RAD_PER_DEG;
            for (let i = 0; i < sides; i++, rad += angle) {
                elements2.push(buildPointElement(properties, options, rad));
            }
            properties.elements = elements2;
            properties.initProperties = { x, y };
            return properties;
        }
    };
    PolygonAnnotation.id = 'polygonAnnotation';
    PolygonAnnotation.defaults = {
        adjustScaleRange: true,
        backgroundShadowColor: 'transparent',
        borderCapStyle: 'butt',
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: 'miter',
        borderShadowColor: 'transparent',
        borderWidth: 1,
        display: true,
        point: {
            radius: 0,
        },
        radius: 10,
        rotation: 0,
        shadowBlur: 0,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        sides: 3,
        xAdjust: 0,
        xMax: void 0,
        xMin: void 0,
        xScaleID: void 0,
        xValue: void 0,
        yAdjust: 0,
        yMax: void 0,
        yMin: void 0,
        yScaleID: void 0,
        yValue: void 0,
        z: 0,
    };
    PolygonAnnotation.defaultRoutes = {
        borderColor: 'color',
        backgroundColor: 'color',
    };
    function buildPointElement(
        { centerX, centerY },
        { radius: radius3, borderWidth: borderWidth3 },
        rad
    ) {
        const halfBorder = borderWidth3 / 2;
        const sin = Math.sin(rad);
        const cos = Math.cos(rad);
        const point = {
            x: centerX + sin * radius3,
            y: centerY - cos * radius3,
        };
        return {
            type: 'point',
            optionScope: 'point',
            properties: {
                x: point.x,
                y: point.y,
                centerX: point.x,
                centerY: point.y,
                bX: centerX + sin * (radius3 + halfBorder),
                bY: centerY - cos * (radius3 + halfBorder),
            },
        };
    }
    function pointIsInPolygon(points, x, y, useFinalPosition) {
        let isInside = false;
        let A = points[points.length - 1].getProps(
            ['bX', 'bY'],
            useFinalPosition
        );
        for (const point of points) {
            const B = point.getProps(['bX', 'bY'], useFinalPosition);
            if (
                B.bY > y !== A.bY > y &&
                x < ((A.bX - B.bX) * (y - B.bY)) / (A.bY - B.bY) + B.bX
            ) {
                isInside = !isInside;
            }
            A = B;
        }
        return isInside;
    }
    var annotationTypes = {
        box: BoxAnnotation,
        ellipse: EllipseAnnotation,
        label: LabelAnnotation,
        line: LineAnnotation,
        point: PointAnnotation,
        polygon: PolygonAnnotation,
    };
    Object.keys(annotationTypes).forEach((key) => {
        defaults.describe(`elements.${annotationTypes[key].id}`, {
            _fallback: 'plugins.annotation.common',
        });
    });
    var directUpdater = {
        update: Object.assign,
    };
    function resolveType(type2 = 'line') {
        if (annotationTypes[type2]) {
            return type2;
        }
        console.warn(
            `Unknown annotation type: '${type2}', defaulting to 'line'`
        );
        return 'line';
    }
    function updateElements(chart, state, options, mode) {
        const animations = resolveAnimations(chart, options.animations, mode);
        const annotations5 = state.annotations;
        const elements2 = resyncElements(state.elements, annotations5);
        for (let i = 0; i < annotations5.length; i++) {
            const annotationOptions = annotations5[i];
            const element = getOrCreateElement(
                elements2,
                i,
                annotationOptions.type
            );
            const resolver = annotationOptions.setContext(
                getContext(chart, element, annotationOptions)
            );
            const properties = element.resolveElementProperties(
                chart,
                resolver
            );
            properties.skip = toSkip(properties);
            if ('elements' in properties) {
                updateSubElements(element, properties, resolver, animations);
                delete properties.elements;
            }
            if (!defined(element.x)) {
                Object.assign(element, properties);
            }
            properties.options = resolveAnnotationOptions(resolver);
            animations.update(element, properties);
        }
    }
    function toSkip(properties) {
        return isNaN(properties.x) || isNaN(properties.y);
    }
    function resolveAnimations(chart, animOpts, mode) {
        if (mode === 'reset' || mode === 'none' || mode === 'resize') {
            return directUpdater;
        }
        return new Animations(chart, animOpts);
    }
    function updateSubElements(
        mainElement,
        { elements: elements2, initProperties },
        resolver,
        animations
    ) {
        const subElements = mainElement.elements || (mainElement.elements = []);
        subElements.length = elements2.length;
        for (let i = 0; i < elements2.length; i++) {
            const definition = elements2[i];
            const properties = definition.properties;
            const subElement = getOrCreateElement(
                subElements,
                i,
                definition.type,
                initProperties
            );
            const subResolver =
                resolver[definition.optionScope].override(definition);
            properties.options = resolveAnnotationOptions(subResolver);
            animations.update(subElement, properties);
        }
    }
    function getOrCreateElement(elements2, index3, type2, initProperties) {
        const elementClass = annotationTypes[resolveType(type2)];
        let element = elements2[index3];
        if (!element || !(element instanceof elementClass)) {
            element = elements2[index3] = new elementClass();
            if (isObject(initProperties)) {
                Object.assign(element, initProperties);
            }
        }
        return element;
    }
    function resolveAnnotationOptions(resolver) {
        const elementClass = annotationTypes[resolveType(resolver.type)];
        const result = {};
        result.id = resolver.id;
        result.type = resolver.type;
        result.drawTime = resolver.drawTime;
        Object.assign(
            result,
            resolveObj(resolver, elementClass.defaults),
            resolveObj(resolver, elementClass.defaultRoutes)
        );
        for (const hook of hooks) {
            result[hook] = resolver[hook];
        }
        return result;
    }
    function resolveObj(resolver, defs) {
        const result = {};
        for (const prop of Object.keys(defs)) {
            const optDefs = defs[prop];
            const value = resolver[prop];
            result[prop] = isObject(optDefs)
                ? resolveObj(value, optDefs)
                : value;
        }
        return result;
    }
    function getContext(chart, element, annotation2) {
        return (
            element.$context ||
            (element.$context = Object.assign(
                Object.create(chart.getContext()),
                {
                    element,
                    id: annotation2.id,
                    type: 'annotation',
                }
            ))
        );
    }
    function resyncElements(elements2, annotations5) {
        const count = annotations5.length;
        const start2 = elements2.length;
        if (start2 < count) {
            const add = count - start2;
            elements2.splice(start2, 0, ...new Array(add));
        } else if (start2 > count) {
            elements2.splice(count, start2 - count);
        }
        return elements2;
    }
    var version2 = '2.0.1';
    var chartStates = /* @__PURE__ */ new Map();
    var annotation = {
        id: 'annotation',
        version: version2,
        beforeRegister() {
            requireVersion('chart.js', '3.7', Chart.version);
        },
        afterRegister() {
            Chart.register(annotationTypes);
        },
        afterUnregister() {
            Chart.unregister(annotationTypes);
        },
        beforeInit(chart) {
            chartStates.set(chart, {
                annotations: [],
                elements: [],
                visibleElements: [],
                listeners: {},
                listened: false,
                moveListened: false,
                hovered: [],
            });
        },
        beforeUpdate(chart, args, options) {
            const state = chartStates.get(chart);
            const annotations5 = (state.annotations = []);
            let annotationOptions = options.annotations;
            if (isObject(annotationOptions)) {
                Object.keys(annotationOptions).forEach((key) => {
                    const value = annotationOptions[key];
                    if (isObject(value)) {
                        value.id = key;
                        annotations5.push(value);
                    }
                });
            } else if (isArray(annotationOptions)) {
                annotations5.push(...annotationOptions);
            }
            verifyScaleOptions(annotations5, chart.scales);
        },
        afterDataLimits(chart, args) {
            const state = chartStates.get(chart);
            adjustScaleRange(
                chart,
                args.scale,
                state.annotations.filter((a) => a.display && a.adjustScaleRange)
            );
        },
        afterUpdate(chart, args, options) {
            const state = chartStates.get(chart);
            updateListeners(chart, state, options);
            updateElements(chart, state, options, args.mode);
            state.visibleElements = state.elements.filter(
                (el) => !el.skip && el.options.display
            );
        },
        beforeDatasetsDraw(chart, _args, options) {
            draw2(chart, 'beforeDatasetsDraw', options.clip);
        },
        afterDatasetsDraw(chart, _args, options) {
            draw2(chart, 'afterDatasetsDraw', options.clip);
        },
        beforeDraw(chart, _args, options) {
            draw2(chart, 'beforeDraw', options.clip);
        },
        afterDraw(chart, _args, options) {
            draw2(chart, 'afterDraw', options.clip);
        },
        beforeEvent(chart, args, options) {
            const state = chartStates.get(chart);
            if (handleEvent(state, args.event, options)) {
                args.changed = true;
            }
        },
        destroy(chart) {
            chartStates.delete(chart);
        },
        _getState(chart) {
            return chartStates.get(chart);
        },
        defaults: {
            animations: {
                numbers: {
                    properties: [
                        'x',
                        'y',
                        'x2',
                        'y2',
                        'width',
                        'height',
                        'centerX',
                        'centerY',
                        'pointX',
                        'pointY',
                        'radius',
                    ],
                    type: 'number',
                },
            },
            clip: true,
            interaction: {
                mode: void 0,
                axis: void 0,
                intersect: void 0,
            },
            common: {
                drawTime: 'afterDatasetsDraw',
                label: {},
            },
        },
        descriptors: {
            _indexable: false,
            _scriptable: (prop) => !hooks.includes(prop),
            annotations: {
                _allKeys: false,
                _fallback: (prop, opts) =>
                    `elements.${annotationTypes[resolveType(opts.type)].id}`,
            },
            interaction: {
                _fallback: true,
            },
            common: {
                label: {
                    _fallback: true,
                },
            },
        },
        additionalOptionScopes: [''],
    };
    function draw2(chart, caller, clip) {
        const { ctx, chartArea } = chart;
        const { visibleElements } = chartStates.get(chart);
        if (clip) {
            clipArea(ctx, chartArea);
        }
        const drawableElements = getDrawableElements(
            visibleElements,
            caller
        ).sort((a, b) => a.options.z - b.options.z);
        for (const element of drawableElements) {
            element.draw(chart.ctx, chartArea);
        }
        if (clip) {
            unclipArea(ctx);
        }
    }
    function getDrawableElements(elements2, caller) {
        const drawableElements = [];
        for (const el of elements2) {
            if (el.options.drawTime === caller) {
                drawableElements.push(el);
            }
            if (el.elements && el.elements.length) {
                for (const sub of el.elements) {
                    if (
                        sub.options.display &&
                        sub.options.drawTime === caller
                    ) {
                        drawableElements.push(sub);
                    }
                }
            }
        }
        return drawableElements;
    }

    // node_modules/@sgratzl/boxplots/build/index.js
    var HELPER = Math.sqrt(2 * Math.PI);
    function gaussian(u) {
        return Math.exp(-0.5 * u * u) / HELPER;
    }
    function toSampleVariance(variance, len) {
        return (variance * len) / (len - 1);
    }
    function nrd(iqr, variance, len) {
        let s = Math.sqrt(toSampleVariance(variance, len));
        if (typeof iqr === 'number') {
            s = Math.min(s, iqr / 1.34);
        }
        return 1.06 * s * Math.pow(len, -0.2);
    }
    function kde(stats) {
        const len = stats.items.length;
        const bandwidth = nrd(stats.iqr, stats.variance, len);
        return (x) => {
            let i = 0;
            let sum = 0;
            for (i = 0; i < len; i++) {
                const v = stats.items[i];
                sum += gaussian((x - v) / bandwidth);
            }
            return sum / bandwidth / len;
        };
    }
    function quantilesInterpolate(arr, length, interpolate3) {
        const n1 = length - 1;
        const compute2 = (q) => {
            const index3 = q * n1;
            const lo = Math.floor(index3);
            const h = index3 - lo;
            const a = arr[lo];
            return h === 0 ? a : interpolate3(a, arr[Math.min(lo + 1, n1)], h);
        };
        return {
            q1: compute2(0.25),
            median: compute2(0.5),
            q3: compute2(0.75),
        };
    }
    function quantilesType7(arr, length = arr.length) {
        return quantilesInterpolate(
            arr,
            length,
            (a, b, alpha2) => a + alpha2 * (b - a)
        );
    }
    function quantilesLinear(arr, length = arr.length) {
        return quantilesInterpolate(
            arr,
            length,
            (i, j, fraction) => i + (j - i) * fraction
        );
    }
    function quantilesLower(arr, length = arr.length) {
        return quantilesInterpolate(arr, length, (i) => i);
    }
    function quantilesHigher(arr, length = arr.length) {
        return quantilesInterpolate(arr, length, (_, j) => j);
    }
    function quantilesNearest(arr, length = arr.length) {
        return quantilesInterpolate(arr, length, (i, j, fraction) =>
            fraction < 0.5 ? i : j
        );
    }
    function quantilesMidpoint(arr, length = arr.length) {
        return quantilesInterpolate(arr, length, (i, j) => (i + j) * 0.5);
    }
    function quantilesFivenum(arr, length = arr.length) {
        const n = length;
        const n4 = Math.floor((n + 3) / 2) / 2;
        const compute2 = (d) =>
            0.5 * (arr[Math.floor(d) - 1] + arr[Math.ceil(d) - 1]);
        return {
            q1: compute2(n4),
            median: compute2((n + 1) / 2),
            q3: compute2(n + 1 - n4),
        };
    }
    function quantilesHinges(arr, length = arr.length) {
        return quantilesFivenum(arr, length);
    }
    function createSortedData(data) {
        let valid = 0;
        const { length } = data;
        const vs =
            data instanceof Float64Array
                ? new Float64Array(length)
                : new Float32Array(length);
        for (let i = 0; i < length; i += 1) {
            const v = data[i];
            if (v == null || Number.isNaN(v)) {
                continue;
            }
            vs[valid] = v;
            valid += 1;
        }
        const missing = length - valid;
        if (valid === 0) {
            return {
                min: Number.NaN,
                max: Number.NaN,
                missing,
                s: [],
            };
        }
        const validData = valid === length ? vs : vs.subarray(0, valid);
        validData.sort((a, b) => (a === b ? 0 : a < b ? -1 : 1));
        const min3 = validData[0];
        const max3 = validData[validData.length - 1];
        return {
            min: min3,
            max: max3,
            missing,
            s: validData,
        };
    }
    function withSortedData(data) {
        if (data.length === 0) {
            return {
                min: Number.NaN,
                max: Number.NaN,
                missing: 0,
                s: [],
            };
        }
        const min3 = data[0];
        const max3 = data[data.length - 1];
        return {
            min: min3,
            max: max3,
            missing: 0,
            s: data,
        };
    }
    function computeWhiskers(
        s,
        valid,
        min3,
        max3,
        { eps, quantiles, coef, whiskersMode }
    ) {
        const same = (a, b) => Math.abs(a - b) < eps;
        const { median, q1, q3 } = quantiles(s, valid);
        const iqr = q3 - q1;
        const isCoefValid = typeof coef === 'number' && coef > 0;
        let whiskerLow = isCoefValid ? Math.max(min3, q1 - coef * iqr) : min3;
        let whiskerHigh = isCoefValid ? Math.min(max3, q3 + coef * iqr) : max3;
        const outlierLow = [];
        for (let i = 0; i < valid; i += 1) {
            const v = s[i];
            if (v >= whiskerLow || same(v, whiskerLow)) {
                if (whiskersMode === 'nearest') {
                    whiskerLow = v;
                }
                break;
            }
            if (
                outlierLow.length === 0 ||
                !same(outlierLow[outlierLow.length - 1], v)
            ) {
                outlierLow.push(v);
            }
        }
        const reversedOutlierHigh = [];
        for (let i = valid - 1; i >= 0; i -= 1) {
            const v = s[i];
            if (v <= whiskerHigh || same(v, whiskerHigh)) {
                if (whiskersMode === 'nearest') {
                    whiskerHigh = v;
                }
                break;
            }
            if (
                (reversedOutlierHigh.length === 0 ||
                    !same(
                        reversedOutlierHigh[reversedOutlierHigh.length - 1],
                        v
                    )) &&
                (outlierLow.length === 0 ||
                    !same(outlierLow[outlierLow.length - 1], v))
            ) {
                reversedOutlierHigh.push(v);
            }
        }
        const outlier = outlierLow.concat(reversedOutlierHigh.reverse());
        return {
            median,
            q1,
            q3,
            iqr,
            outlier,
            whiskerHigh,
            whiskerLow,
        };
    }
    function computeStats(s, valid) {
        let mean2 = 0;
        for (let i = 0; i < valid; i++) {
            const v = s[i];
            mean2 += v;
        }
        mean2 /= valid;
        let variance = 0;
        for (let i = 0; i < valid; i++) {
            const v = s[i];
            variance += (v - mean2) * (v - mean2);
        }
        variance /= valid;
        return {
            mean: mean2,
            variance,
        };
    }
    function boxplot(data, options = {}) {
        const fullOptions = {
            coef: 1.5,
            eps: 0.01,
            quantiles: quantilesType7,
            validAndSorted: false,
            whiskersMode: 'nearest',
            ...options,
        };
        const {
            missing,
            s,
            min: min3,
            max: max3,
        } = fullOptions.validAndSorted
            ? withSortedData(data)
            : createSortedData(data);
        const invalid = {
            min: Number.NaN,
            max: Number.NaN,
            mean: Number.NaN,
            missing,
            iqr: Number.NaN,
            count: data.length,
            whiskerHigh: Number.NaN,
            whiskerLow: Number.NaN,
            outlier: [],
            median: Number.NaN,
            q1: Number.NaN,
            q3: Number.NaN,
            variance: 0,
            items: [],
            kde: () => 0,
        };
        const valid = data.length - missing;
        if (valid === 0) {
            return invalid;
        }
        const result = {
            min: min3,
            max: max3,
            count: data.length,
            missing,
            items: s,
            ...computeStats(s, valid),
            ...computeWhiskers(s, valid, min3, max3, fullOptions),
        };
        return {
            ...result,
            kde: kde(result),
        };
    }

    // node_modules/@sgratzl/chartjs-chart-boxplot/build/index.js
    function whiskers(boxplot3, arr, coef = 1.5) {
        const iqr = boxplot3.q3 - boxplot3.q1;
        const coefValid = typeof coef === 'number' && coef > 0;
        let whiskerMin = coefValid
            ? Math.max(boxplot3.min, boxplot3.q1 - coef * iqr)
            : boxplot3.min;
        let whiskerMax = coefValid
            ? Math.min(boxplot3.max, boxplot3.q3 + coef * iqr)
            : boxplot3.max;
        if (Array.isArray(arr)) {
            for (let i = 0; i < arr.length; i += 1) {
                const v = arr[i];
                if (v >= whiskerMin) {
                    whiskerMin = v;
                    break;
                }
            }
            for (let i = arr.length - 1; i >= 0; i -= 1) {
                const v = arr[i];
                if (v <= whiskerMax) {
                    whiskerMax = v;
                    break;
                }
            }
        }
        return {
            whiskerMin,
            whiskerMax,
        };
    }
    var defaultStatsOptions = {
        coef: 1.5,
        quantiles: 7,
    };
    function determineQuantiles(q) {
        if (typeof q === 'function') {
            return q;
        }
        const lookup = {
            hinges: quantilesHinges,
            fivenum: quantilesFivenum,
            7: quantilesType7,
            quantiles: quantilesType7,
            linear: quantilesLinear,
            lower: quantilesLower,
            higher: quantilesHigher,
            nearest: quantilesNearest,
            midpoint: quantilesMidpoint,
        };
        return lookup[q] || quantilesType7;
    }
    function determineStatsOptions(options) {
        const coef =
            options == null || typeof options.coef !== 'number'
                ? defaultStatsOptions.coef
                : options.coef;
        const q =
            options == null || options.quantiles == null
                ? quantilesType7
                : options.quantiles;
        const quantiles = determineQuantiles(q);
        return {
            coef,
            quantiles,
        };
    }
    function boxplotStats(arr, options) {
        const r = boxplot(arr, determineStatsOptions(options));
        return {
            items: Array.from(r.items),
            outliers: r.outlier,
            whiskerMax: r.whiskerHigh,
            whiskerMin: r.whiskerLow,
            max: r.max,
            median: r.median,
            mean: r.mean,
            min: r.min,
            q1: r.q1,
            q3: r.q3,
        };
    }
    function computeSamples(min3, max3, points) {
        const range = max3 - min3;
        const samples = [];
        const inc = range / points;
        for (let v = min3; v <= max3 && inc > 0; v += inc) {
            samples.push(v);
        }
        if (samples[samples.length - 1] !== max3) {
            samples.push(max3);
        }
        return samples;
    }
    function violinStats(arr, options) {
        if (arr.length === 0) {
            return void 0;
        }
        const stats = boxplot(arr, determineStatsOptions(options));
        const samples = computeSamples(stats.min, stats.max, options.points);
        const coords = samples.map((v) => ({ v, estimate: stats.kde(v) }));
        const maxEstimate = coords.reduce(
            (a, d) => Math.max(a, d.estimate),
            Number.NEGATIVE_INFINITY
        );
        return {
            max: stats.max,
            min: stats.min,
            mean: stats.mean,
            median: stats.median,
            q1: stats.q1,
            q3: stats.q3,
            items: Array.from(stats.items),
            coords,
            outliers: [],
            maxEstimate,
        };
    }
    function asBoxPlotStats(value, options) {
        if (!value) {
            return void 0;
        }
        if (
            typeof value.median === 'number' &&
            typeof value.q1 === 'number' &&
            typeof value.q3 === 'number'
        ) {
            if (typeof value.whiskerMin === 'undefined') {
                const { coef } = determineStatsOptions(options);
                const { whiskerMin, whiskerMax } = whiskers(
                    value,
                    Array.isArray(value.items)
                        ? value.items.slice().sort((a, b) => a - b)
                        : null,
                    coef
                );
                value.whiskerMin = whiskerMin;
                value.whiskerMax = whiskerMax;
            }
            return value;
        }
        if (!Array.isArray(value)) {
            return void 0;
        }
        return boxplotStats(value, options);
    }
    function asViolinStats(value, options) {
        if (!value) {
            return void 0;
        }
        if (typeof value.median === 'number' && Array.isArray(value.coords)) {
            return value;
        }
        if (!Array.isArray(value)) {
            return void 0;
        }
        return violinStats(value, options);
    }
    function rnd(seed = Date.now()) {
        let s = seed;
        return () => {
            s = (s * 9301 + 49297) % 233280;
            return s / 233280;
        };
    }
    var baseDefaults$1 = {
        borderWidth: 1,
        outlierStyle: 'circle',
        outlierRadius: 2,
        outlierBorderWidth: 1,
        itemStyle: 'circle',
        itemRadius: 0,
        itemBorderWidth: 0,
        meanStyle: 'circle',
        meanRadius: 3,
        meanBorderWidth: 1,
        hitPadding: 2,
        outlierHitRadius: 4,
    };
    var baseRoutes = {
        outlierBackgroundColor: 'backgroundColor',
        outlierBorderColor: 'borderColor',
        itemBackgroundColor: 'backgroundColor',
        itemBorderColor: 'borderColor',
        meanBackgroundColor: 'backgroundColor',
        meanBorderColor: 'borderColor',
    };
    var baseOptionKeys = (() =>
        Object.keys(baseDefaults$1).concat(Object.keys(baseRoutes)))();
    var StatsBase$1 = class extends Element {
        isVertical() {
            return !this.horizontal;
        }
        _drawItems(ctx) {
            const vert = this.isVertical();
            const props = this.getProps([
                'x',
                'y',
                'items',
                'width',
                'height',
                'outliers',
            ]);
            const { options } = this;
            if (
                options.itemRadius <= 0 ||
                !props.items ||
                props.items.length <= 0
            ) {
                return;
            }
            ctx.save();
            ctx.strokeStyle = options.itemBorderColor;
            ctx.fillStyle = options.itemBackgroundColor;
            ctx.lineWidth = options.itemBorderWidth;
            const random = rnd(this._datasetIndex * 1e3 + this._index);
            const pointOptions = {
                pointStyle: options.itemStyle,
                radius: options.itemRadius,
                borderWidth: options.itemBorderWidth,
            };
            const outliers = new Set(props.outliers || []);
            if (vert) {
                props.items.forEach((v) => {
                    if (!outliers.has(v)) {
                        drawPoint(
                            ctx,
                            pointOptions,
                            props.x - props.width / 2 + random() * props.width,
                            v
                        );
                    }
                });
            } else {
                props.items.forEach((v) => {
                    if (!outliers.has(v)) {
                        drawPoint(
                            ctx,
                            pointOptions,
                            v,
                            props.y - props.height / 2 + random() * props.height
                        );
                    }
                });
            }
            ctx.restore();
        }
        _drawOutliers(ctx) {
            const vert = this.isVertical();
            const props = this.getProps(['x', 'y', 'outliers']);
            const { options } = this;
            if (
                options.outlierRadius <= 0 ||
                !props.outliers ||
                props.outliers.length === 0
            ) {
                return;
            }
            ctx.save();
            ctx.fillStyle = options.outlierBackgroundColor;
            ctx.strokeStyle = options.outlierBorderColor;
            ctx.lineWidth = options.outlierBorderWidth;
            const pointOptions = {
                pointStyle: options.outlierStyle,
                radius: options.outlierRadius,
                borderWidth: options.outlierBorderWidth,
            };
            if (vert) {
                props.outliers.forEach((v) => {
                    drawPoint(ctx, pointOptions, props.x, v);
                });
            } else {
                props.outliers.forEach((v) => {
                    drawPoint(ctx, pointOptions, v, props.y);
                });
            }
            ctx.restore();
        }
        _drawMeanDot(ctx) {
            const vert = this.isVertical();
            const props = this.getProps(['x', 'y', 'mean']);
            const { options } = this;
            if (
                options.meanRadius <= 0 ||
                props.mean == null ||
                Number.isNaN(props.mean)
            ) {
                return;
            }
            ctx.save();
            ctx.fillStyle = options.meanBackgroundColor;
            ctx.strokeStyle = options.meanBorderColor;
            ctx.lineWidth = options.meanBorderWidth;
            const pointOptions = {
                pointStyle: options.meanStyle,
                radius: options.meanRadius,
                borderWidth: options.meanBorderWidth,
            };
            if (vert) {
                drawPoint(ctx, pointOptions, props.x, props.mean);
            } else {
                drawPoint(ctx, pointOptions, props.mean, props.y);
            }
            ctx.restore();
        }
        _getBounds(_useFinalPosition) {
            return {
                left: 0,
                top: 0,
                right: 0,
                bottom: 0,
            };
        }
        _getHitBounds(useFinalPosition) {
            const padding = this.options.hitPadding;
            const b = this._getBounds(useFinalPosition);
            return {
                left: b.left - padding,
                top: b.top - padding,
                right: b.right + padding,
                bottom: b.bottom + padding,
            };
        }
        inRange(mouseX, mouseY, useFinalPosition) {
            if (Number.isNaN(this.x) && Number.isNaN(this.y)) {
                return false;
            }
            return (
                this._boxInRange(mouseX, mouseY, useFinalPosition) ||
                this._outlierIndexInRange(mouseX, mouseY, useFinalPosition) >= 0
            );
        }
        inXRange(mouseX, useFinalPosition) {
            const bounds = this._getHitBounds(useFinalPosition);
            return mouseX >= bounds.left && mouseX <= bounds.right;
        }
        inYRange(mouseY, useFinalPosition) {
            const bounds = this._getHitBounds(useFinalPosition);
            return mouseY >= bounds.top && mouseY <= bounds.bottom;
        }
        _outlierIndexInRange(mouseX, mouseY, useFinalPosition) {
            const props = this.getProps(['x', 'y'], useFinalPosition);
            const hitRadius = this.options.outlierHitRadius;
            const outliers = this._getOutliers(useFinalPosition);
            const vertical = this.isVertical();
            if (
                (vertical && Math.abs(mouseX - props.x) > hitRadius) ||
                (!vertical && Math.abs(mouseY - props.y) > hitRadius)
            ) {
                return -1;
            }
            const toCompare = vertical ? mouseY : mouseX;
            for (let i = 0; i < outliers.length; i += 1) {
                if (Math.abs(outliers[i] - toCompare) <= hitRadius) {
                    return i;
                }
            }
            return -1;
        }
        _boxInRange(mouseX, mouseY, useFinalPosition) {
            const bounds = this._getHitBounds(useFinalPosition);
            return (
                mouseX >= bounds.left &&
                mouseX <= bounds.right &&
                mouseY >= bounds.top &&
                mouseY <= bounds.bottom
            );
        }
        getCenterPoint(useFinalPosition) {
            const props = this.getProps(['x', 'y'], useFinalPosition);
            return {
                x: props.x,
                y: props.y,
            };
        }
        _getOutliers(useFinalPosition) {
            const props = this.getProps(['outliers'], useFinalPosition);
            return props.outliers || [];
        }
        tooltipPosition(eventPosition, tooltip5) {
            if (!eventPosition || typeof eventPosition === 'boolean') {
                return this.getCenterPoint();
            }
            if (tooltip5) {
                delete tooltip5._tooltipOutlier;
            }
            const props = this.getProps(['x', 'y']);
            const index3 = this._outlierIndexInRange(
                eventPosition.x,
                eventPosition.y
            );
            if (index3 < 0 || !tooltip5) {
                return this.getCenterPoint();
            }
            tooltip5._tooltipOutlier = {
                index: index3,
                datasetIndex: this._datasetIndex,
            };
            if (this.isVertical()) {
                return {
                    x: props.x,
                    y: this._getOutliers()[index3],
                };
            }
            return {
                x: this._getOutliers()[index3],
                y: props.y,
            };
        }
    };
    var boxOptionsKeys = baseOptionKeys.concat([
        'medianColor',
        'lowerBackgroundColor',
    ]);
    var BoxAndWiskers = class extends StatsBase$1 {
        draw(ctx) {
            ctx.save();
            ctx.fillStyle = this.options.backgroundColor;
            ctx.strokeStyle = this.options.borderColor;
            ctx.lineWidth = this.options.borderWidth;
            this._drawBoxPlot(ctx);
            this._drawOutliers(ctx);
            this._drawMeanDot(ctx);
            ctx.restore();
            this._drawItems(ctx);
        }
        _drawBoxPlot(ctx) {
            if (this.isVertical()) {
                this._drawBoxPlotVertical(ctx);
            } else {
                this._drawBoxPlotHorizontal(ctx);
            }
        }
        _drawBoxPlotVertical(ctx) {
            const { options } = this;
            const props = this.getProps([
                'x',
                'width',
                'q1',
                'q3',
                'median',
                'whiskerMin',
                'whiskerMax',
            ]);
            const { x } = props;
            const { width } = props;
            const x0 = x - width / 2;
            if (props.q3 > props.q1) {
                ctx.fillRect(x0, props.q1, width, props.q3 - props.q1);
            } else {
                ctx.fillRect(x0, props.q3, width, props.q1 - props.q3);
            }
            ctx.save();
            if (
                options.medianColor &&
                options.medianColor !== 'transparent' &&
                options.medianColor !== '#0000'
            ) {
                ctx.strokeStyle = options.medianColor;
            }
            ctx.beginPath();
            ctx.moveTo(x0, props.median);
            ctx.lineTo(x0 + width, props.median);
            ctx.closePath();
            ctx.stroke();
            ctx.restore();
            ctx.save();
            if (
                options.lowerBackgroundColor &&
                options.lowerBackgroundColor !== 'transparent' &&
                options.lowerBackgroundColor !== '#0000'
            ) {
                ctx.fillStyle = options.lowerBackgroundColor;
                if (props.q3 > props.q1) {
                    ctx.fillRect(
                        x0,
                        props.median,
                        width,
                        props.q3 - props.median
                    );
                } else {
                    ctx.fillRect(
                        x0,
                        props.median,
                        width,
                        props.q1 - props.median
                    );
                }
            }
            ctx.restore();
            if (props.q3 > props.q1) {
                ctx.strokeRect(x0, props.q1, width, props.q3 - props.q1);
            } else {
                ctx.strokeRect(x0, props.q3, width, props.q1 - props.q3);
            }
            ctx.beginPath();
            ctx.moveTo(x0, props.whiskerMin);
            ctx.lineTo(x0 + width, props.whiskerMin);
            ctx.moveTo(x, props.whiskerMin);
            ctx.lineTo(x, props.q1);
            ctx.moveTo(x0, props.whiskerMax);
            ctx.lineTo(x0 + width, props.whiskerMax);
            ctx.moveTo(x, props.whiskerMax);
            ctx.lineTo(x, props.q3);
            ctx.closePath();
            ctx.stroke();
        }
        _drawBoxPlotHorizontal(ctx) {
            const { options } = this;
            const props = this.getProps([
                'y',
                'height',
                'q1',
                'q3',
                'median',
                'whiskerMin',
                'whiskerMax',
            ]);
            const { y } = props;
            const { height } = props;
            const y0 = y - height / 2;
            if (props.q3 > props.q1) {
                ctx.fillRect(props.q1, y0, props.q3 - props.q1, height);
            } else {
                ctx.fillRect(props.q3, y0, props.q1 - props.q3, height);
            }
            ctx.save();
            if (options.medianColor && options.medianColor !== 'transparent') {
                ctx.strokeStyle = options.medianColor;
            }
            ctx.beginPath();
            ctx.moveTo(props.median, y0);
            ctx.lineTo(props.median, y0 + height);
            ctx.closePath();
            ctx.stroke();
            ctx.restore();
            ctx.save();
            if (
                options.lowerBackgroundColor &&
                options.lowerBackgroundColor !== 'transparent'
            ) {
                ctx.fillStyle = options.lowerBackgroundColor;
                if (props.q3 > props.q1) {
                    ctx.fillRect(
                        props.median,
                        y0,
                        props.q3 - props.median,
                        height
                    );
                } else {
                    ctx.fillRect(
                        props.median,
                        y0,
                        props.q1 - props.median,
                        height
                    );
                }
            }
            ctx.restore();
            if (props.q3 > props.q1) {
                ctx.strokeRect(props.q1, y0, props.q3 - props.q1, height);
            } else {
                ctx.strokeRect(props.q3, y0, props.q1 - props.q3, height);
            }
            ctx.beginPath();
            ctx.moveTo(props.whiskerMin, y0);
            ctx.lineTo(props.whiskerMin, y0 + height);
            ctx.moveTo(props.whiskerMin, y);
            ctx.lineTo(props.q1, y);
            ctx.moveTo(props.whiskerMax, y0);
            ctx.lineTo(props.whiskerMax, y0 + height);
            ctx.moveTo(props.whiskerMax, y);
            ctx.lineTo(props.q3, y);
            ctx.closePath();
            ctx.stroke();
        }
        _getBounds(useFinalPosition) {
            const vert = this.isVertical();
            if (this.x == null) {
                return {
                    left: 0,
                    top: 0,
                    right: 0,
                    bottom: 0,
                };
            }
            if (vert) {
                const {
                    x,
                    width,
                    whiskerMax: whiskerMax2,
                    whiskerMin: whiskerMin2,
                } = this.getProps(
                    ['x', 'width', 'whiskerMin', 'whiskerMax'],
                    useFinalPosition
                );
                const x0 = x - width / 2;
                return {
                    left: x0,
                    top: whiskerMax2,
                    right: x0 + width,
                    bottom: whiskerMin2,
                };
            }
            const { y, height, whiskerMax, whiskerMin } = this.getProps(
                ['y', 'height', 'whiskerMin', 'whiskerMax'],
                useFinalPosition
            );
            const y0 = y - height / 2;
            return {
                left: whiskerMin,
                top: y0,
                right: whiskerMax,
                bottom: y0 + height,
            };
        }
    };
    BoxAndWiskers.id = 'boxandwhiskers';
    BoxAndWiskers.defaults = {
        ...BarElement.defaults,
        ...baseDefaults$1,
        medianColor: 'transparent',
        lowerBackgroundColor: 'transparent',
    };
    BoxAndWiskers.defaultRoutes = {
        ...BarElement.defaultRoutes,
        ...baseRoutes,
    };
    var Violin = class extends StatsBase$1 {
        draw(ctx) {
            ctx.save();
            ctx.fillStyle = this.options.backgroundColor;
            ctx.strokeStyle = this.options.borderColor;
            ctx.lineWidth = this.options.borderWidth;
            const props = this.getProps([
                'x',
                'y',
                'median',
                'width',
                'height',
                'min',
                'max',
                'coords',
                'maxEstimate',
            ]);
            if (props.median != null) {
                drawPoint(
                    ctx,
                    {
                        pointStyle: 'rectRot',
                        radius: 5,
                        borderWidth: this.options.borderWidth,
                    },
                    props.x,
                    props.y
                );
            }
            if (props.coords && props.coords.length > 0) {
                this._drawCoords(ctx, props);
            }
            this._drawOutliers(ctx);
            this._drawMeanDot(ctx);
            ctx.restore();
            this._drawItems(ctx);
        }
        _drawCoords(ctx, props) {
            let maxEstimate;
            if (props.maxEstimate == null) {
                maxEstimate = props.coords.reduce(
                    (a, d) => Math.max(a, d.estimate),
                    Number.NEGATIVE_INFINITY
                );
            } else {
                maxEstimate = props.maxEstimate;
            }
            if (this.isVertical()) {
                const { x, width } = props;
                const factor = width / 2 / maxEstimate;
                ctx.moveTo(x, props.min);
                props.coords.forEach((c) => {
                    ctx.lineTo(x - c.estimate * factor, c.v);
                });
                ctx.lineTo(x, props.max);
                ctx.moveTo(x, props.min);
                props.coords.forEach((c) => {
                    ctx.lineTo(x + c.estimate * factor, c.v);
                });
                ctx.lineTo(x, props.max);
            } else {
                const { y, height } = props;
                const factor = height / 2 / maxEstimate;
                ctx.moveTo(props.min, y);
                props.coords.forEach((c) => {
                    ctx.lineTo(c.v, y - c.estimate * factor);
                });
                ctx.lineTo(props.max, y);
                ctx.moveTo(props.min, y);
                props.coords.forEach((c) => {
                    ctx.lineTo(c.v, y + c.estimate * factor);
                });
                ctx.lineTo(props.max, y);
            }
            ctx.closePath();
            ctx.stroke();
            ctx.fill();
        }
        _getBounds(useFinalPosition) {
            if (this.isVertical()) {
                const {
                    x,
                    width,
                    min: min4,
                    max: max4,
                } = this.getProps(
                    ['x', 'width', 'min', 'max'],
                    useFinalPosition
                );
                const x0 = x - width / 2;
                return {
                    left: x0,
                    top: max4,
                    right: x0 + width,
                    bottom: min4,
                };
            }
            const {
                y,
                height,
                min: min3,
                max: max3,
            } = this.getProps(['y', 'height', 'min', 'max'], useFinalPosition);
            const y0 = y - height / 2;
            return {
                left: min3,
                top: y0,
                right: max3,
                bottom: y0 + height,
            };
        }
    };
    Violin.id = 'violin';
    Violin.defaults = { ...BarElement.defaults, ...baseDefaults$1 };
    Violin.defaultRoutes = { ...BarElement.defaultRoutes, ...baseRoutes };
    var interpolators2 = {
        number(from2, to2, factor) {
            if (from2 === to2) {
                return to2;
            }
            if (from2 == null) {
                return to2;
            }
            if (to2 == null) {
                return from2;
            }
            return from2 + (to2 - from2) * factor;
        },
    };
    function interpolateNumberArray(from2, to2, factor) {
        if (typeof from2 === 'number' && typeof to2 === 'number') {
            return interpolators2.number(from2, to2, factor);
        }
        if (Array.isArray(from2) && Array.isArray(to2)) {
            return to2.map((t, i) =>
                interpolators2.number(from2[i], t, factor)
            );
        }
        return to2;
    }
    function interpolateKdeCoords(from2, to2, factor) {
        if (Array.isArray(from2) && Array.isArray(to2)) {
            return to2.map((t, i) => ({
                v: interpolators2.number(
                    from2[i] ? from2[i].v : null,
                    t.v,
                    factor
                ),
                estimate: interpolators2.number(
                    from2[i] ? from2[i].estimate : null,
                    t.estimate,
                    factor
                ),
            }));
        }
        return to2;
    }
    function patchInHoveredOutlier(item) {
        const value = item.formattedValue;
        const that = this;
        if (
            value &&
            that._tooltipOutlier != null &&
            item.datasetIndex === that._tooltipOutlier.datasetIndex
        ) {
            value.hoveredOutlierIndex = that._tooltipOutlier.index;
        }
    }
    function outlierPositioner(items, eventPosition) {
        if (!items.length) {
            return false;
        }
        let x = 0;
        let y = 0;
        let count = 0;
        for (let i = 0; i < items.length; i += 1) {
            const el = items[i].element;
            if (el && el.hasValue()) {
                const pos = el.tooltipPosition(eventPosition, this);
                x += pos.x;
                y += pos.y;
                count += 1;
            }
        }
        return {
            x: x / count,
            y: y / count,
        };
    }
    outlierPositioner.id = 'average';
    outlierPositioner.register = () => {
        plugin_tooltip.positioners.average = outlierPositioner;
        return outlierPositioner;
    };
    function baseDefaults(keys) {
        const colorKeys = ['borderColor', 'backgroundColor'].concat(
            keys.filter((c) => c.endsWith('Color'))
        );
        return {
            animations: {
                numberArray: {
                    fn: interpolateNumberArray,
                    properties: ['outliers', 'items'],
                },
                colors: {
                    type: 'color',
                    properties: colorKeys,
                },
            },
            transitions: {
                show: {
                    animations: {
                        colors: {
                            type: 'color',
                            properties: colorKeys,
                            from: 'transparent',
                        },
                    },
                },
                hide: {
                    animations: {
                        colors: {
                            type: 'color',
                            properties: colorKeys,
                            to: 'transparent',
                        },
                    },
                },
            },
            minStats: 'min',
            maxStats: 'max',
            ...defaultStatsOptions,
        };
    }
    function defaultOverrides() {
        return {
            plugins: {
                tooltip: {
                    position: outlierPositioner.register().id,
                    callbacks: {
                        beforeLabel: patchInHoveredOutlier,
                    },
                },
            },
        };
    }
    var StatsBase = class extends BarController {
        _transformStats(target, source, mapper) {
            for (const key of ['min', 'max', 'median', 'q3', 'q1', 'mean']) {
                const v = source[key];
                if (typeof v === 'number') {
                    target[key] = mapper(v);
                }
            }
            for (const key of ['outliers', 'items']) {
                if (Array.isArray(source[key])) {
                    target[key] = source[key].map(mapper);
                }
            }
        }
        getMinMax(scale, canStack) {
            const bak = scale.axis;
            const config = this.options;
            scale.axis = config.minStats;
            const { min: min3 } = super.getMinMax(scale, canStack);
            scale.axis = config.maxStats;
            const { max: max3 } = super.getMinMax(scale, canStack);
            scale.axis = bak;
            return { min: min3, max: max3 };
        }
        parsePrimitiveData(meta, data, start2, count) {
            const vScale = meta.vScale;
            const iScale = meta.iScale;
            const labels = iScale.getLabels();
            const r = [];
            for (let i = 0; i < count; i += 1) {
                const index3 = i + start2;
                const parsed = {};
                parsed[iScale.axis] = iScale.parse(labels[index3], index3);
                const stats = this._parseStats(
                    data == null ? null : data[index3],
                    this.options
                );
                if (stats) {
                    Object.assign(parsed, stats);
                    parsed[vScale.axis] = stats.median;
                }
                r.push(parsed);
            }
            return r;
        }
        parseArrayData(meta, data, start2, count) {
            return this.parsePrimitiveData(meta, data, start2, count);
        }
        parseObjectData(meta, data, start2, count) {
            return this.parsePrimitiveData(meta, data, start2, count);
        }
        getLabelAndValue(index3) {
            const r = super.getLabelAndValue(index3);
            const { vScale } = this._cachedMeta;
            const parsed = this.getParsed(index3);
            if (!vScale || !parsed || r.value === 'NaN') {
                return r;
            }
            r.value = {
                raw: parsed,
                hoveredOutlierIndex: -1,
            };
            this._transformStats(r.value, parsed, (v) =>
                vScale.getLabelForValue(v)
            );
            const s = this._toStringStats(r.value.raw);
            r.value.toString = function toString() {
                if (this.hoveredOutlierIndex >= 0) {
                    return `(outlier: ${
                        this.outliers[this.hoveredOutlierIndex]
                    })`;
                }
                return s;
            };
            return r;
        }
        _toStringStats(b) {
            const f = (v) =>
                v == null
                    ? 'NaN'
                    : formatNumber(v, this.chart.options.locale, {});
            return `(min: ${f(b.min)}, 25% quantile: ${f(b.q1)}, median: ${f(
                b.median
            )}, mean: ${f(b.mean)}, 75% quantile: ${f(b.q3)}, max: ${f(
                b.max
            )})`;
        }
        updateElement(rectangle, index3, properties, mode) {
            const reset = mode === 'reset';
            const scale = this._cachedMeta.vScale;
            const parsed = this.getParsed(index3);
            const base = scale.getBasePixel();
            properties._datasetIndex = this.index;
            properties._index = index3;
            this._transformStats(properties, parsed, (v) =>
                reset ? base : scale.getPixelForValue(v, index3)
            );
            super.updateElement(rectangle, index3, properties, mode);
        }
    };
    function patchController(
        type2,
        config,
        controller,
        elements2 = [],
        scales2 = []
    ) {
        registry.addControllers(controller);
        if (Array.isArray(elements2)) {
            registry.addElements(...elements2);
        } else {
            registry.addElements(elements2);
        }
        if (Array.isArray(scales2)) {
            registry.addScales(...scales2);
        } else {
            registry.addScales(scales2);
        }
        const c = config;
        c.type = type2;
        return c;
    }
    var BoxPlotController = class extends StatsBase {
        _parseStats(value, config) {
            return asBoxPlotStats(value, config);
        }
        _transformStats(target, source, mapper) {
            super._transformStats(target, source, mapper);
            for (const key of ['whiskerMin', 'whiskerMax']) {
                target[key] = mapper(source[key]);
            }
        }
    };
    BoxPlotController.id = 'boxplot';
    BoxPlotController.defaults = merge({}, [
        BarController.defaults,
        baseDefaults(boxOptionsKeys),
        {
            animations: {
                numbers: {
                    type: 'number',
                    properties:
                        BarController.defaults.animations.numbers.properties.concat(
                            [
                                'q1',
                                'q3',
                                'min',
                                'max',
                                'median',
                                'whiskerMin',
                                'whiskerMax',
                                'mean',
                            ],
                            boxOptionsKeys.filter((c) => !c.endsWith('Color'))
                        ),
                },
            },
            dataElementType: BoxAndWiskers.id,
        },
    ]);
    BoxPlotController.overrides = merge({}, [
        BarController.overrides,
        defaultOverrides(),
    ]);
    var BoxPlotChart = class extends Chart {
        constructor(item, config) {
            super(
                item,
                patchController(
                    'boxplot',
                    config,
                    BoxPlotController,
                    BoxAndWiskers,
                    [LinearScale, CategoryScale]
                )
            );
        }
    };
    BoxPlotChart.id = BoxPlotController.id;
    var ViolinController = class extends StatsBase {
        _parseStats(value, config) {
            return asViolinStats(value, config);
        }
        _transformStats(target, source, mapper) {
            super._transformStats(target, source, mapper);
            target.maxEstimate = source.maxEstimate;
            if (Array.isArray(source.coords)) {
                target.coords = source.coords.map((c) => ({
                    ...c,
                    v: mapper(c.v),
                }));
            }
        }
    };
    ViolinController.id = 'violin';
    ViolinController.defaults = merge({}, [
        BarController.defaults,
        baseDefaults(baseOptionKeys),
        {
            points: 100,
            animations: {
                numbers: {
                    type: 'number',
                    properties:
                        BarController.defaults.animations.numbers.properties.concat(
                            ['q1', 'q3', 'min', 'max', 'median', 'maxEstimate'],
                            baseOptionKeys.filter((c) => !c.endsWith('Color'))
                        ),
                },
                kdeCoords: {
                    fn: interpolateKdeCoords,
                    properties: ['coords'],
                },
            },
            dataElementType: Violin.id,
        },
    ]);
    ViolinController.overrides = merge({}, [
        BarController.overrides,
        defaultOverrides(),
    ]);
    var ViolinChart = class extends Chart {
        constructor(item, config) {
            super(
                item,
                patchController('violin', config, ViolinController, Violin, [
                    LinearScale,
                    CategoryScale,
                ])
            );
        }
    };
    ViolinChart.id = ViolinController.id;

    // node_modules/d3-array/src/ascending.js
    function ascending(a, b) {
        return a == null || b == null
            ? NaN
            : a < b
            ? -1
            : a > b
            ? 1
            : a >= b
            ? 0
            : NaN;
    }

    // node_modules/d3-array/src/descending.js
    function descending(a, b) {
        return a == null || b == null
            ? NaN
            : b < a
            ? -1
            : b > a
            ? 1
            : b >= a
            ? 0
            : NaN;
    }

    // node_modules/internmap/src/index.js
    var InternMap = class extends Map {
        constructor(entries, key = keyof) {
            super();
            Object.defineProperties(this, {
                _intern: { value: /* @__PURE__ */ new Map() },
                _key: { value: key },
            });
            if (entries != null)
                for (const [key2, value] of entries) this.set(key2, value);
        }
        get(key) {
            return super.get(intern_get(this, key));
        }
        has(key) {
            return super.has(intern_get(this, key));
        }
        set(key, value) {
            return super.set(intern_set(this, key), value);
        }
        delete(key) {
            return super.delete(intern_delete(this, key));
        }
    };
    function intern_get({ _intern, _key }, value) {
        const key = _key(value);
        return _intern.has(key) ? _intern.get(key) : value;
    }
    function intern_set({ _intern, _key }, value) {
        const key = _key(value);
        if (_intern.has(key)) return _intern.get(key);
        _intern.set(key, value);
        return value;
    }
    function intern_delete({ _intern, _key }, value) {
        const key = _key(value);
        if (_intern.has(key)) {
            value = _intern.get(key);
            _intern.delete(key);
        }
        return value;
    }
    function keyof(value) {
        return value !== null && typeof value === 'object'
            ? value.valueOf()
            : value;
    }

    // node_modules/d3-array/src/identity.js
    function identity(x) {
        return x;
    }

    // node_modules/d3-array/src/group.js
    function group(values, ...keys) {
        return nest(values, identity, identity, keys);
    }
    function rollup(values, reduce, ...keys) {
        return nest(values, identity, reduce, keys);
    }
    function rollups(values, reduce, ...keys) {
        return nest(values, Array.from, reduce, keys);
    }
    function nest(values, map4, reduce, keys) {
        return (function regroup(values2, i) {
            if (i >= keys.length) return reduce(values2);
            const groups2 = new InternMap();
            const keyof2 = keys[i++];
            let index3 = -1;
            for (const value of values2) {
                const key = keyof2(value, ++index3, values2);
                const group2 = groups2.get(key);
                if (group2) group2.push(value);
                else groups2.set(key, [value]);
            }
            for (const [key, values3] of groups2) {
                groups2.set(key, regroup(values3, i));
            }
            return map4(groups2);
        })(values, 0);
    }

    // node_modules/d3-array/src/max.js
    function max(values, valueof) {
        let max3;
        if (valueof === void 0) {
            for (const value of values) {
                if (
                    value != null &&
                    (max3 < value || (max3 === void 0 && value >= value))
                ) {
                    max3 = value;
                }
            }
        } else {
            let index3 = -1;
            for (let value of values) {
                if (
                    (value = valueof(value, ++index3, values)) != null &&
                    (max3 < value || (max3 === void 0 && value >= value))
                ) {
                    max3 = value;
                }
            }
        }
        return max3;
    }

    // node_modules/d3-array/src/min.js
    function min(values, valueof) {
        let min3;
        if (valueof === void 0) {
            for (const value of values) {
                if (
                    value != null &&
                    (min3 > value || (min3 === void 0 && value >= value))
                ) {
                    min3 = value;
                }
            }
        } else {
            let index3 = -1;
            for (let value of values) {
                if (
                    (value = valueof(value, ++index3, values)) != null &&
                    (min3 > value || (min3 === void 0 && value >= value))
                ) {
                    min3 = value;
                }
            }
        }
        return min3;
    }

    // node_modules/d3-array/src/mean.js
    function mean(values, valueof) {
        let count = 0;
        let sum = 0;
        if (valueof === void 0) {
            for (let value of values) {
                if (value != null && (value = +value) >= value) {
                    ++count, (sum += value);
                }
            }
        } else {
            let index3 = -1;
            for (let value of values) {
                if (
                    (value = valueof(value, ++index3, values)) != null &&
                    (value = +value) >= value
                ) {
                    ++count, (sum += value);
                }
            }
        }
        if (count) return sum / count;
    }

    // node_modules/d3-dispatch/src/dispatch.js
    var noop2 = { value: () => {} };
    function dispatch() {
        for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
            if (!(t = arguments[i] + '') || t in _ || /[\s.]/.test(t))
                throw new Error('illegal type: ' + t);
            _[t] = [];
        }
        return new Dispatch(_);
    }
    function Dispatch(_) {
        this._ = _;
    }
    function parseTypenames(typenames, types) {
        return typenames
            .trim()
            .split(/^|\s+/)
            .map(function (t) {
                var name = '',
                    i = t.indexOf('.');
                if (i >= 0) (name = t.slice(i + 1)), (t = t.slice(0, i));
                if (t && !types.hasOwnProperty(t))
                    throw new Error('unknown type: ' + t);
                return { type: t, name };
            });
    }
    Dispatch.prototype = dispatch.prototype = {
        constructor: Dispatch,
        on: function (typename, callback2) {
            var _ = this._,
                T = parseTypenames(typename + '', _),
                t,
                i = -1,
                n = T.length;
            if (arguments.length < 2) {
                while (++i < n)
                    if (
                        (t = (typename = T[i]).type) &&
                        (t = get(_[t], typename.name))
                    )
                        return t;
                return;
            }
            if (callback2 != null && typeof callback2 !== 'function')
                throw new Error('invalid callback: ' + callback2);
            while (++i < n) {
                if ((t = (typename = T[i]).type))
                    _[t] = set2(_[t], typename.name, callback2);
                else if (callback2 == null)
                    for (t in _) _[t] = set2(_[t], typename.name, null);
            }
            return this;
        },
        copy: function () {
            var copy = {},
                _ = this._;
            for (var t in _) copy[t] = _[t].slice();
            return new Dispatch(copy);
        },
        call: function (type2, that) {
            if ((n = arguments.length - 2) > 0)
                for (var args = new Array(n), i = 0, n, t; i < n; ++i)
                    args[i] = arguments[i + 2];
            if (!this._.hasOwnProperty(type2))
                throw new Error('unknown type: ' + type2);
            for (t = this._[type2], i = 0, n = t.length; i < n; ++i)
                t[i].value.apply(that, args);
        },
        apply: function (type2, that, args) {
            if (!this._.hasOwnProperty(type2))
                throw new Error('unknown type: ' + type2);
            for (var t = this._[type2], i = 0, n = t.length; i < n; ++i)
                t[i].value.apply(that, args);
        },
    };
    function get(type2, name) {
        for (var i = 0, n = type2.length, c; i < n; ++i) {
            if ((c = type2[i]).name === name) {
                return c.value;
            }
        }
    }
    function set2(type2, name, callback2) {
        for (var i = 0, n = type2.length; i < n; ++i) {
            if (type2[i].name === name) {
                (type2[i] = noop2),
                    (type2 = type2.slice(0, i).concat(type2.slice(i + 1)));
                break;
            }
        }
        if (callback2 != null) type2.push({ name, value: callback2 });
        return type2;
    }
    var dispatch_default = dispatch;

    // node_modules/d3-selection/src/namespaces.js
    var xhtml = 'http://www.w3.org/1999/xhtml';
    var namespaces_default = {
        svg: 'http://www.w3.org/2000/svg',
        xhtml,
        xlink: 'http://www.w3.org/1999/xlink',
        xml: 'http://www.w3.org/XML/1998/namespace',
        xmlns: 'http://www.w3.org/2000/xmlns/',
    };

    // node_modules/d3-selection/src/namespace.js
    function namespace_default(name) {
        var prefix = (name += ''),
            i = prefix.indexOf(':');
        if (i >= 0 && (prefix = name.slice(0, i)) !== 'xmlns')
            name = name.slice(i + 1);
        return namespaces_default.hasOwnProperty(prefix)
            ? { space: namespaces_default[prefix], local: name }
            : name;
    }

    // node_modules/d3-selection/src/creator.js
    function creatorInherit(name) {
        return function () {
            var document2 = this.ownerDocument,
                uri = this.namespaceURI;
            return uri === xhtml &&
                document2.documentElement.namespaceURI === xhtml
                ? document2.createElement(name)
                : document2.createElementNS(uri, name);
        };
    }
    function creatorFixed(fullname) {
        return function () {
            return this.ownerDocument.createElementNS(
                fullname.space,
                fullname.local
            );
        };
    }
    function creator_default(name) {
        var fullname = namespace_default(name);
        return (fullname.local ? creatorFixed : creatorInherit)(fullname);
    }

    // node_modules/d3-selection/src/selector.js
    function none() {}
    function selector_default(selector) {
        return selector == null
            ? none
            : function () {
                  return this.querySelector(selector);
              };
    }

    // node_modules/d3-selection/src/selection/select.js
    function select_default(select) {
        if (typeof select !== 'function') select = selector_default(select);
        for (
            var groups2 = this._groups,
                m = groups2.length,
                subgroups = new Array(m),
                j = 0;
            j < m;
            ++j
        ) {
            for (
                var group2 = groups2[j],
                    n = group2.length,
                    subgroup = (subgroups[j] = new Array(n)),
                    node,
                    subnode,
                    i = 0;
                i < n;
                ++i
            ) {
                if (
                    (node = group2[i]) &&
                    (subnode = select.call(node, node.__data__, i, group2))
                ) {
                    if ('__data__' in node) subnode.__data__ = node.__data__;
                    subgroup[i] = subnode;
                }
            }
        }
        return new Selection(subgroups, this._parents);
    }

    // node_modules/d3-selection/src/array.js
    function array(x) {
        return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
    }

    // node_modules/d3-selection/src/selectorAll.js
    function empty() {
        return [];
    }
    function selectorAll_default(selector) {
        return selector == null
            ? empty
            : function () {
                  return this.querySelectorAll(selector);
              };
    }

    // node_modules/d3-selection/src/selection/selectAll.js
    function arrayAll(select) {
        return function () {
            return array(select.apply(this, arguments));
        };
    }
    function selectAll_default(select) {
        if (typeof select === 'function') select = arrayAll(select);
        else select = selectorAll_default(select);
        for (
            var groups2 = this._groups,
                m = groups2.length,
                subgroups = [],
                parents = [],
                j = 0;
            j < m;
            ++j
        ) {
            for (
                var group2 = groups2[j], n = group2.length, node, i = 0;
                i < n;
                ++i
            ) {
                if ((node = group2[i])) {
                    subgroups.push(select.call(node, node.__data__, i, group2));
                    parents.push(node);
                }
            }
        }
        return new Selection(subgroups, parents);
    }

    // node_modules/d3-selection/src/matcher.js
    function matcher_default(selector) {
        return function () {
            return this.matches(selector);
        };
    }
    function childMatcher(selector) {
        return function (node) {
            return node.matches(selector);
        };
    }

    // node_modules/d3-selection/src/selection/selectChild.js
    var find = Array.prototype.find;
    function childFind(match) {
        return function () {
            return find.call(this.children, match);
        };
    }
    function childFirst() {
        return this.firstElementChild;
    }
    function selectChild_default(match) {
        return this.select(
            match == null
                ? childFirst
                : childFind(
                      typeof match === 'function' ? match : childMatcher(match)
                  )
        );
    }

    // node_modules/d3-selection/src/selection/selectChildren.js
    var filter = Array.prototype.filter;
    function children() {
        return Array.from(this.children);
    }
    function childrenFilter(match) {
        return function () {
            return filter.call(this.children, match);
        };
    }
    function selectChildren_default(match) {
        return this.selectAll(
            match == null
                ? children
                : childrenFilter(
                      typeof match === 'function' ? match : childMatcher(match)
                  )
        );
    }

    // node_modules/d3-selection/src/selection/filter.js
    function filter_default(match) {
        if (typeof match !== 'function') match = matcher_default(match);
        for (
            var groups2 = this._groups,
                m = groups2.length,
                subgroups = new Array(m),
                j = 0;
            j < m;
            ++j
        ) {
            for (
                var group2 = groups2[j],
                    n = group2.length,
                    subgroup = (subgroups[j] = []),
                    node,
                    i = 0;
                i < n;
                ++i
            ) {
                if (
                    (node = group2[i]) &&
                    match.call(node, node.__data__, i, group2)
                ) {
                    subgroup.push(node);
                }
            }
        }
        return new Selection(subgroups, this._parents);
    }

    // node_modules/d3-selection/src/selection/sparse.js
    function sparse_default(update) {
        return new Array(update.length);
    }

    // node_modules/d3-selection/src/selection/enter.js
    function enter_default() {
        return new Selection(
            this._enter || this._groups.map(sparse_default),
            this._parents
        );
    }
    function EnterNode(parent, datum2) {
        this.ownerDocument = parent.ownerDocument;
        this.namespaceURI = parent.namespaceURI;
        this._next = null;
        this._parent = parent;
        this.__data__ = datum2;
    }
    EnterNode.prototype = {
        constructor: EnterNode,
        appendChild: function (child) {
            return this._parent.insertBefore(child, this._next);
        },
        insertBefore: function (child, next) {
            return this._parent.insertBefore(child, next);
        },
        querySelector: function (selector) {
            return this._parent.querySelector(selector);
        },
        querySelectorAll: function (selector) {
            return this._parent.querySelectorAll(selector);
        },
    };

    // node_modules/d3-selection/src/constant.js
    function constant_default(x) {
        return function () {
            return x;
        };
    }

    // node_modules/d3-selection/src/selection/data.js
    function bindIndex(parent, group2, enter, update, exit, data) {
        var i = 0,
            node,
            groupLength = group2.length,
            dataLength = data.length;
        for (; i < dataLength; ++i) {
            if ((node = group2[i])) {
                node.__data__ = data[i];
                update[i] = node;
            } else {
                enter[i] = new EnterNode(parent, data[i]);
            }
        }
        for (; i < groupLength; ++i) {
            if ((node = group2[i])) {
                exit[i] = node;
            }
        }
    }
    function bindKey(parent, group2, enter, update, exit, data, key) {
        var i,
            node,
            nodeByKeyValue = /* @__PURE__ */ new Map(),
            groupLength = group2.length,
            dataLength = data.length,
            keyValues = new Array(groupLength),
            keyValue;
        for (i = 0; i < groupLength; ++i) {
            if ((node = group2[i])) {
                keyValues[i] = keyValue =
                    key.call(node, node.__data__, i, group2) + '';
                if (nodeByKeyValue.has(keyValue)) {
                    exit[i] = node;
                } else {
                    nodeByKeyValue.set(keyValue, node);
                }
            }
        }
        for (i = 0; i < dataLength; ++i) {
            keyValue = key.call(parent, data[i], i, data) + '';
            if ((node = nodeByKeyValue.get(keyValue))) {
                update[i] = node;
                node.__data__ = data[i];
                nodeByKeyValue.delete(keyValue);
            } else {
                enter[i] = new EnterNode(parent, data[i]);
            }
        }
        for (i = 0; i < groupLength; ++i) {
            if (
                (node = group2[i]) &&
                nodeByKeyValue.get(keyValues[i]) === node
            ) {
                exit[i] = node;
            }
        }
    }
    function datum(node) {
        return node.__data__;
    }
    function data_default(value, key) {
        if (!arguments.length) return Array.from(this, datum);
        var bind = key ? bindKey : bindIndex,
            parents = this._parents,
            groups2 = this._groups;
        if (typeof value !== 'function') value = constant_default(value);
        for (
            var m = groups2.length,
                update = new Array(m),
                enter = new Array(m),
                exit = new Array(m),
                j = 0;
            j < m;
            ++j
        ) {
            var parent = parents[j],
                group2 = groups2[j],
                groupLength = group2.length,
                data = arraylike(
                    value.call(parent, parent && parent.__data__, j, parents)
                ),
                dataLength = data.length,
                enterGroup = (enter[j] = new Array(dataLength)),
                updateGroup = (update[j] = new Array(dataLength)),
                exitGroup = (exit[j] = new Array(groupLength));
            bind(parent, group2, enterGroup, updateGroup, exitGroup, data, key);
            for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
                if ((previous = enterGroup[i0])) {
                    if (i0 >= i1) i1 = i0 + 1;
                    while (!(next = updateGroup[i1]) && ++i1 < dataLength);
                    previous._next = next || null;
                }
            }
        }
        update = new Selection(update, parents);
        update._enter = enter;
        update._exit = exit;
        return update;
    }
    function arraylike(data) {
        return typeof data === 'object' && 'length' in data
            ? data
            : Array.from(data);
    }

    // node_modules/d3-selection/src/selection/exit.js
    function exit_default() {
        return new Selection(
            this._exit || this._groups.map(sparse_default),
            this._parents
        );
    }

    // node_modules/d3-selection/src/selection/join.js
    function join_default(onenter, onupdate, onexit) {
        var enter = this.enter(),
            update = this,
            exit = this.exit();
        if (typeof onenter === 'function') {
            enter = onenter(enter);
            if (enter) enter = enter.selection();
        } else {
            enter = enter.append(onenter + '');
        }
        if (onupdate != null) {
            update = onupdate(update);
            if (update) update = update.selection();
        }
        if (onexit == null) exit.remove();
        else onexit(exit);
        return enter && update ? enter.merge(update).order() : update;
    }

    // node_modules/d3-selection/src/selection/merge.js
    function merge_default(context) {
        var selection2 = context.selection ? context.selection() : context;
        for (
            var groups0 = this._groups,
                groups1 = selection2._groups,
                m0 = groups0.length,
                m1 = groups1.length,
                m = Math.min(m0, m1),
                merges = new Array(m0),
                j = 0;
            j < m;
            ++j
        ) {
            for (
                var group0 = groups0[j],
                    group1 = groups1[j],
                    n = group0.length,
                    merge2 = (merges[j] = new Array(n)),
                    node,
                    i = 0;
                i < n;
                ++i
            ) {
                if ((node = group0[i] || group1[i])) {
                    merge2[i] = node;
                }
            }
        }
        for (; j < m0; ++j) {
            merges[j] = groups0[j];
        }
        return new Selection(merges, this._parents);
    }

    // node_modules/d3-selection/src/selection/order.js
    function order_default() {
        for (
            var groups2 = this._groups, j = -1, m = groups2.length;
            ++j < m;

        ) {
            for (
                var group2 = groups2[j],
                    i = group2.length - 1,
                    next = group2[i],
                    node;
                --i >= 0;

            ) {
                if ((node = group2[i])) {
                    if (next && node.compareDocumentPosition(next) ^ 4)
                        next.parentNode.insertBefore(node, next);
                    next = node;
                }
            }
        }
        return this;
    }

    // node_modules/d3-selection/src/selection/sort.js
    function sort_default(compare) {
        if (!compare) compare = ascending2;
        function compareNode(a, b) {
            return a && b ? compare(a.__data__, b.__data__) : !a - !b;
        }
        for (
            var groups2 = this._groups,
                m = groups2.length,
                sortgroups = new Array(m),
                j = 0;
            j < m;
            ++j
        ) {
            for (
                var group2 = groups2[j],
                    n = group2.length,
                    sortgroup = (sortgroups[j] = new Array(n)),
                    node,
                    i = 0;
                i < n;
                ++i
            ) {
                if ((node = group2[i])) {
                    sortgroup[i] = node;
                }
            }
            sortgroup.sort(compareNode);
        }
        return new Selection(sortgroups, this._parents).order();
    }
    function ascending2(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    // node_modules/d3-selection/src/selection/call.js
    function call_default() {
        var callback2 = arguments[0];
        arguments[0] = this;
        callback2.apply(null, arguments);
        return this;
    }

    // node_modules/d3-selection/src/selection/nodes.js
    function nodes_default() {
        return Array.from(this);
    }

    // node_modules/d3-selection/src/selection/node.js
    function node_default() {
        for (
            var groups2 = this._groups, j = 0, m = groups2.length;
            j < m;
            ++j
        ) {
            for (
                var group2 = groups2[j], i = 0, n = group2.length;
                i < n;
                ++i
            ) {
                var node = group2[i];
                if (node) return node;
            }
        }
        return null;
    }

    // node_modules/d3-selection/src/selection/size.js
    function size_default() {
        let size = 0;
        for (const node of this) ++size;
        return size;
    }

    // node_modules/d3-selection/src/selection/empty.js
    function empty_default() {
        return !this.node();
    }

    // node_modules/d3-selection/src/selection/each.js
    function each_default(callback2) {
        for (
            var groups2 = this._groups, j = 0, m = groups2.length;
            j < m;
            ++j
        ) {
            for (
                var group2 = groups2[j], i = 0, n = group2.length, node;
                i < n;
                ++i
            ) {
                if ((node = group2[i]))
                    callback2.call(node, node.__data__, i, group2);
            }
        }
        return this;
    }

    // node_modules/d3-selection/src/selection/attr.js
    function attrRemove(name) {
        return function () {
            this.removeAttribute(name);
        };
    }
    function attrRemoveNS(fullname) {
        return function () {
            this.removeAttributeNS(fullname.space, fullname.local);
        };
    }
    function attrConstant(name, value) {
        return function () {
            this.setAttribute(name, value);
        };
    }
    function attrConstantNS(fullname, value) {
        return function () {
            this.setAttributeNS(fullname.space, fullname.local, value);
        };
    }
    function attrFunction(name, value) {
        return function () {
            var v = value.apply(this, arguments);
            if (v == null) this.removeAttribute(name);
            else this.setAttribute(name, v);
        };
    }
    function attrFunctionNS(fullname, value) {
        return function () {
            var v = value.apply(this, arguments);
            if (v == null)
                this.removeAttributeNS(fullname.space, fullname.local);
            else this.setAttributeNS(fullname.space, fullname.local, v);
        };
    }
    function attr_default(name, value) {
        var fullname = namespace_default(name);
        if (arguments.length < 2) {
            var node = this.node();
            return fullname.local
                ? node.getAttributeNS(fullname.space, fullname.local)
                : node.getAttribute(fullname);
        }
        return this.each(
            (value == null
                ? fullname.local
                    ? attrRemoveNS
                    : attrRemove
                : typeof value === 'function'
                ? fullname.local
                    ? attrFunctionNS
                    : attrFunction
                : fullname.local
                ? attrConstantNS
                : attrConstant)(fullname, value)
        );
    }

    // node_modules/d3-selection/src/window.js
    function window_default(node) {
        return (
            (node.ownerDocument && node.ownerDocument.defaultView) ||
            (node.document && node) ||
            node.defaultView
        );
    }

    // node_modules/d3-selection/src/selection/style.js
    function styleRemove(name) {
        return function () {
            this.style.removeProperty(name);
        };
    }
    function styleConstant(name, value, priority) {
        return function () {
            this.style.setProperty(name, value, priority);
        };
    }
    function styleFunction(name, value, priority) {
        return function () {
            var v = value.apply(this, arguments);
            if (v == null) this.style.removeProperty(name);
            else this.style.setProperty(name, v, priority);
        };
    }
    function style_default(name, value, priority) {
        return arguments.length > 1
            ? this.each(
                  (value == null
                      ? styleRemove
                      : typeof value === 'function'
                      ? styleFunction
                      : styleConstant)(
                      name,
                      value,
                      priority == null ? '' : priority
                  )
              )
            : styleValue(this.node(), name);
    }
    function styleValue(node, name) {
        return (
            node.style.getPropertyValue(name) ||
            window_default(node)
                .getComputedStyle(node, null)
                .getPropertyValue(name)
        );
    }

    // node_modules/d3-selection/src/selection/property.js
    function propertyRemove(name) {
        return function () {
            delete this[name];
        };
    }
    function propertyConstant(name, value) {
        return function () {
            this[name] = value;
        };
    }
    function propertyFunction(name, value) {
        return function () {
            var v = value.apply(this, arguments);
            if (v == null) delete this[name];
            else this[name] = v;
        };
    }
    function property_default(name, value) {
        return arguments.length > 1
            ? this.each(
                  (value == null
                      ? propertyRemove
                      : typeof value === 'function'
                      ? propertyFunction
                      : propertyConstant)(name, value)
              )
            : this.node()[name];
    }

    // node_modules/d3-selection/src/selection/classed.js
    function classArray(string) {
        return string.trim().split(/^|\s+/);
    }
    function classList(node) {
        return node.classList || new ClassList(node);
    }
    function ClassList(node) {
        this._node = node;
        this._names = classArray(node.getAttribute('class') || '');
    }
    ClassList.prototype = {
        add: function (name) {
            var i = this._names.indexOf(name);
            if (i < 0) {
                this._names.push(name);
                this._node.setAttribute('class', this._names.join(' '));
            }
        },
        remove: function (name) {
            var i = this._names.indexOf(name);
            if (i >= 0) {
                this._names.splice(i, 1);
                this._node.setAttribute('class', this._names.join(' '));
            }
        },
        contains: function (name) {
            return this._names.indexOf(name) >= 0;
        },
    };
    function classedAdd(node, names2) {
        var list = classList(node),
            i = -1,
            n = names2.length;
        while (++i < n) list.add(names2[i]);
    }
    function classedRemove(node, names2) {
        var list = classList(node),
            i = -1,
            n = names2.length;
        while (++i < n) list.remove(names2[i]);
    }
    function classedTrue(names2) {
        return function () {
            classedAdd(this, names2);
        };
    }
    function classedFalse(names2) {
        return function () {
            classedRemove(this, names2);
        };
    }
    function classedFunction(names2, value) {
        return function () {
            (value.apply(this, arguments) ? classedAdd : classedRemove)(
                this,
                names2
            );
        };
    }
    function classed_default(name, value) {
        var names2 = classArray(name + '');
        if (arguments.length < 2) {
            var list = classList(this.node()),
                i = -1,
                n = names2.length;
            while (++i < n) if (!list.contains(names2[i])) return false;
            return true;
        }
        return this.each(
            (typeof value === 'function'
                ? classedFunction
                : value
                ? classedTrue
                : classedFalse)(names2, value)
        );
    }

    // node_modules/d3-selection/src/selection/text.js
    function textRemove() {
        this.textContent = '';
    }
    function textConstant(value) {
        return function () {
            this.textContent = value;
        };
    }
    function textFunction(value) {
        return function () {
            var v = value.apply(this, arguments);
            this.textContent = v == null ? '' : v;
        };
    }
    function text_default(value) {
        return arguments.length
            ? this.each(
                  value == null
                      ? textRemove
                      : (typeof value === 'function'
                            ? textFunction
                            : textConstant)(value)
              )
            : this.node().textContent;
    }

    // node_modules/d3-selection/src/selection/html.js
    function htmlRemove() {
        this.innerHTML = '';
    }
    function htmlConstant(value) {
        return function () {
            this.innerHTML = value;
        };
    }
    function htmlFunction(value) {
        return function () {
            var v = value.apply(this, arguments);
            this.innerHTML = v == null ? '' : v;
        };
    }
    function html_default(value) {
        return arguments.length
            ? this.each(
                  value == null
                      ? htmlRemove
                      : (typeof value === 'function'
                            ? htmlFunction
                            : htmlConstant)(value)
              )
            : this.node().innerHTML;
    }

    // node_modules/d3-selection/src/selection/raise.js
    function raise() {
        if (this.nextSibling) this.parentNode.appendChild(this);
    }
    function raise_default() {
        return this.each(raise);
    }

    // node_modules/d3-selection/src/selection/lower.js
    function lower() {
        if (this.previousSibling)
            this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }
    function lower_default() {
        return this.each(lower);
    }

    // node_modules/d3-selection/src/selection/append.js
    function append_default(name) {
        var create2 = typeof name === 'function' ? name : creator_default(name);
        return this.select(function () {
            return this.appendChild(create2.apply(this, arguments));
        });
    }

    // node_modules/d3-selection/src/selection/insert.js
    function constantNull() {
        return null;
    }
    function insert_default(name, before) {
        var create2 = typeof name === 'function' ? name : creator_default(name),
            select =
                before == null
                    ? constantNull
                    : typeof before === 'function'
                    ? before
                    : selector_default(before);
        return this.select(function () {
            return this.insertBefore(
                create2.apply(this, arguments),
                select.apply(this, arguments) || null
            );
        });
    }

    // node_modules/d3-selection/src/selection/remove.js
    function remove() {
        var parent = this.parentNode;
        if (parent) parent.removeChild(this);
    }
    function remove_default() {
        return this.each(remove);
    }

    // node_modules/d3-selection/src/selection/clone.js
    function selection_cloneShallow() {
        var clone2 = this.cloneNode(false),
            parent = this.parentNode;
        return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
    }
    function selection_cloneDeep() {
        var clone2 = this.cloneNode(true),
            parent = this.parentNode;
        return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
    }
    function clone_default(deep) {
        return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
    }

    // node_modules/d3-selection/src/selection/datum.js
    function datum_default(value) {
        return arguments.length
            ? this.property('__data__', value)
            : this.node().__data__;
    }

    // node_modules/d3-selection/src/selection/on.js
    function contextListener(listener) {
        return function (event) {
            listener.call(this, event, this.__data__);
        };
    }
    function parseTypenames2(typenames) {
        return typenames
            .trim()
            .split(/^|\s+/)
            .map(function (t) {
                var name = '',
                    i = t.indexOf('.');
                if (i >= 0) (name = t.slice(i + 1)), (t = t.slice(0, i));
                return { type: t, name };
            });
    }
    function onRemove(typename) {
        return function () {
            var on = this.__on;
            if (!on) return;
            for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
                if (
                    ((o = on[j]),
                    (!typename.type || o.type === typename.type) &&
                        o.name === typename.name)
                ) {
                    this.removeEventListener(o.type, o.listener, o.options);
                } else {
                    on[++i] = o;
                }
            }
            if (++i) on.length = i;
            else delete this.__on;
        };
    }
    function onAdd(typename, value, options) {
        return function () {
            var on = this.__on,
                o,
                listener = contextListener(value);
            if (on)
                for (var j = 0, m = on.length; j < m; ++j) {
                    if (
                        (o = on[j]).type === typename.type &&
                        o.name === typename.name
                    ) {
                        this.removeEventListener(o.type, o.listener, o.options);
                        this.addEventListener(
                            o.type,
                            (o.listener = listener),
                            (o.options = options)
                        );
                        o.value = value;
                        return;
                    }
                }
            this.addEventListener(typename.type, listener, options);
            o = {
                type: typename.type,
                name: typename.name,
                value,
                listener,
                options,
            };
            if (!on) this.__on = [o];
            else on.push(o);
        };
    }
    function on_default(typename, value, options) {
        var typenames = parseTypenames2(typename + ''),
            i,
            n = typenames.length,
            t;
        if (arguments.length < 2) {
            var on = this.node().__on;
            if (on)
                for (var j = 0, m = on.length, o; j < m; ++j) {
                    for (i = 0, o = on[j]; i < n; ++i) {
                        if (
                            (t = typenames[i]).type === o.type &&
                            t.name === o.name
                        ) {
                            return o.value;
                        }
                    }
                }
            return;
        }
        on = value ? onAdd : onRemove;
        for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
        return this;
    }

    // node_modules/d3-selection/src/selection/dispatch.js
    function dispatchEvent2(node, type2, params) {
        var window2 = window_default(node),
            event = window2.CustomEvent;
        if (typeof event === 'function') {
            event = new event(type2, params);
        } else {
            event = window2.document.createEvent('Event');
            if (params)
                event.initEvent(type2, params.bubbles, params.cancelable),
                    (event.detail = params.detail);
            else event.initEvent(type2, false, false);
        }
        node.dispatchEvent(event);
    }
    function dispatchConstant(type2, params) {
        return function () {
            return dispatchEvent2(this, type2, params);
        };
    }
    function dispatchFunction(type2, params) {
        return function () {
            return dispatchEvent2(this, type2, params.apply(this, arguments));
        };
    }
    function dispatch_default2(type2, params) {
        return this.each(
            (typeof params === 'function'
                ? dispatchFunction
                : dispatchConstant)(type2, params)
        );
    }

    // node_modules/d3-selection/src/selection/iterator.js
    function* iterator_default() {
        for (
            var groups2 = this._groups, j = 0, m = groups2.length;
            j < m;
            ++j
        ) {
            for (
                var group2 = groups2[j], i = 0, n = group2.length, node;
                i < n;
                ++i
            ) {
                if ((node = group2[i])) yield node;
            }
        }
    }

    // node_modules/d3-selection/src/selection/index.js
    var root = [null];
    function Selection(groups2, parents) {
        this._groups = groups2;
        this._parents = parents;
    }
    function selection() {
        return new Selection([[document.documentElement]], root);
    }
    function selection_selection() {
        return this;
    }
    Selection.prototype = selection.prototype = {
        constructor: Selection,
        select: select_default,
        selectAll: selectAll_default,
        selectChild: selectChild_default,
        selectChildren: selectChildren_default,
        filter: filter_default,
        data: data_default,
        enter: enter_default,
        exit: exit_default,
        join: join_default,
        merge: merge_default,
        selection: selection_selection,
        order: order_default,
        sort: sort_default,
        call: call_default,
        nodes: nodes_default,
        node: node_default,
        size: size_default,
        empty: empty_default,
        each: each_default,
        attr: attr_default,
        style: style_default,
        property: property_default,
        classed: classed_default,
        text: text_default,
        html: html_default,
        raise: raise_default,
        lower: lower_default,
        append: append_default,
        insert: insert_default,
        remove: remove_default,
        clone: clone_default,
        datum: datum_default,
        on: on_default,
        dispatch: dispatch_default2,
        [Symbol.iterator]: iterator_default,
    };
    var selection_default = selection;

    // node_modules/d3-selection/src/select.js
    function select_default2(selector) {
        return typeof selector === 'string'
            ? new Selection(
                  [[document.querySelector(selector)]],
                  [document.documentElement]
              )
            : new Selection([[selector]], root);
    }

    // node_modules/d3-color/src/define.js
    function define_default(constructor, factory, prototype) {
        constructor.prototype = factory.prototype = prototype;
        prototype.constructor = constructor;
    }
    function extend(parent, definition) {
        var prototype = Object.create(parent.prototype);
        for (var key in definition) prototype[key] = definition[key];
        return prototype;
    }

    // node_modules/d3-color/src/color.js
    function Color2() {}
    var darker = 0.7;
    var brighter = 1 / darker;
    var reI = '\\s*([+-]?\\d+)\\s*';
    var reN = '\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*';
    var reP = '\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*';
    var reHex = /^#([0-9a-f]{3,8})$/;
    var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
    var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
    var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
    var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
    var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
    var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
    var named = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074,
    };
    define_default(Color2, color2, {
        copy(channels) {
            return Object.assign(new this.constructor(), this, channels);
        },
        displayable() {
            return this.rgb().displayable();
        },
        hex: color_formatHex,
        // Deprecated! Use color.formatHex.
        formatHex: color_formatHex,
        formatHex8: color_formatHex8,
        formatHsl: color_formatHsl,
        formatRgb: color_formatRgb,
        toString: color_formatRgb,
    });
    function color_formatHex() {
        return this.rgb().formatHex();
    }
    function color_formatHex8() {
        return this.rgb().formatHex8();
    }
    function color_formatHsl() {
        return hslConvert(this).formatHsl();
    }
    function color_formatRgb() {
        return this.rgb().formatRgb();
    }
    function color2(format2) {
        var m, l;
        format2 = (format2 + '').trim().toLowerCase();
        return (m = reHex.exec(format2))
            ? ((l = m[1].length),
              (m = parseInt(m[1], 16)),
              l === 6
                  ? rgbn(m)
                  : l === 3
                  ? new Rgb(
                        ((m >> 8) & 15) | ((m >> 4) & 240),
                        ((m >> 4) & 15) | (m & 240),
                        ((m & 15) << 4) | (m & 15),
                        1
                    )
                  : l === 8
                  ? rgba(
                        (m >> 24) & 255,
                        (m >> 16) & 255,
                        (m >> 8) & 255,
                        (m & 255) / 255
                    )
                  : l === 4
                  ? rgba(
                        ((m >> 12) & 15) | ((m >> 8) & 240),
                        ((m >> 8) & 15) | ((m >> 4) & 240),
                        ((m >> 4) & 15) | (m & 240),
                        (((m & 15) << 4) | (m & 15)) / 255
                    )
                  : null)
            : (m = reRgbInteger.exec(format2))
            ? new Rgb(m[1], m[2], m[3], 1)
            : (m = reRgbPercent.exec(format2))
            ? new Rgb(
                  (m[1] * 255) / 100,
                  (m[2] * 255) / 100,
                  (m[3] * 255) / 100,
                  1
              )
            : (m = reRgbaInteger.exec(format2))
            ? rgba(m[1], m[2], m[3], m[4])
            : (m = reRgbaPercent.exec(format2))
            ? rgba(
                  (m[1] * 255) / 100,
                  (m[2] * 255) / 100,
                  (m[3] * 255) / 100,
                  m[4]
              )
            : (m = reHslPercent.exec(format2))
            ? hsla(m[1], m[2] / 100, m[3] / 100, 1)
            : (m = reHslaPercent.exec(format2))
            ? hsla(m[1], m[2] / 100, m[3] / 100, m[4])
            : named.hasOwnProperty(format2)
            ? rgbn(named[format2])
            : format2 === 'transparent'
            ? new Rgb(NaN, NaN, NaN, 0)
            : null;
    }
    function rgbn(n) {
        return new Rgb((n >> 16) & 255, (n >> 8) & 255, n & 255, 1);
    }
    function rgba(r, g, b, a) {
        if (a <= 0) r = g = b = NaN;
        return new Rgb(r, g, b, a);
    }
    function rgbConvert(o) {
        if (!(o instanceof Color2)) o = color2(o);
        if (!o) return new Rgb();
        o = o.rgb();
        return new Rgb(o.r, o.g, o.b, o.opacity);
    }
    function rgb(r, g, b, opacity) {
        return arguments.length === 1
            ? rgbConvert(r)
            : new Rgb(r, g, b, opacity == null ? 1 : opacity);
    }
    function Rgb(r, g, b, opacity) {
        this.r = +r;
        this.g = +g;
        this.b = +b;
        this.opacity = +opacity;
    }
    define_default(
        Rgb,
        rgb,
        extend(Color2, {
            brighter(k) {
                k = k == null ? brighter : Math.pow(brighter, k);
                return new Rgb(
                    this.r * k,
                    this.g * k,
                    this.b * k,
                    this.opacity
                );
            },
            darker(k) {
                k = k == null ? darker : Math.pow(darker, k);
                return new Rgb(
                    this.r * k,
                    this.g * k,
                    this.b * k,
                    this.opacity
                );
            },
            rgb() {
                return this;
            },
            clamp() {
                return new Rgb(
                    clampi(this.r),
                    clampi(this.g),
                    clampi(this.b),
                    clampa(this.opacity)
                );
            },
            displayable() {
                return (
                    -0.5 <= this.r &&
                    this.r < 255.5 &&
                    -0.5 <= this.g &&
                    this.g < 255.5 &&
                    -0.5 <= this.b &&
                    this.b < 255.5 &&
                    0 <= this.opacity &&
                    this.opacity <= 1
                );
            },
            hex: rgb_formatHex,
            // Deprecated! Use color.formatHex.
            formatHex: rgb_formatHex,
            formatHex8: rgb_formatHex8,
            formatRgb: rgb_formatRgb,
            toString: rgb_formatRgb,
        })
    );
    function rgb_formatHex() {
        return `#${hex2(this.r)}${hex2(this.g)}${hex2(this.b)}`;
    }
    function rgb_formatHex8() {
        return `#${hex2(this.r)}${hex2(this.g)}${hex2(this.b)}${hex2(
            (isNaN(this.opacity) ? 1 : this.opacity) * 255
        )}`;
    }
    function rgb_formatRgb() {
        const a = clampa(this.opacity);
        return `${a === 1 ? 'rgb(' : 'rgba('}${clampi(this.r)}, ${clampi(
            this.g
        )}, ${clampi(this.b)}${a === 1 ? ')' : `, ${a})`}`;
    }
    function clampa(opacity) {
        return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
    }
    function clampi(value) {
        return Math.max(0, Math.min(255, Math.round(value) || 0));
    }
    function hex2(value) {
        value = clampi(value);
        return (value < 16 ? '0' : '') + value.toString(16);
    }
    function hsla(h, s, l, a) {
        if (a <= 0) h = s = l = NaN;
        else if (l <= 0 || l >= 1) h = s = NaN;
        else if (s <= 0) h = NaN;
        return new Hsl(h, s, l, a);
    }
    function hslConvert(o) {
        if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
        if (!(o instanceof Color2)) o = color2(o);
        if (!o) return new Hsl();
        if (o instanceof Hsl) return o;
        o = o.rgb();
        var r = o.r / 255,
            g = o.g / 255,
            b = o.b / 255,
            min3 = Math.min(r, g, b),
            max3 = Math.max(r, g, b),
            h = NaN,
            s = max3 - min3,
            l = (max3 + min3) / 2;
        if (s) {
            if (r === max3) h = (g - b) / s + (g < b) * 6;
            else if (g === max3) h = (b - r) / s + 2;
            else h = (r - g) / s + 4;
            s /= l < 0.5 ? max3 + min3 : 2 - max3 - min3;
            h *= 60;
        } else {
            s = l > 0 && l < 1 ? 0 : h;
        }
        return new Hsl(h, s, l, o.opacity);
    }
    function hsl(h, s, l, opacity) {
        return arguments.length === 1
            ? hslConvert(h)
            : new Hsl(h, s, l, opacity == null ? 1 : opacity);
    }
    function Hsl(h, s, l, opacity) {
        this.h = +h;
        this.s = +s;
        this.l = +l;
        this.opacity = +opacity;
    }
    define_default(
        Hsl,
        hsl,
        extend(Color2, {
            brighter(k) {
                k = k == null ? brighter : Math.pow(brighter, k);
                return new Hsl(this.h, this.s, this.l * k, this.opacity);
            },
            darker(k) {
                k = k == null ? darker : Math.pow(darker, k);
                return new Hsl(this.h, this.s, this.l * k, this.opacity);
            },
            rgb() {
                var h = (this.h % 360) + (this.h < 0) * 360,
                    s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
                    l = this.l,
                    m2 = l + (l < 0.5 ? l : 1 - l) * s,
                    m1 = 2 * l - m2;
                return new Rgb(
                    hsl2rgb2(h >= 240 ? h - 240 : h + 120, m1, m2),
                    hsl2rgb2(h, m1, m2),
                    hsl2rgb2(h < 120 ? h + 240 : h - 120, m1, m2),
                    this.opacity
                );
            },
            clamp() {
                return new Hsl(
                    clamph(this.h),
                    clampt(this.s),
                    clampt(this.l),
                    clampa(this.opacity)
                );
            },
            displayable() {
                return (
                    ((0 <= this.s && this.s <= 1) || isNaN(this.s)) &&
                    0 <= this.l &&
                    this.l <= 1 &&
                    0 <= this.opacity &&
                    this.opacity <= 1
                );
            },
            formatHsl() {
                const a = clampa(this.opacity);
                return `${a === 1 ? 'hsl(' : 'hsla('}${clamph(this.h)}, ${
                    clampt(this.s) * 100
                }%, ${clampt(this.l) * 100}%${a === 1 ? ')' : `, ${a})`}`;
            },
        })
    );
    function clamph(value) {
        value = (value || 0) % 360;
        return value < 0 ? value + 360 : value;
    }
    function clampt(value) {
        return Math.max(0, Math.min(1, value || 0));
    }
    function hsl2rgb2(h, m1, m2) {
        return (
            (h < 60
                ? m1 + ((m2 - m1) * h) / 60
                : h < 180
                ? m2
                : h < 240
                ? m1 + ((m2 - m1) * (240 - h)) / 60
                : m1) * 255
        );
    }

    // node_modules/d3-interpolate/src/basis.js
    function basis(t1, v0, v1, v2, v3) {
        var t2 = t1 * t1,
            t3 = t2 * t1;
        return (
            ((1 - 3 * t1 + 3 * t2 - t3) * v0 +
                (4 - 6 * t2 + 3 * t3) * v1 +
                (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 +
                t3 * v3) /
            6
        );
    }
    function basis_default(values) {
        var n = values.length - 1;
        return function (t) {
            var i =
                    t <= 0
                        ? (t = 0)
                        : t >= 1
                        ? ((t = 1), n - 1)
                        : Math.floor(t * n),
                v1 = values[i],
                v2 = values[i + 1],
                v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
                v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
            return basis((t - i / n) * n, v0, v1, v2, v3);
        };
    }

    // node_modules/d3-interpolate/src/basisClosed.js
    function basisClosed_default(values) {
        var n = values.length;
        return function (t) {
            var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
                v0 = values[(i + n - 1) % n],
                v1 = values[i % n],
                v2 = values[(i + 1) % n],
                v3 = values[(i + 2) % n];
            return basis((t - i / n) * n, v0, v1, v2, v3);
        };
    }

    // node_modules/d3-interpolate/src/constant.js
    var constant_default2 = (x) => () => x;

    // node_modules/d3-interpolate/src/color.js
    function linear(a, d) {
        return function (t) {
            return a + t * d;
        };
    }
    function exponential(a, b, y) {
        return (
            (a = Math.pow(a, y)),
            (b = Math.pow(b, y) - a),
            (y = 1 / y),
            function (t) {
                return Math.pow(a + t * b, y);
            }
        );
    }
    function gamma(y) {
        return (y = +y) === 1
            ? nogamma
            : function (a, b) {
                  return b - a
                      ? exponential(a, b, y)
                      : constant_default2(isNaN(a) ? b : a);
              };
    }
    function nogamma(a, b) {
        var d = b - a;
        return d ? linear(a, d) : constant_default2(isNaN(a) ? b : a);
    }

    // node_modules/d3-interpolate/src/rgb.js
    var rgb_default = (function rgbGamma(y) {
        var color3 = gamma(y);
        function rgb2(start2, end) {
            var r = color3((start2 = rgb(start2)).r, (end = rgb(end)).r),
                g = color3(start2.g, end.g),
                b = color3(start2.b, end.b),
                opacity = nogamma(start2.opacity, end.opacity);
            return function (t) {
                start2.r = r(t);
                start2.g = g(t);
                start2.b = b(t);
                start2.opacity = opacity(t);
                return start2 + '';
            };
        }
        rgb2.gamma = rgbGamma;
        return rgb2;
    })(1);
    function rgbSpline(spline) {
        return function (colors2) {
            var n = colors2.length,
                r = new Array(n),
                g = new Array(n),
                b = new Array(n),
                i,
                color3;
            for (i = 0; i < n; ++i) {
                color3 = rgb(colors2[i]);
                r[i] = color3.r || 0;
                g[i] = color3.g || 0;
                b[i] = color3.b || 0;
            }
            r = spline(r);
            g = spline(g);
            b = spline(b);
            color3.opacity = 1;
            return function (t) {
                color3.r = r(t);
                color3.g = g(t);
                color3.b = b(t);
                return color3 + '';
            };
        };
    }
    var rgbBasis = rgbSpline(basis_default);
    var rgbBasisClosed = rgbSpline(basisClosed_default);

    // node_modules/d3-interpolate/src/number.js
    function number_default(a, b) {
        return (
            (a = +a),
            (b = +b),
            function (t) {
                return a * (1 - t) + b * t;
            }
        );
    }

    // node_modules/d3-interpolate/src/string.js
    var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
    var reB = new RegExp(reA.source, 'g');
    function zero(b) {
        return function () {
            return b;
        };
    }
    function one(b) {
        return function (t) {
            return b(t) + '';
        };
    }
    function string_default(a, b) {
        var bi = (reA.lastIndex = reB.lastIndex = 0),
            am,
            bm,
            bs,
            i = -1,
            s = [],
            q = [];
        (a = a + ''), (b = b + '');
        while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
            if ((bs = bm.index) > bi) {
                bs = b.slice(bi, bs);
                if (s[i]) s[i] += bs;
                else s[++i] = bs;
            }
            if ((am = am[0]) === (bm = bm[0])) {
                if (s[i]) s[i] += bm;
                else s[++i] = bm;
            } else {
                s[++i] = null;
                q.push({ i, x: number_default(am, bm) });
            }
            bi = reB.lastIndex;
        }
        if (bi < b.length) {
            bs = b.slice(bi);
            if (s[i]) s[i] += bs;
            else s[++i] = bs;
        }
        return s.length < 2
            ? q[0]
                ? one(q[0].x)
                : zero(b)
            : ((b = q.length),
              function (t) {
                  for (var i2 = 0, o; i2 < b; ++i2) s[(o = q[i2]).i] = o.x(t);
                  return s.join('');
              });
    }

    // node_modules/d3-interpolate/src/transform/decompose.js
    var degrees = 180 / Math.PI;
    var identity2 = {
        translateX: 0,
        translateY: 0,
        rotate: 0,
        skewX: 0,
        scaleX: 1,
        scaleY: 1,
    };
    function decompose_default(a, b, c, d, e, f) {
        var scaleX, scaleY, skewX;
        if ((scaleX = Math.sqrt(a * a + b * b))) (a /= scaleX), (b /= scaleX);
        if ((skewX = a * c + b * d)) (c -= a * skewX), (d -= b * skewX);
        if ((scaleY = Math.sqrt(c * c + d * d)))
            (c /= scaleY), (d /= scaleY), (skewX /= scaleY);
        if (a * d < b * c)
            (a = -a), (b = -b), (skewX = -skewX), (scaleX = -scaleX);
        return {
            translateX: e,
            translateY: f,
            rotate: Math.atan2(b, a) * degrees,
            skewX: Math.atan(skewX) * degrees,
            scaleX,
            scaleY,
        };
    }

    // node_modules/d3-interpolate/src/transform/parse.js
    var svgNode;
    function parseCss(value) {
        const m = new (
            typeof DOMMatrix === 'function' ? DOMMatrix : WebKitCSSMatrix
        )(value + '');
        return m.isIdentity
            ? identity2
            : decompose_default(m.a, m.b, m.c, m.d, m.e, m.f);
    }
    function parseSvg(value) {
        if (value == null) return identity2;
        if (!svgNode)
            svgNode = document.createElementNS(
                'http://www.w3.org/2000/svg',
                'g'
            );
        svgNode.setAttribute('transform', value);
        if (!(value = svgNode.transform.baseVal.consolidate()))
            return identity2;
        value = value.matrix;
        return decompose_default(
            value.a,
            value.b,
            value.c,
            value.d,
            value.e,
            value.f
        );
    }

    // node_modules/d3-interpolate/src/transform/index.js
    function interpolateTransform(parse2, pxComma, pxParen, degParen) {
        function pop(s) {
            return s.length ? s.pop() + ' ' : '';
        }
        function translate2(xa, ya, xb, yb, s, q) {
            if (xa !== xb || ya !== yb) {
                var i = s.push('translate(', null, pxComma, null, pxParen);
                q.push(
                    { i: i - 4, x: number_default(xa, xb) },
                    { i: i - 2, x: number_default(ya, yb) }
                );
            } else if (xb || yb) {
                s.push('translate(' + xb + pxComma + yb + pxParen);
            }
        }
        function rotate2(a, b, s, q) {
            if (a !== b) {
                if (a - b > 180) b += 360;
                else if (b - a > 180) a += 360;
                q.push({
                    i: s.push(pop(s) + 'rotate(', null, degParen) - 2,
                    x: number_default(a, b),
                });
            } else if (b) {
                s.push(pop(s) + 'rotate(' + b + degParen);
            }
        }
        function skewX(a, b, s, q) {
            if (a !== b) {
                q.push({
                    i: s.push(pop(s) + 'skewX(', null, degParen) - 2,
                    x: number_default(a, b),
                });
            } else if (b) {
                s.push(pop(s) + 'skewX(' + b + degParen);
            }
        }
        function scale(xa, ya, xb, yb, s, q) {
            if (xa !== xb || ya !== yb) {
                var i = s.push(pop(s) + 'scale(', null, ',', null, ')');
                q.push(
                    { i: i - 4, x: number_default(xa, xb) },
                    { i: i - 2, x: number_default(ya, yb) }
                );
            } else if (xb !== 1 || yb !== 1) {
                s.push(pop(s) + 'scale(' + xb + ',' + yb + ')');
            }
        }
        return function (a, b) {
            var s = [],
                q = [];
            (a = parse2(a)), (b = parse2(b));
            translate2(
                a.translateX,
                a.translateY,
                b.translateX,
                b.translateY,
                s,
                q
            );
            rotate2(a.rotate, b.rotate, s, q);
            skewX(a.skewX, b.skewX, s, q);
            scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
            a = b = null;
            return function (t) {
                var i = -1,
                    n = q.length,
                    o;
                while (++i < n) s[(o = q[i]).i] = o.x(t);
                return s.join('');
            };
        };
    }
    var interpolateTransformCss = interpolateTransform(
        parseCss,
        'px, ',
        'px)',
        'deg)'
    );
    var interpolateTransformSvg = interpolateTransform(
        parseSvg,
        ', ',
        ')',
        ')'
    );

    // node_modules/d3-timer/src/timer.js
    var frame = 0;
    var timeout = 0;
    var interval = 0;
    var pokeDelay = 1e3;
    var taskHead;
    var taskTail;
    var clockLast = 0;
    var clockNow = 0;
    var clockSkew = 0;
    var clock =
        typeof performance === 'object' && performance.now ? performance : Date;
    var setFrame =
        typeof window === 'object' && window.requestAnimationFrame
            ? window.requestAnimationFrame.bind(window)
            : function (f) {
                  setTimeout(f, 17);
              };
    function now() {
        return (
            clockNow ||
            (setFrame(clearNow), (clockNow = clock.now() + clockSkew))
        );
    }
    function clearNow() {
        clockNow = 0;
    }
    function Timer() {
        this._call = this._time = this._next = null;
    }
    Timer.prototype = timer.prototype = {
        constructor: Timer,
        restart: function (callback2, delay, time) {
            if (typeof callback2 !== 'function')
                throw new TypeError('callback is not a function');
            time =
                (time == null ? now() : +time) + (delay == null ? 0 : +delay);
            if (!this._next && taskTail !== this) {
                if (taskTail) taskTail._next = this;
                else taskHead = this;
                taskTail = this;
            }
            this._call = callback2;
            this._time = time;
            sleep();
        },
        stop: function () {
            if (this._call) {
                this._call = null;
                this._time = Infinity;
                sleep();
            }
        },
    };
    function timer(callback2, delay, time) {
        var t = new Timer();
        t.restart(callback2, delay, time);
        return t;
    }
    function timerFlush() {
        now();
        ++frame;
        var t = taskHead,
            e;
        while (t) {
            if ((e = clockNow - t._time) >= 0) t._call.call(void 0, e);
            t = t._next;
        }
        --frame;
    }
    function wake() {
        clockNow = (clockLast = clock.now()) + clockSkew;
        frame = timeout = 0;
        try {
            timerFlush();
        } finally {
            frame = 0;
            nap();
            clockNow = 0;
        }
    }
    function poke() {
        var now2 = clock.now(),
            delay = now2 - clockLast;
        if (delay > pokeDelay) (clockSkew -= delay), (clockLast = now2);
    }
    function nap() {
        var t0,
            t1 = taskHead,
            t2,
            time = Infinity;
        while (t1) {
            if (t1._call) {
                if (time > t1._time) time = t1._time;
                (t0 = t1), (t1 = t1._next);
            } else {
                (t2 = t1._next), (t1._next = null);
                t1 = t0 ? (t0._next = t2) : (taskHead = t2);
            }
        }
        taskTail = t0;
        sleep(time);
    }
    function sleep(time) {
        if (frame) return;
        if (timeout) timeout = clearTimeout(timeout);
        var delay = time - clockNow;
        if (delay > 24) {
            if (time < Infinity)
                timeout = setTimeout(wake, time - clock.now() - clockSkew);
            if (interval) interval = clearInterval(interval);
        } else {
            if (!interval)
                (clockLast = clock.now()),
                    (interval = setInterval(poke, pokeDelay));
            (frame = 1), setFrame(wake);
        }
    }

    // node_modules/d3-timer/src/timeout.js
    function timeout_default(callback2, delay, time) {
        var t = new Timer();
        delay = delay == null ? 0 : +delay;
        t.restart(
            (elapsed) => {
                t.stop();
                callback2(elapsed + delay);
            },
            delay,
            time
        );
        return t;
    }

    // node_modules/d3-transition/src/transition/schedule.js
    var emptyOn = dispatch_default('start', 'end', 'cancel', 'interrupt');
    var emptyTween = [];
    var CREATED = 0;
    var SCHEDULED = 1;
    var STARTING = 2;
    var STARTED = 3;
    var RUNNING = 4;
    var ENDING = 5;
    var ENDED = 6;
    function schedule_default(node, name, id2, index3, group2, timing) {
        var schedules = node.__transition;
        if (!schedules) node.__transition = {};
        else if (id2 in schedules) return;
        create(node, id2, {
            name,
            index: index3,
            // For context during callback.
            group: group2,
            // For context during callback.
            on: emptyOn,
            tween: emptyTween,
            time: timing.time,
            delay: timing.delay,
            duration: timing.duration,
            ease: timing.ease,
            timer: null,
            state: CREATED,
        });
    }
    function init(node, id2) {
        var schedule = get2(node, id2);
        if (schedule.state > CREATED)
            throw new Error('too late; already scheduled');
        return schedule;
    }
    function set3(node, id2) {
        var schedule = get2(node, id2);
        if (schedule.state > STARTED)
            throw new Error('too late; already running');
        return schedule;
    }
    function get2(node, id2) {
        var schedule = node.__transition;
        if (!schedule || !(schedule = schedule[id2]))
            throw new Error('transition not found');
        return schedule;
    }
    function create(node, id2, self) {
        var schedules = node.__transition,
            tween;
        schedules[id2] = self;
        self.timer = timer(schedule, 0, self.time);
        function schedule(elapsed) {
            self.state = SCHEDULED;
            self.timer.restart(start2, self.delay, self.time);
            if (self.delay <= elapsed) start2(elapsed - self.delay);
        }
        function start2(elapsed) {
            var i, j, n, o;
            if (self.state !== SCHEDULED) return stop();
            for (i in schedules) {
                o = schedules[i];
                if (o.name !== self.name) continue;
                if (o.state === STARTED) return timeout_default(start2);
                if (o.state === RUNNING) {
                    o.state = ENDED;
                    o.timer.stop();
                    o.on.call(
                        'interrupt',
                        node,
                        node.__data__,
                        o.index,
                        o.group
                    );
                    delete schedules[i];
                } else if (+i < id2) {
                    o.state = ENDED;
                    o.timer.stop();
                    o.on.call('cancel', node, node.__data__, o.index, o.group);
                    delete schedules[i];
                }
            }
            timeout_default(function () {
                if (self.state === STARTED) {
                    self.state = RUNNING;
                    self.timer.restart(tick, self.delay, self.time);
                    tick(elapsed);
                }
            });
            self.state = STARTING;
            self.on.call('start', node, node.__data__, self.index, self.group);
            if (self.state !== STARTING) return;
            self.state = STARTED;
            tween = new Array((n = self.tween.length));
            for (i = 0, j = -1; i < n; ++i) {
                if (
                    (o = self.tween[i].value.call(
                        node,
                        node.__data__,
                        self.index,
                        self.group
                    ))
                ) {
                    tween[++j] = o;
                }
            }
            tween.length = j + 1;
        }
        function tick(elapsed) {
            var t =
                    elapsed < self.duration
                        ? self.ease.call(null, elapsed / self.duration)
                        : (self.timer.restart(stop), (self.state = ENDING), 1),
                i = -1,
                n = tween.length;
            while (++i < n) {
                tween[i].call(node, t);
            }
            if (self.state === ENDING) {
                self.on.call(
                    'end',
                    node,
                    node.__data__,
                    self.index,
                    self.group
                );
                stop();
            }
        }
        function stop() {
            self.state = ENDED;
            self.timer.stop();
            delete schedules[id2];
            for (var i in schedules) return;
            delete node.__transition;
        }
    }

    // node_modules/d3-transition/src/interrupt.js
    function interrupt_default(node, name) {
        var schedules = node.__transition,
            schedule,
            active,
            empty2 = true,
            i;
        if (!schedules) return;
        name = name == null ? null : name + '';
        for (i in schedules) {
            if ((schedule = schedules[i]).name !== name) {
                empty2 = false;
                continue;
            }
            active = schedule.state > STARTING && schedule.state < ENDING;
            schedule.state = ENDED;
            schedule.timer.stop();
            schedule.on.call(
                active ? 'interrupt' : 'cancel',
                node,
                node.__data__,
                schedule.index,
                schedule.group
            );
            delete schedules[i];
        }
        if (empty2) delete node.__transition;
    }

    // node_modules/d3-transition/src/selection/interrupt.js
    function interrupt_default2(name) {
        return this.each(function () {
            interrupt_default(this, name);
        });
    }

    // node_modules/d3-transition/src/transition/tween.js
    function tweenRemove(id2, name) {
        var tween0, tween1;
        return function () {
            var schedule = set3(this, id2),
                tween = schedule.tween;
            if (tween !== tween0) {
                tween1 = tween0 = tween;
                for (var i = 0, n = tween1.length; i < n; ++i) {
                    if (tween1[i].name === name) {
                        tween1 = tween1.slice();
                        tween1.splice(i, 1);
                        break;
                    }
                }
            }
            schedule.tween = tween1;
        };
    }
    function tweenFunction(id2, name, value) {
        var tween0, tween1;
        if (typeof value !== 'function') throw new Error();
        return function () {
            var schedule = set3(this, id2),
                tween = schedule.tween;
            if (tween !== tween0) {
                tween1 = (tween0 = tween).slice();
                for (
                    var t = { name, value }, i = 0, n = tween1.length;
                    i < n;
                    ++i
                ) {
                    if (tween1[i].name === name) {
                        tween1[i] = t;
                        break;
                    }
                }
                if (i === n) tween1.push(t);
            }
            schedule.tween = tween1;
        };
    }
    function tween_default(name, value) {
        var id2 = this._id;
        name += '';
        if (arguments.length < 2) {
            var tween = get2(this.node(), id2).tween;
            for (var i = 0, n = tween.length, t; i < n; ++i) {
                if ((t = tween[i]).name === name) {
                    return t.value;
                }
            }
            return null;
        }
        return this.each(
            (value == null ? tweenRemove : tweenFunction)(id2, name, value)
        );
    }
    function tweenValue(transition2, name, value) {
        var id2 = transition2._id;
        transition2.each(function () {
            var schedule = set3(this, id2);
            (schedule.value || (schedule.value = {}))[name] = value.apply(
                this,
                arguments
            );
        });
        return function (node) {
            return get2(node, id2).value[name];
        };
    }

    // node_modules/d3-transition/src/transition/interpolate.js
    function interpolate_default(a, b) {
        var c;
        return (
            typeof b === 'number'
                ? number_default
                : b instanceof color2
                ? rgb_default
                : (c = color2(b))
                ? ((b = c), rgb_default)
                : string_default
        )(a, b);
    }

    // node_modules/d3-transition/src/transition/attr.js
    function attrRemove2(name) {
        return function () {
            this.removeAttribute(name);
        };
    }
    function attrRemoveNS2(fullname) {
        return function () {
            this.removeAttributeNS(fullname.space, fullname.local);
        };
    }
    function attrConstant2(name, interpolate3, value1) {
        var string00,
            string1 = value1 + '',
            interpolate0;
        return function () {
            var string0 = this.getAttribute(name);
            return string0 === string1
                ? null
                : string0 === string00
                ? interpolate0
                : (interpolate0 = interpolate3((string00 = string0), value1));
        };
    }
    function attrConstantNS2(fullname, interpolate3, value1) {
        var string00,
            string1 = value1 + '',
            interpolate0;
        return function () {
            var string0 = this.getAttributeNS(fullname.space, fullname.local);
            return string0 === string1
                ? null
                : string0 === string00
                ? interpolate0
                : (interpolate0 = interpolate3((string00 = string0), value1));
        };
    }
    function attrFunction2(name, interpolate3, value) {
        var string00, string10, interpolate0;
        return function () {
            var string0,
                value1 = value(this),
                string1;
            if (value1 == null) return void this.removeAttribute(name);
            string0 = this.getAttribute(name);
            string1 = value1 + '';
            return string0 === string1
                ? null
                : string0 === string00 && string1 === string10
                ? interpolate0
                : ((string10 = string1),
                  (interpolate0 = interpolate3((string00 = string0), value1)));
        };
    }
    function attrFunctionNS2(fullname, interpolate3, value) {
        var string00, string10, interpolate0;
        return function () {
            var string0,
                value1 = value(this),
                string1;
            if (value1 == null)
                return void this.removeAttributeNS(
                    fullname.space,
                    fullname.local
                );
            string0 = this.getAttributeNS(fullname.space, fullname.local);
            string1 = value1 + '';
            return string0 === string1
                ? null
                : string0 === string00 && string1 === string10
                ? interpolate0
                : ((string10 = string1),
                  (interpolate0 = interpolate3((string00 = string0), value1)));
        };
    }
    function attr_default2(name, value) {
        var fullname = namespace_default(name),
            i =
                fullname === 'transform'
                    ? interpolateTransformSvg
                    : interpolate_default;
        return this.attrTween(
            name,
            typeof value === 'function'
                ? (fullname.local ? attrFunctionNS2 : attrFunction2)(
                      fullname,
                      i,
                      tweenValue(this, 'attr.' + name, value)
                  )
                : value == null
                ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname)
                : (fullname.local ? attrConstantNS2 : attrConstant2)(
                      fullname,
                      i,
                      value
                  )
        );
    }

    // node_modules/d3-transition/src/transition/attrTween.js
    function attrInterpolate(name, i) {
        return function (t) {
            this.setAttribute(name, i.call(this, t));
        };
    }
    function attrInterpolateNS(fullname, i) {
        return function (t) {
            this.setAttributeNS(
                fullname.space,
                fullname.local,
                i.call(this, t)
            );
        };
    }
    function attrTweenNS(fullname, value) {
        var t0, i0;
        function tween() {
            var i = value.apply(this, arguments);
            if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
            return t0;
        }
        tween._value = value;
        return tween;
    }
    function attrTween(name, value) {
        var t0, i0;
        function tween() {
            var i = value.apply(this, arguments);
            if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
            return t0;
        }
        tween._value = value;
        return tween;
    }
    function attrTween_default(name, value) {
        var key = 'attr.' + name;
        if (arguments.length < 2) return (key = this.tween(key)) && key._value;
        if (value == null) return this.tween(key, null);
        if (typeof value !== 'function') throw new Error();
        var fullname = namespace_default(name);
        return this.tween(
            key,
            (fullname.local ? attrTweenNS : attrTween)(fullname, value)
        );
    }

    // node_modules/d3-transition/src/transition/delay.js
    function delayFunction(id2, value) {
        return function () {
            init(this, id2).delay = +value.apply(this, arguments);
        };
    }
    function delayConstant(id2, value) {
        return (
            (value = +value),
            function () {
                init(this, id2).delay = value;
            }
        );
    }
    function delay_default(value) {
        var id2 = this._id;
        return arguments.length
            ? this.each(
                  (typeof value === 'function' ? delayFunction : delayConstant)(
                      id2,
                      value
                  )
              )
            : get2(this.node(), id2).delay;
    }

    // node_modules/d3-transition/src/transition/duration.js
    function durationFunction(id2, value) {
        return function () {
            set3(this, id2).duration = +value.apply(this, arguments);
        };
    }
    function durationConstant(id2, value) {
        return (
            (value = +value),
            function () {
                set3(this, id2).duration = value;
            }
        );
    }
    function duration_default(value) {
        var id2 = this._id;
        return arguments.length
            ? this.each(
                  (typeof value === 'function'
                      ? durationFunction
                      : durationConstant)(id2, value)
              )
            : get2(this.node(), id2).duration;
    }

    // node_modules/d3-transition/src/transition/ease.js
    function easeConstant(id2, value) {
        if (typeof value !== 'function') throw new Error();
        return function () {
            set3(this, id2).ease = value;
        };
    }
    function ease_default(value) {
        var id2 = this._id;
        return arguments.length
            ? this.each(easeConstant(id2, value))
            : get2(this.node(), id2).ease;
    }

    // node_modules/d3-transition/src/transition/easeVarying.js
    function easeVarying(id2, value) {
        return function () {
            var v = value.apply(this, arguments);
            if (typeof v !== 'function') throw new Error();
            set3(this, id2).ease = v;
        };
    }
    function easeVarying_default(value) {
        if (typeof value !== 'function') throw new Error();
        return this.each(easeVarying(this._id, value));
    }

    // node_modules/d3-transition/src/transition/filter.js
    function filter_default2(match) {
        if (typeof match !== 'function') match = matcher_default(match);
        for (
            var groups2 = this._groups,
                m = groups2.length,
                subgroups = new Array(m),
                j = 0;
            j < m;
            ++j
        ) {
            for (
                var group2 = groups2[j],
                    n = group2.length,
                    subgroup = (subgroups[j] = []),
                    node,
                    i = 0;
                i < n;
                ++i
            ) {
                if (
                    (node = group2[i]) &&
                    match.call(node, node.__data__, i, group2)
                ) {
                    subgroup.push(node);
                }
            }
        }
        return new Transition(subgroups, this._parents, this._name, this._id);
    }

    // node_modules/d3-transition/src/transition/merge.js
    function merge_default2(transition2) {
        if (transition2._id !== this._id) throw new Error();
        for (
            var groups0 = this._groups,
                groups1 = transition2._groups,
                m0 = groups0.length,
                m1 = groups1.length,
                m = Math.min(m0, m1),
                merges = new Array(m0),
                j = 0;
            j < m;
            ++j
        ) {
            for (
                var group0 = groups0[j],
                    group1 = groups1[j],
                    n = group0.length,
                    merge2 = (merges[j] = new Array(n)),
                    node,
                    i = 0;
                i < n;
                ++i
            ) {
                if ((node = group0[i] || group1[i])) {
                    merge2[i] = node;
                }
            }
        }
        for (; j < m0; ++j) {
            merges[j] = groups0[j];
        }
        return new Transition(merges, this._parents, this._name, this._id);
    }

    // node_modules/d3-transition/src/transition/on.js
    function start(name) {
        return (name + '')
            .trim()
            .split(/^|\s+/)
            .every(function (t) {
                var i = t.indexOf('.');
                if (i >= 0) t = t.slice(0, i);
                return !t || t === 'start';
            });
    }
    function onFunction(id2, name, listener) {
        var on0,
            on1,
            sit = start(name) ? init : set3;
        return function () {
            var schedule = sit(this, id2),
                on = schedule.on;
            if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);
            schedule.on = on1;
        };
    }
    function on_default2(name, listener) {
        var id2 = this._id;
        return arguments.length < 2
            ? get2(this.node(), id2).on.on(name)
            : this.each(onFunction(id2, name, listener));
    }

    // node_modules/d3-transition/src/transition/remove.js
    function removeFunction(id2) {
        return function () {
            var parent = this.parentNode;
            for (var i in this.__transition) if (+i !== id2) return;
            if (parent) parent.removeChild(this);
        };
    }
    function remove_default2() {
        return this.on('end.remove', removeFunction(this._id));
    }

    // node_modules/d3-transition/src/transition/select.js
    function select_default3(select) {
        var name = this._name,
            id2 = this._id;
        if (typeof select !== 'function') select = selector_default(select);
        for (
            var groups2 = this._groups,
                m = groups2.length,
                subgroups = new Array(m),
                j = 0;
            j < m;
            ++j
        ) {
            for (
                var group2 = groups2[j],
                    n = group2.length,
                    subgroup = (subgroups[j] = new Array(n)),
                    node,
                    subnode,
                    i = 0;
                i < n;
                ++i
            ) {
                if (
                    (node = group2[i]) &&
                    (subnode = select.call(node, node.__data__, i, group2))
                ) {
                    if ('__data__' in node) subnode.__data__ = node.__data__;
                    subgroup[i] = subnode;
                    schedule_default(
                        subgroup[i],
                        name,
                        id2,
                        i,
                        subgroup,
                        get2(node, id2)
                    );
                }
            }
        }
        return new Transition(subgroups, this._parents, name, id2);
    }

    // node_modules/d3-transition/src/transition/selectAll.js
    function selectAll_default2(select) {
        var name = this._name,
            id2 = this._id;
        if (typeof select !== 'function') select = selectorAll_default(select);
        for (
            var groups2 = this._groups,
                m = groups2.length,
                subgroups = [],
                parents = [],
                j = 0;
            j < m;
            ++j
        ) {
            for (
                var group2 = groups2[j], n = group2.length, node, i = 0;
                i < n;
                ++i
            ) {
                if ((node = group2[i])) {
                    for (
                        var children2 = select.call(
                                node,
                                node.__data__,
                                i,
                                group2
                            ),
                            child,
                            inherit2 = get2(node, id2),
                            k = 0,
                            l = children2.length;
                        k < l;
                        ++k
                    ) {
                        if ((child = children2[k])) {
                            schedule_default(
                                child,
                                name,
                                id2,
                                k,
                                children2,
                                inherit2
                            );
                        }
                    }
                    subgroups.push(children2);
                    parents.push(node);
                }
            }
        }
        return new Transition(subgroups, parents, name, id2);
    }

    // node_modules/d3-transition/src/transition/selection.js
    var Selection2 = selection_default.prototype.constructor;
    function selection_default2() {
        return new Selection2(this._groups, this._parents);
    }

    // node_modules/d3-transition/src/transition/style.js
    function styleNull(name, interpolate3) {
        var string00, string10, interpolate0;
        return function () {
            var string0 = styleValue(this, name),
                string1 =
                    (this.style.removeProperty(name), styleValue(this, name));
            return string0 === string1
                ? null
                : string0 === string00 && string1 === string10
                ? interpolate0
                : (interpolate0 = interpolate3(
                      (string00 = string0),
                      (string10 = string1)
                  ));
        };
    }
    function styleRemove2(name) {
        return function () {
            this.style.removeProperty(name);
        };
    }
    function styleConstant2(name, interpolate3, value1) {
        var string00,
            string1 = value1 + '',
            interpolate0;
        return function () {
            var string0 = styleValue(this, name);
            return string0 === string1
                ? null
                : string0 === string00
                ? interpolate0
                : (interpolate0 = interpolate3((string00 = string0), value1));
        };
    }
    function styleFunction2(name, interpolate3, value) {
        var string00, string10, interpolate0;
        return function () {
            var string0 = styleValue(this, name),
                value1 = value(this),
                string1 = value1 + '';
            if (value1 == null)
                string1 = value1 =
                    (this.style.removeProperty(name), styleValue(this, name));
            return string0 === string1
                ? null
                : string0 === string00 && string1 === string10
                ? interpolate0
                : ((string10 = string1),
                  (interpolate0 = interpolate3((string00 = string0), value1)));
        };
    }
    function styleMaybeRemove(id2, name) {
        var on0,
            on1,
            listener0,
            key = 'style.' + name,
            event = 'end.' + key,
            remove2;
        return function () {
            var schedule = set3(this, id2),
                on = schedule.on,
                listener =
                    schedule.value[key] == null
                        ? remove2 || (remove2 = styleRemove2(name))
                        : void 0;
            if (on !== on0 || listener0 !== listener)
                (on1 = (on0 = on).copy()).on(event, (listener0 = listener));
            schedule.on = on1;
        };
    }
    function style_default2(name, value, priority) {
        var i =
            (name += '') === 'transform'
                ? interpolateTransformCss
                : interpolate_default;
        return value == null
            ? this.styleTween(name, styleNull(name, i)).on(
                  'end.style.' + name,
                  styleRemove2(name)
              )
            : typeof value === 'function'
            ? this.styleTween(
                  name,
                  styleFunction2(
                      name,
                      i,
                      tweenValue(this, 'style.' + name, value)
                  )
              ).each(styleMaybeRemove(this._id, name))
            : this.styleTween(
                  name,
                  styleConstant2(name, i, value),
                  priority
              ).on('end.style.' + name, null);
    }

    // node_modules/d3-transition/src/transition/styleTween.js
    function styleInterpolate(name, i, priority) {
        return function (t) {
            this.style.setProperty(name, i.call(this, t), priority);
        };
    }
    function styleTween(name, value, priority) {
        var t, i0;
        function tween() {
            var i = value.apply(this, arguments);
            if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
            return t;
        }
        tween._value = value;
        return tween;
    }
    function styleTween_default(name, value, priority) {
        var key = 'style.' + (name += '');
        if (arguments.length < 2) return (key = this.tween(key)) && key._value;
        if (value == null) return this.tween(key, null);
        if (typeof value !== 'function') throw new Error();
        return this.tween(
            key,
            styleTween(name, value, priority == null ? '' : priority)
        );
    }

    // node_modules/d3-transition/src/transition/text.js
    function textConstant2(value) {
        return function () {
            this.textContent = value;
        };
    }
    function textFunction2(value) {
        return function () {
            var value1 = value(this);
            this.textContent = value1 == null ? '' : value1;
        };
    }
    function text_default2(value) {
        return this.tween(
            'text',
            typeof value === 'function'
                ? textFunction2(tweenValue(this, 'text', value))
                : textConstant2(value == null ? '' : value + '')
        );
    }

    // node_modules/d3-transition/src/transition/textTween.js
    function textInterpolate(i) {
        return function (t) {
            this.textContent = i.call(this, t);
        };
    }
    function textTween(value) {
        var t0, i0;
        function tween() {
            var i = value.apply(this, arguments);
            if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
            return t0;
        }
        tween._value = value;
        return tween;
    }
    function textTween_default(value) {
        var key = 'text';
        if (arguments.length < 1) return (key = this.tween(key)) && key._value;
        if (value == null) return this.tween(key, null);
        if (typeof value !== 'function') throw new Error();
        return this.tween(key, textTween(value));
    }

    // node_modules/d3-transition/src/transition/transition.js
    function transition_default() {
        var name = this._name,
            id0 = this._id,
            id1 = newId();
        for (
            var groups2 = this._groups, m = groups2.length, j = 0;
            j < m;
            ++j
        ) {
            for (
                var group2 = groups2[j], n = group2.length, node, i = 0;
                i < n;
                ++i
            ) {
                if ((node = group2[i])) {
                    var inherit2 = get2(node, id0);
                    schedule_default(node, name, id1, i, group2, {
                        time:
                            inherit2.time + inherit2.delay + inherit2.duration,
                        delay: 0,
                        duration: inherit2.duration,
                        ease: inherit2.ease,
                    });
                }
            }
        }
        return new Transition(groups2, this._parents, name, id1);
    }

    // node_modules/d3-transition/src/transition/end.js
    function end_default() {
        var on0,
            on1,
            that = this,
            id2 = that._id,
            size = that.size();
        return new Promise(function (resolve2, reject) {
            var cancel = { value: reject },
                end = {
                    value: function () {
                        if (--size === 0) resolve2();
                    },
                };
            that.each(function () {
                var schedule = set3(this, id2),
                    on = schedule.on;
                if (on !== on0) {
                    on1 = (on0 = on).copy();
                    on1._.cancel.push(cancel);
                    on1._.interrupt.push(cancel);
                    on1._.end.push(end);
                }
                schedule.on = on1;
            });
            if (size === 0) resolve2();
        });
    }

    // node_modules/d3-transition/src/transition/index.js
    var id = 0;
    function Transition(groups2, parents, name, id2) {
        this._groups = groups2;
        this._parents = parents;
        this._name = name;
        this._id = id2;
    }
    function transition(name) {
        return selection_default().transition(name);
    }
    function newId() {
        return ++id;
    }
    var selection_prototype = selection_default.prototype;
    Transition.prototype = transition.prototype = {
        constructor: Transition,
        select: select_default3,
        selectAll: selectAll_default2,
        selectChild: selection_prototype.selectChild,
        selectChildren: selection_prototype.selectChildren,
        filter: filter_default2,
        merge: merge_default2,
        selection: selection_default2,
        transition: transition_default,
        call: selection_prototype.call,
        nodes: selection_prototype.nodes,
        node: selection_prototype.node,
        size: selection_prototype.size,
        empty: selection_prototype.empty,
        each: selection_prototype.each,
        on: on_default2,
        attr: attr_default2,
        attrTween: attrTween_default,
        style: style_default2,
        styleTween: styleTween_default,
        text: text_default2,
        textTween: textTween_default,
        remove: remove_default2,
        tween: tween_default,
        delay: delay_default,
        duration: duration_default,
        ease: ease_default,
        easeVarying: easeVarying_default,
        end: end_default,
        [Symbol.iterator]: selection_prototype[Symbol.iterator],
    };

    // node_modules/d3-ease/src/cubic.js
    function cubicInOut(t) {
        return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
    }

    // node_modules/d3-transition/src/selection/transition.js
    var defaultTiming = {
        time: null,
        // Set on use.
        delay: 0,
        duration: 250,
        ease: cubicInOut,
    };
    function inherit(node, id2) {
        var timing;
        while (!(timing = node.__transition) || !(timing = timing[id2])) {
            if (!(node = node.parentNode)) {
                throw new Error(`transition ${id2} not found`);
            }
        }
        return timing;
    }
    function transition_default2(name) {
        var id2, timing;
        if (name instanceof Transition) {
            (id2 = name._id), (name = name._name);
        } else {
            (id2 = newId()),
                ((timing = defaultTiming).time = now()),
                (name = name == null ? null : name + '');
        }
        for (
            var groups2 = this._groups, m = groups2.length, j = 0;
            j < m;
            ++j
        ) {
            for (
                var group2 = groups2[j], n = group2.length, node, i = 0;
                i < n;
                ++i
            ) {
                if ((node = group2[i])) {
                    schedule_default(
                        node,
                        name,
                        id2,
                        i,
                        group2,
                        timing || inherit(node, id2)
                    );
                }
            }
        }
        return new Transition(groups2, this._parents, name, id2);
    }

    // node_modules/d3-transition/src/selection/index.js
    selection_default.prototype.interrupt = interrupt_default2;
    selection_default.prototype.transition = transition_default2;

    // node_modules/d3-brush/src/brush.js
    var { abs, max: max2, min: min2 } = Math;
    function number1(e) {
        return [+e[0], +e[1]];
    }
    function number2(e) {
        return [number1(e[0]), number1(e[1])];
    }
    var X = {
        name: 'x',
        handles: ['w', 'e'].map(type),
        input: function (x, e) {
            return x == null
                ? null
                : [
                      [+x[0], e[0][1]],
                      [+x[1], e[1][1]],
                  ];
        },
        output: function (xy) {
            return xy && [xy[0][0], xy[1][0]];
        },
    };
    var Y = {
        name: 'y',
        handles: ['n', 's'].map(type),
        input: function (y, e) {
            return y == null
                ? null
                : [
                      [e[0][0], +y[0]],
                      [e[1][0], +y[1]],
                  ];
        },
        output: function (xy) {
            return xy && [xy[0][1], xy[1][1]];
        },
    };
    var XY = {
        name: 'xy',
        handles: ['n', 'w', 'e', 's', 'nw', 'ne', 'sw', 'se'].map(type),
        input: function (xy) {
            return xy == null ? null : number2(xy);
        },
        output: function (xy) {
            return xy;
        },
    };
    function type(t) {
        return { type: t };
    }

    // node_modules/d3-format/src/formatDecimal.js
    function formatDecimal_default(x) {
        return Math.abs((x = Math.round(x))) >= 1e21
            ? x.toLocaleString('en').replace(/,/g, '')
            : x.toString(10);
    }
    function formatDecimalParts(x, p) {
        if (
            (i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(
                'e'
            )) < 0
        )
            return null;
        var i,
            coefficient = x.slice(0, i);
        return [
            coefficient.length > 1
                ? coefficient[0] + coefficient.slice(2)
                : coefficient,
            +x.slice(i + 1),
        ];
    }

    // node_modules/d3-format/src/exponent.js
    function exponent_default(x) {
        return (x = formatDecimalParts(Math.abs(x))), x ? x[1] : NaN;
    }

    // node_modules/d3-format/src/formatGroup.js
    function formatGroup_default(grouping, thousands) {
        return function (value, width) {
            var i = value.length,
                t = [],
                j = 0,
                g = grouping[0],
                length = 0;
            while (i > 0 && g > 0) {
                if (length + g + 1 > width) g = Math.max(1, width - length);
                t.push(value.substring((i -= g), i + g));
                if ((length += g + 1) > width) break;
                g = grouping[(j = (j + 1) % grouping.length)];
            }
            return t.reverse().join(thousands);
        };
    }

    // node_modules/d3-format/src/formatNumerals.js
    function formatNumerals_default(numerals) {
        return function (value) {
            return value.replace(/[0-9]/g, function (i) {
                return numerals[+i];
            });
        };
    }

    // node_modules/d3-format/src/formatSpecifier.js
    var re =
        /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
    function formatSpecifier(specifier) {
        if (!(match = re.exec(specifier)))
            throw new Error('invalid format: ' + specifier);
        var match;
        return new FormatSpecifier({
            fill: match[1],
            align: match[2],
            sign: match[3],
            symbol: match[4],
            zero: match[5],
            width: match[6],
            comma: match[7],
            precision: match[8] && match[8].slice(1),
            trim: match[9],
            type: match[10],
        });
    }
    formatSpecifier.prototype = FormatSpecifier.prototype;
    function FormatSpecifier(specifier) {
        this.fill = specifier.fill === void 0 ? ' ' : specifier.fill + '';
        this.align = specifier.align === void 0 ? '>' : specifier.align + '';
        this.sign = specifier.sign === void 0 ? '-' : specifier.sign + '';
        this.symbol = specifier.symbol === void 0 ? '' : specifier.symbol + '';
        this.zero = !!specifier.zero;
        this.width = specifier.width === void 0 ? void 0 : +specifier.width;
        this.comma = !!specifier.comma;
        this.precision =
            specifier.precision === void 0 ? void 0 : +specifier.precision;
        this.trim = !!specifier.trim;
        this.type = specifier.type === void 0 ? '' : specifier.type + '';
    }
    FormatSpecifier.prototype.toString = function () {
        return (
            this.fill +
            this.align +
            this.sign +
            this.symbol +
            (this.zero ? '0' : '') +
            (this.width === void 0 ? '' : Math.max(1, this.width | 0)) +
            (this.comma ? ',' : '') +
            (this.precision === void 0
                ? ''
                : '.' + Math.max(0, this.precision | 0)) +
            (this.trim ? '~' : '') +
            this.type
        );
    };

    // node_modules/d3-format/src/formatTrim.js
    function formatTrim_default(s) {
        out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
            switch (s[i]) {
                case '.':
                    i0 = i1 = i;
                    break;
                case '0':
                    if (i0 === 0) i0 = i;
                    i1 = i;
                    break;
                default:
                    if (!+s[i]) break out;
                    if (i0 > 0) i0 = 0;
                    break;
            }
        }
        return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
    }

    // node_modules/d3-format/src/formatPrefixAuto.js
    var prefixExponent;
    function formatPrefixAuto_default(x, p) {
        var d = formatDecimalParts(x, p);
        if (!d) return x + '';
        var coefficient = d[0],
            exponent = d[1],
            i =
                exponent -
                (prefixExponent =
                    Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) +
                1,
            n = coefficient.length;
        return i === n
            ? coefficient
            : i > n
            ? coefficient + new Array(i - n + 1).join('0')
            : i > 0
            ? coefficient.slice(0, i) + '.' + coefficient.slice(i)
            : '0.' +
              new Array(1 - i).join('0') +
              formatDecimalParts(x, Math.max(0, p + i - 1))[0];
    }

    // node_modules/d3-format/src/formatRounded.js
    function formatRounded_default(x, p) {
        var d = formatDecimalParts(x, p);
        if (!d) return x + '';
        var coefficient = d[0],
            exponent = d[1];
        return exponent < 0
            ? '0.' + new Array(-exponent).join('0') + coefficient
            : coefficient.length > exponent + 1
            ? coefficient.slice(0, exponent + 1) +
              '.' +
              coefficient.slice(exponent + 1)
            : coefficient +
              new Array(exponent - coefficient.length + 2).join('0');
    }

    // node_modules/d3-format/src/formatTypes.js
    var formatTypes_default = {
        '%': (x, p) => (x * 100).toFixed(p),
        b: (x) => Math.round(x).toString(2),
        c: (x) => x + '',
        d: formatDecimal_default,
        e: (x, p) => x.toExponential(p),
        f: (x, p) => x.toFixed(p),
        g: (x, p) => x.toPrecision(p),
        o: (x) => Math.round(x).toString(8),
        p: (x, p) => formatRounded_default(x * 100, p),
        r: formatRounded_default,
        s: formatPrefixAuto_default,
        X: (x) => Math.round(x).toString(16).toUpperCase(),
        x: (x) => Math.round(x).toString(16),
    };

    // node_modules/d3-format/src/identity.js
    function identity_default(x) {
        return x;
    }

    // node_modules/d3-format/src/locale.js
    var map3 = Array.prototype.map;
    var prefixes = [
        'y',
        'z',
        'a',
        'f',
        'p',
        'n',
        '\xB5',
        'm',
        '',
        'k',
        'M',
        'G',
        'T',
        'P',
        'E',
        'Z',
        'Y',
    ];
    function locale_default(locale2) {
        var group2 =
                locale2.grouping === void 0 || locale2.thousands === void 0
                    ? identity_default
                    : formatGroup_default(
                          map3.call(locale2.grouping, Number),
                          locale2.thousands + ''
                      ),
            currencyPrefix =
                locale2.currency === void 0 ? '' : locale2.currency[0] + '',
            currencySuffix =
                locale2.currency === void 0 ? '' : locale2.currency[1] + '',
            decimal = locale2.decimal === void 0 ? '.' : locale2.decimal + '',
            numerals =
                locale2.numerals === void 0
                    ? identity_default
                    : formatNumerals_default(
                          map3.call(locale2.numerals, String)
                      ),
            percent = locale2.percent === void 0 ? '%' : locale2.percent + '',
            minus = locale2.minus === void 0 ? '\u2212' : locale2.minus + '',
            nan = locale2.nan === void 0 ? 'NaN' : locale2.nan + '';
        function newFormat(specifier) {
            specifier = formatSpecifier(specifier);
            var fill2 = specifier.fill,
                align = specifier.align,
                sign2 = specifier.sign,
                symbol = specifier.symbol,
                zero2 = specifier.zero,
                width = specifier.width,
                comma = specifier.comma,
                precision = specifier.precision,
                trim = specifier.trim,
                type2 = specifier.type;
            if (type2 === 'n') (comma = true), (type2 = 'g');
            else if (!formatTypes_default[type2])
                precision === void 0 && (precision = 12),
                    (trim = true),
                    (type2 = 'g');
            if (zero2 || (fill2 === '0' && align === '='))
                (zero2 = true), (fill2 = '0'), (align = '=');
            var prefix =
                    symbol === '$'
                        ? currencyPrefix
                        : symbol === '#' && /[boxX]/.test(type2)
                        ? '0' + type2.toLowerCase()
                        : '',
                suffix =
                    symbol === '$'
                        ? currencySuffix
                        : /[%p]/.test(type2)
                        ? percent
                        : '';
            var formatType = formatTypes_default[type2],
                maybeSuffix = /[defgprs%]/.test(type2);
            precision =
                precision === void 0
                    ? 6
                    : /[gprs]/.test(type2)
                    ? Math.max(1, Math.min(21, precision))
                    : Math.max(0, Math.min(20, precision));
            function format2(value) {
                var valuePrefix = prefix,
                    valueSuffix = suffix,
                    i,
                    n,
                    c;
                if (type2 === 'c') {
                    valueSuffix = formatType(value) + valueSuffix;
                    value = '';
                } else {
                    value = +value;
                    var valueNegative = value < 0 || 1 / value < 0;
                    value = isNaN(value)
                        ? nan
                        : formatType(Math.abs(value), precision);
                    if (trim) value = formatTrim_default(value);
                    if (valueNegative && +value === 0 && sign2 !== '+')
                        valueNegative = false;
                    valuePrefix =
                        (valueNegative
                            ? sign2 === '('
                                ? sign2
                                : minus
                            : sign2 === '-' || sign2 === '('
                            ? ''
                            : sign2) + valuePrefix;
                    valueSuffix =
                        (type2 === 's'
                            ? prefixes[8 + prefixExponent / 3]
                            : '') +
                        valueSuffix +
                        (valueNegative && sign2 === '(' ? ')' : '');
                    if (maybeSuffix) {
                        (i = -1), (n = value.length);
                        while (++i < n) {
                            if (((c = value.charCodeAt(i)), 48 > c || c > 57)) {
                                valueSuffix =
                                    (c === 46
                                        ? decimal + value.slice(i + 1)
                                        : value.slice(i)) + valueSuffix;
                                value = value.slice(0, i);
                                break;
                            }
                        }
                    }
                }
                if (comma && !zero2) value = group2(value, Infinity);
                var length =
                        valuePrefix.length + value.length + valueSuffix.length,
                    padding =
                        length < width
                            ? new Array(width - length + 1).join(fill2)
                            : '';
                if (comma && zero2)
                    (value = group2(
                        padding + value,
                        padding.length ? width - valueSuffix.length : Infinity
                    )),
                        (padding = '');
                switch (align) {
                    case '<':
                        value = valuePrefix + value + valueSuffix + padding;
                        break;
                    case '=':
                        value = valuePrefix + padding + value + valueSuffix;
                        break;
                    case '^':
                        value =
                            padding.slice(0, (length = padding.length >> 1)) +
                            valuePrefix +
                            value +
                            valueSuffix +
                            padding.slice(length);
                        break;
                    default:
                        value = padding + valuePrefix + value + valueSuffix;
                        break;
                }
                return numerals(value);
            }
            format2.toString = function () {
                return specifier + '';
            };
            return format2;
        }
        function formatPrefix2(specifier, value) {
            var f = newFormat(
                    ((specifier = formatSpecifier(specifier)),
                    (specifier.type = 'f'),
                    specifier)
                ),
                e =
                    Math.max(
                        -8,
                        Math.min(8, Math.floor(exponent_default(value) / 3))
                    ) * 3,
                k = Math.pow(10, -e),
                prefix = prefixes[8 + e / 3];
            return function (value2) {
                return f(k * value2) + prefix;
            };
        }
        return {
            format: newFormat,
            formatPrefix: formatPrefix2,
        };
    }

    // node_modules/d3-format/src/defaultLocale.js
    var locale;
    var format;
    var formatPrefix;
    defaultLocale({
        thousands: ',',
        grouping: [3],
        currency: ['$', ''],
    });
    function defaultLocale(definition) {
        locale = locale_default(definition);
        format = locale.format;
        formatPrefix = locale.formatPrefix;
        return locale;
    }

    // node_modules/d3-zoom/src/transform.js
    function Transform(k, x, y) {
        this.k = k;
        this.x = x;
        this.y = y;
    }
    Transform.prototype = {
        constructor: Transform,
        scale: function (k) {
            return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
        },
        translate: function (x, y) {
            return (x === 0) & (y === 0)
                ? this
                : new Transform(
                      this.k,
                      this.x + this.k * x,
                      this.y + this.k * y
                  );
        },
        apply: function (point) {
            return [point[0] * this.k + this.x, point[1] * this.k + this.y];
        },
        applyX: function (x) {
            return x * this.k + this.x;
        },
        applyY: function (y) {
            return y * this.k + this.y;
        },
        invert: function (location) {
            return [
                (location[0] - this.x) / this.k,
                (location[1] - this.y) / this.k,
            ];
        },
        invertX: function (x) {
            return (x - this.x) / this.k;
        },
        invertY: function (y) {
            return (y - this.y) / this.k;
        },
        rescaleX: function (x) {
            return x
                .copy()
                .domain(x.range().map(this.invertX, this).map(x.invert, x));
        },
        rescaleY: function (y) {
            return y
                .copy()
                .domain(y.range().map(this.invertY, this).map(y.invert, y));
        },
        toString: function () {
            return (
                'translate(' + this.x + ',' + this.y + ') scale(' + this.k + ')'
            );
        },
    };
    var identity3 = new Transform(1, 0, 0);
    transform.prototype = Transform.prototype;
    function transform(node) {
        while (!node.__zoom) if (!(node = node.parentNode)) return identity3;
        return node.__zoom;
    }

    // node_modules/chart.js/auto/auto.mjs
    Chart.register(...registerables);
    var auto_default = Chart;

    // node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.esm.js
    var devicePixelRatio = (function () {
        if (typeof window !== 'undefined') {
            if (window.devicePixelRatio) {
                return window.devicePixelRatio;
            }
            var screen = window.screen;
            if (screen) {
                return (screen.deviceXDPI || 1) / (screen.logicalXDPI || 1);
            }
        }
        return 1;
    })();
    var utils = {
        // @todo move this in Chart.helpers.toTextLines
        toTextLines: function (inputs) {
            var lines = [];
            var input;
            inputs = [].concat(inputs);
            while (inputs.length) {
                input = inputs.pop();
                if (typeof input === 'string') {
                    lines.unshift.apply(lines, input.split('\n'));
                } else if (Array.isArray(input)) {
                    inputs.push.apply(inputs, input);
                } else if (!isNullOrUndef(inputs)) {
                    lines.unshift('' + input);
                }
            }
            return lines;
        },
        // @todo move this in Chart.helpers.canvas.textSize
        // @todo cache calls of measureText if font doesn't change?!
        textSize: function (ctx, lines, font) {
            var items = [].concat(lines);
            var ilen = items.length;
            var prev = ctx.font;
            var width = 0;
            var i;
            ctx.font = font.string;
            for (i = 0; i < ilen; ++i) {
                width = Math.max(ctx.measureText(items[i]).width, width);
            }
            ctx.font = prev;
            return {
                height: ilen * font.lineHeight,
                width,
            };
        },
        /**
         * Returns value bounded by min and max. This is equivalent to max(min, min(value, max)).
         * @todo move this method in Chart.helpers.bound
         * https://doc.qt.io/qt-5/qtglobal.html#qBound
         */
        bound: function (min3, value, max3) {
            return Math.max(min3, Math.min(value, max3));
        },
        /**
         * Returns an array of pair [value, state] where state is:
         * * -1: value is only in a0 (removed)
         * *  1: value is only in a1 (added)
         */
        arrayDiff: function (a0, a1) {
            var prev = a0.slice();
            var updates = [];
            var i, j, ilen, v;
            for (i = 0, ilen = a1.length; i < ilen; ++i) {
                v = a1[i];
                j = prev.indexOf(v);
                if (j === -1) {
                    updates.push([v, 1]);
                } else {
                    prev.splice(j, 1);
                }
            }
            for (i = 0, ilen = prev.length; i < ilen; ++i) {
                updates.push([prev[i], -1]);
            }
            return updates;
        },
        /**
         * https://github.com/chartjs/chartjs-plugin-datalabels/issues/70
         */
        rasterize: function (v) {
            return Math.round(v * devicePixelRatio) / devicePixelRatio;
        },
    };
    function orient(point, origin) {
        var x0 = origin.x;
        var y0 = origin.y;
        if (x0 === null) {
            return { x: 0, y: -1 };
        }
        if (y0 === null) {
            return { x: 1, y: 0 };
        }
        var dx = point.x - x0;
        var dy = point.y - y0;
        var ln = Math.sqrt(dx * dx + dy * dy);
        return {
            x: ln ? dx / ln : 0,
            y: ln ? dy / ln : -1,
        };
    }
    function aligned(x, y, vx, vy, align) {
        switch (align) {
            case 'center':
                vx = vy = 0;
                break;
            case 'bottom':
                vx = 0;
                vy = 1;
                break;
            case 'right':
                vx = 1;
                vy = 0;
                break;
            case 'left':
                vx = -1;
                vy = 0;
                break;
            case 'top':
                vx = 0;
                vy = -1;
                break;
            case 'start':
                vx = -vx;
                vy = -vy;
                break;
            case 'end':
                break;
            default:
                align *= Math.PI / 180;
                vx = Math.cos(align);
                vy = Math.sin(align);
                break;
        }
        return {
            x,
            y,
            vx,
            vy,
        };
    }
    var R_INSIDE = 0;
    var R_LEFT = 1;
    var R_RIGHT = 2;
    var R_BOTTOM = 4;
    var R_TOP = 8;
    function region(x, y, rect) {
        var res = R_INSIDE;
        if (x < rect.left) {
            res |= R_LEFT;
        } else if (x > rect.right) {
            res |= R_RIGHT;
        }
        if (y < rect.top) {
            res |= R_TOP;
        } else if (y > rect.bottom) {
            res |= R_BOTTOM;
        }
        return res;
    }
    function clipped(segment, area) {
        var x0 = segment.x0;
        var y0 = segment.y0;
        var x1 = segment.x1;
        var y1 = segment.y1;
        var r0 = region(x0, y0, area);
        var r1 = region(x1, y1, area);
        var r, x, y;
        while (true) {
            if (!(r0 | r1) || r0 & r1) {
                break;
            }
            r = r0 || r1;
            if (r & R_TOP) {
                x = x0 + ((x1 - x0) * (area.top - y0)) / (y1 - y0);
                y = area.top;
            } else if (r & R_BOTTOM) {
                x = x0 + ((x1 - x0) * (area.bottom - y0)) / (y1 - y0);
                y = area.bottom;
            } else if (r & R_RIGHT) {
                y = y0 + ((y1 - y0) * (area.right - x0)) / (x1 - x0);
                x = area.right;
            } else if (r & R_LEFT) {
                y = y0 + ((y1 - y0) * (area.left - x0)) / (x1 - x0);
                x = area.left;
            }
            if (r === r0) {
                x0 = x;
                y0 = y;
                r0 = region(x0, y0, area);
            } else {
                x1 = x;
                y1 = y;
                r1 = region(x1, y1, area);
            }
        }
        return {
            x0,
            x1,
            y0,
            y1,
        };
    }
    function compute$1(range, config) {
        var anchor = config.anchor;
        var segment = range;
        var x, y;
        if (config.clamp) {
            segment = clipped(segment, config.area);
        }
        if (anchor === 'start') {
            x = segment.x0;
            y = segment.y0;
        } else if (anchor === 'end') {
            x = segment.x1;
            y = segment.y1;
        } else {
            x = (segment.x0 + segment.x1) / 2;
            y = (segment.y0 + segment.y1) / 2;
        }
        return aligned(x, y, range.vx, range.vy, config.align);
    }
    var positioners2 = {
        arc: function (el, config) {
            var angle = (el.startAngle + el.endAngle) / 2;
            var vx = Math.cos(angle);
            var vy = Math.sin(angle);
            var r0 = el.innerRadius;
            var r1 = el.outerRadius;
            return compute$1(
                {
                    x0: el.x + vx * r0,
                    y0: el.y + vy * r0,
                    x1: el.x + vx * r1,
                    y1: el.y + vy * r1,
                    vx,
                    vy,
                },
                config
            );
        },
        point: function (el, config) {
            var v = orient(el, config.origin);
            var rx = v.x * el.options.radius;
            var ry = v.y * el.options.radius;
            return compute$1(
                {
                    x0: el.x - rx,
                    y0: el.y - ry,
                    x1: el.x + rx,
                    y1: el.y + ry,
                    vx: v.x,
                    vy: v.y,
                },
                config
            );
        },
        bar: function (el, config) {
            var v = orient(el, config.origin);
            var x = el.x;
            var y = el.y;
            var sx = 0;
            var sy = 0;
            if (el.horizontal) {
                x = Math.min(el.x, el.base);
                sx = Math.abs(el.base - el.x);
            } else {
                y = Math.min(el.y, el.base);
                sy = Math.abs(el.base - el.y);
            }
            return compute$1(
                {
                    x0: x,
                    y0: y + sy,
                    x1: x + sx,
                    y1: y,
                    vx: v.x,
                    vy: v.y,
                },
                config
            );
        },
        fallback: function (el, config) {
            var v = orient(el, config.origin);
            return compute$1(
                {
                    x0: el.x,
                    y0: el.y,
                    x1: el.x + (el.width || 0),
                    y1: el.y + (el.height || 0),
                    vx: v.x,
                    vy: v.y,
                },
                config
            );
        },
    };
    var rasterize = utils.rasterize;
    function boundingRects2(model) {
        var borderWidth3 = model.borderWidth || 0;
        var padding = model.padding;
        var th = model.size.height;
        var tw = model.size.width;
        var tx = -tw / 2;
        var ty = -th / 2;
        return {
            frame: {
                x: tx - padding.left - borderWidth3,
                y: ty - padding.top - borderWidth3,
                w: tw + padding.width + borderWidth3 * 2,
                h: th + padding.height + borderWidth3 * 2,
            },
            text: {
                x: tx,
                y: ty,
                w: tw,
                h: th,
            },
        };
    }
    function getScaleOrigin(el, context) {
        var scale = context.chart.getDatasetMeta(context.datasetIndex).vScale;
        if (!scale) {
            return null;
        }
        if (scale.xCenter !== void 0 && scale.yCenter !== void 0) {
            return { x: scale.xCenter, y: scale.yCenter };
        }
        var pixel = scale.getBasePixel();
        return el.horizontal ? { x: pixel, y: null } : { x: null, y: pixel };
    }
    function getPositioner(el) {
        if (el instanceof ArcElement) {
            return positioners2.arc;
        }
        if (el instanceof PointElement) {
            return positioners2.point;
        }
        if (el instanceof BarElement) {
            return positioners2.bar;
        }
        return positioners2.fallback;
    }
    function drawRoundedRect(ctx, x, y, w, h, radius3) {
        var HALF_PI2 = Math.PI / 2;
        if (radius3) {
            var r = Math.min(radius3, h / 2, w / 2);
            var left = x + r;
            var top = y + r;
            var right = x + w - r;
            var bottom = y + h - r;
            ctx.moveTo(x, top);
            if (left < right && top < bottom) {
                ctx.arc(left, top, r, -Math.PI, -HALF_PI2);
                ctx.arc(right, top, r, -HALF_PI2, 0);
                ctx.arc(right, bottom, r, 0, HALF_PI2);
                ctx.arc(left, bottom, r, HALF_PI2, Math.PI);
            } else if (left < right) {
                ctx.moveTo(left, y);
                ctx.arc(right, top, r, -HALF_PI2, HALF_PI2);
                ctx.arc(left, top, r, HALF_PI2, Math.PI + HALF_PI2);
            } else if (top < bottom) {
                ctx.arc(left, top, r, -Math.PI, 0);
                ctx.arc(left, bottom, r, 0, Math.PI);
            } else {
                ctx.arc(left, top, r, -Math.PI, Math.PI);
            }
            ctx.closePath();
            ctx.moveTo(x, y);
        } else {
            ctx.rect(x, y, w, h);
        }
    }
    function drawFrame(ctx, rect, model) {
        var bgColor = model.backgroundColor;
        var borderColor4 = model.borderColor;
        var borderWidth3 = model.borderWidth;
        if (!bgColor && (!borderColor4 || !borderWidth3)) {
            return;
        }
        ctx.beginPath();
        drawRoundedRect(
            ctx,
            rasterize(rect.x) + borderWidth3 / 2,
            rasterize(rect.y) + borderWidth3 / 2,
            rasterize(rect.w) - borderWidth3,
            rasterize(rect.h) - borderWidth3,
            model.borderRadius
        );
        ctx.closePath();
        if (bgColor) {
            ctx.fillStyle = bgColor;
            ctx.fill();
        }
        if (borderColor4 && borderWidth3) {
            ctx.strokeStyle = borderColor4;
            ctx.lineWidth = borderWidth3;
            ctx.lineJoin = 'miter';
            ctx.stroke();
        }
    }
    function textGeometry(rect, align, font) {
        var h = font.lineHeight;
        var w = rect.w;
        var x = rect.x;
        var y = rect.y + h / 2;
        if (align === 'center') {
            x += w / 2;
        } else if (align === 'end' || align === 'right') {
            x += w;
        }
        return {
            h,
            w,
            x,
            y,
        };
    }
    function drawTextLine(ctx, text, cfg) {
        var shadow = ctx.shadowBlur;
        var stroked = cfg.stroked;
        var x = rasterize(cfg.x);
        var y = rasterize(cfg.y);
        var w = rasterize(cfg.w);
        if (stroked) {
            ctx.strokeText(text, x, y, w);
        }
        if (cfg.filled) {
            if (shadow && stroked) {
                ctx.shadowBlur = 0;
            }
            ctx.fillText(text, x, y, w);
            if (shadow && stroked) {
                ctx.shadowBlur = shadow;
            }
        }
    }
    function drawText(ctx, lines, rect, model) {
        var align = model.textAlign;
        var color3 = model.color;
        var filled = !!color3;
        var font = model.font;
        var ilen = lines.length;
        var strokeColor = model.textStrokeColor;
        var strokeWidth = model.textStrokeWidth;
        var stroked = strokeColor && strokeWidth;
        var i;
        if (!ilen || (!filled && !stroked)) {
            return;
        }
        rect = textGeometry(rect, align, font);
        ctx.font = font.string;
        ctx.textAlign = align;
        ctx.textBaseline = 'middle';
        ctx.shadowBlur = model.textShadowBlur;
        ctx.shadowColor = model.textShadowColor;
        if (filled) {
            ctx.fillStyle = color3;
        }
        if (stroked) {
            ctx.lineJoin = 'round';
            ctx.lineWidth = strokeWidth;
            ctx.strokeStyle = strokeColor;
        }
        for (i = 0, ilen = lines.length; i < ilen; ++i) {
            drawTextLine(ctx, lines[i], {
                stroked,
                filled,
                w: rect.w,
                x: rect.x,
                y: rect.y + rect.h * i,
            });
        }
    }
    var Label = function (config, ctx, el, index3) {
        var me = this;
        me._config = config;
        me._index = index3;
        me._model = null;
        me._rects = null;
        me._ctx = ctx;
        me._el = el;
    };
    merge(Label.prototype, {
        /**
         * @private
         */
        _modelize: function (display, lines, config, context) {
            var me = this;
            var index3 = me._index;
            var font = toFont(resolve([config.font, {}], context, index3));
            var color3 = resolve(
                [config.color, defaults.color],
                context,
                index3
            );
            return {
                align: resolve([config.align, 'center'], context, index3),
                anchor: resolve([config.anchor, 'center'], context, index3),
                area: context.chart.chartArea,
                backgroundColor: resolve(
                    [config.backgroundColor, null],
                    context,
                    index3
                ),
                borderColor: resolve(
                    [config.borderColor, null],
                    context,
                    index3
                ),
                borderRadius: resolve(
                    [config.borderRadius, 0],
                    context,
                    index3
                ),
                borderWidth: resolve([config.borderWidth, 0], context, index3),
                clamp: resolve([config.clamp, false], context, index3),
                clip: resolve([config.clip, false], context, index3),
                color: color3,
                display,
                font,
                lines,
                offset: resolve([config.offset, 4], context, index3),
                opacity: resolve([config.opacity, 1], context, index3),
                origin: getScaleOrigin(me._el, context),
                padding: toPadding(
                    resolve([config.padding, 4], context, index3)
                ),
                positioner: getPositioner(me._el),
                rotation:
                    resolve([config.rotation, 0], context, index3) *
                    (Math.PI / 180),
                size: utils.textSize(me._ctx, lines, font),
                textAlign: resolve(
                    [config.textAlign, 'start'],
                    context,
                    index3
                ),
                textShadowBlur: resolve(
                    [config.textShadowBlur, 0],
                    context,
                    index3
                ),
                textShadowColor: resolve(
                    [config.textShadowColor, color3],
                    context,
                    index3
                ),
                textStrokeColor: resolve(
                    [config.textStrokeColor, color3],
                    context,
                    index3
                ),
                textStrokeWidth: resolve(
                    [config.textStrokeWidth, 0],
                    context,
                    index3
                ),
            };
        },
        update: function (context) {
            var me = this;
            var model = null;
            var rects = null;
            var index3 = me._index;
            var config = me._config;
            var value, label, lines;
            var display = resolve([config.display, true], context, index3);
            if (display) {
                value = context.dataset.data[index3];
                label = valueOrDefault(
                    callback(config.formatter, [value, context]),
                    value
                );
                lines = isNullOrUndef(label) ? [] : utils.toTextLines(label);
                if (lines.length) {
                    model = me._modelize(display, lines, config, context);
                    rects = boundingRects2(model);
                }
            }
            me._model = model;
            me._rects = rects;
        },
        geometry: function () {
            return this._rects ? this._rects.frame : {};
        },
        rotation: function () {
            return this._model ? this._model.rotation : 0;
        },
        visible: function () {
            return this._model && this._model.opacity;
        },
        model: function () {
            return this._model;
        },
        draw: function (chart, center) {
            var me = this;
            var ctx = chart.ctx;
            var model = me._model;
            var rects = me._rects;
            var area;
            if (!this.visible()) {
                return;
            }
            ctx.save();
            if (model.clip) {
                area = model.area;
                ctx.beginPath();
                ctx.rect(
                    area.left,
                    area.top,
                    area.right - area.left,
                    area.bottom - area.top
                );
                ctx.clip();
            }
            ctx.globalAlpha = utils.bound(0, model.opacity, 1);
            ctx.translate(rasterize(center.x), rasterize(center.y));
            ctx.rotate(model.rotation);
            drawFrame(ctx, rects.frame, model);
            drawText(ctx, model.lines, rects.text, model);
            ctx.restore();
        },
    });
    var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
    var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    function rotated2(point, center, angle) {
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);
        var cx = center.x;
        var cy = center.y;
        return {
            x: cx + cos * (point.x - cx) - sin * (point.y - cy),
            y: cy + sin * (point.x - cx) + cos * (point.y - cy),
        };
    }
    function projected(points, axis) {
        var min3 = MAX_INTEGER;
        var max3 = MIN_INTEGER;
        var origin = axis.origin;
        var i, pt, vx, vy, dp;
        for (i = 0; i < points.length; ++i) {
            pt = points[i];
            vx = pt.x - origin.x;
            vy = pt.y - origin.y;
            dp = axis.vx * vx + axis.vy * vy;
            min3 = Math.min(min3, dp);
            max3 = Math.max(max3, dp);
        }
        return {
            min: min3,
            max: max3,
        };
    }
    function toAxis(p0, p1) {
        var vx = p1.x - p0.x;
        var vy = p1.y - p0.y;
        var ln = Math.sqrt(vx * vx + vy * vy);
        return {
            vx: (p1.x - p0.x) / ln,
            vy: (p1.y - p0.y) / ln,
            origin: p0,
            ln,
        };
    }
    var HitBox = function () {
        this._rotation = 0;
        this._rect = {
            x: 0,
            y: 0,
            w: 0,
            h: 0,
        };
    };
    merge(HitBox.prototype, {
        center: function () {
            var r = this._rect;
            return {
                x: r.x + r.w / 2,
                y: r.y + r.h / 2,
            };
        },
        update: function (center, rect, rotation) {
            this._rotation = rotation;
            this._rect = {
                x: rect.x + center.x,
                y: rect.y + center.y,
                w: rect.w,
                h: rect.h,
            };
        },
        contains: function (point) {
            var me = this;
            var margin = 1;
            var rect = me._rect;
            point = rotated2(point, me.center(), -me._rotation);
            return !(
                point.x < rect.x - margin ||
                point.y < rect.y - margin ||
                point.x > rect.x + rect.w + margin * 2 ||
                point.y > rect.y + rect.h + margin * 2
            );
        },
        // Separating Axis Theorem
        // https://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169
        intersects: function (other) {
            var r0 = this._points();
            var r1 = other._points();
            var axes = [toAxis(r0[0], r0[1]), toAxis(r0[0], r0[3])];
            var i, pr0, pr1;
            if (this._rotation !== other._rotation) {
                axes.push(toAxis(r1[0], r1[1]), toAxis(r1[0], r1[3]));
            }
            for (i = 0; i < axes.length; ++i) {
                pr0 = projected(r0, axes[i]);
                pr1 = projected(r1, axes[i]);
                if (pr0.max < pr1.min || pr1.max < pr0.min) {
                    return false;
                }
            }
            return true;
        },
        /**
         * @private
         */
        _points: function () {
            var me = this;
            var rect = me._rect;
            var angle = me._rotation;
            var center = me.center();
            return [
                rotated2({ x: rect.x, y: rect.y }, center, angle),
                rotated2({ x: rect.x + rect.w, y: rect.y }, center, angle),
                rotated2(
                    { x: rect.x + rect.w, y: rect.y + rect.h },
                    center,
                    angle
                ),
                rotated2({ x: rect.x, y: rect.y + rect.h }, center, angle),
            ];
        },
    });
    function coordinates(el, model, geometry) {
        var point = model.positioner(el, model);
        var vx = point.vx;
        var vy = point.vy;
        if (!vx && !vy) {
            return { x: point.x, y: point.y };
        }
        var w = geometry.w;
        var h = geometry.h;
        var rotation = model.rotation;
        var dx =
            Math.abs((w / 2) * Math.cos(rotation)) +
            Math.abs((h / 2) * Math.sin(rotation));
        var dy =
            Math.abs((w / 2) * Math.sin(rotation)) +
            Math.abs((h / 2) * Math.cos(rotation));
        var vs = 1 / Math.max(Math.abs(vx), Math.abs(vy));
        dx *= vx * vs;
        dy *= vy * vs;
        dx += model.offset * vx;
        dy += model.offset * vy;
        return {
            x: point.x + dx,
            y: point.y + dy,
        };
    }
    function collide(labels, collider) {
        var i, j, s0, s1;
        for (i = labels.length - 1; i >= 0; --i) {
            s0 = labels[i].$layout;
            for (j = i - 1; j >= 0 && s0._visible; --j) {
                s1 = labels[j].$layout;
                if (s1._visible && s0._box.intersects(s1._box)) {
                    collider(s0, s1);
                }
            }
        }
        return labels;
    }
    function compute(labels) {
        var i, ilen, label, state, geometry, center, proxy;
        for (i = 0, ilen = labels.length; i < ilen; ++i) {
            label = labels[i];
            state = label.$layout;
            if (state._visible) {
                proxy = new Proxy(label._el, {
                    get: (el, p) => el.getProps([p], true)[p],
                });
                geometry = label.geometry();
                center = coordinates(proxy, label.model(), geometry);
                state._box.update(center, geometry, label.rotation());
            }
        }
        return collide(labels, function (s0, s1) {
            var h0 = s0._hidable;
            var h12 = s1._hidable;
            if ((h0 && h12) || h12) {
                s1._visible = false;
            } else if (h0) {
                s0._visible = false;
            }
        });
    }
    var layout = {
        prepare: function (datasets) {
            var labels = [];
            var i, j, ilen, jlen, label;
            for (i = 0, ilen = datasets.length; i < ilen; ++i) {
                for (j = 0, jlen = datasets[i].length; j < jlen; ++j) {
                    label = datasets[i][j];
                    labels.push(label);
                    label.$layout = {
                        _box: new HitBox(),
                        _hidable: false,
                        _visible: true,
                        _set: i,
                        _idx: label._index,
                    };
                }
            }
            labels.sort(function (a, b) {
                var sa = a.$layout;
                var sb = b.$layout;
                return sa._idx === sb._idx
                    ? sb._set - sa._set
                    : sb._idx - sa._idx;
            });
            this.update(labels);
            return labels;
        },
        update: function (labels) {
            var dirty = false;
            var i, ilen, label, model, state;
            for (i = 0, ilen = labels.length; i < ilen; ++i) {
                label = labels[i];
                model = label.model();
                state = label.$layout;
                state._hidable = model && model.display === 'auto';
                state._visible = label.visible();
                dirty |= state._hidable;
            }
            if (dirty) {
                compute(labels);
            }
        },
        lookup: function (labels, point) {
            var i, state;
            for (i = labels.length - 1; i >= 0; --i) {
                state = labels[i].$layout;
                if (state && state._visible && state._box.contains(point)) {
                    return labels[i];
                }
            }
            return null;
        },
        draw: function (chart, labels) {
            var i, ilen, label, state, geometry, center;
            for (i = 0, ilen = labels.length; i < ilen; ++i) {
                label = labels[i];
                state = label.$layout;
                if (state._visible) {
                    geometry = label.geometry();
                    center = coordinates(label._el, label.model(), geometry);
                    state._box.update(center, geometry, label.rotation());
                    label.draw(chart, center);
                }
            }
        },
    };
    var formatter = function (value) {
        if (isNullOrUndef(value)) {
            return null;
        }
        var label = value;
        var keys, klen, k;
        if (isObject(value)) {
            if (!isNullOrUndef(value.label)) {
                label = value.label;
            } else if (!isNullOrUndef(value.r)) {
                label = value.r;
            } else {
                label = '';
                keys = Object.keys(value);
                for (k = 0, klen = keys.length; k < klen; ++k) {
                    label +=
                        (k !== 0 ? ', ' : '') + keys[k] + ': ' + value[keys[k]];
                }
            }
        }
        return '' + label;
    };
    var defaults2 = {
        align: 'center',
        anchor: 'center',
        backgroundColor: null,
        borderColor: null,
        borderRadius: 0,
        borderWidth: 0,
        clamp: false,
        clip: false,
        color: void 0,
        display: true,
        font: {
            family: void 0,
            lineHeight: 1.2,
            size: void 0,
            style: void 0,
            weight: null,
        },
        formatter,
        labels: void 0,
        listeners: {},
        offset: 4,
        opacity: 1,
        padding: {
            top: 4,
            right: 4,
            bottom: 4,
            left: 4,
        },
        rotation: 0,
        textAlign: 'start',
        textStrokeColor: void 0,
        textStrokeWidth: 0,
        textShadowBlur: 0,
        textShadowColor: void 0,
    };
    var EXPANDO_KEY2 = '$datalabels';
    var DEFAULT_KEY = '$default';
    function configure(dataset, options) {
        var override = dataset.datalabels;
        var listeners = {};
        var configs = [];
        var labels, keys;
        if (override === false) {
            return null;
        }
        if (override === true) {
            override = {};
        }
        options = merge({}, [options, override]);
        labels = options.labels || {};
        keys = Object.keys(labels);
        delete options.labels;
        if (keys.length) {
            keys.forEach(function (key) {
                if (labels[key]) {
                    configs.push(
                        merge({}, [options, labels[key], { _key: key }])
                    );
                }
            });
        } else {
            configs.push(options);
        }
        listeners = configs.reduce(function (target, config) {
            each(config.listeners || {}, function (fn, event) {
                target[event] = target[event] || {};
                target[event][config._key || DEFAULT_KEY] = fn;
            });
            delete config.listeners;
            return target;
        }, {});
        return {
            labels: configs,
            listeners,
        };
    }
    function dispatchEvent3(chart, listeners, label, event) {
        if (!listeners) {
            return;
        }
        var context = label.$context;
        var groups2 = label.$groups;
        var callback$1;
        if (!listeners[groups2._set]) {
            return;
        }
        callback$1 = listeners[groups2._set][groups2._key];
        if (!callback$1) {
            return;
        }
        if (callback(callback$1, [context, event]) === true) {
            chart[EXPANDO_KEY2]._dirty = true;
            label.update(context);
        }
    }
    function dispatchMoveEvents2(chart, listeners, previous, label, event) {
        var enter, leave;
        if (!previous && !label) {
            return;
        }
        if (!previous) {
            enter = true;
        } else if (!label) {
            leave = true;
        } else if (previous !== label) {
            leave = enter = true;
        }
        if (leave) {
            dispatchEvent3(chart, listeners.leave, previous, event);
        }
        if (enter) {
            dispatchEvent3(chart, listeners.enter, label, event);
        }
    }
    function handleMoveEvents2(chart, event) {
        var expando = chart[EXPANDO_KEY2];
        var listeners = expando._listeners;
        var previous, label;
        if (!listeners.enter && !listeners.leave) {
            return;
        }
        if (event.type === 'mousemove') {
            label = layout.lookup(expando._labels, event);
        } else if (event.type !== 'mouseout') {
            return;
        }
        previous = expando._hovered;
        expando._hovered = label;
        dispatchMoveEvents2(chart, listeners, previous, label, event);
    }
    function handleClickEvents2(chart, event) {
        var expando = chart[EXPANDO_KEY2];
        var handlers = expando._listeners.click;
        var label = handlers && layout.lookup(expando._labels, event);
        if (label) {
            dispatchEvent3(chart, handlers, label, event);
        }
    }
    var plugin = {
        id: 'datalabels',
        defaults: defaults2,
        beforeInit: function (chart) {
            chart[EXPANDO_KEY2] = {
                _actives: [],
            };
        },
        beforeUpdate: function (chart) {
            var expando = chart[EXPANDO_KEY2];
            expando._listened = false;
            expando._listeners = {};
            expando._datasets = [];
            expando._labels = [];
        },
        afterDatasetUpdate: function (chart, args, options) {
            var datasetIndex = args.index;
            var expando = chart[EXPANDO_KEY2];
            var labels = (expando._datasets[datasetIndex] = []);
            var visible = chart.isDatasetVisible(datasetIndex);
            var dataset = chart.data.datasets[datasetIndex];
            var config = configure(dataset, options);
            var elements2 = args.meta.data || [];
            var ctx = chart.ctx;
            var i, j, ilen, jlen, cfg, key, el, label;
            ctx.save();
            for (i = 0, ilen = elements2.length; i < ilen; ++i) {
                el = elements2[i];
                el[EXPANDO_KEY2] = [];
                if (visible && el && chart.getDataVisibility(i) && !el.skip) {
                    for (j = 0, jlen = config.labels.length; j < jlen; ++j) {
                        cfg = config.labels[j];
                        key = cfg._key;
                        label = new Label(cfg, ctx, el, i);
                        label.$groups = {
                            _set: datasetIndex,
                            _key: key || DEFAULT_KEY,
                        };
                        label.$context = {
                            active: false,
                            chart,
                            dataIndex: i,
                            dataset,
                            datasetIndex,
                        };
                        label.update(label.$context);
                        el[EXPANDO_KEY2].push(label);
                        labels.push(label);
                    }
                }
            }
            ctx.restore();
            merge(expando._listeners, config.listeners, {
                merger: function (event, target, source) {
                    target[event] = target[event] || {};
                    target[event][args.index] = source[event];
                    expando._listened = true;
                },
            });
        },
        afterUpdate: function (chart) {
            chart[EXPANDO_KEY2]._labels = layout.prepare(
                chart[EXPANDO_KEY2]._datasets
            );
        },
        // Draw labels on top of all dataset elements
        // https://github.com/chartjs/chartjs-plugin-datalabels/issues/29
        // https://github.com/chartjs/chartjs-plugin-datalabels/issues/32
        afterDatasetsDraw: function (chart) {
            layout.draw(chart, chart[EXPANDO_KEY2]._labels);
        },
        beforeEvent: function (chart, args) {
            if (chart[EXPANDO_KEY2]._listened) {
                var event = args.event;
                switch (event.type) {
                    case 'mousemove':
                    case 'mouseout':
                        handleMoveEvents2(chart, event);
                        break;
                    case 'click':
                        handleClickEvents2(chart, event);
                        break;
                }
            }
        },
        afterEvent: function (chart) {
            var expando = chart[EXPANDO_KEY2];
            var previous = expando._actives;
            var actives = (expando._actives = chart.getActiveElements());
            var updates = utils.arrayDiff(previous, actives);
            var i, ilen, j, jlen, update, label, labels;
            for (i = 0, ilen = updates.length; i < ilen; ++i) {
                update = updates[i];
                if (update[1]) {
                    labels = update[0].element[EXPANDO_KEY2] || [];
                    for (j = 0, jlen = labels.length; j < jlen; ++j) {
                        label = labels[j];
                        label.$context.active = update[1] === 1;
                        label.update(label.$context);
                    }
                }
            }
            if (expando._dirty || updates.length) {
                layout.update(expando._labels);
                chart.render();
            }
            delete expando._dirty;
        },
    };

    // src/data/schema/flagCounts.json
    var flagCounts_default = {
        title: 'Flag Counts',
        description: 'JSON schema of discrete input data to timeSeries modules',
        version: '0.14.0',
        type: 'array',
        modules: {
            sparkline: {
                required: true,
            },
            timeSeries: {
                required: true,
            },
        },
        items: {
            type: 'object',
            required: [
                'GroupID',
                'MetricID',
                'n',
                'n_at_risk',
                'n_flagged',
                'n_at_risk_or_flagged',
            ],
            properties: {
                StudyID: {
                    title: 'Study ID',
                    description: 'Unique study identifier',
                    type: 'string',
                    required: false,
                    key: true,
                },
                GroupID: {
                    title: 'Group ID',
                    description: 'Unique group identifier',
                    type: 'string',
                    required: true,
                    key: true,
                    alternate: 'MetricID',
                },
                MetricID: {
                    title: 'Metric ID',
                    description: 'Unique workflow identifier',
                    type: 'string',
                    required: true,
                    key: true,
                    alternate: 'GroupID',
                },
                n: {
                    title: '# of Groups/Metrics',
                    description: 'Total number of assessed groups/Metrics',
                    type: 'number',
                    required: true,
                    key: false,
                },
                n_at_risk: {
                    title: '# of Amber Groups/Metrics',
                    description: 'Number of amber groups/Metrics',
                    type: 'number',
                    required: true,
                    key: false,
                },
                n_flagged: {
                    title: '# of Red Groups/Metrics',
                    description: 'Number of red groups/Metrics',
                    type: 'number',
                    required: true,
                    key: false,
                },
                n_at_risk_or_flagged: {
                    title: '# of Amber of Red Groups/Metrics',
                    description: 'Number of amber or red groups/Metrics',
                    type: 'number',
                    required: true,
                    key: false,
                },
            },
        },
    };

    // src/data/schema/groupMetadata.json
    var groupMetadata_default = {
        title: 'Group Metadata',
        description: 'JSON schema of group metadata',
        version: '0.14.0',
        type: 'array',
        modules: {
            barChart: {
                required: false,
            },
            groupOverview: {
                required: true,
            },
            scatterPlot: {
                required: false,
            },
            timeSeries: {
                required: false,
            },
        },
        items: {
            type: 'object',
            required: ['GroupLevel', 'GroupID', 'Param', 'Value'],
            properties: {
                GroupLevel: {
                    title: 'Grouping Variable',
                    description:
                        'Grouping variable of analysis, one of Site, Country, or Study',
                    type: 'string',
                    required: true,
                    key: true,
                },
                GroupID: {
                    title: 'Group ID',
                    description: 'Unique group identifier',
                    type: 'string',
                    required: true,
                    key: true,
                },
                Param: {
                    title: 'Group Attribute Name',
                    description: 'Name of group attribute',
                    type: 'string',
                    required: true,
                    key: true,
                },
                Value: {
                    title: 'Group Attribute Value',
                    description: 'Value of group attribute',
                    type: 'string',
                    required: true,
                    key: false,
                },
            },
        },
    };

    // src/data/schema/metricMetadata.json
    var metricMetadata_default = {
        title: 'Metric Metadata',
        description:
            'JSON schema of metric metadata, the default configuration of the barChart, scatterPlot, timeSeries, and sparkline modules',
        version: '0.14.0',
        type: 'array',
        modules: {
            groupOverview: {
                required: true,
            },
        },
        items: {
            type: 'object',
            required: [
                'MetricID',
                'GroupLevel',
                'Abbreviation',
                'Numerator',
                'Denominator',
                'Metric',
                'Score',
                'Threshold',
            ],
        },
    };

    // src/data/schema/metricMetadatum.json
    var metricMetadatum_default = {
        title: 'Metric Metadata',
        description:
            'JSON schema of metric metadata, the default configuration of the barChart, scatterPlot, timeSeries, and sparkline modules',
        version: '0.14.0',
        type: 'object',
        modules: {
            barChart: {
                required: false,
            },
            groupOverview: {
                required: true,
            },
            scatterPlot: {
                required: false,
            },
            sparkline: {
                required: false,
            },
            timeSeries: {
                required: false,
            },
        },
        required: [
            'MetricID',
            'GroupLevel',
            'Abbreviation',
            'Numerator',
            'Denominator',
            'Metric',
            'Score',
            'Threshold',
        ],
        properties: {
            MetricID: {
                title: 'Metric ID',
                description: 'Unique metric identifier',
                type: 'string',
                required: false,
                key: false,
            },
            GroupLevel: {
                title: 'Grouping Variable',
                description:
                    "Grouping variable of metric, one of 'Site', 'Country', or 'Study'",
                type: 'string',
                required: false,
                key: false,
            },
            Abbreviation: {
                title: 'Abbreviation',
                description: 'Metric Abbreviation',
                type: 'string',
                required: false,
                key: false,
            },
            Numerator: {
                title: 'Metric Numerator',
                description: 'Unit of metric numerator',
                type: 'string',
                required: false,
                key: false,
            },
            Denominator: {
                title: 'Metric Denominator',
                description: 'Unit of metric denominator',
                type: 'string',
                required: false,
                key: false,
            },
            Metric: {
                title: 'Metric Description',
                description: 'Description of metric',
                type: 'string',
                required: false,
                key: false,
            },
            Score: {
                title: 'Metric Score',
                description: 'Analysis method of metric',
                type: 'string',
                required: false,
                key: false,
            },
            Threshold: {
                title: 'Thresholds',
                description: 'Thresholds for metric',
                type: 'string',
                required: false,
                key: false,
            },
        },
    };

    // src/data/schema/results.json
    var results_default = {
        title: 'Standard Metric Analysis Output',
        description:
            'JSON schema of input data to barChart and scatterPlot modules',
        version: '0.14.0',
        type: 'array',
        modules: {
            barChart: {
                required: true,
            },
            groupOverview: {
                required: true,
            },
            scatterPlot: {
                required: true,
            },
            sparkline: {
                required: true,
            },
            timeSeries: {
                required: true,
            },
        },
        items: {
            type: 'object',
            required: [
                'StudyID',
                'MetricID',
                'GroupLevel',
                'GroupID',
                'Numerator',
                'Denominator',
                'Metric',
                'Score',
                'Flag',
                'SnapshotDate',
            ],
            properties: {
                StudyID: {
                    title: 'Study ID',
                    description: 'Unique study identifier',
                    type: 'string',
                    required: false,
                    key: true,
                },
                MetricID: {
                    title: 'Metric ID',
                    description: 'Unique workflow identifier',
                    type: 'string',
                    required: false,
                    key: true,
                },
                GroupLevel: {
                    title: 'Group Level',
                    description: 'Group level',
                    type: 'number',
                    required: true,
                    key: true,
                },
                GroupID: {
                    title: 'Group ID',
                    description: 'Unique group identifier',
                    type: 'string',
                    required: true,
                    key: true,
                },
                Numerator: {
                    title: 'Numerator',
                    description: 'Metric numerator',
                    type: 'number',
                    required: true,
                    key: false,
                },
                Denominator: {
                    title: 'Denominator',
                    description: 'Metric denominator',
                    type: 'number',
                    required: true,
                    key: false,
                },
                Metric: {
                    title: 'Metric Value',
                    description: 'Metric value',
                    type: 'number',
                    required: true,
                    key: false,
                },
                Score: {
                    title: 'Metric Score',
                    description: 'Metric score',
                    type: 'number',
                    required: true,
                    key: false,
                },
                Flag: {
                    title: 'Flag Status',
                    description:
                        'Flag assigned given metric score and specified thresholds',
                    type: 'number',
                    required: true,
                    key: false,
                },
                SnapshotDate: {
                    title: 'Snapshot Date',
                    description: 'Date of data refresh',
                    type: 'string',
                    required: false,
                    key: false,
                },
            },
        },
    };

    // src/data/schema/resultsPredicted.json
    var resultsPredicted_default = {
        title: 'Predicted Metric Analysis Output',
        description:
            'JSON schema of predicted input data to scatterPlot module',
        version: '0.14.0',
        type: 'array',
        modules: {
            scatterPlot: {
                required: false,
            },
        },
        items: {
            type: 'object',
            required: ['Numerator', 'Denominator', 'Threshold'],
            properties: {
                StudyID: {
                    title: 'Study ID',
                    description: 'Unique study identifier',
                    type: 'string',
                    required: false,
                    key: true,
                },
                MetricID: {
                    title: 'Metric ID',
                    description: 'Unique workflow identifier',
                    type: 'string',
                    required: false,
                    key: true,
                },
                Threshold: {
                    title: 'Threshold',
                    description: 'Directional factor of predicted results',
                    type: 'number',
                    required: true,
                    key: true,
                },
                Numerator: {
                    title: 'Predicted Numerator',
                    description: 'Predicted numerator of Metric metric',
                    type: 'number',
                    required: true,
                    key: false,
                },
                Denominator: {
                    title: 'Predicted Denominator',
                    description: 'Predicted denominator of Metric metric',
                    type: 'number',
                    required: true,
                    key: false,
                },
                LogDenominator: {
                    title: 'Predicted Denominator (log)',
                    description: 'Predicted Denominator of Metric metric (log)',
                    type: 'number',
                    required: false,
                    key: false,
                },
                SnapshotDate: {
                    title: 'Snapshot Date',
                    description: 'Date of data refresh',
                    type: 'string',
                    required: false,
                    key: false,
                },
            },
        },
    };

    // src/data/schema/resultsVertical.json
    var resultsVertical_default = {
        title: 'Additional Metric Analysis Output',
        description: 'JSON schema of ancillary input data to timeSeries module',
        version: '0.14.0',
        type: 'array',
        modules: {
            timeSeries: {
                required: false,
            },
        },
        items: {
            type: 'object',
            required: ['Param', 'Value'],
            properties: {
                StudyID: {
                    title: 'Study ID',
                    description: 'Unique study identifier',
                    type: 'string',
                    required: false,
                    key: true,
                },
                MetricID: {
                    title: 'Metric ID',
                    description: 'Unique workflow identifier',
                    type: 'string',
                    required: false,
                    key: true,
                },
                Param: {
                    title: 'Analysis Parameter',
                    description: 'Analysis parameter',
                    type: 'string',
                    required: true,
                    key: true,
                },
                Value: {
                    title: 'Analysis Result',
                    description: 'Analysis result',
                    type: 'number',
                    required: true,
                    key: false,
                },
                SnapshotDate: {
                    title: 'Snapshot Date',
                    description: 'Date of data refresh',
                    type: 'string',
                    required: false,
                    key: false,
                },
            },
        },
    };

    // src/data/schema/snapshotDate.json
    var snapshotDate_default = {
        title: 'Snapshot Date',
        description: 'Date of data refresh',
        type: 'string',
        required: true,
        key: true,
    };

    // src/data/schema/thresholds.json
    var thresholds_default = {
        title: 'Thresholds',
        description: 'Threshold values',
        type: 'array',
        modules: {
            barChart: {
                required: false,
            },
            sparkline: {
                required: false,
            },
            timeSeries: {
                required: false,
            },
        },
        items: {
            type: 'number',
        },
    };

    // src/data/schema/index.js
    metricMetadata_default.items.properties =
        metricMetadatum_default.properties;
    var schemata = {
        flagCounts: flagCounts_default,
        groupMetadata: groupMetadata_default,
        metricMetadata: metricMetadata_default,
        metricMetadatum: metricMetadatum_default,
        results: results_default,
        resultsPredicted: resultsPredicted_default,
        resultsVertical: resultsVertical_default,
        thresholds: thresholds_default,
        snapshotDate: snapshotDate_default,
    };
    var schema_default = schemata;

    // src/data/checkInput/getType.js
    function getType(variable) {
        let variableType = typeof variable;
        if (variable instanceof Array) variableType = 'array';
        if (variable instanceof Map) variableType = 'map';
        if (variable instanceof Set) variableType = 'set';
        if (variable instanceof Function) variableType = 'function';
        return variableType;
    }

    // src/data/checkInput/checkProps.js
    function checkProps({
        obj,
        properties,
        parameter = null,
        module = null,
        i = null,
    }) {
        const actualProps = Object.keys(obj);
        const expectedProps = Object.keys(properties);
        const requiredProps = expectedProps.filter(
            (prop) => properties[prop].required
        );
        const alternateProps = expectedProps.filter(
            (prop) => properties[prop].alternate !== void 0
        );
        for (const requiredProp of requiredProps) {
            if (actualProps.includes(requiredProp) === false) {
                if (
                    actualProps.some((actualProp) =>
                        alternateProps.includes(actualProp)
                    ) === false
                ) {
                    let message = `Missing property: [ ${requiredProp} ] property expected but not found`;
                    if (i !== null) message = `${message} in item ${i}`;
                    if (parameter !== null)
                        message = `${message} ${
                            i === null ? 'in' : 'of'
                        } [ ${parameter} ] argument`;
                    if (module !== null)
                        message = `${message} to [ ${module}() ]`;
                    throw new Error(`${message}.`);
                }
            }
        }
    }

    // src/data/checkInput.js
    function checkInput({
        parameter = null,
        argument = null,
        schemaName = null,
        module = null,
        verbose = false,
    }) {
        if (schemaName === null) {
            if (verbose)
                console.log(
                    `[ ${schemaName} ] unspecified. Terminating execution of [ checkInputs() ].`
                );
            return;
        }
        if (!Object.keys(schema_default).includes(schemaName)) {
            throw new Error(`Schema [ ${schemaName} ] not found.`);
        }
        const schema = JSON.parse(JSON.stringify(schema_default[schemaName]));
        if (Object.keys(schema.modules).includes(module)) {
            const required = schema.modules[module].required;
            if ([void 0, null].includes(argument)) {
                if (required) {
                    throw new Error(
                        `Missing value: [ ${parameter} ] argument to [ ${module}() ] is required.`
                    );
                } else {
                    if (verbose)
                        console.log(
                            `[ ${parameter} ] unspecified. Terminating execution of [ checkInputs() ].`
                        );
                    return;
                }
            }
        } else {
            if (verbose)
                console.log(
                    `Module [ ${module} ] not referenced in schema [ ${schemaName} ].`
                );
        }
        if (
            module === 'timeSeries' &&
            ['flagCounts', 'results', 'resultsVertical'].includes(schemaName)
        ) {
            schema.items.properties.SnapshotDate = schema_default.snapshotDate;
        }
        const argumentType = getType(argument);
        if (argumentType !== schema.type) {
            throw new Error(
                `Incorrect data type: [ ${schema.type} ] expected but [ ${argumentType} ] detected for [ ${parameter} ] argument to [ ${module}() ].`
            );
        }
        if (schema.type === 'array') {
            if (argument.length === 0) {
                if (verbose) {
                    console.log(
                        `Empty array: [ ${parameter} ] argument to [ ${module}() ] contains zero elements.`
                    );
                }
            }
            argument.forEach((item, i) => {
                const itemType = getType(item);
                if (itemType !== schema.items.type) {
                    throw new Error(
                        `Incorrect data type: [ ${schema.items.type} ] expected but [ ${itemType} ] detected for item ${i} of [ ${parameter} ] argument to [ ${module}() ].`
                    );
                }
                if (schema.items.type === 'object') {
                    const properties = schema.items.properties;
                    checkProps({
                        obj: item,
                        properties,
                        parameter,
                        module,
                        i,
                    });
                }
            });
        }
        if (schema.type === 'object') {
            const properties = schema.properties;
            checkProps({
                obj: argument,
                properties,
                parameter,
                module,
            });
        }
        return;
    }

    // src/barChart/checkInputs.js
    function checkInputs(_results_, _config_, _thresholds_, _groupMetadata_) {
        checkInput({
            parameter: '_results_',
            argument: _results_,
            schemaName: 'results',
            module: 'barChart',
        });
        checkInput({
            parameter: '_config_',
            argument: _config_,
            schemaName: 'metricMetadatum',
            module: 'barChart',
        });
        checkInput({
            parameter: '_thresholds_',
            argument: _thresholds_,
            schemaName: 'thresholds',
            module: 'barChart',
        });
        if (_groupMetadata_ !== null) {
            checkInput({
                parameter: '_groupMetadata_',
                argument: _groupMetadata_,
                schemaName: 'groupMetadata',
                module: 'barChart',
            });
        }
    }

    // src/util/coalesce.js
    function coalesce(customSetting, defaultSetting) {
        if ([null, void 0].includes(customSetting)) {
            return defaultSetting;
        }
        if (typeof defaultSetting === 'string' && customSetting === '') {
            return defaultSetting;
        }
        if (Array.isArray(defaultSetting) && !Array.isArray(customSetting)) {
            customSetting = [customSetting];
        }
        if (
            Array.isArray(defaultSetting) &&
            Array.isArray(customSetting) &&
            customSetting[0] === ''
        ) {
            return defaultSetting;
        }
        return customSetting;
    }

    // src/util/configure.js
    function configure2(defaults3, _config_, customSettings = null) {
        const config = { ..._config_ };
        for (const key in defaults3) {
            config[key] = coalesce(config[key], defaults3[key]);
        }
        if (customSettings !== null) {
            for (const key in customSettings) {
                config[key] = customSettings[key]();
            }
        }
        return config;
    }

    // src/util/checkSelectedGroupIDs.js
    function checkSelectedGroupIDs(selectedGroupIDs, _data_) {
        if (
            ['', null, void 0].includes(selectedGroupIDs) ||
            (Array.isArray(selectedGroupIDs) && selectedGroupIDs.length === 0)
        )
            return [];
        if (!Array.isArray(selectedGroupIDs))
            selectedGroupIDs = [selectedGroupIDs];
        if (Array.isArray(selectedGroupIDs)) {
            const actualGroupIDs = [...new Set(_data_.map((d) => d.GroupID))];
            for (const selectedGroupID of selectedGroupIDs) {
                if (actualGroupIDs.includes(selectedGroupID) === false)
                    selectedGroupIDs = selectedGroupIDs.filter(
                        (groupID) => groupID !== selectedGroupID
                    );
            }
        }
        return selectedGroupIDs;
    }

    // src/util/mapThresholdsToFlags.js
    function mapThresholdsToFlags(_thresholds_) {
        const thresholds2 = [...new Set(_thresholds_)].map(
            (Threshold) => +Threshold
        );
        const negativeThresholds = thresholds2
            .filter((Threshold) => Threshold < 0)
            .sort(descending);
        const negativeFlags = negativeThresholds.map((Threshold, i) => {
            return {
                Threshold,
                Flag: -(i + 1),
            };
        });
        if (negativeThresholds.length > 2) {
            console.warn(
                'More than two negative thresholds present. Threshold annotations will not be displayed.'
            );
            return null;
        }
        const positiveThresholds = thresholds2
            .filter((Threshold) => Threshold > 0)
            .sort(ascending);
        const positiveFlags = positiveThresholds.map((Threshold, i) => {
            return {
                Threshold,
                Flag: i + 1,
            };
        });
        if (positiveThresholds.length > 2) {
            console.warn(
                'More than two positive thresholds present. Threshold annotations will not be displayed.'
            );
            return null;
        }
        const zeroFlag = thresholds2
            .filter((Threshold) => Threshold === 0)
            .map((Threshold) => {
                return {
                    Threshold,
                    Flag: 0,
                };
            });
        let flags = [...negativeFlags, ...zeroFlag, ...positiveFlags].sort(
            (a, b) => a.Flag - b.Flag
        );
        flags.descending = false;
        if (
            negativeThresholds.length === 0 &&
            thresholds2.join(',') !==
                thresholds2
                    .map((threshold) => threshold)
                    .sort(ascending)
                    .join(',')
        ) {
            flags = thresholds2.map((Threshold, i) => {
                return {
                    Threshold,
                    Flag: i + 1,
                };
            });
            flags.descending = true;
        }
        return flags;
    }

    // src/util/checkThresholds.js
    function checkThresholds(_config_, _thresholds_) {
        let thresholds2 = _config_?.thresholds || _thresholds_ || [];
        if (_config_?.variableThresholds) return null;
        if (
            Array.isArray(thresholds2) &&
            thresholds2.length > 0 &&
            thresholds2.every(
                (Threshold) =>
                    typeof Threshold === 'object' &&
                    Threshold.hasOwnProperty('Threshold') &&
                    Threshold.hasOwnProperty('Flag')
            )
        )
            return thresholds2;
        if (thresholds2.filter((Threshold) => Threshold !== 0).length > 4) {
            console.warn(
                'More than four non-zero thresholds present. Threshold annotations will not be displayed.'
            );
            return null;
        }
        return mapThresholdsToFlags(thresholds2);
    }

    // src/util/updateSelectedGroupDatum.js
    function updateSelectedGroupDatum(results, selectedGroupIDs) {
        if (selectedGroupIDs.length !== 1) return {};
        const result = results
            .sort((a, b) => descending(a.SnapshotDate, b.SnapshotDate))
            .find((d) => selectedGroupIDs.includes(d.GroupID));
        const selectedGroupDatum = results_default.items.required.reduce(
            (acc, item) => {
                acc[item] = result[item];
                return acc;
            },
            {}
        );
        return selectedGroupDatum;
    }

    // src/util/addCanvas/getCallbackWrapper.js
    function getCallbackWrapper(callback2) {
        const callbackWrapper = function (event) {
            const pointDatum = event.data;
            callback2(pointDatum);
            return pointDatum;
        };
        return callbackWrapper;
    }

    // src/barChart/configure.js
    function configure3(_config_, _results_, _thresholds_) {
        const defaults3 = {};
        defaults3.resultTooltipKeys = [
            'Score',
            'Metric',
            'Numerator',
            'Denominator',
        ];
        defaults3.GroupLevel = 'Site';
        defaults3.groupLabelKey = 'InvestigatorLastName';
        defaults3.groupParticipantCountKey = 'ParticipantCount';
        defaults3.groupTooltipKeys = null;
        defaults3.x = 'GroupID';
        defaults3.xType = 'category';
        defaults3.y = 'Score';
        defaults3.yType = 'linear';
        defaults3.color = 'Flag';
        defaults3.hoverCallback = (datum2) => {};
        defaults3.clickCallback = (datum2) => {
            console.log(datum2);
        };
        defaults3.displayTitle = false;
        defaults3.maintainAspectRatio = false;
        const config = configure2(defaults3, _config_ || {}, {
            selectedGroupIDs: checkSelectedGroupIDs.bind(
                null,
                _config_?.selectedGroupIDs,
                _results_
            ),
            thresholds: checkThresholds.bind(null, _config_, _thresholds_),
        });
        config.selectedGroupDatum = updateSelectedGroupDatum(
            _results_,
            config.selectedGroupIDs
        );
        config.xLabel = coalesce(_config_?.xLabel, config['Group']);
        config.yLabel = coalesce(_config_?.yLabel, config[config.y]);
        config.chartName = `Bar Chart of ${config.yLabel} by ${config.xLabel}`;
        if (config.y !== 'Score') delete config.thresholds;
        if (config.hoverCallbackWrapper === void 0)
            config.hoverCallbackWrapper = getCallbackWrapper(
                config.hoverCallback
            );
        if (config.clickCallbackWrapper === void 0)
            config.clickCallbackWrapper = getCallbackWrapper(
                config.clickCallback
            );
        return config;
    }

    // src/util/addCanvas/addCustomEvent.js
    function addCustomEvent(canvas, callback2, eventType) {
        const callbackWrapper = getCallbackWrapper(callback2);
        const eventID = `${eventType}-event`;
        canvas.removeEventListener(eventID, callback2, false);
        const customEvent = new Event(eventID, { bubbles: true });
        canvas.addEventListener(eventID, callback2, false);
        return customEvent;
    }

    // src/util/addCanvas.js
    function addCanvas(_element_, config) {
        let canvas;
        if (
            _element_.nodeName &&
            _element_.nodeName.toLowerCase() === 'canvas'
        ) {
            if (_element_.hasOwnProperty('chart')) _element_.chart.destroy();
            canvas = _element_;
        } else {
            const newCanvas = document.createElement('canvas');
            const oldCanvas = _element_.getElementsByTagName('canvas')[0];
            if (oldCanvas !== void 0) {
                if (oldCanvas.hasOwnProperty('chart'))
                    oldCanvas.chart.destroy();
                oldCanvas.replaceWith(newCanvas);
            } else {
                _element_.appendChild(newCanvas);
            }
            canvas = newCanvas;
        }
        canvas.hoverEvent = addCustomEvent(
            canvas,
            config.hoverCallbackWrapper,
            'hover'
        );
        canvas.clickEvent = addCustomEvent(
            canvas,
            config.clickCallbackWrapper,
            'click'
        );
        canvas.riskSignalSelected = new CustomEvent('riskSignalSelected', {
            bubbles: true,
        });
        return canvas;
    }

    // src/util/structureGroupMetadata.js
    function structureGroupMetadata(groupMetadata, config) {
        if (groupMetadata === null) return null;
        const structuredGroupMetadata = rollup(
            groupMetadata,
            (group2) =>
                group2.reduce((acc, cur) => {
                    acc[cur.Param] = cur.Value;
                    return acc;
                }, {}),
            (d) => d.GroupLevel,
            (d) => d.GroupID
        );
        const keys = Array.from(structuredGroupMetadata.keys());
        if (keys.includes(config.GroupLevel)) {
            return structuredGroupMetadata.get(config.GroupLevel);
        } else {
            console.warn(
                `Group level "${config.GroupLevel}" not found in group metadata.`
            );
            return null;
        }
    }

    // src/util/falsy.js
    var falsy = [void 0, null, NaN, '', 'NA'];
    var falsy_default = falsy;

    // src/barChart/structureData/mutate.js
    function mutate(_results_, config, groupMetadata = null) {
        const data = _results_
            .map((d) => {
                if (groupMetadata !== null) {
                    const group2 = groupMetadata.get(d.GroupID);
                    if (group2 !== void 0) {
                        d.group = group2;
                        d.group.groupLabel = d.group.hasOwnProperty(
                            config.groupLabelKey
                        )
                            ? d.group[config.groupLabelKey]
                            : d.GroupID;
                    }
                }
                const datum2 = {
                    ...d,
                    x: d[config.x],
                    y: falsy_default.includes(d[config.y]) ? 0 : +d[config.y],
                    stratum: falsy_default.includes(d[config.color])
                        ? 3
                        : Math.abs(+d[config.color]),
                };
                return datum2;
            })
            .sort((a, b) => b.y - a.y);
        return data;
    }

    // src/util/colorScheme.js
    var colorScheme = [
        {
            color: '#3DAF06',
            order: 0,
            description: 'Green Flag',
            Flag: [0],
        },
        {
            color: '#FEAA02',
            order: 1,
            description: 'Amber Flag',
            Flag: [-1, 1],
        },
        {
            color: '#FF5859',
            order: 2,
            description: 'Red Flag',
            Flag: [-2, 2],
        },
        {
            color: '#828282',
            order: 3,
            description: 'No Flag',
            Flag: falsy_default,
        },
    ];
    colorScheme.forEach((color3) => {
        color3.rgba = color2(color3.color);
    });
    colorScheme.green = colorScheme.find((c) => c.order === 0);
    colorScheme.amber = colorScheme.find((c) => c.order === 1);
    colorScheme.red = colorScheme.find((c) => c.order === 2);
    colorScheme.gray = colorScheme.find((c) => c.Flag === falsy_default);
    var amber = colorScheme.amber;
    var red = colorScheme.red;
    colorScheme.amberRed = {
        color: `rgb(${Math.round((amber.rgba.r + red.rgba.r) / 2)},${Math.round(
            (amber.rgba.g + red.rgba.g) / 2
        )},${Math.round((amber.rgba.b + red.rgba.b) / 2)})`,
        order: -1,
        description: 'Amber or Red Flag',
        Flag: [...amber.Flag, ...red.Flag].sort(ascending),
        rgba: color2(
            `rgb(${Math.round((amber.rgba.r + red.rgba.r) / 2)},${Math.round(
                (amber.rgba.g + red.rgba.g) / 2
            )},${Math.round((amber.rgba.b + red.rgba.b) / 2)})`
        ),
    };
    var colorScheme_default = colorScheme;

    // src/barChart/structureData/scriptableOptions/backgroundColor.js
    function backgroundColor(context, options) {
        const chart = context.chart;
        const config = chart.data.config;
        const dataset = context.dataset;
        const datum2 = dataset.data[context.dataIndex];
        if (datum2 !== void 0 && dataset.type === 'bar') {
            const color3 = colorScheme_default[datum2.stratum];
            color3.rgba.opacity =
                config.selectedGroupIDs.includes(datum2.GroupID) |
                (config.selectedGroupIDs.length === 0)
                    ? 1
                    : 0.25;
            return color3.rgba + '';
        }
    }

    // src/barChart/structureData/scriptableOptions.js
    function scriptableOptions() {
        return {
            backgroundColor,
            //borderColor,
        };
    }

    // src/barChart/structureData.js
    function structureData(_results_, config, _groupMetadata_ = null) {
        const groupMetadata = structureGroupMetadata(_groupMetadata_, config);
        const data = mutate(_results_, config, groupMetadata);
        const datasets = [
            {
                type: 'bar',
                data,
                listenClick: true,
                listenHover: true,
                label: '',
                ...scriptableOptions(),
                minBarLength: 2,
                grouped: false,
            },
            ...colorScheme_default.map((color3) => ({
                type: 'bar',
                label: color3.description,
                backgroundColor: color3.color,
            })),
        ];
        return datasets;
    }

    // src/util/identifyDuplicatePoints.js
    function identifyDuplicatePoints(data, config, mutate5 = true) {
        const numericGroupIDs = data.every((d) => /^\d+$/.test(d.GroupID));
        data.sort((a, b) => {
            const x = ascending(a[config.x], b[config.x]);
            const y = ascending(a[config.y], b[config.y]);
            const selected =
                config.selectedGroupIDs.includes(b.GroupID) -
                config.selectedGroupIDs.includes(a.GroupID);
            const GroupID = numericGroupIDs
                ? ascending(+a.GroupID, +b.GroupID)
                : ascending(a.GroupID, b.GroupID);
            return x || y || selected || GroupID;
        });
        if (mutate5)
            rollup(
                data,
                (Group) => {
                    Group.forEach((d, i) => {
                        d.duplicate = i > 0;
                    });
                },
                (d) => d[config.x],
                (d) => d[config.y]
            );
    }

    // src/util/getElementDatum.js
    function getElementDatum(activeElements, chart) {
        const element = activeElements.sort(
            (a, b) => b.index - a.index
            // retrieve first element by index in dataset
        )[0];
        const data = chart.data.datasets[element.datasetIndex].data;
        const activeData = data.filter((d, i) =>
            activeElements
                .map((activeElement) => activeElement.index)
                .includes(i)
        );
        identifyDuplicatePoints(activeData, chart.data.config, false);
        const datum2 = activeData[0];
        return datum2;
    }

    // src/util/onClick.js
    function onClick(event, activeElements, chart) {
        const canvas = chart.canvas;
        if (
            activeElements.length &&
            chart.data.datasets[activeElements[0].datasetIndex].listenClick ===
                true
        ) {
            const datum2 = getElementDatum(activeElements, chart);
            canvas.clickEvent.data = updateSelectedGroupDatum(
                [datum2],
                [datum2.GroupID]
            );
            canvas.dispatchEvent(canvas.clickEvent);
            canvas.riskSignalSelected.data = updateSelectedGroupDatum(
                [datum2],
                [datum2.GroupID]
            );
            canvas.dispatchEvent(canvas.riskSignalSelected);
        }
    }

    // src/util/onHover.js
    function onHover(event, activeElements, chart) {
        const canvas = chart.canvas;
        if (
            activeElements.length &&
            chart.data.datasets[activeElements[0].datasetIndex].listenHover ===
                true
        ) {
            event.native.target.style.cursor = 'pointer';
            const datum2 = getElementDatum(activeElements, chart);
            canvas.hoverEvent.data = updateSelectedGroupDatum(
                [datum2],
                [datum2.GroupID]
            );
            canvas.dispatchEvent(canvas.hoverEvent);
        } else {
            event.native.target.style.cursor = 'default';
        }
    }

    // src/barChart/getPlugins/annotations.js
    function annotations(config) {
        let annotations5 = null;
        if (config.thresholds) {
            annotations5 = config.thresholds
                .sort((a, b) => Math.abs(a.Threshold) - Math.abs(b.Threshold))
                .map((x, i) => {
                    const content = colorScheme_default.find((y) =>
                        y.Flag.includes(+x.Flag)
                    ).description;
                    return {
                        adjustScaleRange: false,
                        borderColor: colorScheme_default.filter((y) =>
                            y.Flag.includes(+x.Flag)
                        )[0].color,
                        borderDash: [2],
                        borderWidth: 1,
                        label: {
                            backgroundColor: 'white',
                            color: colorScheme_default.filter((y) =>
                                y.Flag.includes(+x.Flag)
                            )[0].color,
                            content: config.thresholds.descending
                                ? `${content} \u2193`
                                : Math.sign(+x.Flag) === 1
                                ? `${content} \u2191`
                                : Math.sign(+x.Flag) === -1
                                ? `\u2193 ${content}`
                                : content,
                            display: true,
                            font: {
                                size: 12,
                            },
                            padding: 2,
                            position:
                                Math.sign(+x.Flag) === 1 ? 'end' : 'start',
                            rotation: 'auto',
                            yValue: x.Threshold,
                            yAdjust: 0,
                        },
                        type: 'line',
                        yMin: x.Threshold,
                        yMax: x.Threshold,
                    };
                });
        }
        return annotations5;
    }

    // src/barChart/getPlugins/dataLabels.js
    function dataLabels(config) {
        return {
            align: (context) =>
                (config.y === 'Score' &&
                    Math.sign(context.dataset.data[context.dataIndex].y) ===
                        1) ||
                (config.y === 'Metric' &&
                    Math.sign(context.dataset.data[context.dataIndex].y) === -1)
                    ? 'start'
                    : 'end',
            anchor: (context) =>
                (config.y === 'Score' &&
                    Math.sign(context.dataset.data[context.dataIndex].y) ===
                        1) ||
                (config.y === 'Metric' &&
                    Math.sign(context.dataset.data[context.dataIndex].y) === -1)
                    ? 'start'
                    : 'end',
            //clip: true,
            color: 'black',
            display: (context) => {
                return (
                    context.chart.getDatasetMeta(0).data[0].width >=
                    context.chart.options.font.size - 3
                );
            },
            formatter: (value, context) =>
                context.chart.data.labels[context.dataIndex],
            rotation: -90,
        };
    }

    // src/barChart/getPlugins/legend.js
    function legend(config) {
        return {
            display: true,
            //!config.thresholds,
            labels: {
                boxHeight: 10,
                boxWidth: 10,
                filter: function (item, chart) {
                    return item.text !== '';
                },
                //sort: function (a, b, chartData) {
                //    return (
                //        legendOrder.indexOf(a.text) -
                //        legendOrder.indexOf(b.text)
                //    );
                //},
            },
            position: 'top',
        };
    }

    // src/barChart/getPlugins/title.js
    function title(config) {
        return {
            display: config.displayTitle,
            text: `${config.Metric} by ${config.GroupLevel}`,
        };
    }

    // src/util/formatMetricTooltipLabel.js
    function formatMetricTooltipLabel(result, config) {
        const resultTooltipKeys = Array.isArray(config.resultTooltipKeys)
            ? config.resultTooltipKeys
            : Object.keys(result);
        const resultTooltipMap = resultTooltipKeys.reduce((acc, key) => {
            const label = config[key] || key;
            acc[key] = label;
            return acc;
        }, {});
        const tooltipLabel = [];
        for (const [key, label] of Object.entries(resultTooltipMap)) {
            if (result[key] !== void 0) {
                let value = result[key];
                value = parseFloat(value);
                if (falsy_default.includes(value)) {
                    value = '\u2014';
                } else if (Number.isInteger(value)) {
                    value = value
                        .toString()
                        .replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                } else {
                    value = value.toFixed(2).toString();
                }
                tooltipLabel.push(`${label}: ${value}`);
            }
        }
        return tooltipLabel;
    }

    // src/util/formatGroupTooltipLabel.js
    function formatGroupTooltipLabel(group2, config) {
        if (!group2) {
            return [];
        }
        const tooltipKeys = ![null, void 0].includes(config.groupTooltipKeys)
            ? config.groupTooltipKeys
            : Object.keys(group2)
                  .filter(
                      (key) =>
                          [
                              'groupLabel',
                              'GroupLabel',
                              'nRedFlags',
                              'nAmberFlags',
                              'nGreenFlags',
                          ].includes(key) === false
                  )
                  .reduce((acc, key) => {
                      const label = key
                          .replace(/_/g, ' ')
                          .replace(/([a-z])([A-Z])/g, '$1 $2')
                          .replace(/\b\w/g, (char) => char.toUpperCase())
                          .replace('Id', 'ID');
                      acc[key] = label;
                      return acc;
                  }, {});
        const tooltipContent = [];
        for (const [key, label] of Object.entries(tooltipKeys)) {
            if (group2[key] !== void 0) {
                let value = group2[key];
                tooltipContent.push(`${label}: ${value}`);
            }
        }
        return tooltipContent;
    }

    // src/util/formatMetricTooltipTitle.js
    function formatMetricTooltipTitle(result, config) {
        return result.group !== void 0
            ? `${config.GroupLevel}: ${result.GroupID} (${
                  result.group.groupLabel
              } / ${result.group[config.groupParticipantCountKey]} enrolled)`
            : `${config.GroupLevel} ${result.GroupID}`;
    }

    // src/util/getTooltipAesthetics.js
    function getTooltipAesthetics() {
        return {
            backgroundColor: 'rgba(255,255,255,.85)',
            bodyColor: 'black',
            bodyFont: {
                family: 'roboto',
                size: 12,
                weight: 'bold',
            },
            borderColor: 'black',
            borderWidth: 1,
            boxPadding: 5,
            boxWidth: 10,
            cornerRadius: 2,
            caretPadding: 4,
            //displayColors: false,
            padding: 10,
            titleColor: 'black',
            titleMarginBottom: 5,
            titleFont: {
                family: 'roboto',
                lineHeight: 1.5,
                size: 16,
                weight: 'bold',
            },
            usePointStyle: true,
        };
    }

    // src/barChart/getPlugins/tooltip.js
    function tooltip(config) {
        const tooltipAesthetics = getTooltipAesthetics();
        tooltipAesthetics.boxWidth = 10;
        return {
            callbacks: {
                label: (d) => [
                    ...formatMetricTooltipLabel(d.raw, config),
                    ...formatGroupTooltipLabel(d.raw.group, config),
                ],
                labelPointStyle: () => ({ pointStyle: 'rect' }),
                title: (data) => {
                    if (data.length) {
                        const datum2 = data[0].dataset.data[data[0].dataIndex];
                        return formatMetricTooltipTitle(datum2, config);
                    }
                },
            },
            ...tooltipAesthetics,
        };
    }

    // src/barChart/getPlugins.js
    function getPlugins(config) {
        const getPlugins5 = {
            annotation: {
                annotations: annotations(config),
                clip: true,
            },
            datalabels: dataLabels(config),
            legend: legend(config),
            title: title(config),
            tooltip: tooltip(config),
        };
        return getPlugins5;
    }

    // src/util/getDefaultScales.js
    function getDefaultScales() {
        const defaultScales = {
            x: {
                grid: {
                    borderDash: [2],
                    display: false,
                    drawBorder: false,
                },
                ticks: {
                    display: true,
                },
                title: {
                    display: true,
                    text: null,
                },
                type: null,
            },
            y: {
                grid: {
                    borderDash: [2],
                    display: true,
                    drawBorder: false,
                },
                ticks: {
                    display: true,
                },
                title: {
                    display: true,
                    text: null,
                    padding: null,
                },
                type: null,
            },
        };
        return defaultScales;
    }

    // src/barChart/getScales.js
    function getScales(config, datasets) {
        const scales2 = getDefaultScales();
        scales2.x.ticks.display = false;
        scales2.x.title.text = config.xLabel;
        scales2.x.type = config.xType;
        scales2.y.title.text = config.yLabel;
        scales2.y.type = config.yType;
        scales2.y.offset = true;
        return scales2;
    }

    // src/util/displayWhiteBackground.js
    function displayWhiteBackground() {
        const plugin2 = {
            id: 'customCanvasBackgroundColor',
            beforeDraw: (chart, args, options) => {
                const { ctx } = chart;
                ctx.save();
                ctx.globalCompositeOperation = 'destination-over';
                ctx.fillStyle = options.color || 'white';
                ctx.fillRect(0, 0, chart.width, chart.height);
                ctx.restore();
            },
        };
        return plugin2;
    }

    // src/util/triggerTooltip.js
    function triggerTooltip(chart) {
        const tooltip5 = chart.tooltip;
        if (tooltip5.getActiveElements().length > 0) {
            tooltip5.setActiveElements([], { x: 0, y: 0 });
        }
        if (chart.data.config.selectedGroupIDs.length > 0) {
            const data = chart.data.datasets[0].data;
            const point = data.find((d) =>
                chart.data.config.selectedGroupIDs.includes(d.GroupID)
            );
            const overlappingPoints = data.filter(
                (d) => d.x === point.x && d.y === point.y
            );
            const pointIndices = data
                .filter((d, i) => overlappingPoints.includes(d))
                .map((d, i) => ({
                    datasetIndex: 0,
                    index: data.findIndex((d1, i2) => d1 === d),
                }));
            tooltip5.setActiveElements(pointIndices);
        }
        chart.update();
    }

    // src/barChart/updateConfig.js
    function updateConfig(
        chart,
        _config_,
        _thresholds_,
        updateChart = true,
        updateTooltip = true
    ) {
        const config = configure3(
            _config_,
            chart.data.datasets.find((dataset) => dataset.type === 'bar').data,
            _thresholds_
        );
        chart.canvas.riskSignalSelected.data = config.selectedGroupDatum;
        const plugins2 = getPlugins(config);
        const scales2 = getScales(config);
        chart.data.config = config;
        chart.options.plugins = plugins2;
        chart.options.scales = scales2;
        if (updateChart) chart.update();
        if (updateTooltip) triggerTooltip(chart);
        return config;
    }

    // src/barChart/updateData.js
    function updateData(
        chart,
        _results_,
        _config_,
        _thresholds_,
        _groupMetadata_ = null
    ) {
        const config = updateConfig(
            chart,
            _config_,
            _thresholds_,
            false,
            false
        );
        const datasets = structureData(_results_, config, _groupMetadata_);
        chart.data.config = config;
        chart.data.datasets = datasets;
        chart.update();
        triggerTooltip(chart);
    }

    // src/util/updateOption.js
    function updateOption(chart, option, value) {
        const objPath = option.split('.');
        let obj = chart.options;
        for (let i = 0; i < objPath.length; i++) {
            if (i < objPath.length - 1) obj = obj[objPath[i]];
            else obj[objPath[i]] = value;
        }
        chart.update();
        triggerTooltip(chart);
    }

    // src/barChart.js
    function barChart(
        _element_ = 'body',
        _results_ = [],
        _config_ = null,
        _thresholds_ = null,
        _groupMetadata_ = null
    ) {
        checkInputs(_results_, _config_, _thresholds_, _groupMetadata_);
        const config = configure3(_config_, _results_, _thresholds_);
        const canvas = addCanvas(_element_, config);
        const datasets = structureData(_results_, config, _groupMetadata_);
        const options = {
            animation: false,
            clip: false,
            interaction: {
                intersect: false,
                mode: 'x',
            },
            layout: {
                padding: {
                    top:
                        config.y === 'Metric'
                            ? max(datasets[0].data, (d) => d.GroupID.length) * 8
                            : null,
                },
            },
            maintainAspectRatio: config.maintainAspectRatio,
            onClick,
            onHover,
            plugins: getPlugins(config),
            scales: getScales(config, datasets),
        };
        const chart = new auto_default(canvas, {
            data: {
                datasets,
                // required by Chart.js
                config,
                // inputs
                _results_,
                _config_,
                _thresholds_,
                _groupMetadata_,
            },
            options,
            plugins: [plugin, displayWhiteBackground()],
        });
        canvas.chart = chart;
        chart.helpers = {
            updateConfig,
            updateData,
            updateOption,
            triggerTooltip,
        };
        triggerTooltip(chart);
        return chart;
    }

    // src/groupOverview/checkInputs.js
    function checkInputs2(
        _results_,
        _config_,
        _groupMetadata_,
        _metricMetadata_
    ) {
        checkInput({
            parameter: '_results_',
            argument: _results_,
            schemaName: 'results',
            module: 'groupOverview',
        });
        checkInput({
            parameter: '_groupMetadata_',
            argument: _groupMetadata_,
            schemaName: 'groupMetadata',
            module: 'groupOverview',
        });
        checkInput({
            parameter: '_metricMetadata_',
            argument: _metricMetadata_,
            schemaName: 'metricMetadata',
            module: 'groupOverview',
        });
    }

    // src/groupOverview/configure.js
    function configure4(_config_) {
        const defaults3 = {};
        defaults3.resultTooltipKeys = [
            'Score',
            'Metric',
            'Numerator',
            'Denominator',
        ];
        defaults3.GroupLevel = 'Site';
        defaults3.groupLabelKey = null;
        defaults3.groupParticipantCountKey = 'ParticipantCount';
        defaults3.groupTooltipKeys = null;
        defaults3.SiteRiskScoreMetricID = 'Analysis_srs0001';
        defaults3.SiteRiskScoreURL =
            'https://gilead-biostats.github.io/gsm.kri/articles/SiteRiskScore.html';
        defaults3.groupClickCallback = (datum2) => {
            console.log(datum2);
        };
        defaults3.metricClickCallback = (datum2) => {
            console.log(datum2);
        };
        const config = configure2(defaults3, _config_);
        return config;
    }

    // src/groupOverview/deriveGroupMetrics.js
    function deriveGroupMetrics(_groupMetadata_, _results_, config) {
        const groupMetadata = structureGroupMetadata(_groupMetadata_, config);
        const missingGroups = [
            ...new Set(
                _results_
                    .map((result) => result.GroupID)
                    .filter(
                        (GroupID) =>
                            ![...groupMetadata.keys()].find(
                                (group2) => group2 === GroupID
                            )
                    )
                    .sort(ascending)
            ),
        ];
        missingGroups.forEach((group2) => {
            groupMetadata.set(group2, { GroupID: group2 });
        });
        const groups2 = Array.from(groupMetadata).map(([key, value]) => ({
            GroupLevel: config.GroupLevel,
            GroupID: key,
            ...value,
        }));
        groups2.forEach((group2) => {
            group2.GroupLabel = group2.hasOwnProperty(config.groupLabelKey)
                ? `${group2.GroupID} (${group2[config.groupLabelKey]})`
                : group2.GroupID;
            const groupResults = _results_.filter(
                (result) => result.GroupID === group2.GroupID
            );
            group2.nRedFlags = groupResults.filter(
                (result) => Math.abs(parseInt(result.Flag)) === 2
            ).length;
            group2.nAmberFlags = groupResults.filter(
                (result) => Math.abs(parseInt(result.Flag)) === 1
            ).length;
            group2.nGreenFlags = groupResults.filter(
                (result) => Math.abs(parseInt(result.Flag)) === 0
            ).length;
            if (config.GroupLevel === 'Site') {
                const riskScoreResult = groupResults.find(
                    (result) => result.MetricID === config.SiteRiskScoreMetricID
                );
                if (riskScoreResult) {
                    group2.siteRiskScore = parseFloat(riskScoreResult.Score);
                }
            }
        });
        return groups2;
    }

    // src/groupOverview/defineColumns/sortString.js
    function sortString(bodyRows, column) {
        const sortAscending = column.sortState < 1;
        bodyRows.sort((a, b) => {
            const aVal = a[column.index].value;
            const bVal = b[column.index].value;
            if (aVal === void 0 || aVal === null) {
                return 1;
            }
            if (bVal === void 0 || bVal === null) {
                return -1;
            }
            const defaultSort = sortAscending
                ? aVal.localeCompare(bVal)
                : bVal.localeCompare(aVal);
            return defaultSort;
        });
        column.sortState = sortAscending ? 1 : -1;
    }

    // src/groupOverview/defineColumns/sortNumber.js
    function sortNumber(bodyRows, column) {
        const sortAscending = column.sortState < 1;
        bodyRows.sort((a, b) => {
            const aVal = a[column.index].sortValue;
            const bVal = b[column.index].sortValue;
            if (aVal === void 0 || aVal === null || isNaN(aVal)) {
                return 1;
            }
            if (bVal === void 0 || bVal === null || isNaN(bVal)) {
                return -1;
            }
            const defaultSort = sortAscending ? aVal - bVal : bVal - aVal;
            return defaultSort;
        });
        column.sortState = sortAscending ? 1 : -1;
    }

    // src/groupOverview/defineColumns/defineGroupTooltip.js
    function defineTooltip(column, content, config) {
        const tooltipContent = formatGroupTooltipLabel(content.group, config);
        return tooltipContent.join('\n');
    }

    // src/groupOverview/defineColumns/defineRiskScoreTooltip.js
    function defineRiskScoreTooltip(
        column,
        content,
        config,
        results,
        metricMetadata = null
    ) {
        const groupID = content.GroupID;
        const groupResults = results.filter(
            (result) => result.GroupID === groupID
        );
        const riskScoreResult = groupResults.find(
            (result) => result.MetricID === config.SiteRiskScoreMetricID
        );
        const amberFlags = groupResults
            .filter((result) => Math.abs(parseInt(result.Flag)) === 1)
            .filter(
                (result) => result.MetricID !== config.SiteRiskScoreMetricID
            );
        const redFlags = groupResults
            .filter((result) => Math.abs(parseInt(result.Flag)) === 2)
            .filter(
                (result) => result.MetricID !== config.SiteRiskScoreMetricID
            );
        const metricLookup = metricMetadata
            ? metricMetadata.reduce((acc, metric) => {
                  acc[metric.MetricID] = {
                      name: metric.Metric,
                      abbreviation: metric.Abbreviation,
                  };
                  return acc;
              }, {})
            : {};
        const tooltipLines = [];
        if (riskScoreResult) {
            const numerator = riskScoreResult.Numerator;
            const denominator = riskScoreResult.Denominator;
            const score = parseFloat(riskScoreResult.Score).toFixed(2);
            tooltipLines.push(`Risk Score Calculation:`);
            tooltipLines.push(`${numerator} / ${denominator} = ${score}`);
            tooltipLines.push('');
        }
        if (redFlags.length > 0) {
            tooltipLines.push(`Red Flags (${redFlags.length}):`);
            redFlags.forEach((result) => {
                const metricInfo = metricLookup[result.MetricID];
                const metricName = metricInfo
                    ? metricInfo.name
                    : result.MetricID;
                const metricText = result.Weight
                    ? `\u2022 ${metricName}: ${result.Weight}`
                    : `\u2022 ${metricName}`;
                tooltipLines.push(metricText);
            });
            tooltipLines.push('');
        }
        if (amberFlags.length > 0) {
            tooltipLines.push(`Amber Flags (${amberFlags.length}):`);
            amberFlags.forEach((result) => {
                const metricInfo = metricLookup[result.MetricID];
                const metricName = metricInfo
                    ? metricInfo.name
                    : result.MetricID;
                const metricText = result.Weight
                    ? `\u2022 ${metricName}: ${result.Weight}`
                    : `\u2022 ${metricName}`;
                tooltipLines.push(metricText);
            });
        }
        if (redFlags.length === 0 && amberFlags.length === 0) {
            tooltipLines.push('No amber or red flags for this group');
        }
        tooltipLines.push('');
        tooltipLines.push('For more information, see:');
        tooltipLines.push(
            config.SiteRiskScoreURL ||
                'https://gilead-biostats.github.io/gsm.kri/articles/SiteRiskScore.html'
        );
        return tooltipLines.join('\n');
    }

    // src/groupOverview/defineColumns/defineGroupColumns.js
    function defineGroupColumns(
        groupMetadata,
        config,
        results = null,
        metricMetadata = null
    ) {
        let columns = [
            {
                label: 'Group',
                data: groupMetadata,
                filterKey: 'GroupID',
                valueKey: 'GroupLabel',
                headerTooltip: null,
                sort: sortString,
                tooltip: true,
                type: 'group',
                dataType: 'string',
            },
            {
                label: 'Enrolled',
                data: groupMetadata,
                filterKey: 'GroupID',
                valueKey: config.groupParticipantCountKey,
                headerTooltip: null,
                sort: sortNumber,
                tooltip: false,
                type: 'group',
                dataType: 'number',
            },
            {
                label: 'Red Flags',
                data: groupMetadata,
                filterKey: 'GroupID',
                valueKey: 'nRedFlags',
                headerTooltip: null,
                sort: sortNumber,
                tooltip: false,
                type: 'group',
                dataType: 'number',
            },
            {
                label: 'Amber Flags',
                data: groupMetadata,
                filterKey: 'GroupID',
                valueKey: 'nAmberFlags',
                headerTooltip: null,
                sort: sortNumber,
                tooltip: false,
                type: 'group',
                dataType: 'number',
            },
        ];
        columns.forEach((column) => {
            column.defineTooltip = defineTooltip;
        });
        columns = columns.filter((column) =>
            groupMetadata.some((groupMetadatum) =>
                groupMetadatum.hasOwnProperty(column.valueKey)
            )
        );
        const hasSiteRiskScoreData =
            results &&
            results.some(
                (result) => result.MetricID === config.SiteRiskScoreMetricID
            );
        const shouldAddRiskScoreColumn =
            config.GroupLevel === 'Site' && hasSiteRiskScoreData;
        if (shouldAddRiskScoreColumn) {
            const riskScoreColumn = {
                label: 'Risk Score',
                data: groupMetadata,
                filterKey: 'GroupID',
                valueKey: 'siteRiskScore',
                headerTooltip:
                    'Site risk score across all metrics. Score ranges from 0-100.\nClick score for more information.',
                sort: sortNumber,
                tooltip: true,
                type: 'group',
                dataType: 'number',
            };
            if (results) {
                riskScoreColumn.defineTooltip = (col, content, config2) =>
                    defineRiskScoreTooltip(
                        col,
                        content,
                        config2,
                        results,
                        metricMetadata
                    );
            } else {
                riskScoreColumn.defineTooltip = defineTooltip;
            }
            columns.push(riskScoreColumn);
        }
        return columns;
    }

    // src/groupOverview/defineColumns/defineMetricTooltip.js
    function defineTooltip2(column, result) {
        const tooltipContent = formatMetricTooltipLabel(result, column.meta);
        return tooltipContent.join('\n');
    }

    // src/groupOverview/defineColumns/defineMetricColumns.js
    function defineMetricColumns(metricMetadata, results, config) {
        const metricColumns = metricMetadata.map((metric) => {
            const column = {
                label: metric.Abbreviation,
                data: results.filter((d) => d.MetricID === metric.MetricID),
                filterKey: 'GroupID',
                valueKey: 'Flag',
                headerTooltip: metric.Metric,
                sort: sortNumber,
                tooltip: true,
                defineTooltip: defineTooltip2,
                type: 'metric',
                dataType: 'number',
                meta: {
                    ...metric,
                    ...{
                        resultTooltipKeys: config.resultTooltipKeys,
                    },
                },
            };
            return column;
        });
        return metricColumns;
    }

    // src/groupOverview/defineColumns.js
    function defineColumns(groupMetadata, metricMetadata, results, config) {
        const groupColumns = defineGroupColumns(
            groupMetadata,
            config,
            results,
            metricMetadata
        );
        const metricColumns = defineMetricColumns(
            metricMetadata,
            results,
            config
        );
        const columns = [...groupColumns, ...metricColumns];
        columns.forEach((column, i) => {
            column.getDatum = (key) =>
                column.data.find((d) => d[column.filterKey] === key);
            column.index = i;
            column.sortState = column.dataType === 'string' ? 0 : 1;
            column.activeSort = false;
        });
        return columns;
    }

    // src/groupOverview/structureData/sortByFlags.js
    function sortByFlags(rowData) {
        const sortedRowData = rowData.sort((a, b) => {
            const redComparison = b[1].nRedFlags - a[1].nRedFlags;
            const amberComparison = b[1].nAmberFlags - a[1].nAmberFlags;
            const greenComparison = b[1].nGreenFlags - a[1].nGreenFlags;
            const groupComparison = a.key.localeCompare(b.key);
            return (
                redComparison ||
                amberComparison ||
                greenComparison ||
                groupComparison
            );
        });
        return sortedRowData;
    }

    // src/groupOverview/structureData.js
    function structureData2(results, columns, groupMetadata, config) {
        const lookup = group(
            results,
            (d) => d.GroupID,
            (d) => d.MetricID
        );
        const rowData = Array.from(lookup, ([key, value]) => {
            const group2 = groupMetadata.find(
                (group3) => group3.GroupID === key
            );
            const rowDatum = columns.map((column) => {
                const datum2 = {
                    ...(column.getDatum(key) || {}),
                    column,
                    group: group2,
                    GroupID: key,
                };
                datum2.value = datum2[column.valueKey];
                datum2.text = datum2.value;
                if (
                    column.valueKey === 'siteRiskScore' &&
                    datum2.value !== null &&
                    !isNaN(datum2.value)
                ) {
                    datum2.text = Math.round(parseFloat(datum2.value));
                }
                datum2.sortValue =
                    column.type === 'metric'
                        ? Math.abs(parseFloat(datum2.value))
                        : datum2.value;
                datum2.class = [
                    `group-overview--${column.type}`,
                    `group-overview--${column.dataType}`,
                    `group-overview--${column.valueKey}`,
                ].join(' ');
                datum2.tooltip = column.tooltip;
                datum2.tooltipContent = column.defineTooltip(
                    column,
                    datum2,
                    config
                );
                return datum2;
            });
            rowDatum.key = key;
            return rowDatum;
        });
        const sortedData = sortByFlags(rowData);
        return sortedData;
    }

    // src/groupOverview/makeTable/addHeaderRow.js
    function addHeaderRow(thead, columns) {
        const headerRow = thead
            .append('tr')
            .selectAll('th')
            .data(columns)
            .join('th')
            .attr('class', (d) => `group-overview--${d.type}`)
            .classed('group-overview--tooltip', (d) => d.headerTooltip !== null)
            .text((d) => d.label)
            .attr('title', (d) => d.headerTooltip);
        return headerRow;
    }

    // src/groupOverview/makeTable/addBodyRows.js
    function addBodyRows(tbody, rows) {
        const bodyRows = tbody
            .selectAll('tr')
            .data(
                rows,
                // Define a unique key for each row.
                (d) => d.key
            )
            .join('tr');
        return bodyRows;
    }

    // src/groupOverview/makeTable/addCells.js
    function addCells(bodyRows) {
        const cells = bodyRows
            .selectAll('td')
            .data(
                (d) => d,
                // Define a unique key for each cell.
                (d) => {
                    const id2 =
                        d.column.type === 'metric'
                            ? `${d.GroupID}-${d.column.meta.MetricID}`
                            : `${d.GroupID}-${d.column.valueKey}`;
                    return id2;
                }
            )
            .join('td')
            .text((d) => (d.text === 'NA' ? '-' : d.text))
            .attr('class', (d) => d.class)
            .classed('group-overview--tooltip', (d) => {
                if (d.column.valueKey === 'siteRiskScore') {
                    return false;
                }
                return d.tooltip;
            })
            .attr('title', (d) => {
                if (d.column.valueKey === 'siteRiskScore') {
                    return null;
                }
                return d.tooltip ? d.tooltipContent : null;
            });
        return cells;
    }

    // src/groupOverview/makeTable/addSorting.js
    function addSorting(headerRow, body) {
        headerRow.on('click', function (event, column) {
            headerRow.data().forEach((d) => {
                d.activeSort = false;
            });
            column.sort(body.selectAll('tr'), column);
            column.activeSort = true;
        });
    }

    // src/groupOverview/makeTable/icons/singleArrow.js
    function singleArrow(flag, color3 = 'white') {
        const direction = Math.sign(flag) === 1 ? 'up' : 'down';
        const svgIcon = `
        <svg aria-hidden="true" role="img" viewBox="0 0 448 512" style="height:1em;width:0.88em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:${color3};overflow:visible;position:relative;${
            direction === 'down' ? 'transform:rotate(180deg);' : ''
        }">
            <path d="M201.4 137.4c12.5-12.5 32.8-12.5 45.3 0l160 160c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L224 205.3 86.6 342.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l160-160z"/>
        </svg>`;
        return svgIcon;
    }

    // src/groupOverview/makeTable/icons/doubleArrow.js
    function doubleArrow(flag, color3 = 'white') {
        const direction = Math.sign(flag) === 1 ? 'up' : 'down';
        const svgIcon = `
        <svg aria-hidden="true" role="img" viewBox="0 0 448 512" style="height:1em;width:0.88em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:${color3};overflow:visible;position:relative;${
            direction === 'down' ? 'transform:rotate(180deg);' : ''
        }">
            <path d="M246.6 41.4c-12.5-12.5-32.8-12.5-45.3 0l-160 160c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L224 109.3 361.4 246.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3l-160-160zm160 352l-160-160c-12.5-12.5-32.8-12.5-45.3 0l-160 160c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L224 301.3 361.4 438.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3z"/>
        </svg>`;
        return svgIcon;
    }

    // src/groupOverview/makeTable/icons/checkMark.js
    function checkMark(color3 = 'white') {
        const svgIcon = `
        <svg aria-hidden="true" role="img" viewBox="0 0 448 512" style="height:1em;width:0.88em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:${color3};overflow:visible;position:relative;">
            <path d="M438.6 105.4c12.5 12.5 12.5 32.8 0 45.3l-256 256c-12.5 12.5-32.8 12.5-45.3 0l-128-128c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0L160 338.7 393.4 105.4c12.5-12.5 32.8-12.5 45.3 0z"/>
        </svg>`;
        return svgIcon;
    }

    // src/groupOverview/makeTable/icons/minus.js
    function checkMark2(color3 = 'white') {
        const svgIcon = `
        <svg aria-hidden="true" role="img" viewBox="0 0 448 512" style="height:1em;width:0.88em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:${color3};overflow:visible;position:relative;">
            <path d="M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z"/>
        </svg>`;
        return svgIcon;
    }

    // src/groupOverview/makeTable/addFlagIcons.js
    function addFlagIcons(rows) {
        const metricCells = rows
            .selectAll('td.group-overview--metric')
            .text('');
        metricCells.each(function (d) {
            const flag = parseInt(d.Flag);
            const absFlag = Math.abs(flag);
            switch (absFlag) {
                case 0:
                    this.insertAdjacentHTML(
                        'beforeend',
                        checkMark(colorScheme_default.green.color)
                    );
                    break;
                case 1:
                    this.insertAdjacentHTML(
                        'beforeend',
                        singleArrow(flag, colorScheme_default.amber.color)
                    );
                    break;
                case 2:
                    this.insertAdjacentHTML(
                        'beforeend',
                        doubleArrow(flag, colorScheme_default.red.color)
                    );
                    break;
                default:
                    this.insertAdjacentHTML(
                        'beforeend',
                        checkMark2(colorScheme_default.gray.color)
                    );
                    break;
            }
        });
    }

    // src/groupOverview/makeTable/addRowHighlighting.js
    function addRowHighlighting(rows) {
        rows.on('mouseover', function () {
            select_default2(this).style('background-color', 'lightgray');
        }).on('mouseout', function () {
            select_default2(this).style('background-color', null);
        });
    }

    // src/groupOverview/makeTable/addClickEvents.js
    function addClickEvents(bodyRows, cells, config) {
        const riskSignalSelected = new CustomEvent('riskSignalSelected', {
            bubbles: true,
        });
        cells
            .filter('.group-overview--metric')
            .on('click', function (event, d) {
                config.metricClickCallback({
                    GroupLevel: config.GroupLevel,
                    GroupID: d.GroupID,
                    MetricID: d.MetricID,
                    data: d,
                });
                riskSignalSelected.data = results_default.items.required.reduce(
                    (acc, item) => {
                        acc[item] = d[item];
                        return acc;
                    },
                    {}
                );
                this.dispatchEvent(riskSignalSelected);
            });
        const groupSelected = new CustomEvent('groupSelected', {
            bubbles: true,
        });
        cells
            .filter('.group-overview--group')
            .filter((d) => d.column.valueKey !== 'siteRiskScore')
            .on('click', function (event, d) {
                config.groupClickCallback({
                    GroupLevel: config.GroupLevel,
                    GroupID: d.GroupID,
                    data: d,
                });
                groupSelected.data = {
                    //StudyID: d.StudyID,
                    //SnapshotDate: d.SnapshotDate,
                    GroupLevel: d.GroupLevel,
                    GroupID: d.GroupID,
                };
                this.dispatchEvent(groupSelected);
            });
    }

    // src/groupOverview/makeTable/addCustomTooltip.js
    function addCustomTooltip(cells) {
        cells.on('click.risk-score-tooltip', null);
        let tooltip5 = select_default2('body').select('.custom-tooltip');
        if (tooltip5.empty()) {
            tooltip5 = select_default2('body')
                .append('div')
                .attr('class', 'custom-tooltip')
                .style('position', 'absolute')
                .style('background', '#ffffff')
                .style('color', '#000')
                .style('padding', '8px 10px')
                .style('border', '1px solid #ccc')
                .style('border-radius', '3px')
                .style('font-size', '11px')
                .style('line-height', '1.3')
                .style('white-space', 'pre-line')
                .style('max-width', '350px')
                .style('box-shadow', '0 2px 4px rgba(0,0,0,0.2)')
                .style('z-index', '1000')
                .style('pointer-events', 'auto')
                .style('display', 'none')
                .style(
                    'font-family',
                    '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
                );
        }
        const riskScoreCells = cells.filter(
            (d) => d.column.valueKey === 'siteRiskScore' && d.tooltip
        );
        let activeCell = null;
        riskScoreCells
            .style('cursor', 'pointer')
            .classed('group-overview--tooltip', false)
            .on('click.risk-score-tooltip', function (event, d) {
                event.stopPropagation();
                event.preventDefault();
                const currentCell = this;
                if (activeCell === currentCell) {
                    tooltip5.style('display', 'none');
                    activeCell = null;
                    return;
                }
                tooltip5.style('display', 'none');
                const content = d.tooltipContent;
                if (!content) {
                    activeCell = null;
                    return;
                }
                activeCell = currentCell;
                tooltip5.selectAll('*').remove();
                const lines = content.split('\n');
                lines.forEach((line) => {
                    const lineElement = tooltip5.append('div');
                    const urlRegex = /(https?:\/\/[^\s]+)/g;
                    const matches = line.match(urlRegex);
                    if (matches) {
                        const parts = line.split(urlRegex);
                        parts.forEach((part) => {
                            if (urlRegex.test(part)) {
                                lineElement
                                    .append('a')
                                    .attr('href', part)
                                    .attr('target', '_blank')
                                    .attr('rel', 'noopener noreferrer')
                                    .style('color', '#0066cc')
                                    .style('text-decoration', 'underline')
                                    .text(part)
                                    .on('mouseover', function () {
                                        select_default2(this).style(
                                            'color',
                                            '#004499'
                                        );
                                    })
                                    .on('mouseout', function () {
                                        select_default2(this).style(
                                            'color',
                                            '#0066cc'
                                        );
                                    });
                            } else if (part) {
                                lineElement.append('span').text(part);
                            }
                        });
                    } else {
                        lineElement.text(line);
                    }
                });
                const [mouseX, mouseY] = [event.pageX, event.pageY];
                tooltip5
                    .style('left', mouseX + 10 + 'px')
                    .style('top', mouseY - 10 + 'px')
                    .style('display', 'block');
            });
        select_default2('body').on('click.custom-tooltip', function (event) {
            const clickedElement = event.target;
            const isTooltipClick =
                tooltip5.node() && tooltip5.node().contains(clickedElement);
            const isRiskScoreClick = riskScoreCells
                .nodes()
                .some((node) => node.contains(clickedElement));
            if (!isTooltipClick && !isRiskScoreClick) {
                tooltip5.style('display', 'none');
                activeCell = null;
            }
        });
    }

    // src/groupOverview/makeTable.js
    function makeTable(_element_, rows, columns, config) {
        const table = select_default2(_element_)
            .append('table')
            .datum({
                config,
                rows,
                columns,
            })
            .classed('group-overview', true);
        const thead = table.append('thead');
        const tbody = table.append('tbody');
        const headerRow = addHeaderRow(thead, columns);
        const bodyRows = addBodyRows(tbody, rows);
        const cells = addCells(bodyRows);
        addSorting(headerRow, tbody, columns);
        addFlagIcons(bodyRows);
        addRowHighlighting(bodyRows);
        addClickEvents(bodyRows, cells, config);
        addCustomTooltip(cells);
        return table;
    }

    // src/groupOverview/updateTable.js
    function updateTable(_results_) {
        const groupMetadata = deriveGroupMetrics(
            this._groupMetadata_,
            _results_,
            this.config
        );
        const columns = defineColumns(
            groupMetadata,
            this._metricMetadata_,
            _results_,
            this.config
        );
        const rows = structureData2(
            _results_,
            columns,
            groupMetadata,
            this.config
        );
        const tbody = this.table.select('tbody');
        const bodyRows = addBodyRows(tbody, rows);
        const cells = addCells(bodyRows);
        addFlagIcons(bodyRows);
        addRowHighlighting(bodyRows);
        addClickEvents(bodyRows, cells, this.config);
        addCustomTooltip(cells);
        const sortedColumn = this.columns.find((d) => d.activeSort);
        if (sortedColumn !== void 0) {
            sortedColumn.sortState = -sortedColumn.sortState;
            sortedColumn.sort(tbody.selectAll('tr'), sortedColumn);
        } else {
            tbody.selectAll('tr').sort((a, b) => {
                const redComparison = b[1].nRedFlags - a[1].nRedFlags;
                const amberComparison = b[1].nAmberFlags - a[1].nAmberFlags;
                const greenComparison = b[1].nGreenFlags - a[1].nGreenFlags;
                const groupComparison = a.key.localeCompare(b.key);
                return (
                    redComparison ||
                    amberComparison ||
                    greenComparison ||
                    groupComparison
                );
            });
        }
    }

    // src/groupOverview.js
    function groupOverview(
        _element_ = 'body',
        _results_ = [],
        _config_ = null,
        _groupMetadata_ = null,
        _metricMetadata_ = null
    ) {
        checkInputs2(_results_, _config_, _groupMetadata_, _metricMetadata_);
        const config = configure4(_config_);
        const groupMetadata = deriveGroupMetrics(
            _groupMetadata_,
            _results_,
            config
        );
        const columns = defineColumns(
            groupMetadata,
            _metricMetadata_,
            _results_,
            config
        );
        const rows = structureData2(_results_, columns, groupMetadata, config);
        const table = makeTable(_element_, rows, columns, config);
        table.updateTable = updateTable.bind({
            _results_,
            _config_,
            _groupMetadata_,
            _metricMetadata_,
            config,
            groupMetadata,
            columns,
            rows,
            table,
        });
        return table;
    }

    // src/scatterPlot/checkInputs.js
    function checkInputs3(_results_, _config_, _bounds_, _groupMetadata_) {
        checkInput({
            parameter: '_results_',
            argument: _results_,
            schemaName: 'results',
            module: 'scatterPlot',
        });
        checkInput({
            parameter: '_config_',
            argument: _config_,
            schemaName: 'metricMetadatum',
            module: 'scatterPlot',
        });
        checkInput({
            parameter: '_bounds_',
            argument: _bounds_,
            schemaName: 'resultsPredicted',
            module: 'scatterPlot',
        });
        if (_groupMetadata_ !== null) {
            checkInput({
                parameter: '_groupMetadata_',
                argument: _groupMetadata_,
                schemaName: 'groupMetadata',
                module: 'scatterPlot',
            });
        }
    }

    // src/scatterPlot/configure.js
    function configure5(_config_, _results_) {
        const defaults3 = {};
        defaults3.resultTooltipKeys = [
            'Score',
            'Metric',
            'Numerator',
            'Denominator',
        ];
        defaults3.GroupLevel = 'Site';
        defaults3.groupLabelKey = 'InvestigatorLastName';
        defaults3.groupParticipantCountKey = 'ParticipantCount';
        defaults3.groupTooltipKeys = null;
        defaults3.x = 'Denominator';
        defaults3[defaults3.x] = defaults3.x;
        defaults3.xType = 'logarithmic';
        defaults3.y = 'Numerator';
        defaults3[defaults3.y] = defaults3.y;
        defaults3.yType = 'linear';
        defaults3.color = 'Flag';
        defaults3.hoverCallback = (datum2) => {};
        defaults3.clickCallback = (datum2) => {
            console.log(datum2);
        };
        defaults3.displayTitle = false;
        defaults3.displayLegend = true;
        defaults3.displayTrendLine = false;
        defaults3.maintainAspectRatio = false;
        const config = configure2(defaults3, _config_, {
            selectedGroupIDs: checkSelectedGroupIDs.bind(
                null,
                _config_?.selectedGroupIDs,
                _results_
            ),
        });
        config.selectedGroupDatum = updateSelectedGroupDatum(
            _results_,
            config.selectedGroupIDs
        );
        config.xLabel = coalesce(_config_?.xLabel, config[config.x]);
        config.yLabel = coalesce(_config_?.yLabel, config[config.y]);
        config.chartName = `Scatter Plot of ${config.yLabel} by ${config.xLabel}`;
        if (config.hoverCallbackWrapper === void 0)
            config.hoverCallbackWrapper = getCallbackWrapper(
                config.hoverCallback
            );
        if (config.clickCallbackWrapper === void 0)
            config.clickCallbackWrapper = getCallbackWrapper(
                config.clickCallback
            );
        return config;
    }

    // src/scatterPlot/structureData/mutate.js
    function mutate2(_results_, config, groupMetadata = null) {
        const results = _results_
            .map((d) => {
                if (groupMetadata !== null) {
                    const group2 = groupMetadata.get(d.GroupID);
                    if (group2 !== void 0) {
                        d.group = group2;
                        d.group.groupLabel = d.group.hasOwnProperty(
                            config.groupLabelKey
                        )
                            ? d.group[config.groupLabelKey]
                            : d.GroupID;
                    }
                }
                const datum2 = {
                    ...d,
                    x: +d[config.x],
                    y: +d[config.y],
                    stratum: isNaN(parseFloat(d[config.color]))
                        ? 3
                        : Math.abs(+d[config.color]),
                };
                return datum2;
            })
            .sort((a, b) => {
                const aSelected =
                    config.selectedGroupIDs.indexOf(a.GroupID) > -1;
                const bSelected =
                    config.selectedGroupIDs.indexOf(b.GroupID) > -1;
                const stratum = b.stratum - a.stratum;
                return aSelected ? 1 : bSelected ? -1 : stratum;
            });
        identifyDuplicatePoints(results, config);
        return results;
    }

    // src/scatterPlot/structureData/scriptableOptions/backgroundColor.js
    function backgroundColor2(context, options) {
        const chart = context.chart;
        const config = chart.data.config;
        const dataset = context.dataset;
        const datum2 = dataset.data[context.dataIndex];
        if (datum2 !== void 0 && dataset.type === 'scatter') {
            const color3 = colorScheme_default[datum2.stratum].rgba;
            color3.opacity = config.selectedGroupIDs.includes(datum2.GroupID)
                ? 1
                : config.selectedGroupIDs.length === 0
                ? 0.5
                : 0.25;
            return color3 + '';
        }
    }

    // src/scatterPlot/structureData/scriptableOptions/borderColor.js
    function borderColor2(context, options) {
        const chart = context.chart;
        const config = chart.data.config;
        const dataset = context.dataset;
        const datum2 = dataset.data[context.dataIndex];
        if (datum2 !== void 0 && dataset.type === 'scatter') {
            const color3 = colorScheme_default[datum2.stratum].rgba;
            color3.opacity = config.selectedGroupIDs.length === 0 ? 1 : 0.5;
            return config.selectedGroupIDs.includes(datum2.GroupID)
                ? 'black'
                : color3 + '';
        }
    }

    // src/scatterPlot/structureData/scriptableOptions/borderWidth.js
    function borderWidth(context, options) {
        const chart = context.chart;
        const config = chart.data.config;
        const dataset = context.dataset;
        const datum2 = dataset.data[context.dataIndex];
        if (datum2 !== void 0 && dataset.type === 'scatter') {
            return 1;
        }
    }

    // src/scatterPlot/structureData/scriptableOptions/pointHoverRadius.js
    function pointHoverRadius(context, options) {
        const chart = context.chart;
        const config = chart.data.config;
        const dataset = context.dataset;
        const datum2 = dataset.data[context.dataIndex];
        if (datum2 !== void 0 && dataset.type === 'scatter') {
            const defaultRadius = 3;
            const hoverRadius = 4;
            if (datum2.group !== void 0) {
                const enrollmentFactor = Math.sqrt(
                    datum2.group[config.groupParticipantCountKey] / Math.PI
                );
                return enrollmentFactor * hoverRadius;
            } else {
                return config.selectedGroupIDs.includes(datum2.GroupID)
                    ? hoverRadius
                    : defaultRadius;
            }
        }
    }

    // src/scatterPlot/structureData/scriptableOptions/radius.js
    function radius(context, options) {
        const chart = context.chart;
        const config = chart.data.config;
        const dataset = context.dataset;
        const datum2 = dataset.data[context.dataIndex];
        if (datum2 !== void 0 && dataset.type === 'scatter') {
            const defaultRadius = 3;
            const hoverRadius = 4;
            if (datum2.group !== void 0) {
                const enrollmentFactor = Math.sqrt(
                    datum2.group[config.groupParticipantCountKey] / Math.PI
                );
                return enrollmentFactor * defaultRadius;
            } else {
                return config.selectedGroupIDs.includes(datum2.GroupID)
                    ? hoverRadius
                    : defaultRadius;
            }
        }
    }

    // src/scatterPlot/structureData/scriptableOptions.js
    function scriptableOptions2() {
        return {
            backgroundColor: backgroundColor2,
            borderColor: borderColor2,
            borderWidth,
            pointHoverRadius,
            radius,
        };
    }

    // src/scatterPlot/structureData/rollupBounds.js
    function rollupBounds(_bounds_, config) {
        if (_bounds_ !== null) {
            const boundUps = rollups(
                _bounds_.sort((a, b) => a.Threshold - b.Threshold),
                (Group) => {
                    return {
                        type: 'line',
                        data: Group.map((d) => ({
                            stratum: Math.abs(+d.Threshold),
                            Threshold: d.Threshold,
                            x: +d.Denominator,
                            y: +d.Numerator,
                        })),
                        borderWidth: 1,
                        hoverRadius: 0,
                        pointRadius: 0,
                    };
                },
                (d) => d.Threshold
            );
            const flags = mapThresholdsToFlags(
                boundUps.map((bound) => bound[0])
            );
            const bounds = boundUps.map((bound, i) => {
                const Group = bound[1];
                Group.Threshold = +bound[0];
                Group.Flag = flags.find(
                    (Flag2) => Flag2.Threshold === Group.Threshold
                );
                const Flag = Group.Flag.Flag;
                Group.label = '';
                const color3 = colorScheme_default[Math.abs(Flag)].color;
                Group.borderColor = color3;
                const backgroundColor4 = color2(color3);
                backgroundColor4.opacity = 0.75;
                Group.backgroundColor = backgroundColor4 + '';
                Group.borderDash = [2];
                if (
                    config.displayTrendLine === false &&
                    Group.Threshold === 0
                ) {
                    Group.borderColor = 'rgba(0,0,0,0)';
                }
                return Group;
            });
            rollup(
                bounds,
                (Group) => {
                    Group.forEach((d, i) => {
                        if (i > 0) d.label = '';
                    });
                },
                (d) => Math.abs(d.Flag.Flag)
            );
            return bounds;
        }
    }

    // src/scatterPlot/structureData.js
    function structureData3(
        _results_,
        config,
        _bounds_,
        _groupMetadata_ = null
    ) {
        const groupMetadata = structureGroupMetadata(_groupMetadata_, config);
        const data = mutate2(_results_, config, groupMetadata);
        let datasets = [
            {
                data,
                label: '',
                listenClick: true,
                listenHover: true,
                type: 'scatter',
                ...scriptableOptions2(),
            },
            ...colorScheme_default.map((color3) => {
                const dataset = {
                    type: 'scatter',
                    label: color3.description,
                    backgroundColor: color3.rgba,
                    borderColor: color3.color,
                };
                dataset.backgroundColor.opacity = 0.5;
                dataset.backgroundColor = dataset.backgroundColor + '';
                return dataset;
            }),
        ];
        const bounds = rollupBounds(_bounds_, config);
        if (bounds !== void 0)
            bounds.forEach((bound) => {
                datasets.push(bound);
            });
        if (data.every((d) => falsy_default.includes(d.Flag) === false))
            datasets = datasets.filter((d) => d.label !== 'No Flag');
        return datasets;
    }

    // src/scatterPlot/getPlugins/legend.js
    function legend2(config) {
        const legendOrder = colorScheme_default
            .sort((a, b) => a.order - b.order)
            .map((color3) => color3.description);
        return {
            display: config.displayLegend,
            labels: {
                boxHeight: 6,
                filter: function (legendItem, chartData) {
                    return legendItem.text !== '';
                },
                sort: function (a, b, chartData) {
                    return (
                        legendOrder.indexOf(a.text) -
                        legendOrder.indexOf(b.text)
                    );
                },
                usePointStyle: true,
            },
            onClick: () => null,
            position: 'top',
        };
    }

    // src/scatterPlot/getPlugins/title.js
    function title2(config) {
        return {
            display: config.displayTitle,
            text: `${config.Metric} by ${config.GroupLevel}`,
        };
    }

    // src/util/sortByGroupID.js
    function sortByGroupID(data, config) {
        const numericGroupIDs = data.every((d) => /^\d+$/.test(d.raw.GroupID));
        const dataSorted = data.sort((a, b) => {
            const selected =
                config.selectedGroupIDs.includes(b.raw.GroupID) -
                config.selectedGroupIDs.includes(a.raw.GroupID);
            const alphanumeric = numericGroupIDs
                ? ascending(+a.raw.GroupID, +b.raw.GroupID)
                : ascending(a.raw.GroupID, b.raw.GroupID);
            return selected || alphanumeric;
        });
        return dataSorted;
    }

    // src/scatterPlot/getPlugins/tooltip.js
    function tooltip2(config) {
        const tooltipAesthetics = getTooltipAesthetics();
        return {
            callbacks: {
                label: (d) => {
                    const content = [
                        ...formatMetricTooltipLabel(d.raw, config),
                        ...formatGroupTooltipLabel(d.raw.group, config),
                    ];
                    return d.raw.duplicate ? '' : content;
                },
                title: (data) => {
                    if (data.length) {
                        const dataSorted = sortByGroupID(data, config);
                        const titles = dataSorted.map((d, i) => {
                            let title5;
                            if (data.length === 1) {
                                title5 = formatMetricTooltipTitle(
                                    d.raw,
                                    config
                                );
                            } else {
                                title5 =
                                    i === 0
                                        ? `${config.GroupLevel}s ${
                                              d.dataset.data[d.dataIndex]
                                                  .GroupID
                                          }`
                                        : d.dataset.data[d.dataIndex].GroupID;
                            }
                            return title5;
                        });
                        const title4 =
                            titles.length <= 4
                                ? titles.join(', ')
                                : `${titles.slice(0, 3).join(', ')} and [ ${
                                      titles.length - 3
                                  } ] more`;
                        return title4;
                    }
                },
            },
            custom: function (tooltipModel) {
                if (!tooltipModel.body || tooltipModel.body.length < 1) {
                    tooltipModel.caretSize = 0;
                    tooltipModel.xPadding = 0;
                    tooltipModel.yPadding = 0;
                    tooltipModel.cornerRadius = 0;
                    tooltipModel.width = 0;
                    tooltipModel.height = 0;
                }
            },
            filter: (data) => data.dataset.type !== 'line',
            // turns off tooltip for bounds
            ...tooltipAesthetics,
        };
    }

    // src/scatterPlot/getPlugins.js
    function getPlugins2(config) {
        const plugins2 = {
            legend: legend2(config),
            title: title2(config),
            tooltip: tooltip2(config),
        };
        return plugins2;
    }

    // src/scatterPlot/getScales.js
    function getScales2(config) {
        const scales2 = getDefaultScales();
        scales2.x.grid.display = true;
        scales2.x.ticks = {
            callback: function (value, index3, context) {
                const tick = context[index3];
                return config.xType !== 'logarithmic' || tick.major
                    ? format(',d')(tick.value)
                    : null;
            },
        };
        scales2.x.title.text =
            config.xType === 'logarithmic'
                ? `${config.xLabel} (Log Scale)`
                : config.xLabel;
        scales2.x.type = config.xType;
        scales2.y.title.text = config.yLabel;
        scales2.y.type = config.yType;
        return scales2;
    }

    // src/scatterPlot/updateConfig.js
    function updateConfig2(
        chart,
        _config_,
        updateChart = true,
        updateTooltip = true
    ) {
        const config = configure5(
            _config_,
            chart.data.datasets.find((dataset) => dataset.type === 'scatter')
                .data
        );
        chart.canvas.riskSignalSelected.data = config.selectedGroupDatum;
        const plugins2 = getPlugins2(config);
        const scales2 = getScales2(config);
        chart.data.config = config;
        chart.options.plugins = plugins2;
        chart.options.scales = scales2;
        if (updateChart) chart.update();
        if (updateTooltip) triggerTooltip(chart);
        return config;
    }

    // src/scatterPlot/updateData.js
    function updateData2(
        chart,
        _results_,
        _config_,
        _bounds_,
        _groupMetadata_
    ) {
        const config = updateConfig2(chart, _config_, false, false);
        const datasets = structureData3(
            _results_,
            config,
            _bounds_,
            _groupMetadata_
        );
        chart.data.config = config;
        chart.data.datasets = datasets;
        chart.update();
        triggerTooltip(chart);
    }

    // src/scatterPlot.js
    function scatterPlot(
        _element_ = 'body',
        _results_ = [],
        _config_ = null,
        _bounds_ = null,
        _groupMetadata_ = null
    ) {
        checkInputs3(_results_, _config_, _bounds_, _groupMetadata_);
        const config = configure5(_config_, _results_);
        const canvas = addCanvas(_element_, config);
        const datasets = structureData3(
            _results_,
            config,
            _bounds_,
            _groupMetadata_
        );
        const options = {
            animation: false,
            maintainAspectRatio: config.maintainAspectRatio,
            onClick,
            onHover,
            plugins: getPlugins2(config),
            scales: getScales2(config),
        };
        const chart = new auto_default(canvas, {
            data: {
                datasets,
                // required by Chart.js
                config,
                // inputs
                _results_,
                _config_,
                _bounds_,
            },
            options,
            plugins: [displayWhiteBackground()],
        });
        canvas.chart = chart;
        chart.helpers = {
            updateConfig: updateConfig2,
            updateData: updateData2,
            updateOption,
            triggerTooltip,
        };
        triggerTooltip(chart);
        return chart;
    }

    // src/sparkline/checkInputs.js
    function checkInputs4(_results_, _config_, _thresholds_) {
        const discrete = /^n_((at_risk)?(_or_)?(flagged)?)$/i.test(_config_?.y);
        checkInput({
            parameter: '_results_',
            argument: _results_,
            schemaName: discrete ? 'flagCounts' : 'results',
            module: 'sparkline',
        });
        checkInput({
            parameter: '_config_',
            argument: discrete ? null : _config_,
            schemaName: 'metricMetadatum',
            module: 'sparkline',
        });
        checkInput({
            parameter: '_thresholds_',
            argument: _thresholds_,
            schemaName: 'thresholds',
            module: 'sparkline',
        });
    }

    // src/sparkline/configure.js
    function configure6(_config_, _data_, _thresholds_) {
        const defaults3 = {};
        defaults3.x = 'SnapshotDate';
        defaults3.xType = 'category';
        defaults3.y = 'Score';
        defaults3.yType = 'linear';
        defaults3.color = 'Flag';
        defaults3.hoverCallback = (datum2) => {};
        defaults3.clickCallback = (datum2) => {
            console.log(datum2);
        };
        defaults3.maintainAspectRatio = false;
        defaults3.nSnapshots = 5;
        defaults3.displayThresholds = false;
        const config = configure2(defaults3, _config_, {
            thresholds: checkThresholds.bind(null, _config_, _thresholds_),
        });
        config.annotation = ['Metric', 'Score'].includes(config.y)
            ? 'Numerator'
            : config.y;
        config.dataType = ['Metric', 'Score'].includes(config.y)
            ? 'continuous'
            : 'discrete';
        config.xLabel = coalesce(_config_?.xLabel, 'Snapshot Date');
        config.yLabel = coalesce(_config_?.yLabel, config[config.y]);
        config.chartName = `Sparkline of ${config.yLabel} by ${config.xLabel}`;
        return config;
    }

    // src/sparkline/structureData/mutate.js
    function mutate3(_data_, config) {
        const data = _data_
            .map((d) => {
                const datum2 = {
                    ...d,
                    //x: +d[config.x],
                    y: +d[config.y],
                    stratum: falsy_default.includes(d[config.color])
                        ? 3
                        : Math.abs(+d[config.color]),
                };
                return datum2;
            })
            .sort((a, b) => ascending(a.SnapshotDate, b.SnapshotDate));
        return data.slice(-config.nSnapshots);
    }

    // src/sparkline/structureData/scriptableOptions/borderColor.js
    function borderColor3(context, options) {
        const chart = context.chart;
        const config = chart.data.config;
        const dataset = context.dataset;
        const datum2 = dataset.data[context.dataIndex];
        if (dataset.type === 'line') {
            return datum2 === dataset.data[dataset.data.length - 1]
                ? 'black'
                : 'rgba(0, 0, 0, 0.1)';
        }
    }

    // src/sparkline/structureData/scriptableOptions/radius.js
    function radius2(context, options) {
        const chart = context.chart;
        const config = chart.data.config;
        const dataset = context.dataset;
        const datum2 = dataset.data[context.dataIndex];
        if (dataset.type === 'line') {
            return datum2 === dataset.data[dataset.data.length - 1] ? 4 : 3;
        }
    }

    // src/sparkline/structureData/scriptableOptions.js
    function scriptableOptions3() {
        return {
            //backgroundColor,
            borderColor: borderColor3,
            //borderWidth,
            radius: radius2,
        };
    }

    // src/sparkline/structureData.js
    function structureData4(_data_, config) {
        const data = mutate3(_data_, config);
        const labels = data.map((d) => d.SnapshotDate);
        const pointBackgroundColor = data.map((d, i) => {
            return config.dataType === 'continuous'
                ? colorScheme_default[d.stratum].color
                : config.y === 'n_at_risk'
                ? colorScheme_default.find((color3) =>
                      /amber/i.test(color3.description)
                  ).color
                : config.y === 'n_flagged'
                ? colorScheme_default.find((color3) =>
                      /red/i.test(color3.description)
                  ).color
                : config.y === 'n_at_risk_or_flagged'
                ? colorScheme_default.amberRed.color
                : '#1890FF';
        });
        const datasets = [
            {
                type: 'line',
                data: data.map((d, i) => {
                    const datum2 = { ...d };
                    datum2.x = i;
                    datum2.y = +d[config.y];
                    return datum2;
                }),
                pointBackgroundColor,
                //label: '',
                ...scriptableOptions3(),
                spanGaps: true,
            },
        ];
        datasets.labels = labels;
        return datasets;
    }

    // src/sparkline/getPlugins/annotation/thresholds.js
    function thresholds(config) {
        let thresholds2 = null;
        if (config.displayThresholds && config.thresholds) {
            thresholds2 = config.thresholds.map((Threshold, i) => {
                const color3 = colorScheme_default.find((color4) =>
                    color4.Flag.includes(+Threshold.Flag)
                );
                color3.rgba.opacity = 0.5;
                const annotation2 = {
                    type: 'line',
                    yMin: Threshold.Threshold,
                    yMax: Threshold.Threshold,
                    borderColor: color3.rgba + '',
                    borderWidth: 1,
                };
                return annotation2;
            });
        }
        return thresholds2;
    }

    // src/sparkline/getPlugins/annotation/value.js
    function annotations2(config, data) {
        const xMin = 0;
        const xMax = data.length - 1;
        const xValue = xMax + xMax / 50;
        const yMin = min(data, (d) => +d[config.y]);
        const yMax = max(data, (d) => +d[config.y]);
        const range = yMin === yMax ? yMin : yMax - yMin;
        const yValue = yMin === yMax ? yMin : yMin + range / 2;
        const format2 = data.every((d) => +d[config.y] % 1 === 0)
            ? `d`
            : config.y === 'Metric'
            ? `.3f`
            : `.1f`;
        const datum2 = data
            .filter((d) => falsy_default.includes(d.y) === false)
            .slice(-1)[0];
        const content = [format(format2)(datum2?.y)];
        const value = {
            content,
            font: {
                size: 14,
                family: 'roboto',
                weight: 700,
            },
            position: {
                x: 'start',
                y: 'center',
            },
            type: 'label',
            xValue,
            yValue,
        };
        return value;
    }

    // src/sparkline/getPlugins/annotation.js
    function annotations3(config, data) {
        const value = annotations2(config, data);
        const thresholds2 = thresholds(config);
        const annotations5 = {
            clip: false,
            annotations: [value],
        };
        if (thresholds2 !== null)
            thresholds2.forEach((Threshold) => {
                annotations5.annotations.push(Threshold);
            });
        return annotations5;
    }

    // src/sparkline/getPlugins/legend.js
    function legend3(config) {
        return {
            display: false,
        };
    }

    // src/sparkline/getPlugins/tooltip.js
    function tooltip3(config) {
        const tooltipAesthetics = getTooltipAesthetics();
        tooltipAesthetics.padding = 4;
        tooltipAesthetics.caretSize = 0;
        return {
            callbacks: {
                label: function (data) {
                    const fmt =
                        config.y === 'Score'
                            ? '.1f'
                            : config.y === 'Metric'
                            ? '.3f'
                            : ',d';
                    return config.dataType === 'continuous'
                        ? `${data.label}: ${format(fmt)(data.parsed.y)}`
                        : //[
                          `${data.label}: ${format(fmt)(
                              data.raw.n_flagged
                          )} red / ${format(fmt)(data.raw.n_at_risk)} amber`;
                },
                title: () => null,
                footer: () => null,
            },
            displayColors: config.dataType === 'continuous',
            ...tooltipAesthetics,
        };
    }

    // src/sparkline/getPlugins.js
    function getPlugins3(config, _data_) {
        const plugins2 = {
            annotation: annotations3(config, _data_),
            legend: legend3(config),
            tooltip: tooltip3(config),
        };
        return plugins2;
    }

    // src/sparkline/getScales.js
    function getScales3(config, data) {
        const scales2 = getDefaultScales();
        scales2.x.display = false;
        scales2.x.type = config.xType;
        const yMin = min(data, (d) => d.y);
        const yMax = max(data, (d) => d.y);
        const range =
            yMin !== yMax
                ? yMax - yMin
                : yMin === yMax && yMin !== 0
                ? yMin
                : 1;
        scales2.y.display = false;
        scales2.y.min =
            config.yMin !== void 0 ? config.yMin : yMin - range * 0.35;
        scales2.y.max =
            config.yMax !== void 0 ? config.yMax : yMax + range * 0.35;
        scales2.y.type = config.yType;
        return scales2;
    }

    // src/sparkline/updateConfig.js
    function updateConfig3(chart, _config_, update = false) {
        const config = configure6(_config_);
        chart.data.config = config;
        if (update) chart.update();
        return config;
    }

    // src/sparkline/updateData.js
    function updateData3(chart, _data_, _config_) {
        chart.data.config = updateConfig3(chart, _config_);
        chart.data.datasets = structureData4(_data_, chart.data.config);
        chart.options.plugins = getPlugins3(
            chart.data.config,
            chart.data.datasets[0].data
        );
        chart.options.scales = getScales3(
            chart.data.config,
            chart.data.datasets[0].data
        );
        chart.update();
    }

    // src/sparkline.js
    function sparkline(
        _element_ = 'body',
        _results_ = [],
        _config_ = null,
        _thresholds_ = null
    ) {
        checkInputs4(_results_, _config_, _thresholds_);
        const config = configure6(_config_, _results_, _thresholds_);
        const canvas = addCanvas(_element_, config);
        const datasets = structureData4(_results_, config);
        const options = {
            animation: false,
            layout: {
                padding: {
                    right: 50,
                },
            },
            maintainAspectRatio: config.maintainAspectRatio,
            plugins: getPlugins3(config, datasets[0].data),
            scales: getScales3(config, datasets[0].data),
        };
        const chart = new auto_default(canvas, {
            data: {
                datasets,
                // required by Chart.js
                labels: datasets.labels,
                // required by Chart.js
                config,
                // inputs
                _results_,
                _config_,
                _thresholds_,
            },
            options,
        });
        canvas.chart = chart;
        chart.helpers = {
            updateConfig: updateConfig3,
            updateData: updateData3,
            updateOption,
        };
        return chart;
    }

    // src/timeSeries/checkInputs.js
    function checkInputs5(
        _results_,
        _config_,
        _thresholds_,
        _intervals_,
        _groupMetadata_
    ) {
        const discrete = /^n_((at_risk)?(_or_)?(flagged)?)$/i.test(_config_?.y);
        checkInput({
            parameter: '_results_',
            argument: _results_,
            schemaName: discrete ? 'flagCounts' : 'results',
            module: 'timeSeries',
        });
        checkInput({
            parameter: '_config_',
            argument: discrete ? null : _config_,
            schemaName: 'metricMetadatum',
            module: 'timeSeries',
        });
        checkInput({
            parameter: '_thresholds_',
            argument: _thresholds_,
            schemaName: 'thresholds',
            module: 'timeSeries',
        });
        checkInput({
            parameter: '_intervals_',
            argument: _intervals_,
            schemaName: 'resultsVertical',
            module: 'timeSeries',
        });
        if (_groupMetadata_ !== null) {
            checkInput({
                parameter: '_groupMetadata_',
                argument: _groupMetadata_,
                schemaName: 'groupMetadata',
                module: 'timeSeries',
            });
        }
    }

    // src/timeSeries/configure.js
    function configure7(_config_, _results_, _thresholds_, _intervals_) {
        const defaults3 = {};
        defaults3.resultTooltipKeys = [
            'Score',
            'Metric',
            'Numerator',
            'Denominator',
        ];
        defaults3.GroupLevel = 'Site';
        defaults3.groupLabelKey = 'InvestigatorLastName';
        defaults3.groupParticipantCountKey = 'ParticipantCount';
        defaults3.groupTooltipKeys = null;
        defaults3.dataType = 'continuous';
        defaults3.discreteUnit = null;
        defaults3.distributionDisplay = 'boxplot';
        defaults3.x = 'SnapshotDate';
        defaults3.xType = 'category';
        defaults3.y = 'Score';
        defaults3.yType = 'linear';
        defaults3.color = 'Flag';
        defaults3.hoverCallback = (datum2) => {};
        defaults3.clickCallback = (datum2) => {
            console.log(datum2);
        };
        defaults3.aggregateLabel = 'Study';
        defaults3.annotateThreshold = _thresholds_ !== null;
        defaults3.displayTitle = false;
        defaults3.maintainAspectRatio = false;
        if (_config_ !== null)
            _config_.variableThresholds = Array.isArray(_thresholds_)
                ? _thresholds_.some(
                      (Threshold) =>
                          Threshold.SnapshotDate !==
                          _thresholds_[0].SnapshotDate
                  )
                : false;
        const config = configure2(defaults3, _config_, {
            selectedGroupIDs: checkSelectedGroupIDs.bind(
                null,
                _config_?.selectedGroupIDs,
                _results_
            ),
            thresholds: checkThresholds.bind(null, _config_, _thresholds_),
        });
        config.selectedGroupDatum = updateSelectedGroupDatum(
            _results_,
            config.selectedGroupIDs
        );
        config.dataType = /flag|risk/.test(config.y)
            ? 'discrete'
            : 'continuous';
        if (defaults3.dataType === 'discrete')
            config.discreteUnit = Object.keys(_results_[0]).includes('GroupID')
                ? 'Metric'
                : 'Site';
        config.xLabel = coalesce(_config_?.xLabel, 'Snapshot Date');
        const discreteUnits =
            config.dataType === 'discrete'
                ? `${config.discreteUnit.replace(/y$/, 'ie')}s`
                : '';
        config.yLabel = coalesce(
            _config_?.yLabel,
            config.dataType === 'continuous'
                ? config[config.y]
                : /flag/.test(config.y) && /risk/.test(config.y)
                ? `Red or Amber ${discreteUnits}`
                : /flag/.test(config.y)
                ? `Red ${discreteUnits}`
                : /risk/.test(config.y)
                ? `Amber ${discreteUnits}`
                : ''
        );
        config.chartName = `Time Series of ${config.yLabel} by ${config.xLabel}`;
        if (
            config.y !== 'Score' &&
            !(config.y === 'Metric' && _intervals_ !== null)
        )
            delete config.thresholds;
        if (config.hoverCallbackWrapper === void 0)
            config.hoverCallbackWrapper = getCallbackWrapper(
                config.hoverCallback
            );
        if (config.clickCallbackWrapper === void 0)
            config.clickCallbackWrapper = getCallbackWrapper(
                config.clickCallback
            );
        return config;
    }

    // src/timeSeries/structureData/getLabels.js
    function getLabels(data, config) {
        const labels = [...new Set(data.map((d) => d[config.x]))];
        return labels;
    }

    // src/timeSeries/structureData/mutate.js
    function mutate4(
        _results_,
        config,
        _thresholds_,
        _intervals_,
        groupMetadata = null
    ) {
        const results = _results_
            .map((d) => {
                const datum2 = { ...d };
                if (groupMetadata !== null) {
                    const group2 = groupMetadata.get(d.GroupID);
                    if (group2 !== void 0) {
                        datum2.group = group2;
                        datum2.group.groupLabel = datum2.group.hasOwnProperty(
                            config.groupLabelKey
                        )
                            ? datum2.group[config.groupLabelKey]
                            : datum2.GroupID;
                    }
                }
                if ([void 0, null].includes(_intervals_) === false) {
                    const intervals2 = _intervals_.filter(
                        (interval2) =>
                            interval2.SnapshotDate === datum2.SnapshotDate
                    );
                    datum2.lowerCI = intervals2.find(
                        (interval2) => interval2.Param === 'LowCI'
                    )?.Value;
                    datum2.upperCI = intervals2.find(
                        (interval2) => interval2.Param === 'UpCI'
                    )?.Value;
                }
                return datum2;
            })
            .sort((a, b) => ascending(a[config.x], b[config.x]));
        const labels = getLabels(results, config);
        let thresholds2 = null;
        if (Array.isArray(_thresholds_) && config.variableThresholds) {
            thresholds2 = _thresholds_
                .filter((d) => labels.includes(d[config.x]))
                .map((d) => ({ ...d }))
                .sort((a, b) => ascending(a[config.x], b[config.x]));
        }
        let intervals = null;
        if (Array.isArray(_intervals_)) {
            intervals = _intervals_
                .filter((d) => labels.includes(d[config.x]))
                .map((d) => ({ ...d }))
                .sort((a, b) => ascending(a[config.x], b[config.x]));
        }
        identifyDuplicatePoints(results, config);
        return {
            results,
            labels,
            thresholds: thresholds2,
            intervals,
        };
    }

    // src/timeSeries/structureData/identityLine.js
    function identityLine(data, config, labels) {
        const aggregateData = rollup(
            data,
            (Group) => mean(Group, (d) => d[config.y]),
            (d) => d[config.x]
        );
        const color3 = '#666666';
        const backgroundColor4 = color2(color3);
        backgroundColor4.opacity = 1;
        const borderColor4 = color2(color3);
        borderColor4.opacity = 0.25;
        const dataset = {
            backgroundColor: (d) => {
                if (d.type === 'dataset') {
                    return backgroundColor4;
                } else {
                    return colorScheme_default.find((color4) =>
                        color4.Flag.includes(+d.raw.Flag)
                    ).color;
                }
            },
            borderColor: borderColor4,
            data: [...aggregateData].map(([key, value], i) => {
                const x = labels[i];
                const y = value;
                return {
                    ...data.find((d) => d[config.x] === x),
                    x,
                    y,
                };
            }),
            label: '',
            listenHover: true,
            listenClick: true,
            pointStyle: 'circle',
            purpose: 'aggregate',
            radius: 2.5,
            type: 'line',
        };
        return dataset;
    }

    // src/timeSeries/structureData/intervalLines.js
    function intervalLines(_intervals_, config, labels) {
        if (_intervals_ === null) return [null];
        const intervals = rollup(
            _intervals_.filter((d) => /ci/i.test(d.Param)),
            (Group) => +Group[0].Value,
            (d) => d.Param,
            (d) => d.SnapshotDate
        );
        const datasets = [...intervals].map(([key, value], i) => {
            return {
                borderColor: '#666',
                borderDash: [2],
                borderWidth: 1,
                data: [...value.values()],
                hoverRadius: 0,
                label: i === 0 ? 'Confidence Interval' : '',
                pointStyle: 'line',
                purpose: 'aggregate',
                radius: 0,
                type: 'line',
            };
        });
        return datasets;
    }

    // src/timeSeries/structureData/selectedGroupLine.js
    function selectedGroupLine(data, config, labels) {
        if (config.selectedGroupIDs.length === 0) return [null];
        const lineData = data
            .filter((d) => config.selectedGroupIDs.includes(d.GroupID))
            .map((d, i) => {
                const datum2 = { ...d };
                datum2.x = datum2[config.x];
                datum2.y = +datum2[config.y];
                return datum2;
            });
        const color3 = 'black';
        const backgroundColor4 = color2(color3);
        backgroundColor4.opacity = 0.5;
        const borderColor4 = color2(color3);
        borderColor4.opacity = 0.5;
        const datasets = config.selectedGroupIDs.map((GroupID) => {
            return {
                data: lineData.filter((d) => d.GroupID === GroupID),
                backgroundColor: function (d) {
                    if (d.element === void 0) {
                        return backgroundColor4;
                    }
                    const color4 = colorScheme_default.find((color5) =>
                        falsy_default.includes(d.raw.Flag)
                            ? color5.Flag.includes(d.raw?.Flag)
                            : color5.Flag.includes(+d.raw?.Flag)
                    );
                    color4.rgba.opacity = 0.75;
                    return color4.rgba + '';
                },
                borderColor: function (d) {
                    return d.type === 'data' ? 'black' : borderColor4;
                },
                label: '',
                pointStyle: 'circle',
                purpose: 'highlight',
                radius: 3,
                spanGaps: true,
                type: 'line',
            };
        });
        return datasets;
    }

    // src/timeSeries/structureData/flagAmber.js
    function flagAmber(data, config, labels) {
        const pointData = data
            .filter((d) => Math.abs(+d.Flag) === 1)
            .map((d) => {
                const datum2 = { ...d };
                datum2.x = datum2[config.x];
                datum2.y = +datum2[config.y];
                return datum2;
            });
        const color3 = colorScheme_default.find((color4) =>
            color4.Flag.some((Flag) => Math.abs(Flag) === 1)
        );
        color3.rgba.opacity = 0.5;
        const dataset = {
            borderColor: color3.color,
            backgroundColor: color3.rgba + '',
            data: pointData,
            label: '',
            listenHover: true,
            listenClick: true,
            pointStyle: 'circle',
            purpose: 'scatter',
            radius: 2,
            type: 'scatter',
        };
        return dataset;
    }

    // src/timeSeries/structureData/flagRed.js
    function flagRed(data, config, labels) {
        const pointData = data
            .filter((d) => Math.abs(+d.Flag) > 1)
            .map((d) => {
                const datum2 = { ...d };
                datum2.x = datum2[config.x];
                datum2.y = +datum2[config.y];
                return datum2;
            });
        const color3 = colorScheme_default.find((color4) =>
            color4.Flag.some((Flag) => Math.abs(Flag) > 1)
        );
        color3.rgba.opacity = 0.5;
        const dataset = {
            borderColor: color3.color,
            backgroundColor: color3.rgba + '',
            data: pointData,
            label: '',
            listenHover: true,
            listenClick: true,
            pointStyle: 'circle',
            purpose: 'scatter',
            radius: 2,
            type: 'scatter',
        };
        return dataset;
    }

    // src/timeSeries/structureData/distribution/boxplot.js
    function boxplot2(data, config) {
        const grouped = rollups(
            data,
            //.filter(d => +d.Flag === 0),
            (Group) => Group.map((d) => +d[config.y]),
            (d) => d.SnapshotDate
        );
        const dataset = {
            data: grouped.map((d) => d[1]),
            maxBarThickness: 7,
            maxWhiskerThickness: 0,
            meanRadius: /^n_/.test(config.y) ? 3 : 0,
            label: /Flag|at.risk/.test(config.y)
                ? `Distribution`
                : `${config.GroupLevel} Distribution`,
            outlierRadius: 0,
            ///^n_/.test(config.y) ? 2 : 0,
            pointRadius: 0,
            pointStyle: 'rect',
            purpose: 'distribution',
            radius: 0,
            type: 'boxplot',
        };
        return dataset;
    }

    // src/timeSeries/structureData/distribution/violin.js
    function violin(data, config) {
        const grouped = rollups(
            data,
            //.filter((d) => +d.Flag === 0),
            (Group) => Group.map((d) => +d[config.y]),
            (d) => d.SnapshotDate
        );
        const dataset = {
            data: grouped.map((d) => d[1]),
            label: /Flag|at.risk/.test(config.y)
                ? `Distribution`
                : `${config.GroupLevel} Distribution`,
            purpose: 'distribution',
            type: 'violin',
        };
        return dataset;
    }

    // src/timeSeries/structureData/distribution.js
    function distribution(data, config, labels) {
        if (!['boxplot', 'violin'].includes(config.distributionDisplay))
            return null;
        const dataset =
            config.distributionDisplay === 'boxplot'
                ? boxplot2(data, config, labels)
                : config.distributionDisplay === 'violin'
                ? violin(data, config, labels)
                : null;
        return dataset;
    }

    // src/timeSeries/structureData/getThresholdLines.js
    function getThresholdLines(_thresholds_, config, labels) {
        let thresholdData = [null];
        if (Array.isArray(_thresholds_) && config.variableThresholds) {
            const thresholds2 = [
                ...rollup(
                    _thresholds_
                        .filter((d) => d.Param === 'vThreshold')
                        .sort((a, b) => (a < b ? -1 : b < a ? 1 : 0)),
                    (Group) => {
                        const flags = checkThresholds({}, Group);
                        flags.forEach((Flag) => {
                            Flag.SnapshotDate = Group[0].SnapshotDate;
                            Flag.SnapshotDate = Group[0].SnapshotDate;
                            Flag.x = Flag.SnapshotDate;
                            Flag.y = Flag.Threshold;
                            Flag.color =
                                flags.length === 1
                                    ? colorScheme_default.amberRed
                                    : colorScheme_default.find((color3) =>
                                          color3.Flag.includes(Flag.Flag)
                                      );
                        });
                        return flags;
                    },
                    (d) => d.SnapshotDate
                ),
            ].flatMap((d) => d[1]);
            const latestSnapshotDate = max(labels);
            thresholdData = [
                ...rollup(
                    thresholds2,
                    (Group) => {
                        const dataset = {
                            adjustScaleRange: false,
                            borderColor: Group[0].color.color,
                            //function (d) {
                            //    return d.color.color;
                            //},
                            borderDash: [2],
                            borderWidth: 1,
                            data: Group,
                            hoverRadius: 0,
                            label: '',
                            purpose: 'annotation',
                            pointRadius: 0,
                            stepped: 'middle',
                            // 'before', 'middle', 'after'
                            type: 'line',
                        };
                        const snapshotDates = [
                            ...new Set(Group.map((d) => d[config.x])),
                        ];
                        const snapshotDate = max(snapshotDates);
                        if (snapshotDate < latestSnapshotDate) {
                            const Threshold = {
                                ...dataset.data.find(
                                    (d) => d[config.x] === snapshotDate
                                ),
                            };
                            Threshold[config.x] = latestSnapshotDate;
                            Threshold.x = latestSnapshotDate;
                            dataset.data.push(Threshold);
                        }
                        return dataset;
                    },
                    (d) => d.Flag
                ),
            ].map((d) => d[1]);
        }
        return thresholdData;
    }

    // src/timeSeries/structureData/aggregateLine.js
    function aggregateLine(data, config, labels) {
        const aggregateData = rollup(
            data,
            (Group) => mean(Group, (d) => d[config.y]),
            (d) => d[config.x]
        );
        const countsBySnapshot = rollup(
            data,
            (Group) => {
                const N = Group.length;
                return rollup(
                    Group,
                    (subgroup) => ({
                        n: subgroup.length,
                        N,
                        pct: Math.round((subgroup.length / N) * 100 * 10) / 10,
                    }),
                    (d) => d[config.y]
                );
            },
            (d) => d[config.x]
        );
        const color3 =
            /at.risk/.test(config.y) && /flagged/.test(config.y)
                ? colorScheme_default.amberRed.color
                : /at.risk/.test(config.y)
                ? colorScheme_default.find((color4) => color4.Flag.includes(1))
                      .color
                : /flagged/.test(config.y)
                ? colorScheme_default.find((color4) => color4.Flag.includes(2))
                      .color
                : '#828282';
        const backgroundColor4 = color2(color3);
        backgroundColor4.opacity = 1;
        const borderColor4 = color2('#828282');
        borderColor4.opacity = 0.25;
        const dataset = {
            backgroundColor: backgroundColor4,
            borderColor: borderColor4,
            data: [...aggregateData].map(([key, value], i) => {
                const x = labels[i];
                const y = value;
                const counts = [...countsBySnapshot.get(labels[i])];
                return {
                    //...data.find((d) => d[config.x] === x),
                    x,
                    y,
                    counts: counts
                        .map(([key1, value1]) => {
                            const countLookup = {
                                ...value1,
                            };
                            countLookup[config.y] = key1;
                            return countLookup;
                        })
                        .sort((a, b) => a[config.y] - b[config.y]),
                };
            }),
            label: '',
            pointStyle: 'circle',
            purpose: 'aggregate',
            radius: 2.5,
            type: 'line',
        };
        return dataset;
    }

    // src/timeSeries/structureData.js
    function structureData5(
        _results_,
        config,
        _thresholds_ = null,
        _intervals_ = null,
        _groupMetadata_ = null
    ) {
        const groupMetadata = structureGroupMetadata(_groupMetadata_, config);
        const {
            results,
            labels,
            thresholds: thresholds2,
            intervals,
        } = mutate4(
            _results_,
            config,
            _thresholds_,
            _intervals_,
            groupMetadata
        );
        let datasets = [];
        if (config.dataType !== 'discrete') {
            if (intervals !== null) {
                datasets = [
                    identityLine(results, config, labels),
                    ...intervalLines(intervals, config, labels),
                    {
                        type: 'scatter',
                        label: '',
                        pointStyle: 'line',
                        pointStyleWidth: 24,
                        boxWidth: 24,
                        backgroundColor: 'rgba(0,0,0,.5)',
                        borderColor: 'rgba(0,0,0,.25)',
                        borderWidth: 3,
                    },
                    ...colorScheme_default
                        .filter((color3) => color3.description !== 'No Flag')
                        .map((color3) => ({
                            type: 'bar',
                            label: color3.description,
                            backgroundColor: color3.color,
                            borderColor: color3.color,
                        })),
                    ...getThresholdLines(thresholds2, config, labels),
                ];
            } else {
                datasets = [
                    ...selectedGroupLine(results, config, labels),
                    {
                        type: 'scatter',
                        label:
                            config.selectedGroupIDs.length === 1
                                ? `${config.GroupLevel} ${config.selectedGroupIDs[0]}`
                                : '',
                        pointStyle: 'line',
                        pointStyleWidth: 24,
                        boxWidth: 24,
                        backgroundColor: 'rgba(0,0,0,.5)',
                        borderColor: 'rgba(0,0,0,.5)',
                        borderWidth: 3,
                    },
                    ...colorScheme_default.map((color3) => ({
                        type: 'bar',
                        label: !(
                            color3.description === 'Within Thresholds' &&
                            config.selectedGroupIDs.length === 0
                        )
                            ? color3.description
                            : '',
                        backgroundColor: color3.color,
                    })),
                    flagRed(results, config, labels),
                    flagAmber(results, config, labels),
                    distribution(results, config, labels),
                    ...getThresholdLines(thresholds2, config, labels),
                ];
            }
        } else if (config.dataType === 'discrete') {
            const color3 =
                config.yLabel === 'Red or Amber Metrics'
                    ? colorScheme_default.amberRed.color
                    : config.yLabel === 'Red Metrics'
                    ? colorScheme_default.find((color4) =>
                          /red/i.test(color4.description)
                      ).color
                    : config.yLabel === 'Amber Metrics'
                    ? colorScheme_default.find((color4) =>
                          /amber/i.test(color4.description)
                      ).color
                    : '#1890FF';
            datasets = [
                config.selectedGroupIDs.length > 0
                    ? {
                          ...selectedGroupLine(results, config, labels),
                          backgroundColor: color3,
                          borderColor: (d) => {
                              return d.raw !== void 0 ? 'black' : '#828282';
                          },
                      }
                    : null,
                {
                    type: 'scatter',
                    label:
                        config.selectedGroupIDs.length > 0
                            ? `${config.GroupLevel} ${config.selectedGroupIDs[0]}`
                            : '',
                    pointStyle: 'line',
                    pointStyleWidth: 24,
                    boxWidth: 24,
                    backgroundColor: 'rgba(0,0,0,.5)',
                    borderColor: 'rgba(0,0,0,.5)',
                    borderWidth: 3,
                },
                // legend item for selected Group ID line
                aggregateLine(results, config, labels),
                {
                    type: 'scatter',
                    label:
                        config.discreteUnit === 'Metric'
                            ? `${config.aggregateLabel} Average`
                            : '',
                    pointStyle: 'line',
                    pointStyleWidth: 24,
                    boxWidth: 24,
                    backgroundColor: 'rgba(0,0,0,.5)',
                    borderColor: 'rgba(0,0,0,.25)',
                    borderWidth: 3,
                },
                // legend item for aggregate line
            ];
        }
        datasets = datasets.filter((dataset) => dataset !== null);
        datasets.labels = labels;
        return datasets;
    }

    // src/timeSeries/getPlugins/annotations.js
    function annotations4(config) {
        let annotations5 = null;
        if (config.thresholds) {
            annotations5 = config.thresholds.map((x, i) => {
                const annotation2 = {
                    adjustScaleRange: config.GroupLevel === 'Study',
                    drawTime: 'beforeDatasetsDraw',
                    type: 'line',
                    yMin: x.Threshold,
                    yMax: x.Threshold,
                    borderColor:
                        config.GroupLevel === 'Study'
                            ? colorScheme_default.amberRed.color
                            : colorScheme_default.find((y) =>
                                  y.Flag.includes(+x.Flag)
                              ).color,
                    borderWidth: 1,
                    borderDash: [2],
                };
                if (
                    config.annotateThreshold === true &&
                    config.GroupLevel === 'Study'
                ) {
                    annotation2.label = {
                        rotation: 'auto',
                        position: Math.sign(+x.Flag) >= 0 ? 'end' : 'start',
                        color:
                            config.GroupLevel === 'Study'
                                ? colorScheme_default.amberRed.color
                                : colorScheme_default.find((y) =>
                                      y.Flag.includes(+x.Flag)
                                  ).color,
                        backgroundColor: 'white',
                        content: `QTL: ${
                            Math.round(+config.thresholds[0].Threshold * 1e3) /
                            (1e3).toString()
                        }`,
                        //    .replace(/^(.*\.\d{3})(\d+)$/, '$1')}`, //colorScheme.filter((y) => y.Flag.includes(+x.Flag))[0].description,
                        display: true,
                        //Math.sign(+x.Flag) === 1,
                        font: {
                            size: 12,
                        },
                    };
                }
                return annotation2;
            });
        }
        return annotations5;
    }

    // src/timeSeries/getPlugins/legend.js
    function legend4(config) {
        const legendOrder = colorScheme_default
            .sort((a, b) => a.order - b.order)
            .map((color3) => color3.description);
        legendOrder.unshift('Confidence Interval');
        legendOrder.unshift(`${config.aggregateLabel} Average`);
        legendOrder.unshift(`${config.GroupLevel} Distribution`);
        if (config.GroupLevel === 'Study')
            return {
                display: true,
                labels: {
                    boxHeight: 7,
                    filter: (legendItem, chartData) => {
                        return legendItem.text !== '';
                    },
                    generateLabels: (chart) =>
                        chart.data.datasets.map((dataset, i) => {
                            return {
                                datasetIndex: i,
                                fillStyle: dataset.backgroundColor,
                                lineWidth:
                                    dataset.label !== 'Study Average' ? 1 : 3,
                                lineDash: dataset.borderDash,
                                pointStyle: dataset.pointStyle,
                                strokeStyle: dataset.borderColor,
                                text: dataset.label,
                            };
                        }),
                    //pointStyleWidth: 3,
                    sort: function (a, b, chartData) {
                        const order =
                            legendOrder.indexOf(a.text) -
                            legendOrder.indexOf(b.text);
                        return /^Site (?!Distribution)/i.test(a.text)
                            ? 1
                            : /^Site (?!Distribution)/i.test(b.text)
                            ? -1
                            : order;
                    },
                    usePointStyle: true,
                },
                onClick: () => null,
                position: 'top',
            };
        else
            return {
                display: true,
                labels: {
                    boxHeight: 7,
                    lineWidth: 10,
                    borderWidth: 10,
                    filter: (legendItem, chartData) => {
                        return legendItem.text !== '';
                    },
                    //pointStyleWidth: 3,
                    sort: function (a, b, chartData) {
                        const order =
                            legendOrder.indexOf(a.text) -
                            legendOrder.indexOf(b.text);
                        return /^Site (?!Distribution)/i.test(a.text) &&
                            /^Site (?!Average)/i.test(a.text)
                            ? 1
                            : /^Site (?!Distribution)/i.test(b.text) &&
                              /^Site (?!Average)/i.test(b.text)
                            ? -1
                            : order;
                    },
                    usePointStyle: true,
                },
                onClick: () => null,
                position: 'top',
            };
    }

    // src/timeSeries/getPlugins/title.js
    function title3(config) {
        return {
            display: config.displayTitle,
            text: `${config.Metric} by ${config.GroupLevel}`,
        };
    }

    // src/util/formatResultTooltipContent.js
    function formatResultTooltipContent(data, config) {
        const datum2 = data.dataset.data[data.dataIndex];
        let content;
        if (
            ['bar', 'line', 'scatter'].includes(data.dataset.type) &&
            config.dataType !== 'discrete'
        ) {
            content =
                config.GroupLevel === 'Study'
                    ? [
                          `${config.yLabel}: ${
                              falsy_default.includes(datum2.Metric)
                                  ? '\u2014'
                                  : format('.3f')(datum2.Metric)
                          }`,
                          `Confidence Interval: (${format('.3f')(
                              datum2.lowerCI
                          )}, ${format('.3f')(datum2.upperCI)})`,
                          `${config.Numerator}: ${format(',')(
                              datum2.Numerator
                          )}`,
                          `${config.Denominator}: ${format(',')(
                              datum2.Denominator
                          )}`,
                      ]
                    : formatMetricTooltipLabel(datum2, config);
        } else if (['boxplot', 'violin'].includes(data.dataset.type)) {
            const stats = ['mean', 'min', 'q1', 'median', 'q3', 'max'].map(
                (stat) =>
                    `${stat.charAt(0).toUpperCase()}${stat.slice(1)}: ${format(
                        '.1f'
                    )(data.parsed[stat])}`
            );
            content = [...stats];
        } else if (config.dataType === 'discrete') {
            content =
                data.dataset.purpose === 'highlight'
                    ? [
                          `${datum2.n_flagged} Red ${config.discreteUnit}${
                              +datum2.n_flagged === 1 ? '' : 's'
                          }`,
                          `${datum2.n_at_risk} Amber ${config.discreteUnit}${
                              +datum2.n_at_risk === 1 ? '' : 's'
                          }`,
                      ]
                    : data.dataset.purpose === 'aggregate' &&
                      config.discreteUnit === 'Metric'
                    ? [
                          `${format('.1f')(datum2.y)} Average ${config.yLabel}`,
                          ...datum2.counts.map(
                              (d) =>
                                  `${d[config.y]} ${config.yLabel}: ${d.n}/${
                                      d.N
                                  } (${d.pct}%) ${config.GroupLevel}s`
                          ),
                      ]
                    : data.dataset.purpose === 'aggregate' &&
                      config.discreteUnit === 'Site'
                    ? `${format('.1f')(datum2.y)} ${config.yLabel}`
                    : null;
        }
        return content;
    }

    // src/timeSeries/getPlugins/tooltip.js
    function tooltip4(config) {
        const tooltipAesthetics = getTooltipAesthetics();
        return {
            callbacks: {
                label: (d) => {
                    const content = [
                        ...formatResultTooltipContent(d, config),
                        ...formatGroupTooltipLabel(d.raw.group, config),
                    ];
                    return d.raw.duplicate ? '' : content;
                },
                labelPointStyle: (data) => {
                    return {
                        pointStyle: ['line', 'scatter'].includes(
                            data.dataset.type
                        )
                            ? 'circle'
                            : 'rect',
                    };
                },
                title: (data) => {
                    if (data.length) {
                        if (data[0].dataset.purpose === 'distribution') {
                            return `${config.GroupLevel} Distribution on ${data[0].label}`;
                        } else if (data[0].dataset.purpose === 'aggregate') {
                            return `${config.GroupLevel} Summary on ${data[0].label}`;
                        } else {
                            let dataSorted = data;
                            try {
                                dataSorted = sortByGroupID(data, config);
                            } catch (err) {
                                console.log(err);
                                console.log(data);
                            }
                            const titles = dataSorted.map(function (d, i) {
                                let title5;
                                if (data.length === 1) {
                                    title5 = formatMetricTooltipTitle(
                                        d.raw,
                                        config
                                    );
                                } else {
                                    title5 =
                                        i === 0
                                            ? `${config.GroupLevel}s ${
                                                  d.dataset.data[d.dataIndex]
                                                      .GroupID
                                              }`
                                            : d.dataset.data[d.dataIndex]
                                                  .GroupID;
                                }
                                return title5;
                            });
                            const title4 =
                                titles.length <= 4
                                    ? `${titles.join(', ')} on ${data[0].label}`
                                    : `${titles.slice(0, 3).join(', ')} and [ ${
                                          titles.length - 3
                                      } ] more on ${data[0].label}`;
                            return title4;
                        }
                    }
                },
            },
            displayColors: true,
            //config.dataType !== 'discrete',
            filter: (data) => {
                const datum2 = data.dataset.data[data.dataIndex];
                const isAnnotation = data.dataset.purpose === 'annotation';
                const isObject2 = typeof datum2 === 'object';
                const isSelected = config.selectedGroupIDs.includes(
                    datum2.GroupID
                );
                const isScatter = data.dataset.type === 'scatter';
                return !isAnnotation && isObject2 && !(isSelected && isScatter);
            },
            ...tooltipAesthetics,
        };
    }

    // src/timeSeries/getPlugins.js
    function getPlugins4(config) {
        return {
            annotation: {
                annotations: annotations4(config),
            },
            legend: legend4(config),
            title: title3(config),
            tooltip: tooltip4(config),
        };
    }

    // src/timeSeries/getScales.js
    function getScales4(config) {
        const scales2 = getDefaultScales();
        scales2.x.title.text = config.xLabel;
        scales2.x.type = config.xType;
        scales2.y.title.text = config.yLabel;
        scales2.y.type = config.yType;
        return scales2;
    }

    // src/timeSeries/updateData.js
    function updateData4(
        chart,
        _results_,
        _config_,
        _thresholds_ = null,
        _intervals_ = null,
        _groupMetadata_ = null
    ) {
        const config = configure7(_config_, _results_, _thresholds_);
        const datasets = structureData5(
            _results_,
            config,
            _thresholds_,
            _intervals_,
            _groupMetadata_
        );
        chart.data = {
            datasets,
            labels: datasets.labels,
            config,
            _results_,
            _config_,
            _thresholds_,
            _intervals_,
            _groupMetadata_,
        };
        chart.options.scales = getScales4(config);
        chart.options.plugins = getPlugins4(config);
        chart.update();
    }

    // src/timeSeries/updateSelectedGroupIDs.js
    function updateSelectedGroupIDs(selectedGroupIDs) {
        if (!Array.isArray(selectedGroupIDs))
            selectedGroupIDs = [selectedGroupIDs];
        this.data.config.selectedGroupIDs = selectedGroupIDs.filter((GroupID) =>
            this.data._results_.map((d) => d.GroupID).includes(GroupID)
        );
        this.data.config.selectedGroupDatum = updateSelectedGroupDatum(
            this.data._results_,
            this.data.config.selectedGroupIDs
        );
        this.canvas.riskSignalSelected.data =
            this.data.config.selectedGroupDatum;
        this.data.datasets = structureData5(
            this.data._results_,
            this.data.config,
            this.data._thresholds_,
            null,
            this.data._groupMetadata_
        );
        this.update();
    }

    // src/timeSeries.js
    function timeSeries(
        _element_,
        _results_,
        _config_ = null,
        _thresholds_ = null,
        _intervals_ = null,
        _groupMetadata_ = null
    ) {
        checkInputs5(
            _results_,
            _config_,
            _thresholds_,
            _intervals_,
            _groupMetadata_
        );
        const config = configure7(
            _config_,
            _results_,
            _thresholds_,
            _intervals_
        );
        const canvas = addCanvas(_element_, config);
        const datasets = structureData5(
            _results_,
            config,
            _thresholds_,
            _intervals_,
            _groupMetadata_
        );
        const options = {
            animation: false,
            maintainAspectRatio: config.maintainAspectRatio,
            onClick,
            onHover,
            plugins: getPlugins4(config),
            responsive: true,
            scales: getScales4(config, _results_),
        };
        const chart = new auto_default(canvas, {
            data: {
                datasets,
                // required by Chart.js
                labels: datasets.labels,
                // required by Chart.js
                config,
                // inputs
                _results_,
                _config_,
                _thresholds_,
                _intervals_,
                _groupMetadata_,
            },
            options,
            plugins: [displayWhiteBackground()],
        });
        canvas.chart = chart;
        chart.helpers = {
            updateData: updateData4.bind(chart),
            updateSelectedGroupIDs: updateSelectedGroupIDs.bind(chart),
        };
        return chart;
    }

    // src/main.js
    Chart.register(
        annotation,
        BoxAndWiskers,
        BoxPlotController,
        CategoryScale,
        LinearScale,
        Violin,
        ViolinController
    );
    var gsmViz = {
        barChart,
        groupOverview,
        scatterPlot,
        sparkline,
        timeSeries,
    };
    var main_default = gsmViz;
    return __toCommonJS(main_exports);
})();
/*! Bundled license information:

chart.js/dist/chunks/helpers.segment.mjs:
  (*!
   * Chart.js v3.9.1
   * https://www.chartjs.org
   * (c) 2022 Chart.js Contributors
   * Released under the MIT License
   *)

chart.js/dist/chunks/helpers.segment.mjs:
  (*!
   * @kurkle/color v0.2.1
   * https://github.com/kurkle/color#readme
   * (c) 2022 Jukka Kurkela
   * Released under the MIT License
   *)

chart.js/dist/chart.mjs:
  (*!
   * Chart.js v3.9.1
   * https://www.chartjs.org
   * (c) 2022 Chart.js Contributors
   * Released under the MIT License
   *)

chart.js/dist/helpers.mjs:
  (*!
   * Chart.js v3.9.1
   * https://www.chartjs.org
   * (c) 2022 Chart.js Contributors
   * Released under the MIT License
   *)

chartjs-plugin-annotation/dist/chartjs-plugin-annotation.esm.js:
  (*!
  * chartjs-plugin-annotation v2.0.1
  * https://www.chartjs.org/chartjs-plugin-annotation/index
   * (c) 2022 chartjs-plugin-annotation Contributors
   * Released under the MIT License
   *)

chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.esm.js:
  (*!
   * chartjs-plugin-datalabels v2.1.0
   * https://chartjs-plugin-datalabels.netlify.app
   * (c) 2017-2022 chartjs-plugin-datalabels contributors
   * Released under the MIT license
   *)
*/
//# sourceMappingURL=index.js.map
</script>
<script>const clickCallback = function(el, input) {
    return function(d) {
        // Get chart instance, attached to canvas element.
        const canvas = el.querySelector('canvas');
        const instance = canvas.chart;

        instance.data.config.selectedGroupIDs = instance.data.config.selectedGroupIDs.includes(d.GroupID)
            ? 'None'
            : d.GroupID;

        // Update group select.
        const groupSelect = el.querySelector('.gsm-widget-control--group');
        if (groupSelect !== null)
            groupSelect.value = instance.data.config.selectedGroupIDs;

        // Set country select to 'None' if a group ID is selected.
        const countrySelect = el.querySelector('.gsm-widget-control--country');
        if (countrySelect !== null)
            countrySelect.value = "None";

        // Update barChart and scatterPlot.
        if (Object.keys(instance.helpers).includes('updateConfig')) {
            instance.helpers.updateConfig(
                instance,
                instance.data.config
            );
        }

        // Update timeSeries.
        else if (Object.keys(instance.helpers).includes('updateSelectedGroupIDs')) {
            if (instance.data.config.selectedGroupIDs === 'None')
                delete instance.data.config.selectedGroupIDs;
            instance.helpers.updateSelectedGroupIDs(
                instance.data.config.selectedGroupIDs
            );
        }

        // Update Shiny input if in Shiny environment.
        if (typeof Shiny !== 'undefined') {
            if (instance.data.config.selectedGroupIDs.length > 0) {
                Shiny.setInputValue(
                    input.strShinyGroupSelectID,
                    instance.data.config.selectedGroupIDs
                )
            }
        }

        // Dispatch [ riskSignalSelected ] event.
        instance.canvas.dispatchEvent(instance.canvas.riskSignalSelected);
    };
};
</script>
<style type="text/css">.html-widget.Widget_ScatterPlot,
.html-widget.Widget_BarChart,
.html-widget.Widget_TimeSeries {
}
.gsm-widget-controls {
}
.gsm-widget-control {
display: inline-block;
margin-right: 8px;
}
.gsm-widget-control--label {
margin-right: 4px;
}
.gsm-widget-control--select {
}
</style>
<script>/**
 * Adds a dropdown to highlight the selected group ID or set of group IDs in the chart.
 *
 * @param {Node} el - widget container, an element in the DOM
 * @param {Array} dfResults - analysis results for a single metric
 * @param {Object} lMetric - metric metadata
 * @param {Array} dfGroups - group metadata
 * @param {boolean} bAddGroupSelect - whether to add a group select dropdown
 *
 * @returns {Node} HTML select element
 */
const addWidgetControls = function(el, dfResults, lMetric, dfGroups, bAddGroupSelect) {
    if (!bAddGroupSelect)
        return {
            widgetControls: null,
            groupSelect: null,
            countrySelect: null
        };

    const instance = el.getElementsByTagName('canvas')[0].chart;

    // add container in which to place dropdown
    const widgetControls = document.createElement('div');
    widgetControls.classList.add('gsm-widget-controls');
    el.prepend(widgetControls);

    // add group select
    const groups = getGroups(dfResults);
    const groupSelect = addSelectControl(
        widgetControls,
        `Highlighted ${lMetric?.GroupLevel || 'Group'}`,
        groups
    );
    groupSelect.classList.add('gsm-widget-control--group');

    // add country select
    let countrySelect;
    if (dfGroups) {
        const countries = getCountries(dfGroups, groups);
        countrySelect = addSelectControl(
            widgetControls,
            'Country',
            countries
        );
        countrySelect.classList.add('gsm-widget-control--country');
    }

    // add event listener to group select
    groupSelect.addEventListener('change', event => {
        if (countrySelect)
            countrySelect.value = "None";
        instance.data.config.selectedGroupIDs = event.target.value;

        // scatterPlot and barChart
        if (Object.keys(instance.helpers).includes('updateConfig')) {
            instance.helpers.updateConfig(instance, instance.data.config, instance.data._thresholds_);
        }
        // timeSeries
        else if (Object.keys(instance.helpers).includes('updateSelectedGroupIDs')) {
            instance.helpers.updateSelectedGroupIDs(instance.data.config.selectedGroupIDs);
        }

        // Dispatch [ riskSignalSelected ] event.
        instance.canvas.dispatchEvent(instance.canvas.riskSignalSelected);
    });

    // add event listener to country select
    if (countrySelect)
        countrySelect.addEventListener('change', event => {
            groupSelect.value = "None";

            const countrySubset = dfGroups
                .filter(
                    d => d.Param === 'Country'
                )
                .filter(
                    d => d.Value === event.target.value
                )
                .map(
                    d => d.GroupID
                );

            instance.data.config.selectedGroupIDs = countrySubset;

            // scatterPlot and barChart
            if (Object.keys(instance.helpers).includes('updateConfig')) {
                instance.helpers.updateConfig(instance, instance.data.config);
            }
            // timeSeries
            else if (Object.keys(instance.helpers).includes('updateSelectedGroupIDs')) {
                instance.helpers.updateSelectedGroupIDs(instance.data.config.selectedGroupIDs);
            }
        });

    return {
        widgetControls,
        groupSelect,
        countrySelect
    };
}
</script>
<script>/**
 * Add a select control to the widget controls
 *
 * @param {HTMLElement} widgetControls - the container for the widget controls
 * @param {String} label - the label for the control
 * @param {Array} values - the values to populate the control with
 *
 * @returns {Node} HTML select element
 */
const addSelectControl = function(widgetControls, label, values, addNone = true, defaultValue = 'None') {
    // add control container
    const selectContainer = document.createElement('div');
    selectContainer.classList.add('gsm-widget-control');
    widgetControls.appendChild(selectContainer);

    // add control label
    const selectLabel = document.createElement('span');
    selectLabel.classList.add("gsm-widget-control--label")
    selectLabel.innerHTML = label;
    selectContainer.appendChild(selectLabel)

    // add control
    const select = document.createElement('select');
    select.classList.add("gsm-widget-control--select")
    selectContainer.appendChild(select);

    // add default option
    if (addNone) {
        const noneOption = document.createElement('option');
        noneOption.innerHTML = defaultValue;
        select.appendChild(noneOption);
    }

    // add data-driven values
    for (const value of values) {
        const option = document.createElement('option');
        option.innerHTML = value;
        select.appendChild(option);
    }

    // set default value
    select.value = defaultValue;

    return select;
}
</script>
<script>/**
 * Get the unique group IDs from the analysis results of a single metric.
 *
 * @param {Array} dfResults - analysis results for a single metric
 *
 * @returns {Array} unique set of group IDs
 */
const getGroups = function(dfResults) {
    let groups = [...new Set(dfResults.map(d => d.GroupID))];
    const numericgroups = groups.every(group => /^\d+$/.test(group));
    groups.sort((a,b) => {
        return numericgroups
            ? a - b
            : a < b ? -1
            : b < a ?  1 : 0;
    });

    return groups;
}
</script>
<script>/**
 * Define unique set of country values.
 *
 * @param {Array} dfGroups - group metadata
 * @param {Array} groups - group IDs present in analysis results
 *
 * @returns {Array} unique countries
 */
const getCountries = function(dfGroups, groups) {
    const countries = [...new Set(
        dfGroups
            .filter(
                d => d.Param === 'Country'
            )
            .filter(
                d => groups.includes(d.GroupID)
            )
            .map(
                d => d.Value
            )
    )].sort((a,b) => a < b ? -1 : b < a ? 1 : 0);

    return countries;
};
</script>
<script>/**
 * Add a dropdown that allows the user to select the outcome to display on the y-axis of the chart.
 *
 * @param {HTMLElement} el - The chart element.
 * @param {Object} dfResults - Analysis results data.
 * @param {Object} lMetric - Metric-level metadata.
 * @param {Object} dfGroups - Group-level metadata.
 * @param {string} strOutcome - The initial outcome to display on the y-axis.
 */

const addOutcomeSelect = function(widgetControls, dfResults, lMetric, dfGroups, strOutcome) {
    const outcomeSelect = addSelectControl(
        widgetControls,
        'Outcome (y-axis)',
        [
            'Score',
            'Metric',
            'Numerator'
        ],
        false, // disable "None" option
        strOutcome // set initial selectection
    );

    // add event listener to outcome select
    const instance = widgetControls.parentNode.getElementsByTagName('canvas')[0].chart;
    outcomeSelect.addEventListener('change', event => {
        // Update y-axis outcome and label.
        instance.data.config.y = event.target.value;
        instance.data.config.yLabel = lMetric[ event.target.value ];

        // barChart
        if (Object.keys(instance.helpers).includes('updateConfig')) {
            instance.helpers.updateData(
                instance,
                dfResults,
                instance.data.config,
                instance.data._thresholds_,
                dfGroups
            );
        }
        // timeSeries
        else if (Object.keys(instance.helpers).includes('updateSelectedGroupIDs')) {
            instance.helpers.updateData(
                instance,
                dfResults,
                instance.data.config,
                instance.data._thresholds_,
                null,
                dfGroups
            )
        }
    });

    return outcomeSelect;
}

</script>
<script>HTMLWidgets.widget({
    name: 'Widget_BarChart',
    type: 'output',
    factory: function(el, width, height) {
        return {
            renderValue: function(input) {
                if (input.bDebug)
                    console.log(input);

                // Coerce `input.lChartConfig` to an object if it is not already.
                if (Object.prototype.toString.call(input.lChartConfig) !== '[object Object]') {
                    input.lChartConfig = {};
                };

                // Assign a unique ID to the element.
                el.id = `barChart--${input.lChartConfig.MetricID}_${input.strOutcome}`;

                // Add click event listener to chart.
                input.lChartConfig.clickCallback = clickCallback(el, input);

                // Generate bar chart.
                const instance = gsmViz.default.barChart(
                    el,
                    input.dfResults,
                    input.lChartConfig,
                    input.vThreshold,
                    input.dfGroups
                );

                // Add dropdowns that highlight group ID(s).
                const { widgetControls } = addWidgetControls(
                    el,
                    input.dfResults,
                    input.lChartConfig,
                    input.dfGroups,
                    input.bAddGroupSelect
                );

                // Add a dropdown that changes the outcome variable.
                const outcomeSelect = addOutcomeSelect(
                    widgetControls,
                    input.dfResults,
                    input.lChartConfig,
                    input.dfGroups,
                    input.strOutcome
                );
            },
            resize: function(width, height) {
            }
        };
    }
});
</script>
<script>HTMLWidgets.widget({
    name: 'Widget_ScatterPlot',
    type: 'output',
    factory: function(el, width, height) {
        return {
            renderValue: function(input) {
                if (input.bDebug)
                    console.log(input);

                // Coerce `input.lChartConfig` to an object if it is not already.
                if (Object.prototype.toString.call(input.lChartConfig) !== '[object Object]') {
                    input.lChartConfig = {};
                };

                // Assign a unique ID to the element.
                el.id = `scatterPlot--${input.lChartConfig.MetricID}`;

                // Add click event callback to chart.
                input.lChartConfig.clickCallback = clickCallback(el, input);

                // Generate scatter plot.
                const instance = gsmViz.default.scatterPlot(
                    el,
                    input.dfResults,
                    input.lChartConfig,
                    input.dfBounds,
                    input.dfGroups
                );

                // Add dropdowns that highlight group ID(s).
                addWidgetControls(
                    el,
                    input.dfResults,
                    input.lChartConfig,
                    input.dfGroups,
                    input.bAddGroupSelect,
                    false
                );

                // Add a footnote below the scatter plot.
                const footnote = document.createElement('div'); // Create a div for the footnote.
                footnote.style.fontSize = '10px'; // Set a smaller font size for the footnote.
                footnote.style.color = '#555'; // Use a lighter color for the footnote text.

                // Set the content of the footnote from the input.
                footnote.innerHTML = input.strFootnote; // Use the footnote passed from R.

                // Append the footnote div to the element containing the scatter plot.
                el.appendChild(footnote);
            },
            resize: function(width, height) {
            }
        };
    }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type="text/css">
.main-container {
max-width: 940px;
margin-left: auto;
margin-right: auto;
}
img {
max-width:100%;
}
.tabbed-pane {
padding-top: 12px;
}
.html-widget {
margin-bottom: 20px;
}
button.code-folding-btn:focus {
outline: none;
}
summary {
display: list-item;
}
details > summary > p:only-child {
display: inline;
}
pre code {
padding: 0;
}
</style>



<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
display: inline-table;
max-height: 500px;
min-height: 44px;
overflow-y: auto;
border: 1px solid #ddd;
border-radius: 4px;
}
.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
content: "\e259";
font-family: 'Glyphicons Halflings';
display: inline-block;
padding: 10px;
border-right: 1px solid #ddd;
}
.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
content: "\e258";
font-family: 'Glyphicons Halflings';
border: none;
}
.tabset-dropdown > .nav-tabs > li.active {
display: block;
}
.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
border: none;
display: inline-block;
border-radius: 4px;
background-color: transparent;
}
.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
display: block;
float: none;
}
.tabset-dropdown > .nav-tabs > li {
display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">
#TOC {
margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
position: relative;
width: 100%;
}
}
@media print {
.toc-content {

float: right;
}
}
.toc-content {
padding-left: 30px;
padding-right: 40px;
}
div.main-container {
max-width: 1200px;
}
div.tocify {
width: 20%;
max-width: 260px;
max-height: 85%;
}
@media (min-width: 768px) and (max-width: 991px) {
div.tocify {
width: 25%;
}
}
@media (max-width: 767px) {
div.tocify {
width: 100%;
max-width: none;
}
}
.tocify ul, .tocify li {
line-height: 20px;
}
.tocify-subheader .tocify-item {
font-size: 0.90em;
}
.tocify .list-group-item {
border-radius: 0px;
}
</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Adverse Event Workflow Examples</h1>
<h4 class="date">2025-11-05 07:44:03 EST</h4>

</div>


<pre class="r"><code>library(gsm.core)
library(gsm.mapping)
library(yaml)
devtools::load_all()</code></pre>
<pre><code>#&gt;  Loading gsm.kri</code></pre>
<div id="example-2.1---configurable-adverse-event-workflow" class="section level2">
<h2>Example 2.1 - Configurable Adverse Event Workflow</h2>
<p>This example demonstrates how to create a configurable workflow using
YAML to define the analysis pipeline.</p>
<pre class="r"><code># Define YAML workflow
AE_workflow &lt;- yaml::read_yaml(text=
&#39;meta:
  Type: Analysis
  ID: kri0001
  GroupLevel: Site
  Abbreviation: AE
  Metric: Adverse Event Rate
  Numerator: Adverse Events
  Denominator: Days on Study
  Model: Normal Approximation
  Score: Adjusted Z-Score
  AnalysisType: rate
  Threshold: -2,-1,2,3
  AccrualThreshold: 30
  AccrualMetric: Denominator
spec:
  Mapped_AE:
    subjid:
      type: character
  Mapped_SUBJ:
    subjid:
      type: character
    invid:
      type: character
    timeonstudy:
      type: integer
steps:
  - output: vThreshold
    name: ParseThreshold
    params:
      strThreshold: Threshold
  - output: Analysis_Input
    name: Input_Rate
    params:
      dfSubjects: Mapped_SUBJ
      dfNumerator: Mapped_AE
      dfDenominator: Mapped_SUBJ
      strSubjectCol: subjid
      strGroupCol: invid
      strGroupLevel: GroupLevel
      strNumeratorMethod: Count
      strDenominatorMethod: Sum
      strDenominatorCol: timeonstudy
  - output: Analysis_Transformed
    name: Transform_Rate
    params:
      dfInput: Analysis_Input
  - output: Analysis_Analyzed
    name: Analyze_NormalApprox
    params:
      dfTransformed: Analysis_Transformed
      strType: AnalysisType
  - output: Analysis_Flagged
    name: Flag
    params:
      dfAnalyzed: Analysis_Analyzed
      vThreshold: vThreshold
      nAccrualThreshold: AccrualThreshold
      strAccrualMetric: AccrualMetric
  - output: Analysis_Summary
    name: Summarize
    params:
      dfFlagged: Analysis_Flagged
  - output: lAnalysis
    name: list
    params:
      ID: ID
      Analysis_Input: Analysis_Input
      Analysis_Transformed: Analysis_Transformed
      Analysis_Analyzed: Analysis_Analyzed
      Analysis_Flagged: Analysis_Flagged
      Analysis_Summary: Analysis_Summary
&#39;)

# Grab simulated data
dm &lt;- gsm.core::lSource$Raw_SUBJ
ae &lt;- gsm.core::lSource$Raw_AE

# Run the workflow
AE_data &lt;-list(
  Mapped_SUBJ= dm,
  Mapped_AE= ae
)
AE_KRI &lt;- RunWorkflow(lWorkflow = AE_workflow, lData = AE_data)</code></pre>
<pre><code>#&gt; </code></pre>
<pre><code>#&gt;  Initializing `Analysis_kri0001` Workflow </code></pre>
<pre><code>#&gt; </code></pre>
<pre><code>#&gt;  Checking data against spec</code></pre>
<pre><code>#&gt;  All 2 data.frame(s) in the spec are present in the data: Mapped_AE, Mapped_SUBJ</code></pre>
<pre><code>#&gt;  All specified columns in Mapped_AE are in the expected format</code></pre>
<pre><code>#&gt;  All specified columns in Mapped_SUBJ are in the expected format</code></pre>
<pre><code>#&gt;  All 4 specified column(s) in the spec are present in the data: Mapped_AE$subjid, Mapped_SUBJ$subjid, Mapped_SUBJ$invid, Mapped_SUBJ$timeonstudy</code></pre>
<pre><code>#&gt; </code></pre>
<pre><code>#&gt;  Workflow Step 1 of 7: `ParseThreshold` </code></pre>
<pre><code>#&gt; </code></pre>
<pre><code>#&gt;  Evaluating 1 parameter(s) for `ParseThreshold`</code></pre>
<pre><code>#&gt;  strThreshold = Threshold: Passing lMeta$Threshold.</code></pre>
<pre><code>#&gt; </code></pre>
<pre><code>#&gt;  Calling `ParseThreshold`</code></pre>
<pre><code>#&gt; Parsed -2,-1,2,3 to numeric vector: -2, -1, 2, 3
#&gt; 
#&gt; 
#&gt;  double of length 4 saved as `lData$vThreshold`. 
#&gt; 
#&gt; 
#&gt; 
#&gt;  Workflow Step 2 of 7: `Input_Rate` 
#&gt; 
#&gt; 
#&gt; 
#&gt;  Evaluating 9 parameter(s) for `Input_Rate` 
#&gt; 
#&gt;  dfSubjects = Mapped_SUBJ: Passing lData$Mapped_SUBJ.
#&gt; 
#&gt;  dfNumerator = Mapped_AE: Passing lData$Mapped_AE.
#&gt; 
#&gt;  dfDenominator = Mapped_SUBJ: Passing lData$Mapped_SUBJ.
#&gt; 
#&gt;  strSubjectCol = subjid: No matching data found. Passing &#39;subjid&#39; as a string.
#&gt; 
#&gt;  strGroupCol = invid: No matching data found. Passing &#39;invid&#39; as a string.
#&gt; 
#&gt;  strGroupLevel = GroupLevel: Passing lMeta$GroupLevel.
#&gt; 
#&gt;  strNumeratorMethod = Count: No matching data found. Passing &#39;Count&#39; as a string.
#&gt; 
#&gt;  strDenominatorMethod = Sum: No matching data found. Passing &#39;Sum&#39; as a string.
#&gt; 
#&gt;  strDenominatorCol = timeonstudy: No matching data found. Passing &#39;timeonstudy&#39; as a string.
#&gt; 
#&gt; 
#&gt; 
#&gt;  Calling `Input_Rate` 
#&gt; 
#&gt; 
#&gt; 
#&gt;  1000x6 data.frame saved as `lData$Analysis_Input`. 
#&gt; 
#&gt; 
#&gt; 
#&gt;  Workflow Step 3 of 7: `Transform_Rate` 
#&gt; 
#&gt; 
#&gt; 
#&gt;  Evaluating 1 parameter(s) for `Transform_Rate` 
#&gt; 
#&gt;  dfInput = Analysis_Input: Passing lData$Analysis_Input.
#&gt; 
#&gt; 
#&gt; 
#&gt;  Calling `Transform_Rate`</code></pre>
<pre><code>#&gt; Warning: 4 values of [ GroupID ] with a [ Denominator ] value of 0 removed.</code></pre>
<pre><code>#&gt; 
#&gt;  145x5 data.frame saved as `lData$Analysis_Transformed`. 
#&gt; 
#&gt;  Workflow Step 4 of 7: `Analyze_NormalApprox` 
#&gt; 
#&gt;  Evaluating 2 parameter(s) for `Analyze_NormalApprox` 
#&gt;  dfTransformed = Analysis_Transformed: Passing lData$Analysis_Transformed.
#&gt;  strType = AnalysisType: Passing lMeta$AnalysisType.
#&gt; 
#&gt;  Calling `Analyze_NormalApprox` 
#&gt; `OverallMetric`, `Factor`, and `Score` columns created from normal approximation.
#&gt;  145x8 data.frame saved as `lData$Analysis_Analyzed`. 
#&gt; 
#&gt;  Workflow Step 5 of 7: `Flag` 
#&gt; 
#&gt;  Evaluating 4 parameter(s) for `Flag` 
#&gt;  dfAnalyzed = Analysis_Analyzed: Passing lData$Analysis_Analyzed.
#&gt;  vThreshold = vThreshold: Passing lData$vThreshold.
#&gt;  nAccrualThreshold = AccrualThreshold: Passing lMeta$AccrualThreshold.
#&gt;  strAccrualMetric = AccrualMetric: Passing lMeta$AccrualMetric.
#&gt; 
#&gt;  Calling `Flag` 
#&gt;  20 Group(s) have insufficient sample size due to KRI denominator less than 30: 0X7147, 0X5182, 0X5579, 0X4185, 0X3556, 0X2508, 0X3857, 0X1800, 0X9364, 0X8592, 0X5503, 0X8547, 0X155, 0X439, 0X6041, 0X3565, 0X3777, 0X283, 0X3214, 0X7844
#&gt; These group(s) will not have KRI score and flag summarized.
#&gt;  Sorted dfFlagged using custom Flag order: 2.Sorted dfFlagged using custom Flag order: -2.Sorted dfFlagged using custom Flag order: 1.Sorted dfFlagged using custom Flag order: -1.Sorted dfFlagged using custom Flag order: 0.
#&gt; 
#&gt;  145x9 data.frame saved as `lData$Analysis_Flagged`. 
#&gt; 
#&gt;  Workflow Step 6 of 7: `Summarize` 
#&gt; 
#&gt;  Evaluating 1 parameter(s) for `Summarize` 
#&gt;  dfFlagged = Analysis_Flagged: Passing lData$Analysis_Flagged.
#&gt; 
#&gt;  Calling `Summarize` 
#&gt; 
#&gt;  145x7 data.frame saved as `lData$Analysis_Summary`. 
#&gt; 
#&gt;  Workflow Step 7 of 7: `list` 
#&gt; 
#&gt;  Evaluating 6 parameter(s) for `list` 
#&gt;  ID = ID: Passing lMeta$ID.
#&gt;  Analysis_Input = Analysis_Input: Passing lData$Analysis_Input.
#&gt;  Analysis_Transformed = Analysis_Transformed: Passing lData$Analysis_Transformed.
#&gt;  Analysis_Analyzed = Analysis_Analyzed: Passing lData$Analysis_Analyzed.
#&gt;  Analysis_Flagged = Analysis_Flagged: Passing lData$Analysis_Flagged.
#&gt;  Analysis_Summary = Analysis_Summary: Passing lData$Analysis_Summary.
#&gt; 
#&gt;  Calling `list` 
#&gt; 
#&gt;  list of length 6 saved as `lData$lAnalysis`. 
#&gt; 
#&gt;  Returning results from final step: list of length 6`. 
#&gt; 
#&gt;  Completed `Analysis_kri0001` Workflow </code></pre>
<pre class="r"><code># Create labels for visualizations
labels &lt;- list(
  Metric= &quot;Adverse Event Rate&quot;,
  Numerator= &quot;Adverse Events&quot;,
  Denominator= &quot;Days on Study&quot;
)</code></pre>
<div id="visualizations" class="section level3">
<h3>Visualizations</h3>
<p>We can create various visualizations from the workflow results:</p>
<div id="bar-chart---summary" class="section level4">
<h4>Bar Chart - Summary</h4>
<pre class="r"><code>Widget_BarChart(dfResults = AE_KRI$Analysis_Summary)</code></pre>
<div class="Widget_BarChart html-widget html-fill-item" id="htmlwidget-e33c5b00ca8288780255" style="width:672px;height:480px;"></div>
<script type="application/json" data-for="htmlwidget-e33c5b00ca8288780255">{"x":{"dfResults":[{"GroupID":"0X8351","GroupLevel":"Site","Numerator":86,"Denominator":448,"Metric":0.192,"Score":3.5357,"Flag":2},{"GroupID":"0X4323","GroupLevel":"Site","Numerator":47,"Denominator":675,"Metric":0.0696,"Score":-2.0907,"Flag":-2},{"GroupID":"0X6405","GroupLevel":"Site","Numerator":34,"Denominator":521,"Metric":0.0653,"Score":-2.0386,"Flag":-2},{"GroupID":"0X414","GroupLevel":"Site","Numerator":17,"Denominator":68,"Metric":0.25,"Score":2.3458,"Flag":1},{"GroupID":"0X8764","GroupLevel":"Site","Numerator":28,"Denominator":120,"Metric":0.2333,"Score":2.7468,"Flag":1},{"GroupID":"0X4874","GroupLevel":"Site","Numerator":33,"Denominator":173,"Metric":0.1908,"Score":2.1649,"Flag":1},{"GroupID":"0X1257","GroupLevel":"Site","Numerator":31,"Denominator":163,"Metric":0.1902,"Score":2.0867,"Flag":1},{"GroupID":"0X101","GroupLevel":"Site","Numerator":36,"Denominator":197,"Metric":0.1827,"Score":2.0827,"Flag":1},{"GroupID":"0X9737","GroupLevel":"Site","Numerator":39,"Denominator":467,"Metric":0.0835,"Score":-1.132,"Flag":-1},{"GroupID":"0X4629","GroupLevel":"Site","Numerator":35,"Denominator":435,"Metric":0.0805,"Score":-1.2213,"Flag":-1},{"GroupID":"0X759","GroupLevel":"Site","Numerator":42,"Denominator":523,"Metric":0.0803,"Score":-1.3463,"Flag":-1},{"GroupID":"0X8625","GroupLevel":"Site","Numerator":36,"Denominator":481,"Metric":0.0748,"Score":-1.5335,"Flag":-1},{"GroupID":"0X9360","GroupLevel":"Site","Numerator":32,"Denominator":430,"Metric":0.0744,"Score":-1.4677,"Flag":-1},{"GroupID":"0X7228","GroupLevel":"Site","Numerator":15,"Denominator":225,"Metric":0.0667,"Score":-1.297,"Flag":-1},{"GroupID":"0X1137","GroupLevel":"Site","Numerator":13,"Denominator":196,"Metric":0.0663,"Score":-1.2201,"Flag":-1},{"GroupID":"0X8382","GroupLevel":"Site","Numerator":8,"Denominator":125,"Metric":0.064,"Score":-1.027,"Flag":-1},{"GroupID":"0X9862","GroupLevel":"Site","Numerator":10,"Denominator":157,"Metric":0.0637,"Score":-1.1588,"Flag":-1},{"GroupID":"0X3585","GroupLevel":"Site","Numerator":17,"Denominator":270,"Metric":0.063,"Score":-1.5439,"Flag":-1},{"GroupID":"0X4324","GroupLevel":"Site","Numerator":7,"Denominator":120,"Metric":0.0583,"Score":-1.1319,"Flag":-1},{"GroupID":"0X1548","GroupLevel":"Site","Numerator":5,"Denominator":93,"Metric":0.0538,"Score":-1.0856,"Flag":-1},{"GroupID":"0X5362","GroupLevel":"Site","Numerator":5,"Denominator":110,"Metric":0.0455,"Score":-1.357,"Flag":-1},{"GroupID":"0X5137","GroupLevel":"Site","Numerator":1,"Denominator":39,"Metric":0.0256,"Score":-1.0583,"Flag":-1},{"GroupID":"0X5048","GroupLevel":"Site","Numerator":0,"Denominator":42,"Metric":0,"Score":-1.4345,"Flag":-1},{"GroupID":"0X3197","GroupLevel":"Site","Numerator":13,"Denominator":57,"Metric":0.2281,"Score":1.8127,"Flag":0},{"GroupID":"0X9520","GroupLevel":"Site","Numerator":20,"Denominator":97,"Metric":0.2062,"Score":1.9286,"Flag":0},{"GroupID":"0X3736","GroupLevel":"Site","Numerator":19,"Denominator":102,"Metric":0.1863,"Score":1.5708,"Flag":0},{"GroupID":"0X6367","GroupLevel":"Site","Numerator":8,"Denominator":44,"Metric":0.1818,"Score":0.9719,"Flag":0},{"GroupID":"0X8551","GroupLevel":"Site","Numerator":18,"Denominator":105,"Metric":0.1714,"Score":1.286,"Flag":0},{"GroupID":"0X7983","GroupLevel":"Site","Numerator":41,"Denominator":243,"Metric":0.1687,"Score":1.871,"Flag":0},{"GroupID":"0X567","GroupLevel":"Site","Numerator":15,"Denominator":90,"Metric":0.1667,"Score":1.0992,"Flag":0},{"GroupID":"0X3909","GroupLevel":"Site","Numerator":36,"Denominator":216,"Metric":0.1667,"Score":1.7028,"Flag":0},{"GroupID":"0X2397","GroupLevel":"Site","Numerator":17,"Denominator":105,"Metric":0.1619,"Score":1.0885,"Flag":0},{"GroupID":"0X8823","GroupLevel":"Site","Numerator":18,"Denominator":112,"Metric":0.1607,"Score":1.0987,"Flag":0},{"GroupID":"0X3639","GroupLevel":"Site","Numerator":7,"Denominator":44,"Metric":0.1591,"Score":0.6669,"Flag":0},{"GroupID":"0X7789","GroupLevel":"Site","Numerator":7,"Denominator":44,"Metric":0.1591,"Score":0.6669,"Flag":0},{"GroupID":"0X8669","GroupLevel":"Site","Numerator":10,"Denominator":64,"Metric":0.1562,"Score":0.7583,"Flag":0},{"GroupID":"0X1982","GroupLevel":"Site","Numerator":25,"Denominator":164,"Metric":0.1524,"Score":1.1151,"Flag":0},{"GroupID":"0X9580","GroupLevel":"Site","Numerator":36,"Denominator":238,"Metric":0.1513,"Score":1.3066,"Flag":0},{"GroupID":"0X6603","GroupLevel":"Site","Numerator":36,"Denominator":239,"Metric":0.1506,"Score":1.2895,"Flag":0},{"GroupID":"0X5384","GroupLevel":"Site","Numerator":58,"Denominator":399,"Metric":0.1454,"Score":1.4534,"Flag":0},{"GroupID":"0X5782","GroupLevel":"Site","Numerator":9,"Denominator":62,"Metric":0.1452,"Score":0.5697,"Flag":0},{"GroupID":"0X9381","GroupLevel":"Site","Numerator":8,"Denominator":56,"Metric":0.1429,"Score":0.5065,"Flag":0},{"GroupID":"0X180","GroupLevel":"Site","Numerator":39,"Denominator":281,"Metric":0.1388,"Score":0.9967,"Flag":0},{"GroupID":"0X2376","GroupLevel":"Site","Numerator":17,"Denominator":123,"Metric":0.1382,"Score":0.6465,"Flag":0},{"GroupID":"0X3252","GroupLevel":"Site","Numerator":6,"Denominator":44,"Metric":0.1364,"Score":0.3618,"Flag":0},{"GroupID":"0X6521","GroupLevel":"Site","Numerator":7,"Denominator":52,"Metric":0.1346,"Score":0.3679,"Flag":0},{"GroupID":"0X3289","GroupLevel":"Site","Numerator":37,"Denominator":275,"Metric":0.1345,"Score":0.8436,"Flag":0},{"GroupID":"0X5033","GroupLevel":"Site","Numerator":28,"Denominator":210,"Metric":0.1333,"Score":0.7017,"Flag":0},{"GroupID":"0X7011","GroupLevel":"Site","Numerator":55,"Denominator":416,"Metric":0.1322,"Score":0.9413,"Flag":0},{"GroupID":"0X7513","GroupLevel":"Site","Numerator":25,"Denominator":191,"Metric":0.1309,"Score":0.6009,"Flag":0},{"GroupID":"0X905","GroupLevel":"Site","Numerator":6,"Denominator":46,"Metric":0.1304,"Score":0.2886,"Flag":0},{"GroupID":"0X2574","GroupLevel":"Site","Numerator":21,"Denominator":161,"Metric":0.1304,"Score":0.54,"Flag":0},{"GroupID":"0X6301","GroupLevel":"Site","Numerator":11,"Denominator":86,"Metric":0.1279,"Score":0.3472,"Flag":0},{"GroupID":"0X1839","GroupLevel":"Site","Numerator":24,"Denominator":190,"Metric":0.1263,"Score":0.4717,"Flag":0},{"GroupID":"0X5787","GroupLevel":"Site","Numerator":23,"Denominator":185,"Metric":0.1243,"Score":0.4107,"Flag":0},{"GroupID":"0X2002","GroupLevel":"Site","Numerator":9,"Denominator":73,"Metric":0.1233,"Score":0.24,"Flag":0},{"GroupID":"0X3090","GroupLevel":"Site","Numerator":26,"Denominator":213,"Metric":0.1221,"Score":0.3739,"Flag":0},{"GroupID":"0X2323","GroupLevel":"Site","Numerator":36,"Denominator":295,"Metric":0.122,"Score":0.439,"Flag":0},{"GroupID":"0X2513","GroupLevel":"Site","Numerator":5,"Denominator":41,"Metric":0.122,"Score":0.1626,"Flag":0},{"GroupID":"0X5895","GroupLevel":"Site","Numerator":64,"Denominator":526,"Metric":0.1217,"Score":0.5694,"Flag":0},{"GroupID":"0X6384","GroupLevel":"Site","Numerator":22,"Denominator":184,"Metric":0.1196,"Score":0.2789,"Flag":0},{"GroupID":"0X7656","GroupLevel":"Site","Numerator":12,"Denominator":101,"Metric":0.1188,"Score":0.1913,"Flag":0},{"GroupID":"0X213","GroupLevel":"Site","Numerator":88,"Denominator":742,"Metric":0.1186,"Score":0.5069,"Flag":0},{"GroupID":"0X7938","GroupLevel":"Site","Numerator":14,"Denominator":119,"Metric":0.1176,"Score":0.182,"Flag":0},{"GroupID":"0X956","GroupLevel":"Site","Numerator":18,"Denominator":153,"Metric":0.1176,"Score":0.2063,"Flag":0},{"GroupID":"0X8091","GroupLevel":"Site","Numerator":33,"Denominator":287,"Metric":0.115,"Score":0.1913,"Flag":0},{"GroupID":"0X2170","GroupLevel":"Site","Numerator":49,"Denominator":428,"Metric":0.1145,"Score":0.2128,"Flag":0},{"GroupID":"0X2532","GroupLevel":"Site","Numerator":53,"Denominator":466,"Metric":0.1137,"Score":0.1892,"Flag":0},{"GroupID":"0X9142","GroupLevel":"Site","Numerator":92,"Denominator":812,"Metric":0.1133,"Score":0.2248,"Flag":0},{"GroupID":"0X4561","GroupLevel":"Site","Numerator":17,"Denominator":151,"Metric":0.1126,"Score":0.0791,"Flag":0},{"GroupID":"0X7809","GroupLevel":"Site","Numerator":41,"Denominator":366,"Metric":0.112,"Score":0.1014,"Flag":0},{"GroupID":"0X2192","GroupLevel":"Site","Numerator":70,"Denominator":633,"Metric":0.1106,"Score":0.0602,"Flag":0},{"GroupID":"0X5788","GroupLevel":"Site","Numerator":20,"Denominator":184,"Metric":0.1087,"Score":-0.0194,"Flag":0},{"GroupID":"0X5386","GroupLevel":"Site","Numerator":5,"Denominator":46,"Metric":0.1087,"Score":-0.0097,"Flag":0},{"GroupID":"0X3574","GroupLevel":"Site","Numerator":18,"Denominator":166,"Metric":0.1084,"Score":-0.0252,"Flag":0},{"GroupID":"0X9210","GroupLevel":"Site","Numerator":4,"Denominator":37,"Metric":0.1081,"Score":-0.0159,"Flag":0},{"GroupID":"0X2123","GroupLevel":"Site","Numerator":15,"Denominator":140,"Metric":0.1071,"Score":-0.0541,"Flag":0},{"GroupID":"0X5808","GroupLevel":"Site","Numerator":6,"Denominator":56,"Metric":0.1071,"Score":-0.0342,"Flag":0},{"GroupID":"0X203","GroupLevel":"Site","Numerator":11,"Denominator":103,"Metric":0.1068,"Score":-0.0535,"Flag":0},{"GroupID":"0X8508","GroupLevel":"Site","Numerator":26,"Denominator":245,"Metric":0.1061,"Score":-0.1039,"Flag":0},{"GroupID":"0X4485","GroupLevel":"Site","Numerator":42,"Denominator":396,"Metric":0.1061,"Score":-0.1345,"Flag":0},{"GroupID":"0X1910","GroupLevel":"Site","Numerator":32,"Denominator":305,"Metric":0.1049,"Score":-0.1584,"Flag":0},{"GroupID":"0X7349","GroupLevel":"Site","Numerator":5,"Denominator":48,"Metric":0.1042,"Score":-0.0734,"Flag":0},{"GroupID":"0X9017","GroupLevel":"Site","Numerator":17,"Denominator":164,"Metric":0.1037,"Score":-0.1488,"Flag":0},{"GroupID":"0X2355","GroupLevel":"Site","Numerator":13,"Denominator":128,"Metric":0.1016,"Score":-0.1794,"Flag":0},{"GroupID":"0X4590","GroupLevel":"Site","Numerator":49,"Denominator":483,"Metric":0.1014,"Score":-0.3536,"Flag":0},{"GroupID":"0X2318","GroupLevel":"Site","Numerator":14,"Denominator":138,"Metric":0.1014,"Score":-0.189,"Flag":0},{"GroupID":"0X958","GroupLevel":"Site","Numerator":32,"Denominator":316,"Metric":0.1013,"Score":-0.2926,"Flag":0},{"GroupID":"0X9834","GroupLevel":"Site","Numerator":15,"Denominator":149,"Metric":0.1007,"Score":-0.2156,"Flag":0},{"GroupID":"0X8517","GroupLevel":"Site","Numerator":38,"Denominator":378,"Metric":0.1005,"Score":-0.349,"Flag":0},{"GroupID":"0X8799","GroupLevel":"Site","Numerator":46,"Denominator":458,"Metric":0.1004,"Score":-0.3882,"Flag":0},{"GroupID":"0X8591","GroupLevel":"Site","Numerator":3,"Denominator":30,"Metric":0.1,"Score":-0.1042,"Flag":0},{"GroupID":"0X4130","GroupLevel":"Site","Numerator":12,"Denominator":122,"Metric":0.0984,"Score":-0.2467,"Flag":0},{"GroupID":"0X9858","GroupLevel":"Site","Numerator":12,"Denominator":122,"Metric":0.0984,"Score":-0.2467,"Flag":0},{"GroupID":"0X9860","GroupLevel":"Site","Numerator":4,"Denominator":41,"Metric":0.0976,"Score":-0.1534,"Flag":0},{"GroupID":"0X8633","GroupLevel":"Site","Numerator":61,"Denominator":633,"Metric":0.0964,"Score":-0.6636,"Flag":0},{"GroupID":"0X1750","GroupLevel":"Site","Numerator":32,"Denominator":336,"Metric":0.0952,"Score":-0.5253,"Flag":0},{"GroupID":"0X8786","GroupLevel":"Site","Numerator":38,"Denominator":401,"Metric":0.0948,"Score":-0.5931,"Flag":0},{"GroupID":"0X9814","GroupLevel":"Site","Numerator":27,"Denominator":288,"Metric":0.0938,"Score":-0.5374,"Flag":0},{"GroupID":"0X2638","GroupLevel":"Site","Numerator":12,"Denominator":128,"Metric":0.0938,"Score":-0.3583,"Flag":0},{"GroupID":"0X6900","GroupLevel":"Site","Numerator":37,"Denominator":396,"Metric":0.0934,"Score":-0.6429,"Flag":0},{"GroupID":"0X5478","GroupLevel":"Site","Numerator":20,"Denominator":216,"Metric":0.0926,"Score":-0.4998,"Flag":0},{"GroupID":"0X8354","GroupLevel":"Site","Numerator":16,"Denominator":175,"Metric":0.0914,"Score":-0.4811,"Flag":0},{"GroupID":"0X9346","GroupLevel":"Site","Numerator":42,"Denominator":461,"Metric":0.0911,"Score":-0.7948,"Flag":0},{"GroupID":"0X2814","GroupLevel":"Site","Numerator":7,"Denominator":78,"Metric":0.0897,"Score":-0.3513,"Flag":0},{"GroupID":"0X4264","GroupLevel":"Site","Numerator":33,"Denominator":369,"Metric":0.0894,"Score":-0.7762,"Flag":0},{"GroupID":"0X4959","GroupLevel":"Site","Numerator":27,"Denominator":304,"Metric":0.0888,"Score":-0.7262,"Flag":0},{"GroupID":"0X2901","GroupLevel":"Site","Numerator":28,"Denominator":319,"Metric":0.0878,"Score":-0.7815,"Flag":0},{"GroupID":"0X8788","GroupLevel":"Site","Numerator":27,"Denominator":310,"Metric":0.0871,"Score":-0.7946,"Flag":0},{"GroupID":"0X6792","GroupLevel":"Site","Numerator":22,"Denominator":257,"Metric":0.0856,"Score":-0.7719,"Flag":0},{"GroupID":"0X334","GroupLevel":"Site","Numerator":16,"Denominator":188,"Metric":0.0851,"Score":-0.674,"Flag":0},{"GroupID":"0X6980","GroupLevel":"Site","Numerator":12,"Denominator":141,"Metric":0.0851,"Score":-0.5837,"Flag":0},{"GroupID":"0X6590","GroupLevel":"Site","Numerator":14,"Denominator":165,"Metric":0.0848,"Score":-0.6381,"Flag":0},{"GroupID":"0X7438","GroupLevel":"Site","Numerator":3,"Denominator":36,"Metric":0.0833,"Score":-0.3165,"Flag":0},{"GroupID":"0X4707","GroupLevel":"Site","Numerator":8,"Denominator":97,"Metric":0.0825,"Score":-0.5366,"Flag":0},{"GroupID":"0X2309","GroupLevel":"Site","Numerator":21,"Denominator":255,"Metric":0.0824,"Score":-0.8739,"Flag":0},{"GroupID":"0X3136","GroupLevel":"Site","Numerator":14,"Denominator":170,"Metric":0.0824,"Score":-0.7136,"Flag":0},{"GroupID":"0X7447","GroupLevel":"Site","Numerator":11,"Denominator":140,"Metric":0.0786,"Score":-0.7381,"Flag":0},{"GroupID":"0X3989","GroupLevel":"Site","Numerator":11,"Denominator":150,"Metric":0.0733,"Score":-0.8938,"Flag":0},{"GroupID":"0X9683","GroupLevel":"Site","Numerator":5,"Denominator":69,"Metric":0.0725,"Score":-0.6208,"Flag":0},{"GroupID":"0X2865","GroupLevel":"Site","Numerator":5,"Denominator":71,"Metric":0.0704,"Score":-0.6645,"Flag":0},{"GroupID":"0X6930","GroupLevel":"Site","Numerator":3,"Denominator":45,"Metric":0.0667,"Score":-0.58,"Flag":0},{"GroupID":"0X3083","GroupLevel":"Site","Numerator":3,"Denominator":48,"Metric":0.0625,"Score":-0.6575,"Flag":0},{"GroupID":"0X1109","GroupLevel":"Site","Numerator":2,"Denominator":32,"Metric":0.0625,"Score":-0.5368,"Flag":0},{"GroupID":"0X8494","GroupLevel":"Site","Numerator":2,"Denominator":40,"Metric":0.05,"Score":-0.7601,"Flag":0},{"GroupID":"0X7844","GroupLevel":"Site","Numerator":7,"Denominator":14,"Metric":0.5,"Score":"NA","Flag":"NA"},{"GroupID":"0X283","GroupLevel":"Site","Numerator":4,"Denominator":12,"Metric":0.3333,"Score":"NA","Flag":"NA"},{"GroupID":"0X3777","GroupLevel":"Site","Numerator":4,"Denominator":13,"Metric":0.3077,"Score":"NA","Flag":"NA"},{"GroupID":"0X3214","GroupLevel":"Site","Numerator":7,"Denominator":25,"Metric":0.28,"Score":"NA","Flag":"NA"},{"GroupID":"0X3565","GroupLevel":"Site","Numerator":4,"Denominator":16,"Metric":0.25,"Score":"NA","Flag":"NA"},{"GroupID":"0X155","GroupLevel":"Site","Numerator":3,"Denominator":13,"Metric":0.2308,"Score":"NA","Flag":"NA"},{"GroupID":"0X439","GroupLevel":"Site","Numerator":5,"Denominator":23,"Metric":0.2174,"Score":"NA","Flag":"NA"},{"GroupID":"0X6041","GroupLevel":"Site","Numerator":6,"Denominator":29,"Metric":0.2069,"Score":"NA","Flag":"NA"},{"GroupID":"0X8547","GroupLevel":"Site","Numerator":5,"Denominator":26,"Metric":0.1923,"Score":"NA","Flag":"NA"},{"GroupID":"0X5503","GroupLevel":"Site","Numerator":4,"Denominator":25,"Metric":0.16,"Score":"NA","Flag":"NA"},{"GroupID":"0X8592","GroupLevel":"Site","Numerator":4,"Denominator":28,"Metric":0.1429,"Score":"NA","Flag":"NA"},{"GroupID":"0X9364","GroupLevel":"Site","Numerator":4,"Denominator":29,"Metric":0.1379,"Score":"NA","Flag":"NA"},{"GroupID":"0X1800","GroupLevel":"Site","Numerator":3,"Denominator":24,"Metric":0.125,"Score":"NA","Flag":"NA"},{"GroupID":"0X2508","GroupLevel":"Site","Numerator":2,"Denominator":17,"Metric":0.1176,"Score":"NA","Flag":"NA"},{"GroupID":"0X3857","GroupLevel":"Site","Numerator":2,"Denominator":17,"Metric":0.1176,"Score":"NA","Flag":"NA"},{"GroupID":"0X4185","GroupLevel":"Site","Numerator":2,"Denominator":20,"Metric":0.1,"Score":"NA","Flag":"NA"},{"GroupID":"0X3556","GroupLevel":"Site","Numerator":1,"Denominator":10,"Metric":0.1,"Score":"NA","Flag":"NA"},{"GroupID":"0X5579","GroupLevel":"Site","Numerator":1,"Denominator":12,"Metric":0.0833,"Score":"NA","Flag":"NA"},{"GroupID":"0X5182","GroupLevel":"Site","Numerator":1,"Denominator":14,"Metric":0.0714,"Score":"NA","Flag":"NA"},{"GroupID":"0X7147","GroupLevel":"Site","Numerator":1,"Denominator":18,"Metric":0.0556,"Score":"NA","Flag":"NA"}],"lMetric":null,"dfGroups":null,"vThreshold":null,"lChartConfig":{"y":"Score"},"strOutcome":"Score","bAddGroupSelect":true,"strShinyGroupSelectID":"GroupID","bDebug":false},"evals":[],"jsHooks":[]}</script>
</div>
<div id="bar-chart---metric" class="section level4">
<h4>Bar Chart - Metric</h4>
<pre class="r"><code>Widget_BarChart(dfResults = AE_KRI$Analysis_Summary, lMetric=labels, strOutcome=&quot;Metric&quot;)</code></pre>
<div class="Widget_BarChart html-widget html-fill-item" id="htmlwidget-4f68dde91a2dc6947167" style="width:672px;height:480px;"></div>
<script type="application/json" data-for="htmlwidget-4f68dde91a2dc6947167">{"x":{"dfResults":[{"GroupID":"0X8351","GroupLevel":"Site","Numerator":86,"Denominator":448,"Metric":0.192,"Score":3.5357,"Flag":2},{"GroupID":"0X4323","GroupLevel":"Site","Numerator":47,"Denominator":675,"Metric":0.0696,"Score":-2.0907,"Flag":-2},{"GroupID":"0X6405","GroupLevel":"Site","Numerator":34,"Denominator":521,"Metric":0.0653,"Score":-2.0386,"Flag":-2},{"GroupID":"0X414","GroupLevel":"Site","Numerator":17,"Denominator":68,"Metric":0.25,"Score":2.3458,"Flag":1},{"GroupID":"0X8764","GroupLevel":"Site","Numerator":28,"Denominator":120,"Metric":0.2333,"Score":2.7468,"Flag":1},{"GroupID":"0X4874","GroupLevel":"Site","Numerator":33,"Denominator":173,"Metric":0.1908,"Score":2.1649,"Flag":1},{"GroupID":"0X1257","GroupLevel":"Site","Numerator":31,"Denominator":163,"Metric":0.1902,"Score":2.0867,"Flag":1},{"GroupID":"0X101","GroupLevel":"Site","Numerator":36,"Denominator":197,"Metric":0.1827,"Score":2.0827,"Flag":1},{"GroupID":"0X9737","GroupLevel":"Site","Numerator":39,"Denominator":467,"Metric":0.0835,"Score":-1.132,"Flag":-1},{"GroupID":"0X4629","GroupLevel":"Site","Numerator":35,"Denominator":435,"Metric":0.0805,"Score":-1.2213,"Flag":-1},{"GroupID":"0X759","GroupLevel":"Site","Numerator":42,"Denominator":523,"Metric":0.0803,"Score":-1.3463,"Flag":-1},{"GroupID":"0X8625","GroupLevel":"Site","Numerator":36,"Denominator":481,"Metric":0.0748,"Score":-1.5335,"Flag":-1},{"GroupID":"0X9360","GroupLevel":"Site","Numerator":32,"Denominator":430,"Metric":0.0744,"Score":-1.4677,"Flag":-1},{"GroupID":"0X7228","GroupLevel":"Site","Numerator":15,"Denominator":225,"Metric":0.0667,"Score":-1.297,"Flag":-1},{"GroupID":"0X1137","GroupLevel":"Site","Numerator":13,"Denominator":196,"Metric":0.0663,"Score":-1.2201,"Flag":-1},{"GroupID":"0X8382","GroupLevel":"Site","Numerator":8,"Denominator":125,"Metric":0.064,"Score":-1.027,"Flag":-1},{"GroupID":"0X9862","GroupLevel":"Site","Numerator":10,"Denominator":157,"Metric":0.0637,"Score":-1.1588,"Flag":-1},{"GroupID":"0X3585","GroupLevel":"Site","Numerator":17,"Denominator":270,"Metric":0.063,"Score":-1.5439,"Flag":-1},{"GroupID":"0X4324","GroupLevel":"Site","Numerator":7,"Denominator":120,"Metric":0.0583,"Score":-1.1319,"Flag":-1},{"GroupID":"0X1548","GroupLevel":"Site","Numerator":5,"Denominator":93,"Metric":0.0538,"Score":-1.0856,"Flag":-1},{"GroupID":"0X5362","GroupLevel":"Site","Numerator":5,"Denominator":110,"Metric":0.0455,"Score":-1.357,"Flag":-1},{"GroupID":"0X5137","GroupLevel":"Site","Numerator":1,"Denominator":39,"Metric":0.0256,"Score":-1.0583,"Flag":-1},{"GroupID":"0X5048","GroupLevel":"Site","Numerator":0,"Denominator":42,"Metric":0,"Score":-1.4345,"Flag":-1},{"GroupID":"0X3197","GroupLevel":"Site","Numerator":13,"Denominator":57,"Metric":0.2281,"Score":1.8127,"Flag":0},{"GroupID":"0X9520","GroupLevel":"Site","Numerator":20,"Denominator":97,"Metric":0.2062,"Score":1.9286,"Flag":0},{"GroupID":"0X3736","GroupLevel":"Site","Numerator":19,"Denominator":102,"Metric":0.1863,"Score":1.5708,"Flag":0},{"GroupID":"0X6367","GroupLevel":"Site","Numerator":8,"Denominator":44,"Metric":0.1818,"Score":0.9719,"Flag":0},{"GroupID":"0X8551","GroupLevel":"Site","Numerator":18,"Denominator":105,"Metric":0.1714,"Score":1.286,"Flag":0},{"GroupID":"0X7983","GroupLevel":"Site","Numerator":41,"Denominator":243,"Metric":0.1687,"Score":1.871,"Flag":0},{"GroupID":"0X567","GroupLevel":"Site","Numerator":15,"Denominator":90,"Metric":0.1667,"Score":1.0992,"Flag":0},{"GroupID":"0X3909","GroupLevel":"Site","Numerator":36,"Denominator":216,"Metric":0.1667,"Score":1.7028,"Flag":0},{"GroupID":"0X2397","GroupLevel":"Site","Numerator":17,"Denominator":105,"Metric":0.1619,"Score":1.0885,"Flag":0},{"GroupID":"0X8823","GroupLevel":"Site","Numerator":18,"Denominator":112,"Metric":0.1607,"Score":1.0987,"Flag":0},{"GroupID":"0X3639","GroupLevel":"Site","Numerator":7,"Denominator":44,"Metric":0.1591,"Score":0.6669,"Flag":0},{"GroupID":"0X7789","GroupLevel":"Site","Numerator":7,"Denominator":44,"Metric":0.1591,"Score":0.6669,"Flag":0},{"GroupID":"0X8669","GroupLevel":"Site","Numerator":10,"Denominator":64,"Metric":0.1562,"Score":0.7583,"Flag":0},{"GroupID":"0X1982","GroupLevel":"Site","Numerator":25,"Denominator":164,"Metric":0.1524,"Score":1.1151,"Flag":0},{"GroupID":"0X9580","GroupLevel":"Site","Numerator":36,"Denominator":238,"Metric":0.1513,"Score":1.3066,"Flag":0},{"GroupID":"0X6603","GroupLevel":"Site","Numerator":36,"Denominator":239,"Metric":0.1506,"Score":1.2895,"Flag":0},{"GroupID":"0X5384","GroupLevel":"Site","Numerator":58,"Denominator":399,"Metric":0.1454,"Score":1.4534,"Flag":0},{"GroupID":"0X5782","GroupLevel":"Site","Numerator":9,"Denominator":62,"Metric":0.1452,"Score":0.5697,"Flag":0},{"GroupID":"0X9381","GroupLevel":"Site","Numerator":8,"Denominator":56,"Metric":0.1429,"Score":0.5065,"Flag":0},{"GroupID":"0X180","GroupLevel":"Site","Numerator":39,"Denominator":281,"Metric":0.1388,"Score":0.9967,"Flag":0},{"GroupID":"0X2376","GroupLevel":"Site","Numerator":17,"Denominator":123,"Metric":0.1382,"Score":0.6465,"Flag":0},{"GroupID":"0X3252","GroupLevel":"Site","Numerator":6,"Denominator":44,"Metric":0.1364,"Score":0.3618,"Flag":0},{"GroupID":"0X6521","GroupLevel":"Site","Numerator":7,"Denominator":52,"Metric":0.1346,"Score":0.3679,"Flag":0},{"GroupID":"0X3289","GroupLevel":"Site","Numerator":37,"Denominator":275,"Metric":0.1345,"Score":0.8436,"Flag":0},{"GroupID":"0X5033","GroupLevel":"Site","Numerator":28,"Denominator":210,"Metric":0.1333,"Score":0.7017,"Flag":0},{"GroupID":"0X7011","GroupLevel":"Site","Numerator":55,"Denominator":416,"Metric":0.1322,"Score":0.9413,"Flag":0},{"GroupID":"0X7513","GroupLevel":"Site","Numerator":25,"Denominator":191,"Metric":0.1309,"Score":0.6009,"Flag":0},{"GroupID":"0X905","GroupLevel":"Site","Numerator":6,"Denominator":46,"Metric":0.1304,"Score":0.2886,"Flag":0},{"GroupID":"0X2574","GroupLevel":"Site","Numerator":21,"Denominator":161,"Metric":0.1304,"Score":0.54,"Flag":0},{"GroupID":"0X6301","GroupLevel":"Site","Numerator":11,"Denominator":86,"Metric":0.1279,"Score":0.3472,"Flag":0},{"GroupID":"0X1839","GroupLevel":"Site","Numerator":24,"Denominator":190,"Metric":0.1263,"Score":0.4717,"Flag":0},{"GroupID":"0X5787","GroupLevel":"Site","Numerator":23,"Denominator":185,"Metric":0.1243,"Score":0.4107,"Flag":0},{"GroupID":"0X2002","GroupLevel":"Site","Numerator":9,"Denominator":73,"Metric":0.1233,"Score":0.24,"Flag":0},{"GroupID":"0X3090","GroupLevel":"Site","Numerator":26,"Denominator":213,"Metric":0.1221,"Score":0.3739,"Flag":0},{"GroupID":"0X2323","GroupLevel":"Site","Numerator":36,"Denominator":295,"Metric":0.122,"Score":0.439,"Flag":0},{"GroupID":"0X2513","GroupLevel":"Site","Numerator":5,"Denominator":41,"Metric":0.122,"Score":0.1626,"Flag":0},{"GroupID":"0X5895","GroupLevel":"Site","Numerator":64,"Denominator":526,"Metric":0.1217,"Score":0.5694,"Flag":0},{"GroupID":"0X6384","GroupLevel":"Site","Numerator":22,"Denominator":184,"Metric":0.1196,"Score":0.2789,"Flag":0},{"GroupID":"0X7656","GroupLevel":"Site","Numerator":12,"Denominator":101,"Metric":0.1188,"Score":0.1913,"Flag":0},{"GroupID":"0X213","GroupLevel":"Site","Numerator":88,"Denominator":742,"Metric":0.1186,"Score":0.5069,"Flag":0},{"GroupID":"0X7938","GroupLevel":"Site","Numerator":14,"Denominator":119,"Metric":0.1176,"Score":0.182,"Flag":0},{"GroupID":"0X956","GroupLevel":"Site","Numerator":18,"Denominator":153,"Metric":0.1176,"Score":0.2063,"Flag":0},{"GroupID":"0X8091","GroupLevel":"Site","Numerator":33,"Denominator":287,"Metric":0.115,"Score":0.1913,"Flag":0},{"GroupID":"0X2170","GroupLevel":"Site","Numerator":49,"Denominator":428,"Metric":0.1145,"Score":0.2128,"Flag":0},{"GroupID":"0X2532","GroupLevel":"Site","Numerator":53,"Denominator":466,"Metric":0.1137,"Score":0.1892,"Flag":0},{"GroupID":"0X9142","GroupLevel":"Site","Numerator":92,"Denominator":812,"Metric":0.1133,"Score":0.2248,"Flag":0},{"GroupID":"0X4561","GroupLevel":"Site","Numerator":17,"Denominator":151,"Metric":0.1126,"Score":0.0791,"Flag":0},{"GroupID":"0X7809","GroupLevel":"Site","Numerator":41,"Denominator":366,"Metric":0.112,"Score":0.1014,"Flag":0},{"GroupID":"0X2192","GroupLevel":"Site","Numerator":70,"Denominator":633,"Metric":0.1106,"Score":0.0602,"Flag":0},{"GroupID":"0X5788","GroupLevel":"Site","Numerator":20,"Denominator":184,"Metric":0.1087,"Score":-0.0194,"Flag":0},{"GroupID":"0X5386","GroupLevel":"Site","Numerator":5,"Denominator":46,"Metric":0.1087,"Score":-0.0097,"Flag":0},{"GroupID":"0X3574","GroupLevel":"Site","Numerator":18,"Denominator":166,"Metric":0.1084,"Score":-0.0252,"Flag":0},{"GroupID":"0X9210","GroupLevel":"Site","Numerator":4,"Denominator":37,"Metric":0.1081,"Score":-0.0159,"Flag":0},{"GroupID":"0X2123","GroupLevel":"Site","Numerator":15,"Denominator":140,"Metric":0.1071,"Score":-0.0541,"Flag":0},{"GroupID":"0X5808","GroupLevel":"Site","Numerator":6,"Denominator":56,"Metric":0.1071,"Score":-0.0342,"Flag":0},{"GroupID":"0X203","GroupLevel":"Site","Numerator":11,"Denominator":103,"Metric":0.1068,"Score":-0.0535,"Flag":0},{"GroupID":"0X8508","GroupLevel":"Site","Numerator":26,"Denominator":245,"Metric":0.1061,"Score":-0.1039,"Flag":0},{"GroupID":"0X4485","GroupLevel":"Site","Numerator":42,"Denominator":396,"Metric":0.1061,"Score":-0.1345,"Flag":0},{"GroupID":"0X1910","GroupLevel":"Site","Numerator":32,"Denominator":305,"Metric":0.1049,"Score":-0.1584,"Flag":0},{"GroupID":"0X7349","GroupLevel":"Site","Numerator":5,"Denominator":48,"Metric":0.1042,"Score":-0.0734,"Flag":0},{"GroupID":"0X9017","GroupLevel":"Site","Numerator":17,"Denominator":164,"Metric":0.1037,"Score":-0.1488,"Flag":0},{"GroupID":"0X2355","GroupLevel":"Site","Numerator":13,"Denominator":128,"Metric":0.1016,"Score":-0.1794,"Flag":0},{"GroupID":"0X4590","GroupLevel":"Site","Numerator":49,"Denominator":483,"Metric":0.1014,"Score":-0.3536,"Flag":0},{"GroupID":"0X2318","GroupLevel":"Site","Numerator":14,"Denominator":138,"Metric":0.1014,"Score":-0.189,"Flag":0},{"GroupID":"0X958","GroupLevel":"Site","Numerator":32,"Denominator":316,"Metric":0.1013,"Score":-0.2926,"Flag":0},{"GroupID":"0X9834","GroupLevel":"Site","Numerator":15,"Denominator":149,"Metric":0.1007,"Score":-0.2156,"Flag":0},{"GroupID":"0X8517","GroupLevel":"Site","Numerator":38,"Denominator":378,"Metric":0.1005,"Score":-0.349,"Flag":0},{"GroupID":"0X8799","GroupLevel":"Site","Numerator":46,"Denominator":458,"Metric":0.1004,"Score":-0.3882,"Flag":0},{"GroupID":"0X8591","GroupLevel":"Site","Numerator":3,"Denominator":30,"Metric":0.1,"Score":-0.1042,"Flag":0},{"GroupID":"0X4130","GroupLevel":"Site","Numerator":12,"Denominator":122,"Metric":0.0984,"Score":-0.2467,"Flag":0},{"GroupID":"0X9858","GroupLevel":"Site","Numerator":12,"Denominator":122,"Metric":0.0984,"Score":-0.2467,"Flag":0},{"GroupID":"0X9860","GroupLevel":"Site","Numerator":4,"Denominator":41,"Metric":0.0976,"Score":-0.1534,"Flag":0},{"GroupID":"0X8633","GroupLevel":"Site","Numerator":61,"Denominator":633,"Metric":0.0964,"Score":-0.6636,"Flag":0},{"GroupID":"0X1750","GroupLevel":"Site","Numerator":32,"Denominator":336,"Metric":0.0952,"Score":-0.5253,"Flag":0},{"GroupID":"0X8786","GroupLevel":"Site","Numerator":38,"Denominator":401,"Metric":0.0948,"Score":-0.5931,"Flag":0},{"GroupID":"0X9814","GroupLevel":"Site","Numerator":27,"Denominator":288,"Metric":0.0938,"Score":-0.5374,"Flag":0},{"GroupID":"0X2638","GroupLevel":"Site","Numerator":12,"Denominator":128,"Metric":0.0938,"Score":-0.3583,"Flag":0},{"GroupID":"0X6900","GroupLevel":"Site","Numerator":37,"Denominator":396,"Metric":0.0934,"Score":-0.6429,"Flag":0},{"GroupID":"0X5478","GroupLevel":"Site","Numerator":20,"Denominator":216,"Metric":0.0926,"Score":-0.4998,"Flag":0},{"GroupID":"0X8354","GroupLevel":"Site","Numerator":16,"Denominator":175,"Metric":0.0914,"Score":-0.4811,"Flag":0},{"GroupID":"0X9346","GroupLevel":"Site","Numerator":42,"Denominator":461,"Metric":0.0911,"Score":-0.7948,"Flag":0},{"GroupID":"0X2814","GroupLevel":"Site","Numerator":7,"Denominator":78,"Metric":0.0897,"Score":-0.3513,"Flag":0},{"GroupID":"0X4264","GroupLevel":"Site","Numerator":33,"Denominator":369,"Metric":0.0894,"Score":-0.7762,"Flag":0},{"GroupID":"0X4959","GroupLevel":"Site","Numerator":27,"Denominator":304,"Metric":0.0888,"Score":-0.7262,"Flag":0},{"GroupID":"0X2901","GroupLevel":"Site","Numerator":28,"Denominator":319,"Metric":0.0878,"Score":-0.7815,"Flag":0},{"GroupID":"0X8788","GroupLevel":"Site","Numerator":27,"Denominator":310,"Metric":0.0871,"Score":-0.7946,"Flag":0},{"GroupID":"0X6792","GroupLevel":"Site","Numerator":22,"Denominator":257,"Metric":0.0856,"Score":-0.7719,"Flag":0},{"GroupID":"0X334","GroupLevel":"Site","Numerator":16,"Denominator":188,"Metric":0.0851,"Score":-0.674,"Flag":0},{"GroupID":"0X6980","GroupLevel":"Site","Numerator":12,"Denominator":141,"Metric":0.0851,"Score":-0.5837,"Flag":0},{"GroupID":"0X6590","GroupLevel":"Site","Numerator":14,"Denominator":165,"Metric":0.0848,"Score":-0.6381,"Flag":0},{"GroupID":"0X7438","GroupLevel":"Site","Numerator":3,"Denominator":36,"Metric":0.0833,"Score":-0.3165,"Flag":0},{"GroupID":"0X4707","GroupLevel":"Site","Numerator":8,"Denominator":97,"Metric":0.0825,"Score":-0.5366,"Flag":0},{"GroupID":"0X2309","GroupLevel":"Site","Numerator":21,"Denominator":255,"Metric":0.0824,"Score":-0.8739,"Flag":0},{"GroupID":"0X3136","GroupLevel":"Site","Numerator":14,"Denominator":170,"Metric":0.0824,"Score":-0.7136,"Flag":0},{"GroupID":"0X7447","GroupLevel":"Site","Numerator":11,"Denominator":140,"Metric":0.0786,"Score":-0.7381,"Flag":0},{"GroupID":"0X3989","GroupLevel":"Site","Numerator":11,"Denominator":150,"Metric":0.0733,"Score":-0.8938,"Flag":0},{"GroupID":"0X9683","GroupLevel":"Site","Numerator":5,"Denominator":69,"Metric":0.0725,"Score":-0.6208,"Flag":0},{"GroupID":"0X2865","GroupLevel":"Site","Numerator":5,"Denominator":71,"Metric":0.0704,"Score":-0.6645,"Flag":0},{"GroupID":"0X6930","GroupLevel":"Site","Numerator":3,"Denominator":45,"Metric":0.0667,"Score":-0.58,"Flag":0},{"GroupID":"0X3083","GroupLevel":"Site","Numerator":3,"Denominator":48,"Metric":0.0625,"Score":-0.6575,"Flag":0},{"GroupID":"0X1109","GroupLevel":"Site","Numerator":2,"Denominator":32,"Metric":0.0625,"Score":-0.5368,"Flag":0},{"GroupID":"0X8494","GroupLevel":"Site","Numerator":2,"Denominator":40,"Metric":0.05,"Score":-0.7601,"Flag":0},{"GroupID":"0X7844","GroupLevel":"Site","Numerator":7,"Denominator":14,"Metric":0.5,"Score":"NA","Flag":"NA"},{"GroupID":"0X283","GroupLevel":"Site","Numerator":4,"Denominator":12,"Metric":0.3333,"Score":"NA","Flag":"NA"},{"GroupID":"0X3777","GroupLevel":"Site","Numerator":4,"Denominator":13,"Metric":0.3077,"Score":"NA","Flag":"NA"},{"GroupID":"0X3214","GroupLevel":"Site","Numerator":7,"Denominator":25,"Metric":0.28,"Score":"NA","Flag":"NA"},{"GroupID":"0X3565","GroupLevel":"Site","Numerator":4,"Denominator":16,"Metric":0.25,"Score":"NA","Flag":"NA"},{"GroupID":"0X155","GroupLevel":"Site","Numerator":3,"Denominator":13,"Metric":0.2308,"Score":"NA","Flag":"NA"},{"GroupID":"0X439","GroupLevel":"Site","Numerator":5,"Denominator":23,"Metric":0.2174,"Score":"NA","Flag":"NA"},{"GroupID":"0X6041","GroupLevel":"Site","Numerator":6,"Denominator":29,"Metric":0.2069,"Score":"NA","Flag":"NA"},{"GroupID":"0X8547","GroupLevel":"Site","Numerator":5,"Denominator":26,"Metric":0.1923,"Score":"NA","Flag":"NA"},{"GroupID":"0X5503","GroupLevel":"Site","Numerator":4,"Denominator":25,"Metric":0.16,"Score":"NA","Flag":"NA"},{"GroupID":"0X8592","GroupLevel":"Site","Numerator":4,"Denominator":28,"Metric":0.1429,"Score":"NA","Flag":"NA"},{"GroupID":"0X9364","GroupLevel":"Site","Numerator":4,"Denominator":29,"Metric":0.1379,"Score":"NA","Flag":"NA"},{"GroupID":"0X1800","GroupLevel":"Site","Numerator":3,"Denominator":24,"Metric":0.125,"Score":"NA","Flag":"NA"},{"GroupID":"0X2508","GroupLevel":"Site","Numerator":2,"Denominator":17,"Metric":0.1176,"Score":"NA","Flag":"NA"},{"GroupID":"0X3857","GroupLevel":"Site","Numerator":2,"Denominator":17,"Metric":0.1176,"Score":"NA","Flag":"NA"},{"GroupID":"0X4185","GroupLevel":"Site","Numerator":2,"Denominator":20,"Metric":0.1,"Score":"NA","Flag":"NA"},{"GroupID":"0X3556","GroupLevel":"Site","Numerator":1,"Denominator":10,"Metric":0.1,"Score":"NA","Flag":"NA"},{"GroupID":"0X5579","GroupLevel":"Site","Numerator":1,"Denominator":12,"Metric":0.0833,"Score":"NA","Flag":"NA"},{"GroupID":"0X5182","GroupLevel":"Site","Numerator":1,"Denominator":14,"Metric":0.0714,"Score":"NA","Flag":"NA"},{"GroupID":"0X7147","GroupLevel":"Site","Numerator":1,"Denominator":18,"Metric":0.0556,"Score":"NA","Flag":"NA"}],"lMetric":{"Metric":"Adverse Event Rate","Numerator":"Adverse Events","Denominator":"Days on Study"},"dfGroups":null,"vThreshold":null,"lChartConfig":{"Metric":"Adverse Event Rate","Numerator":"Adverse Events","Denominator":"Days on Study","y":"Metric"},"strOutcome":"Metric","bAddGroupSelect":true,"strShinyGroupSelectID":"GroupID","bDebug":false},"evals":[],"jsHooks":[]}</script>
</div>
<div id="bar-chart---score" class="section level4">
<h4>Bar Chart - Score</h4>
<pre class="r"><code>Widget_BarChart(dfResults = AE_KRI$Analysis_Summary, lMetric=labels, strOutcome=&quot;Score&quot;)</code></pre>
<div class="Widget_BarChart html-widget html-fill-item" id="htmlwidget-1316c778179d344d0cfe" style="width:672px;height:480px;"></div>
<script type="application/json" data-for="htmlwidget-1316c778179d344d0cfe">{"x":{"dfResults":[{"GroupID":"0X8351","GroupLevel":"Site","Numerator":86,"Denominator":448,"Metric":0.192,"Score":3.5357,"Flag":2},{"GroupID":"0X4323","GroupLevel":"Site","Numerator":47,"Denominator":675,"Metric":0.0696,"Score":-2.0907,"Flag":-2},{"GroupID":"0X6405","GroupLevel":"Site","Numerator":34,"Denominator":521,"Metric":0.0653,"Score":-2.0386,"Flag":-2},{"GroupID":"0X414","GroupLevel":"Site","Numerator":17,"Denominator":68,"Metric":0.25,"Score":2.3458,"Flag":1},{"GroupID":"0X8764","GroupLevel":"Site","Numerator":28,"Denominator":120,"Metric":0.2333,"Score":2.7468,"Flag":1},{"GroupID":"0X4874","GroupLevel":"Site","Numerator":33,"Denominator":173,"Metric":0.1908,"Score":2.1649,"Flag":1},{"GroupID":"0X1257","GroupLevel":"Site","Numerator":31,"Denominator":163,"Metric":0.1902,"Score":2.0867,"Flag":1},{"GroupID":"0X101","GroupLevel":"Site","Numerator":36,"Denominator":197,"Metric":0.1827,"Score":2.0827,"Flag":1},{"GroupID":"0X9737","GroupLevel":"Site","Numerator":39,"Denominator":467,"Metric":0.0835,"Score":-1.132,"Flag":-1},{"GroupID":"0X4629","GroupLevel":"Site","Numerator":35,"Denominator":435,"Metric":0.0805,"Score":-1.2213,"Flag":-1},{"GroupID":"0X759","GroupLevel":"Site","Numerator":42,"Denominator":523,"Metric":0.0803,"Score":-1.3463,"Flag":-1},{"GroupID":"0X8625","GroupLevel":"Site","Numerator":36,"Denominator":481,"Metric":0.0748,"Score":-1.5335,"Flag":-1},{"GroupID":"0X9360","GroupLevel":"Site","Numerator":32,"Denominator":430,"Metric":0.0744,"Score":-1.4677,"Flag":-1},{"GroupID":"0X7228","GroupLevel":"Site","Numerator":15,"Denominator":225,"Metric":0.0667,"Score":-1.297,"Flag":-1},{"GroupID":"0X1137","GroupLevel":"Site","Numerator":13,"Denominator":196,"Metric":0.0663,"Score":-1.2201,"Flag":-1},{"GroupID":"0X8382","GroupLevel":"Site","Numerator":8,"Denominator":125,"Metric":0.064,"Score":-1.027,"Flag":-1},{"GroupID":"0X9862","GroupLevel":"Site","Numerator":10,"Denominator":157,"Metric":0.0637,"Score":-1.1588,"Flag":-1},{"GroupID":"0X3585","GroupLevel":"Site","Numerator":17,"Denominator":270,"Metric":0.063,"Score":-1.5439,"Flag":-1},{"GroupID":"0X4324","GroupLevel":"Site","Numerator":7,"Denominator":120,"Metric":0.0583,"Score":-1.1319,"Flag":-1},{"GroupID":"0X1548","GroupLevel":"Site","Numerator":5,"Denominator":93,"Metric":0.0538,"Score":-1.0856,"Flag":-1},{"GroupID":"0X5362","GroupLevel":"Site","Numerator":5,"Denominator":110,"Metric":0.0455,"Score":-1.357,"Flag":-1},{"GroupID":"0X5137","GroupLevel":"Site","Numerator":1,"Denominator":39,"Metric":0.0256,"Score":-1.0583,"Flag":-1},{"GroupID":"0X5048","GroupLevel":"Site","Numerator":0,"Denominator":42,"Metric":0,"Score":-1.4345,"Flag":-1},{"GroupID":"0X3197","GroupLevel":"Site","Numerator":13,"Denominator":57,"Metric":0.2281,"Score":1.8127,"Flag":0},{"GroupID":"0X9520","GroupLevel":"Site","Numerator":20,"Denominator":97,"Metric":0.2062,"Score":1.9286,"Flag":0},{"GroupID":"0X3736","GroupLevel":"Site","Numerator":19,"Denominator":102,"Metric":0.1863,"Score":1.5708,"Flag":0},{"GroupID":"0X6367","GroupLevel":"Site","Numerator":8,"Denominator":44,"Metric":0.1818,"Score":0.9719,"Flag":0},{"GroupID":"0X8551","GroupLevel":"Site","Numerator":18,"Denominator":105,"Metric":0.1714,"Score":1.286,"Flag":0},{"GroupID":"0X7983","GroupLevel":"Site","Numerator":41,"Denominator":243,"Metric":0.1687,"Score":1.871,"Flag":0},{"GroupID":"0X567","GroupLevel":"Site","Numerator":15,"Denominator":90,"Metric":0.1667,"Score":1.0992,"Flag":0},{"GroupID":"0X3909","GroupLevel":"Site","Numerator":36,"Denominator":216,"Metric":0.1667,"Score":1.7028,"Flag":0},{"GroupID":"0X2397","GroupLevel":"Site","Numerator":17,"Denominator":105,"Metric":0.1619,"Score":1.0885,"Flag":0},{"GroupID":"0X8823","GroupLevel":"Site","Numerator":18,"Denominator":112,"Metric":0.1607,"Score":1.0987,"Flag":0},{"GroupID":"0X3639","GroupLevel":"Site","Numerator":7,"Denominator":44,"Metric":0.1591,"Score":0.6669,"Flag":0},{"GroupID":"0X7789","GroupLevel":"Site","Numerator":7,"Denominator":44,"Metric":0.1591,"Score":0.6669,"Flag":0},{"GroupID":"0X8669","GroupLevel":"Site","Numerator":10,"Denominator":64,"Metric":0.1562,"Score":0.7583,"Flag":0},{"GroupID":"0X1982","GroupLevel":"Site","Numerator":25,"Denominator":164,"Metric":0.1524,"Score":1.1151,"Flag":0},{"GroupID":"0X9580","GroupLevel":"Site","Numerator":36,"Denominator":238,"Metric":0.1513,"Score":1.3066,"Flag":0},{"GroupID":"0X6603","GroupLevel":"Site","Numerator":36,"Denominator":239,"Metric":0.1506,"Score":1.2895,"Flag":0},{"GroupID":"0X5384","GroupLevel":"Site","Numerator":58,"Denominator":399,"Metric":0.1454,"Score":1.4534,"Flag":0},{"GroupID":"0X5782","GroupLevel":"Site","Numerator":9,"Denominator":62,"Metric":0.1452,"Score":0.5697,"Flag":0},{"GroupID":"0X9381","GroupLevel":"Site","Numerator":8,"Denominator":56,"Metric":0.1429,"Score":0.5065,"Flag":0},{"GroupID":"0X180","GroupLevel":"Site","Numerator":39,"Denominator":281,"Metric":0.1388,"Score":0.9967,"Flag":0},{"GroupID":"0X2376","GroupLevel":"Site","Numerator":17,"Denominator":123,"Metric":0.1382,"Score":0.6465,"Flag":0},{"GroupID":"0X3252","GroupLevel":"Site","Numerator":6,"Denominator":44,"Metric":0.1364,"Score":0.3618,"Flag":0},{"GroupID":"0X6521","GroupLevel":"Site","Numerator":7,"Denominator":52,"Metric":0.1346,"Score":0.3679,"Flag":0},{"GroupID":"0X3289","GroupLevel":"Site","Numerator":37,"Denominator":275,"Metric":0.1345,"Score":0.8436,"Flag":0},{"GroupID":"0X5033","GroupLevel":"Site","Numerator":28,"Denominator":210,"Metric":0.1333,"Score":0.7017,"Flag":0},{"GroupID":"0X7011","GroupLevel":"Site","Numerator":55,"Denominator":416,"Metric":0.1322,"Score":0.9413,"Flag":0},{"GroupID":"0X7513","GroupLevel":"Site","Numerator":25,"Denominator":191,"Metric":0.1309,"Score":0.6009,"Flag":0},{"GroupID":"0X905","GroupLevel":"Site","Numerator":6,"Denominator":46,"Metric":0.1304,"Score":0.2886,"Flag":0},{"GroupID":"0X2574","GroupLevel":"Site","Numerator":21,"Denominator":161,"Metric":0.1304,"Score":0.54,"Flag":0},{"GroupID":"0X6301","GroupLevel":"Site","Numerator":11,"Denominator":86,"Metric":0.1279,"Score":0.3472,"Flag":0},{"GroupID":"0X1839","GroupLevel":"Site","Numerator":24,"Denominator":190,"Metric":0.1263,"Score":0.4717,"Flag":0},{"GroupID":"0X5787","GroupLevel":"Site","Numerator":23,"Denominator":185,"Metric":0.1243,"Score":0.4107,"Flag":0},{"GroupID":"0X2002","GroupLevel":"Site","Numerator":9,"Denominator":73,"Metric":0.1233,"Score":0.24,"Flag":0},{"GroupID":"0X3090","GroupLevel":"Site","Numerator":26,"Denominator":213,"Metric":0.1221,"Score":0.3739,"Flag":0},{"GroupID":"0X2323","GroupLevel":"Site","Numerator":36,"Denominator":295,"Metric":0.122,"Score":0.439,"Flag":0},{"GroupID":"0X2513","GroupLevel":"Site","Numerator":5,"Denominator":41,"Metric":0.122,"Score":0.1626,"Flag":0},{"GroupID":"0X5895","GroupLevel":"Site","Numerator":64,"Denominator":526,"Metric":0.1217,"Score":0.5694,"Flag":0},{"GroupID":"0X6384","GroupLevel":"Site","Numerator":22,"Denominator":184,"Metric":0.1196,"Score":0.2789,"Flag":0},{"GroupID":"0X7656","GroupLevel":"Site","Numerator":12,"Denominator":101,"Metric":0.1188,"Score":0.1913,"Flag":0},{"GroupID":"0X213","GroupLevel":"Site","Numerator":88,"Denominator":742,"Metric":0.1186,"Score":0.5069,"Flag":0},{"GroupID":"0X7938","GroupLevel":"Site","Numerator":14,"Denominator":119,"Metric":0.1176,"Score":0.182,"Flag":0},{"GroupID":"0X956","GroupLevel":"Site","Numerator":18,"Denominator":153,"Metric":0.1176,"Score":0.2063,"Flag":0},{"GroupID":"0X8091","GroupLevel":"Site","Numerator":33,"Denominator":287,"Metric":0.115,"Score":0.1913,"Flag":0},{"GroupID":"0X2170","GroupLevel":"Site","Numerator":49,"Denominator":428,"Metric":0.1145,"Score":0.2128,"Flag":0},{"GroupID":"0X2532","GroupLevel":"Site","Numerator":53,"Denominator":466,"Metric":0.1137,"Score":0.1892,"Flag":0},{"GroupID":"0X9142","GroupLevel":"Site","Numerator":92,"Denominator":812,"Metric":0.1133,"Score":0.2248,"Flag":0},{"GroupID":"0X4561","GroupLevel":"Site","Numerator":17,"Denominator":151,"Metric":0.1126,"Score":0.0791,"Flag":0},{"GroupID":"0X7809","GroupLevel":"Site","Numerator":41,"Denominator":366,"Metric":0.112,"Score":0.1014,"Flag":0},{"GroupID":"0X2192","GroupLevel":"Site","Numerator":70,"Denominator":633,"Metric":0.1106,"Score":0.0602,"Flag":0},{"GroupID":"0X5788","GroupLevel":"Site","Numerator":20,"Denominator":184,"Metric":0.1087,"Score":-0.0194,"Flag":0},{"GroupID":"0X5386","GroupLevel":"Site","Numerator":5,"Denominator":46,"Metric":0.1087,"Score":-0.0097,"Flag":0},{"GroupID":"0X3574","GroupLevel":"Site","Numerator":18,"Denominator":166,"Metric":0.1084,"Score":-0.0252,"Flag":0},{"GroupID":"0X9210","GroupLevel":"Site","Numerator":4,"Denominator":37,"Metric":0.1081,"Score":-0.0159,"Flag":0},{"GroupID":"0X2123","GroupLevel":"Site","Numerator":15,"Denominator":140,"Metric":0.1071,"Score":-0.0541,"Flag":0},{"GroupID":"0X5808","GroupLevel":"Site","Numerator":6,"Denominator":56,"Metric":0.1071,"Score":-0.0342,"Flag":0},{"GroupID":"0X203","GroupLevel":"Site","Numerator":11,"Denominator":103,"Metric":0.1068,"Score":-0.0535,"Flag":0},{"GroupID":"0X8508","GroupLevel":"Site","Numerator":26,"Denominator":245,"Metric":0.1061,"Score":-0.1039,"Flag":0},{"GroupID":"0X4485","GroupLevel":"Site","Numerator":42,"Denominator":396,"Metric":0.1061,"Score":-0.1345,"Flag":0},{"GroupID":"0X1910","GroupLevel":"Site","Numerator":32,"Denominator":305,"Metric":0.1049,"Score":-0.1584,"Flag":0},{"GroupID":"0X7349","GroupLevel":"Site","Numerator":5,"Denominator":48,"Metric":0.1042,"Score":-0.0734,"Flag":0},{"GroupID":"0X9017","GroupLevel":"Site","Numerator":17,"Denominator":164,"Metric":0.1037,"Score":-0.1488,"Flag":0},{"GroupID":"0X2355","GroupLevel":"Site","Numerator":13,"Denominator":128,"Metric":0.1016,"Score":-0.1794,"Flag":0},{"GroupID":"0X4590","GroupLevel":"Site","Numerator":49,"Denominator":483,"Metric":0.1014,"Score":-0.3536,"Flag":0},{"GroupID":"0X2318","GroupLevel":"Site","Numerator":14,"Denominator":138,"Metric":0.1014,"Score":-0.189,"Flag":0},{"GroupID":"0X958","GroupLevel":"Site","Numerator":32,"Denominator":316,"Metric":0.1013,"Score":-0.2926,"Flag":0},{"GroupID":"0X9834","GroupLevel":"Site","Numerator":15,"Denominator":149,"Metric":0.1007,"Score":-0.2156,"Flag":0},{"GroupID":"0X8517","GroupLevel":"Site","Numerator":38,"Denominator":378,"Metric":0.1005,"Score":-0.349,"Flag":0},{"GroupID":"0X8799","GroupLevel":"Site","Numerator":46,"Denominator":458,"Metric":0.1004,"Score":-0.3882,"Flag":0},{"GroupID":"0X8591","GroupLevel":"Site","Numerator":3,"Denominator":30,"Metric":0.1,"Score":-0.1042,"Flag":0},{"GroupID":"0X4130","GroupLevel":"Site","Numerator":12,"Denominator":122,"Metric":0.0984,"Score":-0.2467,"Flag":0},{"GroupID":"0X9858","GroupLevel":"Site","Numerator":12,"Denominator":122,"Metric":0.0984,"Score":-0.2467,"Flag":0},{"GroupID":"0X9860","GroupLevel":"Site","Numerator":4,"Denominator":41,"Metric":0.0976,"Score":-0.1534,"Flag":0},{"GroupID":"0X8633","GroupLevel":"Site","Numerator":61,"Denominator":633,"Metric":0.0964,"Score":-0.6636,"Flag":0},{"GroupID":"0X1750","GroupLevel":"Site","Numerator":32,"Denominator":336,"Metric":0.0952,"Score":-0.5253,"Flag":0},{"GroupID":"0X8786","GroupLevel":"Site","Numerator":38,"Denominator":401,"Metric":0.0948,"Score":-0.5931,"Flag":0},{"GroupID":"0X9814","GroupLevel":"Site","Numerator":27,"Denominator":288,"Metric":0.0938,"Score":-0.5374,"Flag":0},{"GroupID":"0X2638","GroupLevel":"Site","Numerator":12,"Denominator":128,"Metric":0.0938,"Score":-0.3583,"Flag":0},{"GroupID":"0X6900","GroupLevel":"Site","Numerator":37,"Denominator":396,"Metric":0.0934,"Score":-0.6429,"Flag":0},{"GroupID":"0X5478","GroupLevel":"Site","Numerator":20,"Denominator":216,"Metric":0.0926,"Score":-0.4998,"Flag":0},{"GroupID":"0X8354","GroupLevel":"Site","Numerator":16,"Denominator":175,"Metric":0.0914,"Score":-0.4811,"Flag":0},{"GroupID":"0X9346","GroupLevel":"Site","Numerator":42,"Denominator":461,"Metric":0.0911,"Score":-0.7948,"Flag":0},{"GroupID":"0X2814","GroupLevel":"Site","Numerator":7,"Denominator":78,"Metric":0.0897,"Score":-0.3513,"Flag":0},{"GroupID":"0X4264","GroupLevel":"Site","Numerator":33,"Denominator":369,"Metric":0.0894,"Score":-0.7762,"Flag":0},{"GroupID":"0X4959","GroupLevel":"Site","Numerator":27,"Denominator":304,"Metric":0.0888,"Score":-0.7262,"Flag":0},{"GroupID":"0X2901","GroupLevel":"Site","Numerator":28,"Denominator":319,"Metric":0.0878,"Score":-0.7815,"Flag":0},{"GroupID":"0X8788","GroupLevel":"Site","Numerator":27,"Denominator":310,"Metric":0.0871,"Score":-0.7946,"Flag":0},{"GroupID":"0X6792","GroupLevel":"Site","Numerator":22,"Denominator":257,"Metric":0.0856,"Score":-0.7719,"Flag":0},{"GroupID":"0X334","GroupLevel":"Site","Numerator":16,"Denominator":188,"Metric":0.0851,"Score":-0.674,"Flag":0},{"GroupID":"0X6980","GroupLevel":"Site","Numerator":12,"Denominator":141,"Metric":0.0851,"Score":-0.5837,"Flag":0},{"GroupID":"0X6590","GroupLevel":"Site","Numerator":14,"Denominator":165,"Metric":0.0848,"Score":-0.6381,"Flag":0},{"GroupID":"0X7438","GroupLevel":"Site","Numerator":3,"Denominator":36,"Metric":0.0833,"Score":-0.3165,"Flag":0},{"GroupID":"0X4707","GroupLevel":"Site","Numerator":8,"Denominator":97,"Metric":0.0825,"Score":-0.5366,"Flag":0},{"GroupID":"0X2309","GroupLevel":"Site","Numerator":21,"Denominator":255,"Metric":0.0824,"Score":-0.8739,"Flag":0},{"GroupID":"0X3136","GroupLevel":"Site","Numerator":14,"Denominator":170,"Metric":0.0824,"Score":-0.7136,"Flag":0},{"GroupID":"0X7447","GroupLevel":"Site","Numerator":11,"Denominator":140,"Metric":0.0786,"Score":-0.7381,"Flag":0},{"GroupID":"0X3989","GroupLevel":"Site","Numerator":11,"Denominator":150,"Metric":0.0733,"Score":-0.8938,"Flag":0},{"GroupID":"0X9683","GroupLevel":"Site","Numerator":5,"Denominator":69,"Metric":0.0725,"Score":-0.6208,"Flag":0},{"GroupID":"0X2865","GroupLevel":"Site","Numerator":5,"Denominator":71,"Metric":0.0704,"Score":-0.6645,"Flag":0},{"GroupID":"0X6930","GroupLevel":"Site","Numerator":3,"Denominator":45,"Metric":0.0667,"Score":-0.58,"Flag":0},{"GroupID":"0X3083","GroupLevel":"Site","Numerator":3,"Denominator":48,"Metric":0.0625,"Score":-0.6575,"Flag":0},{"GroupID":"0X1109","GroupLevel":"Site","Numerator":2,"Denominator":32,"Metric":0.0625,"Score":-0.5368,"Flag":0},{"GroupID":"0X8494","GroupLevel":"Site","Numerator":2,"Denominator":40,"Metric":0.05,"Score":-0.7601,"Flag":0},{"GroupID":"0X7844","GroupLevel":"Site","Numerator":7,"Denominator":14,"Metric":0.5,"Score":"NA","Flag":"NA"},{"GroupID":"0X283","GroupLevel":"Site","Numerator":4,"Denominator":12,"Metric":0.3333,"Score":"NA","Flag":"NA"},{"GroupID":"0X3777","GroupLevel":"Site","Numerator":4,"Denominator":13,"Metric":0.3077,"Score":"NA","Flag":"NA"},{"GroupID":"0X3214","GroupLevel":"Site","Numerator":7,"Denominator":25,"Metric":0.28,"Score":"NA","Flag":"NA"},{"GroupID":"0X3565","GroupLevel":"Site","Numerator":4,"Denominator":16,"Metric":0.25,"Score":"NA","Flag":"NA"},{"GroupID":"0X155","GroupLevel":"Site","Numerator":3,"Denominator":13,"Metric":0.2308,"Score":"NA","Flag":"NA"},{"GroupID":"0X439","GroupLevel":"Site","Numerator":5,"Denominator":23,"Metric":0.2174,"Score":"NA","Flag":"NA"},{"GroupID":"0X6041","GroupLevel":"Site","Numerator":6,"Denominator":29,"Metric":0.2069,"Score":"NA","Flag":"NA"},{"GroupID":"0X8547","GroupLevel":"Site","Numerator":5,"Denominator":26,"Metric":0.1923,"Score":"NA","Flag":"NA"},{"GroupID":"0X5503","GroupLevel":"Site","Numerator":4,"Denominator":25,"Metric":0.16,"Score":"NA","Flag":"NA"},{"GroupID":"0X8592","GroupLevel":"Site","Numerator":4,"Denominator":28,"Metric":0.1429,"Score":"NA","Flag":"NA"},{"GroupID":"0X9364","GroupLevel":"Site","Numerator":4,"Denominator":29,"Metric":0.1379,"Score":"NA","Flag":"NA"},{"GroupID":"0X1800","GroupLevel":"Site","Numerator":3,"Denominator":24,"Metric":0.125,"Score":"NA","Flag":"NA"},{"GroupID":"0X2508","GroupLevel":"Site","Numerator":2,"Denominator":17,"Metric":0.1176,"Score":"NA","Flag":"NA"},{"GroupID":"0X3857","GroupLevel":"Site","Numerator":2,"Denominator":17,"Metric":0.1176,"Score":"NA","Flag":"NA"},{"GroupID":"0X4185","GroupLevel":"Site","Numerator":2,"Denominator":20,"Metric":0.1,"Score":"NA","Flag":"NA"},{"GroupID":"0X3556","GroupLevel":"Site","Numerator":1,"Denominator":10,"Metric":0.1,"Score":"NA","Flag":"NA"},{"GroupID":"0X5579","GroupLevel":"Site","Numerator":1,"Denominator":12,"Metric":0.0833,"Score":"NA","Flag":"NA"},{"GroupID":"0X5182","GroupLevel":"Site","Numerator":1,"Denominator":14,"Metric":0.0714,"Score":"NA","Flag":"NA"},{"GroupID":"0X7147","GroupLevel":"Site","Numerator":1,"Denominator":18,"Metric":0.0556,"Score":"NA","Flag":"NA"}],"lMetric":{"Metric":"Adverse Event Rate","Numerator":"Adverse Events","Denominator":"Days on Study"},"dfGroups":null,"vThreshold":null,"lChartConfig":{"Metric":"Adverse Event Rate","Numerator":"Adverse Events","Denominator":"Days on Study","y":"Score"},"strOutcome":"Score","bAddGroupSelect":true,"strShinyGroupSelectID":"GroupID","bDebug":false},"evals":[],"jsHooks":[]}</script>
</div>
<div id="bar-chart---numerator" class="section level4">
<h4>Bar Chart - Numerator</h4>
<pre class="r"><code>Widget_BarChart(dfResults = AE_KRI$Analysis_Summary, lMetric=labels, strOutcome=&quot;Numerator&quot;)</code></pre>
<div class="Widget_BarChart html-widget html-fill-item" id="htmlwidget-f94f857eabc8112538ff" style="width:672px;height:480px;"></div>
<script type="application/json" data-for="htmlwidget-f94f857eabc8112538ff">{"x":{"dfResults":[{"GroupID":"0X8351","GroupLevel":"Site","Numerator":86,"Denominator":448,"Metric":0.192,"Score":3.5357,"Flag":2},{"GroupID":"0X4323","GroupLevel":"Site","Numerator":47,"Denominator":675,"Metric":0.0696,"Score":-2.0907,"Flag":-2},{"GroupID":"0X6405","GroupLevel":"Site","Numerator":34,"Denominator":521,"Metric":0.0653,"Score":-2.0386,"Flag":-2},{"GroupID":"0X414","GroupLevel":"Site","Numerator":17,"Denominator":68,"Metric":0.25,"Score":2.3458,"Flag":1},{"GroupID":"0X8764","GroupLevel":"Site","Numerator":28,"Denominator":120,"Metric":0.2333,"Score":2.7468,"Flag":1},{"GroupID":"0X4874","GroupLevel":"Site","Numerator":33,"Denominator":173,"Metric":0.1908,"Score":2.1649,"Flag":1},{"GroupID":"0X1257","GroupLevel":"Site","Numerator":31,"Denominator":163,"Metric":0.1902,"Score":2.0867,"Flag":1},{"GroupID":"0X101","GroupLevel":"Site","Numerator":36,"Denominator":197,"Metric":0.1827,"Score":2.0827,"Flag":1},{"GroupID":"0X9737","GroupLevel":"Site","Numerator":39,"Denominator":467,"Metric":0.0835,"Score":-1.132,"Flag":-1},{"GroupID":"0X4629","GroupLevel":"Site","Numerator":35,"Denominator":435,"Metric":0.0805,"Score":-1.2213,"Flag":-1},{"GroupID":"0X759","GroupLevel":"Site","Numerator":42,"Denominator":523,"Metric":0.0803,"Score":-1.3463,"Flag":-1},{"GroupID":"0X8625","GroupLevel":"Site","Numerator":36,"Denominator":481,"Metric":0.0748,"Score":-1.5335,"Flag":-1},{"GroupID":"0X9360","GroupLevel":"Site","Numerator":32,"Denominator":430,"Metric":0.0744,"Score":-1.4677,"Flag":-1},{"GroupID":"0X7228","GroupLevel":"Site","Numerator":15,"Denominator":225,"Metric":0.0667,"Score":-1.297,"Flag":-1},{"GroupID":"0X1137","GroupLevel":"Site","Numerator":13,"Denominator":196,"Metric":0.0663,"Score":-1.2201,"Flag":-1},{"GroupID":"0X8382","GroupLevel":"Site","Numerator":8,"Denominator":125,"Metric":0.064,"Score":-1.027,"Flag":-1},{"GroupID":"0X9862","GroupLevel":"Site","Numerator":10,"Denominator":157,"Metric":0.0637,"Score":-1.1588,"Flag":-1},{"GroupID":"0X3585","GroupLevel":"Site","Numerator":17,"Denominator":270,"Metric":0.063,"Score":-1.5439,"Flag":-1},{"GroupID":"0X4324","GroupLevel":"Site","Numerator":7,"Denominator":120,"Metric":0.0583,"Score":-1.1319,"Flag":-1},{"GroupID":"0X1548","GroupLevel":"Site","Numerator":5,"Denominator":93,"Metric":0.0538,"Score":-1.0856,"Flag":-1},{"GroupID":"0X5362","GroupLevel":"Site","Numerator":5,"Denominator":110,"Metric":0.0455,"Score":-1.357,"Flag":-1},{"GroupID":"0X5137","GroupLevel":"Site","Numerator":1,"Denominator":39,"Metric":0.0256,"Score":-1.0583,"Flag":-1},{"GroupID":"0X5048","GroupLevel":"Site","Numerator":0,"Denominator":42,"Metric":0,"Score":-1.4345,"Flag":-1},{"GroupID":"0X3197","GroupLevel":"Site","Numerator":13,"Denominator":57,"Metric":0.2281,"Score":1.8127,"Flag":0},{"GroupID":"0X9520","GroupLevel":"Site","Numerator":20,"Denominator":97,"Metric":0.2062,"Score":1.9286,"Flag":0},{"GroupID":"0X3736","GroupLevel":"Site","Numerator":19,"Denominator":102,"Metric":0.1863,"Score":1.5708,"Flag":0},{"GroupID":"0X6367","GroupLevel":"Site","Numerator":8,"Denominator":44,"Metric":0.1818,"Score":0.9719,"Flag":0},{"GroupID":"0X8551","GroupLevel":"Site","Numerator":18,"Denominator":105,"Metric":0.1714,"Score":1.286,"Flag":0},{"GroupID":"0X7983","GroupLevel":"Site","Numerator":41,"Denominator":243,"Metric":0.1687,"Score":1.871,"Flag":0},{"GroupID":"0X567","GroupLevel":"Site","Numerator":15,"Denominator":90,"Metric":0.1667,"Score":1.0992,"Flag":0},{"GroupID":"0X3909","GroupLevel":"Site","Numerator":36,"Denominator":216,"Metric":0.1667,"Score":1.7028,"Flag":0},{"GroupID":"0X2397","GroupLevel":"Site","Numerator":17,"Denominator":105,"Metric":0.1619,"Score":1.0885,"Flag":0},{"GroupID":"0X8823","GroupLevel":"Site","Numerator":18,"Denominator":112,"Metric":0.1607,"Score":1.0987,"Flag":0},{"GroupID":"0X3639","GroupLevel":"Site","Numerator":7,"Denominator":44,"Metric":0.1591,"Score":0.6669,"Flag":0},{"GroupID":"0X7789","GroupLevel":"Site","Numerator":7,"Denominator":44,"Metric":0.1591,"Score":0.6669,"Flag":0},{"GroupID":"0X8669","GroupLevel":"Site","Numerator":10,"Denominator":64,"Metric":0.1562,"Score":0.7583,"Flag":0},{"GroupID":"0X1982","GroupLevel":"Site","Numerator":25,"Denominator":164,"Metric":0.1524,"Score":1.1151,"Flag":0},{"GroupID":"0X9580","GroupLevel":"Site","Numerator":36,"Denominator":238,"Metric":0.1513,"Score":1.3066,"Flag":0},{"GroupID":"0X6603","GroupLevel":"Site","Numerator":36,"Denominator":239,"Metric":0.1506,"Score":1.2895,"Flag":0},{"GroupID":"0X5384","GroupLevel":"Site","Numerator":58,"Denominator":399,"Metric":0.1454,"Score":1.4534,"Flag":0},{"GroupID":"0X5782","GroupLevel":"Site","Numerator":9,"Denominator":62,"Metric":0.1452,"Score":0.5697,"Flag":0},{"GroupID":"0X9381","GroupLevel":"Site","Numerator":8,"Denominator":56,"Metric":0.1429,"Score":0.5065,"Flag":0},{"GroupID":"0X180","GroupLevel":"Site","Numerator":39,"Denominator":281,"Metric":0.1388,"Score":0.9967,"Flag":0},{"GroupID":"0X2376","GroupLevel":"Site","Numerator":17,"Denominator":123,"Metric":0.1382,"Score":0.6465,"Flag":0},{"GroupID":"0X3252","GroupLevel":"Site","Numerator":6,"Denominator":44,"Metric":0.1364,"Score":0.3618,"Flag":0},{"GroupID":"0X6521","GroupLevel":"Site","Numerator":7,"Denominator":52,"Metric":0.1346,"Score":0.3679,"Flag":0},{"GroupID":"0X3289","GroupLevel":"Site","Numerator":37,"Denominator":275,"Metric":0.1345,"Score":0.8436,"Flag":0},{"GroupID":"0X5033","GroupLevel":"Site","Numerator":28,"Denominator":210,"Metric":0.1333,"Score":0.7017,"Flag":0},{"GroupID":"0X7011","GroupLevel":"Site","Numerator":55,"Denominator":416,"Metric":0.1322,"Score":0.9413,"Flag":0},{"GroupID":"0X7513","GroupLevel":"Site","Numerator":25,"Denominator":191,"Metric":0.1309,"Score":0.6009,"Flag":0},{"GroupID":"0X905","GroupLevel":"Site","Numerator":6,"Denominator":46,"Metric":0.1304,"Score":0.2886,"Flag":0},{"GroupID":"0X2574","GroupLevel":"Site","Numerator":21,"Denominator":161,"Metric":0.1304,"Score":0.54,"Flag":0},{"GroupID":"0X6301","GroupLevel":"Site","Numerator":11,"Denominator":86,"Metric":0.1279,"Score":0.3472,"Flag":0},{"GroupID":"0X1839","GroupLevel":"Site","Numerator":24,"Denominator":190,"Metric":0.1263,"Score":0.4717,"Flag":0},{"GroupID":"0X5787","GroupLevel":"Site","Numerator":23,"Denominator":185,"Metric":0.1243,"Score":0.4107,"Flag":0},{"GroupID":"0X2002","GroupLevel":"Site","Numerator":9,"Denominator":73,"Metric":0.1233,"Score":0.24,"Flag":0},{"GroupID":"0X3090","GroupLevel":"Site","Numerator":26,"Denominator":213,"Metric":0.1221,"Score":0.3739,"Flag":0},{"GroupID":"0X2323","GroupLevel":"Site","Numerator":36,"Denominator":295,"Metric":0.122,"Score":0.439,"Flag":0},{"GroupID":"0X2513","GroupLevel":"Site","Numerator":5,"Denominator":41,"Metric":0.122,"Score":0.1626,"Flag":0},{"GroupID":"0X5895","GroupLevel":"Site","Numerator":64,"Denominator":526,"Metric":0.1217,"Score":0.5694,"Flag":0},{"GroupID":"0X6384","GroupLevel":"Site","Numerator":22,"Denominator":184,"Metric":0.1196,"Score":0.2789,"Flag":0},{"GroupID":"0X7656","GroupLevel":"Site","Numerator":12,"Denominator":101,"Metric":0.1188,"Score":0.1913,"Flag":0},{"GroupID":"0X213","GroupLevel":"Site","Numerator":88,"Denominator":742,"Metric":0.1186,"Score":0.5069,"Flag":0},{"GroupID":"0X7938","GroupLevel":"Site","Numerator":14,"Denominator":119,"Metric":0.1176,"Score":0.182,"Flag":0},{"GroupID":"0X956","GroupLevel":"Site","Numerator":18,"Denominator":153,"Metric":0.1176,"Score":0.2063,"Flag":0},{"GroupID":"0X8091","GroupLevel":"Site","Numerator":33,"Denominator":287,"Metric":0.115,"Score":0.1913,"Flag":0},{"GroupID":"0X2170","GroupLevel":"Site","Numerator":49,"Denominator":428,"Metric":0.1145,"Score":0.2128,"Flag":0},{"GroupID":"0X2532","GroupLevel":"Site","Numerator":53,"Denominator":466,"Metric":0.1137,"Score":0.1892,"Flag":0},{"GroupID":"0X9142","GroupLevel":"Site","Numerator":92,"Denominator":812,"Metric":0.1133,"Score":0.2248,"Flag":0},{"GroupID":"0X4561","GroupLevel":"Site","Numerator":17,"Denominator":151,"Metric":0.1126,"Score":0.0791,"Flag":0},{"GroupID":"0X7809","GroupLevel":"Site","Numerator":41,"Denominator":366,"Metric":0.112,"Score":0.1014,"Flag":0},{"GroupID":"0X2192","GroupLevel":"Site","Numerator":70,"Denominator":633,"Metric":0.1106,"Score":0.0602,"Flag":0},{"GroupID":"0X5788","GroupLevel":"Site","Numerator":20,"Denominator":184,"Metric":0.1087,"Score":-0.0194,"Flag":0},{"GroupID":"0X5386","GroupLevel":"Site","Numerator":5,"Denominator":46,"Metric":0.1087,"Score":-0.0097,"Flag":0},{"GroupID":"0X3574","GroupLevel":"Site","Numerator":18,"Denominator":166,"Metric":0.1084,"Score":-0.0252,"Flag":0},{"GroupID":"0X9210","GroupLevel":"Site","Numerator":4,"Denominator":37,"Metric":0.1081,"Score":-0.0159,"Flag":0},{"GroupID":"0X2123","GroupLevel":"Site","Numerator":15,"Denominator":140,"Metric":0.1071,"Score":-0.0541,"Flag":0},{"GroupID":"0X5808","GroupLevel":"Site","Numerator":6,"Denominator":56,"Metric":0.1071,"Score":-0.0342,"Flag":0},{"GroupID":"0X203","GroupLevel":"Site","Numerator":11,"Denominator":103,"Metric":0.1068,"Score":-0.0535,"Flag":0},{"GroupID":"0X8508","GroupLevel":"Site","Numerator":26,"Denominator":245,"Metric":0.1061,"Score":-0.1039,"Flag":0},{"GroupID":"0X4485","GroupLevel":"Site","Numerator":42,"Denominator":396,"Metric":0.1061,"Score":-0.1345,"Flag":0},{"GroupID":"0X1910","GroupLevel":"Site","Numerator":32,"Denominator":305,"Metric":0.1049,"Score":-0.1584,"Flag":0},{"GroupID":"0X7349","GroupLevel":"Site","Numerator":5,"Denominator":48,"Metric":0.1042,"Score":-0.0734,"Flag":0},{"GroupID":"0X9017","GroupLevel":"Site","Numerator":17,"Denominator":164,"Metric":0.1037,"Score":-0.1488,"Flag":0},{"GroupID":"0X2355","GroupLevel":"Site","Numerator":13,"Denominator":128,"Metric":0.1016,"Score":-0.1794,"Flag":0},{"GroupID":"0X4590","GroupLevel":"Site","Numerator":49,"Denominator":483,"Metric":0.1014,"Score":-0.3536,"Flag":0},{"GroupID":"0X2318","GroupLevel":"Site","Numerator":14,"Denominator":138,"Metric":0.1014,"Score":-0.189,"Flag":0},{"GroupID":"0X958","GroupLevel":"Site","Numerator":32,"Denominator":316,"Metric":0.1013,"Score":-0.2926,"Flag":0},{"GroupID":"0X9834","GroupLevel":"Site","Numerator":15,"Denominator":149,"Metric":0.1007,"Score":-0.2156,"Flag":0},{"GroupID":"0X8517","GroupLevel":"Site","Numerator":38,"Denominator":378,"Metric":0.1005,"Score":-0.349,"Flag":0},{"GroupID":"0X8799","GroupLevel":"Site","Numerator":46,"Denominator":458,"Metric":0.1004,"Score":-0.3882,"Flag":0},{"GroupID":"0X8591","GroupLevel":"Site","Numerator":3,"Denominator":30,"Metric":0.1,"Score":-0.1042,"Flag":0},{"GroupID":"0X4130","GroupLevel":"Site","Numerator":12,"Denominator":122,"Metric":0.0984,"Score":-0.2467,"Flag":0},{"GroupID":"0X9858","GroupLevel":"Site","Numerator":12,"Denominator":122,"Metric":0.0984,"Score":-0.2467,"Flag":0},{"GroupID":"0X9860","GroupLevel":"Site","Numerator":4,"Denominator":41,"Metric":0.0976,"Score":-0.1534,"Flag":0},{"GroupID":"0X8633","GroupLevel":"Site","Numerator":61,"Denominator":633,"Metric":0.0964,"Score":-0.6636,"Flag":0},{"GroupID":"0X1750","GroupLevel":"Site","Numerator":32,"Denominator":336,"Metric":0.0952,"Score":-0.5253,"Flag":0},{"GroupID":"0X8786","GroupLevel":"Site","Numerator":38,"Denominator":401,"Metric":0.0948,"Score":-0.5931,"Flag":0},{"GroupID":"0X9814","GroupLevel":"Site","Numerator":27,"Denominator":288,"Metric":0.0938,"Score":-0.5374,"Flag":0},{"GroupID":"0X2638","GroupLevel":"Site","Numerator":12,"Denominator":128,"Metric":0.0938,"Score":-0.3583,"Flag":0},{"GroupID":"0X6900","GroupLevel":"Site","Numerator":37,"Denominator":396,"Metric":0.0934,"Score":-0.6429,"Flag":0},{"GroupID":"0X5478","GroupLevel":"Site","Numerator":20,"Denominator":216,"Metric":0.0926,"Score":-0.4998,"Flag":0},{"GroupID":"0X8354","GroupLevel":"Site","Numerator":16,"Denominator":175,"Metric":0.0914,"Score":-0.4811,"Flag":0},{"GroupID":"0X9346","GroupLevel":"Site","Numerator":42,"Denominator":461,"Metric":0.0911,"Score":-0.7948,"Flag":0},{"GroupID":"0X2814","GroupLevel":"Site","Numerator":7,"Denominator":78,"Metric":0.0897,"Score":-0.3513,"Flag":0},{"GroupID":"0X4264","GroupLevel":"Site","Numerator":33,"Denominator":369,"Metric":0.0894,"Score":-0.7762,"Flag":0},{"GroupID":"0X4959","GroupLevel":"Site","Numerator":27,"Denominator":304,"Metric":0.0888,"Score":-0.7262,"Flag":0},{"GroupID":"0X2901","GroupLevel":"Site","Numerator":28,"Denominator":319,"Metric":0.0878,"Score":-0.7815,"Flag":0},{"GroupID":"0X8788","GroupLevel":"Site","Numerator":27,"Denominator":310,"Metric":0.0871,"Score":-0.7946,"Flag":0},{"GroupID":"0X6792","GroupLevel":"Site","Numerator":22,"Denominator":257,"Metric":0.0856,"Score":-0.7719,"Flag":0},{"GroupID":"0X334","GroupLevel":"Site","Numerator":16,"Denominator":188,"Metric":0.0851,"Score":-0.674,"Flag":0},{"GroupID":"0X6980","GroupLevel":"Site","Numerator":12,"Denominator":141,"Metric":0.0851,"Score":-0.5837,"Flag":0},{"GroupID":"0X6590","GroupLevel":"Site","Numerator":14,"Denominator":165,"Metric":0.0848,"Score":-0.6381,"Flag":0},{"GroupID":"0X7438","GroupLevel":"Site","Numerator":3,"Denominator":36,"Metric":0.0833,"Score":-0.3165,"Flag":0},{"GroupID":"0X4707","GroupLevel":"Site","Numerator":8,"Denominator":97,"Metric":0.0825,"Score":-0.5366,"Flag":0},{"GroupID":"0X2309","GroupLevel":"Site","Numerator":21,"Denominator":255,"Metric":0.0824,"Score":-0.8739,"Flag":0},{"GroupID":"0X3136","GroupLevel":"Site","Numerator":14,"Denominator":170,"Metric":0.0824,"Score":-0.7136,"Flag":0},{"GroupID":"0X7447","GroupLevel":"Site","Numerator":11,"Denominator":140,"Metric":0.0786,"Score":-0.7381,"Flag":0},{"GroupID":"0X3989","GroupLevel":"Site","Numerator":11,"Denominator":150,"Metric":0.0733,"Score":-0.8938,"Flag":0},{"GroupID":"0X9683","GroupLevel":"Site","Numerator":5,"Denominator":69,"Metric":0.0725,"Score":-0.6208,"Flag":0},{"GroupID":"0X2865","GroupLevel":"Site","Numerator":5,"Denominator":71,"Metric":0.0704,"Score":-0.6645,"Flag":0},{"GroupID":"0X6930","GroupLevel":"Site","Numerator":3,"Denominator":45,"Metric":0.0667,"Score":-0.58,"Flag":0},{"GroupID":"0X3083","GroupLevel":"Site","Numerator":3,"Denominator":48,"Metric":0.0625,"Score":-0.6575,"Flag":0},{"GroupID":"0X1109","GroupLevel":"Site","Numerator":2,"Denominator":32,"Metric":0.0625,"Score":-0.5368,"Flag":0},{"GroupID":"0X8494","GroupLevel":"Site","Numerator":2,"Denominator":40,"Metric":0.05,"Score":-0.7601,"Flag":0},{"GroupID":"0X7844","GroupLevel":"Site","Numerator":7,"Denominator":14,"Metric":0.5,"Score":"NA","Flag":"NA"},{"GroupID":"0X283","GroupLevel":"Site","Numerator":4,"Denominator":12,"Metric":0.3333,"Score":"NA","Flag":"NA"},{"GroupID":"0X3777","GroupLevel":"Site","Numerator":4,"Denominator":13,"Metric":0.3077,"Score":"NA","Flag":"NA"},{"GroupID":"0X3214","GroupLevel":"Site","Numerator":7,"Denominator":25,"Metric":0.28,"Score":"NA","Flag":"NA"},{"GroupID":"0X3565","GroupLevel":"Site","Numerator":4,"Denominator":16,"Metric":0.25,"Score":"NA","Flag":"NA"},{"GroupID":"0X155","GroupLevel":"Site","Numerator":3,"Denominator":13,"Metric":0.2308,"Score":"NA","Flag":"NA"},{"GroupID":"0X439","GroupLevel":"Site","Numerator":5,"Denominator":23,"Metric":0.2174,"Score":"NA","Flag":"NA"},{"GroupID":"0X6041","GroupLevel":"Site","Numerator":6,"Denominator":29,"Metric":0.2069,"Score":"NA","Flag":"NA"},{"GroupID":"0X8547","GroupLevel":"Site","Numerator":5,"Denominator":26,"Metric":0.1923,"Score":"NA","Flag":"NA"},{"GroupID":"0X5503","GroupLevel":"Site","Numerator":4,"Denominator":25,"Metric":0.16,"Score":"NA","Flag":"NA"},{"GroupID":"0X8592","GroupLevel":"Site","Numerator":4,"Denominator":28,"Metric":0.1429,"Score":"NA","Flag":"NA"},{"GroupID":"0X9364","GroupLevel":"Site","Numerator":4,"Denominator":29,"Metric":0.1379,"Score":"NA","Flag":"NA"},{"GroupID":"0X1800","GroupLevel":"Site","Numerator":3,"Denominator":24,"Metric":0.125,"Score":"NA","Flag":"NA"},{"GroupID":"0X2508","GroupLevel":"Site","Numerator":2,"Denominator":17,"Metric":0.1176,"Score":"NA","Flag":"NA"},{"GroupID":"0X3857","GroupLevel":"Site","Numerator":2,"Denominator":17,"Metric":0.1176,"Score":"NA","Flag":"NA"},{"GroupID":"0X4185","GroupLevel":"Site","Numerator":2,"Denominator":20,"Metric":0.1,"Score":"NA","Flag":"NA"},{"GroupID":"0X3556","GroupLevel":"Site","Numerator":1,"Denominator":10,"Metric":0.1,"Score":"NA","Flag":"NA"},{"GroupID":"0X5579","GroupLevel":"Site","Numerator":1,"Denominator":12,"Metric":0.0833,"Score":"NA","Flag":"NA"},{"GroupID":"0X5182","GroupLevel":"Site","Numerator":1,"Denominator":14,"Metric":0.0714,"Score":"NA","Flag":"NA"},{"GroupID":"0X7147","GroupLevel":"Site","Numerator":1,"Denominator":18,"Metric":0.0556,"Score":"NA","Flag":"NA"}],"lMetric":{"Metric":"Adverse Event Rate","Numerator":"Adverse Events","Denominator":"Days on Study"},"dfGroups":null,"vThreshold":null,"lChartConfig":{"Metric":"Adverse Event Rate","Numerator":"Adverse Events","Denominator":"Days on Study","y":"Numerator"},"strOutcome":"Numerator","bAddGroupSelect":true,"strShinyGroupSelectID":"GroupID","bDebug":false},"evals":[],"jsHooks":[]}</script>
</div>
<div id="scatter-plot-with-confidence-bounds" class="section level4">
<h4>Scatter Plot with Confidence Bounds</h4>
<pre class="r"><code>dfBounds &lt;- Analyze_NormalApprox_PredictBounds(AE_KRI$Analysis_Transformed, vThreshold = c(-3,-2,2,3))</code></pre>
<pre><code>#&gt; nStep was not provided. Setting default step to 3.208.</code></pre>
<pre class="r"><code>Widget_ScatterPlot(AE_KRI$Analysis_Summary, lMetric = labels, dfBounds = dfBounds)</code></pre>
<div class="Widget_ScatterPlot html-widget html-fill-item" id="htmlwidget-01169a0691b82df29584" style="width:672px;height:480px;"></div>
<script type="application/json" data-for="htmlwidget-01169a0691b82df29584">{"x":{"dfResults":[{"GroupID":"0X8351","GroupLevel":"Site","Numerator":86,"Denominator":448,"Metric":0.192,"Score":3.5357,"Flag":2},{"GroupID":"0X4323","GroupLevel":"Site","Numerator":47,"Denominator":675,"Metric":0.0696,"Score":-2.0907,"Flag":-2},{"GroupID":"0X6405","GroupLevel":"Site","Numerator":34,"Denominator":521,"Metric":0.0653,"Score":-2.0386,"Flag":-2},{"GroupID":"0X414","GroupLevel":"Site","Numerator":17,"Denominator":68,"Metric":0.25,"Score":2.3458,"Flag":1},{"GroupID":"0X8764","GroupLevel":"Site","Numerator":28,"Denominator":120,"Metric":0.2333,"Score":2.7468,"Flag":1},{"GroupID":"0X4874","GroupLevel":"Site","Numerator":33,"Denominator":173,"Metric":0.1908,"Score":2.1649,"Flag":1},{"GroupID":"0X1257","GroupLevel":"Site","Numerator":31,"Denominator":163,"Metric":0.1902,"Score":2.0867,"Flag":1},{"GroupID":"0X101","GroupLevel":"Site","Numerator":36,"Denominator":197,"Metric":0.1827,"Score":2.0827,"Flag":1},{"GroupID":"0X9737","GroupLevel":"Site","Numerator":39,"Denominator":467,"Metric":0.0835,"Score":-1.132,"Flag":-1},{"GroupID":"0X4629","GroupLevel":"Site","Numerator":35,"Denominator":435,"Metric":0.0805,"Score":-1.2213,"Flag":-1},{"GroupID":"0X759","GroupLevel":"Site","Numerator":42,"Denominator":523,"Metric":0.0803,"Score":-1.3463,"Flag":-1},{"GroupID":"0X8625","GroupLevel":"Site","Numerator":36,"Denominator":481,"Metric":0.0748,"Score":-1.5335,"Flag":-1},{"GroupID":"0X9360","GroupLevel":"Site","Numerator":32,"Denominator":430,"Metric":0.0744,"Score":-1.4677,"Flag":-1},{"GroupID":"0X7228","GroupLevel":"Site","Numerator":15,"Denominator":225,"Metric":0.0667,"Score":-1.297,"Flag":-1},{"GroupID":"0X1137","GroupLevel":"Site","Numerator":13,"Denominator":196,"Metric":0.0663,"Score":-1.2201,"Flag":-1},{"GroupID":"0X8382","GroupLevel":"Site","Numerator":8,"Denominator":125,"Metric":0.064,"Score":-1.027,"Flag":-1},{"GroupID":"0X9862","GroupLevel":"Site","Numerator":10,"Denominator":157,"Metric":0.0637,"Score":-1.1588,"Flag":-1},{"GroupID":"0X3585","GroupLevel":"Site","Numerator":17,"Denominator":270,"Metric":0.063,"Score":-1.5439,"Flag":-1},{"GroupID":"0X4324","GroupLevel":"Site","Numerator":7,"Denominator":120,"Metric":0.0583,"Score":-1.1319,"Flag":-1},{"GroupID":"0X1548","GroupLevel":"Site","Numerator":5,"Denominator":93,"Metric":0.0538,"Score":-1.0856,"Flag":-1},{"GroupID":"0X5362","GroupLevel":"Site","Numerator":5,"Denominator":110,"Metric":0.0455,"Score":-1.357,"Flag":-1},{"GroupID":"0X5137","GroupLevel":"Site","Numerator":1,"Denominator":39,"Metric":0.0256,"Score":-1.0583,"Flag":-1},{"GroupID":"0X5048","GroupLevel":"Site","Numerator":0,"Denominator":42,"Metric":0,"Score":-1.4345,"Flag":-1},{"GroupID":"0X3197","GroupLevel":"Site","Numerator":13,"Denominator":57,"Metric":0.2281,"Score":1.8127,"Flag":0},{"GroupID":"0X9520","GroupLevel":"Site","Numerator":20,"Denominator":97,"Metric":0.2062,"Score":1.9286,"Flag":0},{"GroupID":"0X3736","GroupLevel":"Site","Numerator":19,"Denominator":102,"Metric":0.1863,"Score":1.5708,"Flag":0},{"GroupID":"0X6367","GroupLevel":"Site","Numerator":8,"Denominator":44,"Metric":0.1818,"Score":0.9719,"Flag":0},{"GroupID":"0X8551","GroupLevel":"Site","Numerator":18,"Denominator":105,"Metric":0.1714,"Score":1.286,"Flag":0},{"GroupID":"0X7983","GroupLevel":"Site","Numerator":41,"Denominator":243,"Metric":0.1687,"Score":1.871,"Flag":0},{"GroupID":"0X567","GroupLevel":"Site","Numerator":15,"Denominator":90,"Metric":0.1667,"Score":1.0992,"Flag":0},{"GroupID":"0X3909","GroupLevel":"Site","Numerator":36,"Denominator":216,"Metric":0.1667,"Score":1.7028,"Flag":0},{"GroupID":"0X2397","GroupLevel":"Site","Numerator":17,"Denominator":105,"Metric":0.1619,"Score":1.0885,"Flag":0},{"GroupID":"0X8823","GroupLevel":"Site","Numerator":18,"Denominator":112,"Metric":0.1607,"Score":1.0987,"Flag":0},{"GroupID":"0X3639","GroupLevel":"Site","Numerator":7,"Denominator":44,"Metric":0.1591,"Score":0.6669,"Flag":0},{"GroupID":"0X7789","GroupLevel":"Site","Numerator":7,"Denominator":44,"Metric":0.1591,"Score":0.6669,"Flag":0},{"GroupID":"0X8669","GroupLevel":"Site","Numerator":10,"Denominator":64,"Metric":0.1562,"Score":0.7583,"Flag":0},{"GroupID":"0X1982","GroupLevel":"Site","Numerator":25,"Denominator":164,"Metric":0.1524,"Score":1.1151,"Flag":0},{"GroupID":"0X9580","GroupLevel":"Site","Numerator":36,"Denominator":238,"Metric":0.1513,"Score":1.3066,"Flag":0},{"GroupID":"0X6603","GroupLevel":"Site","Numerator":36,"Denominator":239,"Metric":0.1506,"Score":1.2895,"Flag":0},{"GroupID":"0X5384","GroupLevel":"Site","Numerator":58,"Denominator":399,"Metric":0.1454,"Score":1.4534,"Flag":0},{"GroupID":"0X5782","GroupLevel":"Site","Numerator":9,"Denominator":62,"Metric":0.1452,"Score":0.5697,"Flag":0},{"GroupID":"0X9381","GroupLevel":"Site","Numerator":8,"Denominator":56,"Metric":0.1429,"Score":0.5065,"Flag":0},{"GroupID":"0X180","GroupLevel":"Site","Numerator":39,"Denominator":281,"Metric":0.1388,"Score":0.9967,"Flag":0},{"GroupID":"0X2376","GroupLevel":"Site","Numerator":17,"Denominator":123,"Metric":0.1382,"Score":0.6465,"Flag":0},{"GroupID":"0X3252","GroupLevel":"Site","Numerator":6,"Denominator":44,"Metric":0.1364,"Score":0.3618,"Flag":0},{"GroupID":"0X6521","GroupLevel":"Site","Numerator":7,"Denominator":52,"Metric":0.1346,"Score":0.3679,"Flag":0},{"GroupID":"0X3289","GroupLevel":"Site","Numerator":37,"Denominator":275,"Metric":0.1345,"Score":0.8436,"Flag":0},{"GroupID":"0X5033","GroupLevel":"Site","Numerator":28,"Denominator":210,"Metric":0.1333,"Score":0.7017,"Flag":0},{"GroupID":"0X7011","GroupLevel":"Site","Numerator":55,"Denominator":416,"Metric":0.1322,"Score":0.9413,"Flag":0},{"GroupID":"0X7513","GroupLevel":"Site","Numerator":25,"Denominator":191,"Metric":0.1309,"Score":0.6009,"Flag":0},{"GroupID":"0X905","GroupLevel":"Site","Numerator":6,"Denominator":46,"Metric":0.1304,"Score":0.2886,"Flag":0},{"GroupID":"0X2574","GroupLevel":"Site","Numerator":21,"Denominator":161,"Metric":0.1304,"Score":0.54,"Flag":0},{"GroupID":"0X6301","GroupLevel":"Site","Numerator":11,"Denominator":86,"Metric":0.1279,"Score":0.3472,"Flag":0},{"GroupID":"0X1839","GroupLevel":"Site","Numerator":24,"Denominator":190,"Metric":0.1263,"Score":0.4717,"Flag":0},{"GroupID":"0X5787","GroupLevel":"Site","Numerator":23,"Denominator":185,"Metric":0.1243,"Score":0.4107,"Flag":0},{"GroupID":"0X2002","GroupLevel":"Site","Numerator":9,"Denominator":73,"Metric":0.1233,"Score":0.24,"Flag":0},{"GroupID":"0X3090","GroupLevel":"Site","Numerator":26,"Denominator":213,"Metric":0.1221,"Score":0.3739,"Flag":0},{"GroupID":"0X2323","GroupLevel":"Site","Numerator":36,"Denominator":295,"Metric":0.122,"Score":0.439,"Flag":0},{"GroupID":"0X2513","GroupLevel":"Site","Numerator":5,"Denominator":41,"Metric":0.122,"Score":0.1626,"Flag":0},{"GroupID":"0X5895","GroupLevel":"Site","Numerator":64,"Denominator":526,"Metric":0.1217,"Score":0.5694,"Flag":0},{"GroupID":"0X6384","GroupLevel":"Site","Numerator":22,"Denominator":184,"Metric":0.1196,"Score":0.2789,"Flag":0},{"GroupID":"0X7656","GroupLevel":"Site","Numerator":12,"Denominator":101,"Metric":0.1188,"Score":0.1913,"Flag":0},{"GroupID":"0X213","GroupLevel":"Site","Numerator":88,"Denominator":742,"Metric":0.1186,"Score":0.5069,"Flag":0},{"GroupID":"0X7938","GroupLevel":"Site","Numerator":14,"Denominator":119,"Metric":0.1176,"Score":0.182,"Flag":0},{"GroupID":"0X956","GroupLevel":"Site","Numerator":18,"Denominator":153,"Metric":0.1176,"Score":0.2063,"Flag":0},{"GroupID":"0X8091","GroupLevel":"Site","Numerator":33,"Denominator":287,"Metric":0.115,"Score":0.1913,"Flag":0},{"GroupID":"0X2170","GroupLevel":"Site","Numerator":49,"Denominator":428,"Metric":0.1145,"Score":0.2128,"Flag":0},{"GroupID":"0X2532","GroupLevel":"Site","Numerator":53,"Denominator":466,"Metric":0.1137,"Score":0.1892,"Flag":0},{"GroupID":"0X9142","GroupLevel":"Site","Numerator":92,"Denominator":812,"Metric":0.1133,"Score":0.2248,"Flag":0},{"GroupID":"0X4561","GroupLevel":"Site","Numerator":17,"Denominator":151,"Metric":0.1126,"Score":0.0791,"Flag":0},{"GroupID":"0X7809","GroupLevel":"Site","Numerator":41,"Denominator":366,"Metric":0.112,"Score":0.1014,"Flag":0},{"GroupID":"0X2192","GroupLevel":"Site","Numerator":70,"Denominator":633,"Metric":0.1106,"Score":0.0602,"Flag":0},{"GroupID":"0X5788","GroupLevel":"Site","Numerator":20,"Denominator":184,"Metric":0.1087,"Score":-0.0194,"Flag":0},{"GroupID":"0X5386","GroupLevel":"Site","Numerator":5,"Denominator":46,"Metric":0.1087,"Score":-0.0097,"Flag":0},{"GroupID":"0X3574","GroupLevel":"Site","Numerator":18,"Denominator":166,"Metric":0.1084,"Score":-0.0252,"Flag":0},{"GroupID":"0X9210","GroupLevel":"Site","Numerator":4,"Denominator":37,"Metric":0.1081,"Score":-0.0159,"Flag":0},{"GroupID":"0X2123","GroupLevel":"Site","Numerator":15,"Denominator":140,"Metric":0.1071,"Score":-0.0541,"Flag":0},{"GroupID":"0X5808","GroupLevel":"Site","Numerator":6,"Denominator":56,"Metric":0.1071,"Score":-0.0342,"Flag":0},{"GroupID":"0X203","GroupLevel":"Site","Numerator":11,"Denominator":103,"Metric":0.1068,"Score":-0.0535,"Flag":0},{"GroupID":"0X8508","GroupLevel":"Site","Numerator":26,"Denominator":245,"Metric":0.1061,"Score":-0.1039,"Flag":0},{"GroupID":"0X4485","GroupLevel":"Site","Numerator":42,"Denominator":396,"Metric":0.1061,"Score":-0.1345,"Flag":0},{"GroupID":"0X1910","GroupLevel":"Site","Numerator":32,"Denominator":305,"Metric":0.1049,"Score":-0.1584,"Flag":0},{"GroupID":"0X7349","GroupLevel":"Site","Numerator":5,"Denominator":48,"Metric":0.1042,"Score":-0.0734,"Flag":0},{"GroupID":"0X9017","GroupLevel":"Site","Numerator":17,"Denominator":164,"Metric":0.1037,"Score":-0.1488,"Flag":0},{"GroupID":"0X2355","GroupLevel":"Site","Numerator":13,"Denominator":128,"Metric":0.1016,"Score":-0.1794,"Flag":0},{"GroupID":"0X4590","GroupLevel":"Site","Numerator":49,"Denominator":483,"Metric":0.1014,"Score":-0.3536,"Flag":0},{"GroupID":"0X2318","GroupLevel":"Site","Numerator":14,"Denominator":138,"Metric":0.1014,"Score":-0.189,"Flag":0},{"GroupID":"0X958","GroupLevel":"Site","Numerator":32,"Denominator":316,"Metric":0.1013,"Score":-0.2926,"Flag":0},{"GroupID":"0X9834","GroupLevel":"Site","Numerator":15,"Denominator":149,"Metric":0.1007,"Score":-0.2156,"Flag":0},{"GroupID":"0X8517","GroupLevel":"Site","Numerator":38,"Denominator":378,"Metric":0.1005,"Score":-0.349,"Flag":0},{"GroupID":"0X8799","GroupLevel":"Site","Numerator":46,"Denominator":458,"Metric":0.1004,"Score":-0.3882,"Flag":0},{"GroupID":"0X8591","GroupLevel":"Site","Numerator":3,"Denominator":30,"Metric":0.1,"Score":-0.1042,"Flag":0},{"GroupID":"0X4130","GroupLevel":"Site","Numerator":12,"Denominator":122,"Metric":0.0984,"Score":-0.2467,"Flag":0},{"GroupID":"0X9858","GroupLevel":"Site","Numerator":12,"Denominator":122,"Metric":0.0984,"Score":-0.2467,"Flag":0},{"GroupID":"0X9860","GroupLevel":"Site","Numerator":4,"Denominator":41,"Metric":0.0976,"Score":-0.1534,"Flag":0},{"GroupID":"0X8633","GroupLevel":"Site","Numerator":61,"Denominator":633,"Metric":0.0964,"Score":-0.6636,"Flag":0},{"GroupID":"0X1750","GroupLevel":"Site","Numerator":32,"Denominator":336,"Metric":0.0952,"Score":-0.5253,"Flag":0},{"GroupID":"0X8786","GroupLevel":"Site","Numerator":38,"Denominator":401,"Metric":0.0948,"Score":-0.5931,"Flag":0},{"GroupID":"0X9814","GroupLevel":"Site","Numerator":27,"Denominator":288,"Metric":0.0938,"Score":-0.5374,"Flag":0},{"GroupID":"0X2638","GroupLevel":"Site","Numerator":12,"Denominator":128,"Metric":0.0938,"Score":-0.3583,"Flag":0},{"GroupID":"0X6900","GroupLevel":"Site","Numerator":37,"Denominator":396,"Metric":0.0934,"Score":-0.6429,"Flag":0},{"GroupID":"0X5478","GroupLevel":"Site","Numerator":20,"Denominator":216,"Metric":0.0926,"Score":-0.4998,"Flag":0},{"GroupID":"0X8354","GroupLevel":"Site","Numerator":16,"Denominator":175,"Metric":0.0914,"Score":-0.4811,"Flag":0},{"GroupID":"0X9346","GroupLevel":"Site","Numerator":42,"Denominator":461,"Metric":0.0911,"Score":-0.7948,"Flag":0},{"GroupID":"0X2814","GroupLevel":"Site","Numerator":7,"Denominator":78,"Metric":0.0897,"Score":-0.3513,"Flag":0},{"GroupID":"0X4264","GroupLevel":"Site","Numerator":33,"Denominator":369,"Metric":0.0894,"Score":-0.7762,"Flag":0},{"GroupID":"0X4959","GroupLevel":"Site","Numerator":27,"Denominator":304,"Metric":0.0888,"Score":-0.7262,"Flag":0},{"GroupID":"0X2901","GroupLevel":"Site","Numerator":28,"Denominator":319,"Metric":0.0878,"Score":-0.7815,"Flag":0},{"GroupID":"0X8788","GroupLevel":"Site","Numerator":27,"Denominator":310,"Metric":0.0871,"Score":-0.7946,"Flag":0},{"GroupID":"0X6792","GroupLevel":"Site","Numerator":22,"Denominator":257,"Metric":0.0856,"Score":-0.7719,"Flag":0},{"GroupID":"0X334","GroupLevel":"Site","Numerator":16,"Denominator":188,"Metric":0.0851,"Score":-0.674,"Flag":0},{"GroupID":"0X6980","GroupLevel":"Site","Numerator":12,"Denominator":141,"Metric":0.0851,"Score":-0.5837,"Flag":0},{"GroupID":"0X6590","GroupLevel":"Site","Numerator":14,"Denominator":165,"Metric":0.0848,"Score":-0.6381,"Flag":0},{"GroupID":"0X7438","GroupLevel":"Site","Numerator":3,"Denominator":36,"Metric":0.0833,"Score":-0.3165,"Flag":0},{"GroupID":"0X4707","GroupLevel":"Site","Numerator":8,"Denominator":97,"Metric":0.0825,"Score":-0.5366,"Flag":0},{"GroupID":"0X2309","GroupLevel":"Site","Numerator":21,"Denominator":255,"Metric":0.0824,"Score":-0.8739,"Flag":0},{"GroupID":"0X3136","GroupLevel":"Site","Numerator":14,"Denominator":170,"Metric":0.0824,"Score":-0.7136,"Flag":0},{"GroupID":"0X7447","GroupLevel":"Site","Numerator":11,"Denominator":140,"Metric":0.0786,"Score":-0.7381,"Flag":0},{"GroupID":"0X3989","GroupLevel":"Site","Numerator":11,"Denominator":150,"Metric":0.0733,"Score":-0.8938,"Flag":0},{"GroupID":"0X9683","GroupLevel":"Site","Numerator":5,"Denominator":69,"Metric":0.0725,"Score":-0.6208,"Flag":0},{"GroupID":"0X2865","GroupLevel":"Site","Numerator":5,"Denominator":71,"Metric":0.0704,"Score":-0.6645,"Flag":0},{"GroupID":"0X6930","GroupLevel":"Site","Numerator":3,"Denominator":45,"Metric":0.0667,"Score":-0.58,"Flag":0},{"GroupID":"0X3083","GroupLevel":"Site","Numerator":3,"Denominator":48,"Metric":0.0625,"Score":-0.6575,"Flag":0},{"GroupID":"0X1109","GroupLevel":"Site","Numerator":2,"Denominator":32,"Metric":0.0625,"Score":-0.5368,"Flag":0},{"GroupID":"0X8494","GroupLevel":"Site","Numerator":2,"Denominator":40,"Metric":0.05,"Score":-0.7601,"Flag":0},{"GroupID":"0X7844","GroupLevel":"Site","Numerator":7,"Denominator":14,"Metric":0.5,"Score":"NA","Flag":"NA"},{"GroupID":"0X283","GroupLevel":"Site","Numerator":4,"Denominator":12,"Metric":0.3333,"Score":"NA","Flag":"NA"},{"GroupID":"0X3777","GroupLevel":"Site","Numerator":4,"Denominator":13,"Metric":0.3077,"Score":"NA","Flag":"NA"},{"GroupID":"0X3214","GroupLevel":"Site","Numerator":7,"Denominator":25,"Metric":0.28,"Score":"NA","Flag":"NA"},{"GroupID":"0X3565","GroupLevel":"Site","Numerator":4,"Denominator":16,"Metric":0.25,"Score":"NA","Flag":"NA"},{"GroupID":"0X155","GroupLevel":"Site","Numerator":3,"Denominator":13,"Metric":0.2308,"Score":"NA","Flag":"NA"},{"GroupID":"0X439","GroupLevel":"Site","Numerator":5,"Denominator":23,"Metric":0.2174,"Score":"NA","Flag":"NA"},{"GroupID":"0X6041","GroupLevel":"Site","Numerator":6,"Denominator":29,"Metric":0.2069,"Score":"NA","Flag":"NA"},{"GroupID":"0X8547","GroupLevel":"Site","Numerator":5,"Denominator":26,"Metric":0.1923,"Score":"NA","Flag":"NA"},{"GroupID":"0X5503","GroupLevel":"Site","Numerator":4,"Denominator":25,"Metric":0.16,"Score":"NA","Flag":"NA"},{"GroupID":"0X8592","GroupLevel":"Site","Numerator":4,"Denominator":28,"Metric":0.1429,"Score":"NA","Flag":"NA"},{"GroupID":"0X9364","GroupLevel":"Site","Numerator":4,"Denominator":29,"Metric":0.1379,"Score":"NA","Flag":"NA"},{"GroupID":"0X1800","GroupLevel":"Site","Numerator":3,"Denominator":24,"Metric":0.125,"Score":"NA","Flag":"NA"},{"GroupID":"0X2508","GroupLevel":"Site","Numerator":2,"Denominator":17,"Metric":0.1176,"Score":"NA","Flag":"NA"},{"GroupID":"0X3857","GroupLevel":"Site","Numerator":2,"Denominator":17,"Metric":0.1176,"Score":"NA","Flag":"NA"},{"GroupID":"0X4185","GroupLevel":"Site","Numerator":2,"Denominator":20,"Metric":0.1,"Score":"NA","Flag":"NA"},{"GroupID":"0X3556","GroupLevel":"Site","Numerator":1,"Denominator":10,"Metric":0.1,"Score":"NA","Flag":"NA"},{"GroupID":"0X5579","GroupLevel":"Site","Numerator":1,"Denominator":12,"Metric":0.0833,"Score":"NA","Flag":"NA"},{"GroupID":"0X5182","GroupLevel":"Site","Numerator":1,"Denominator":14,"Metric":0.0714,"Score":"NA","Flag":"NA"},{"GroupID":"0X7147","GroupLevel":"Site","Numerator":1,"Denominator":18,"Metric":0.0556,"Score":"NA","Flag":"NA"}],"lMetric":{"Metric":"Adverse Event Rate","Numerator":"Adverse Events","Denominator":"Days on Study"},"dfGroups":null,"dfBounds":[{"Threshold":-3,"Denominator":186.44,"LogDenominator":5.2281,"Numerator":0.1509,"Metric":0.0008},{"Threshold":-3,"Denominator":189.648,"LogDenominator":5.2452,"Numerator":0.3284,"Metric":0.0017},{"Threshold":-3,"Denominator":192.856,"LogDenominator":5.2619,"Numerator":0.5074,"Metric":0.0026},{"Threshold":-3,"Denominator":196.064,"LogDenominator":5.2784,"Numerator":0.6878,"Metric":0.0035},{"Threshold":-3,"Denominator":199.272,"LogDenominator":5.2947,"Numerator":0.8696,"Metric":0.0044},{"Threshold":-3,"Denominator":202.48,"LogDenominator":5.3106,"Numerator":1.0528,"Metric":0.0052},{"Threshold":-3,"Denominator":205.688,"LogDenominator":5.3264,"Numerator":1.2373,"Metric":0.006},{"Threshold":-3,"Denominator":208.896,"LogDenominator":5.3418,"Numerator":1.423,"Metric":0.0068},{"Threshold":-3,"Denominator":212.104,"LogDenominator":5.3571,"Numerator":1.6101,"Metric":0.0076},{"Threshold":-3,"Denominator":215.312,"LogDenominator":5.3721,"Numerator":1.7983,"Metric":0.0084},{"Threshold":-3,"Denominator":218.52,"LogDenominator":5.3869,"Numerator":1.9878,"Metric":0.0091},{"Threshold":-3,"Denominator":221.728,"LogDenominator":5.4015,"Numerator":2.1785,"Metric":0.0098},{"Threshold":-3,"Denominator":224.936,"LogDenominator":5.4158,"Numerator":2.3703,"Metric":0.0105},{"Threshold":-3,"Denominator":228.144,"LogDenominator":5.43,"Numerator":2.5632,"Metric":0.0112},{"Threshold":-3,"Denominator":231.352,"LogDenominator":5.4439,"Numerator":2.7573,"Metric":0.0119},{"Threshold":-3,"Denominator":234.56,"LogDenominator":5.4577,"Numerator":2.9524,"Metric":0.0126},{"Threshold":-3,"Denominator":237.768,"LogDenominator":5.4713,"Numerator":3.1486,"Metric":0.0132},{"Threshold":-3,"Denominator":240.976,"LogDenominator":5.4847,"Numerator":3.3459,"Metric":0.0139},{"Threshold":-3,"Denominator":244.184,"LogDenominator":5.4979,"Numerator":3.5441,"Metric":0.0145},{"Threshold":-3,"Denominator":247.392,"LogDenominator":5.511,"Numerator":3.7434,"Metric":0.0151},{"Threshold":-3,"Denominator":250.6,"LogDenominator":5.5239,"Numerator":3.9436,"Metric":0.0157},{"Threshold":-3,"Denominator":253.808,"LogDenominator":5.5366,"Numerator":4.1448,"Metric":0.0163},{"Threshold":-3,"Denominator":257.016,"LogDenominator":5.5491,"Numerator":4.347,"Metric":0.0169},{"Threshold":-3,"Denominator":260.224,"LogDenominator":5.5615,"Numerator":4.55,"Metric":0.0175},{"Threshold":-3,"Denominator":263.432,"LogDenominator":5.5738,"Numerator":4.754,"Metric":0.018},{"Threshold":-3,"Denominator":266.64,"LogDenominator":5.5859,"Numerator":4.9589,"Metric":0.0186},{"Threshold":-3,"Denominator":269.848,"LogDenominator":5.5979,"Numerator":5.1646,"Metric":0.0191},{"Threshold":-3,"Denominator":273.056,"LogDenominator":5.6097,"Numerator":5.3712,"Metric":0.0197},{"Threshold":-3,"Denominator":276.264,"LogDenominator":5.6214,"Numerator":5.5787,"Metric":0.0202},{"Threshold":-3,"Denominator":279.472,"LogDenominator":5.6329,"Numerator":5.787,"Metric":0.0207},{"Threshold":-3,"Denominator":282.68,"LogDenominator":5.6443,"Numerator":5.9961,"Metric":0.0212},{"Threshold":-3,"Denominator":285.888,"LogDenominator":5.6556,"Numerator":6.206,"Metric":0.0217},{"Threshold":-3,"Denominator":289.096,"LogDenominator":5.6668,"Numerator":6.4167,"Metric":0.0222},{"Threshold":-3,"Denominator":292.304,"LogDenominator":5.6778,"Numerator":6.6281,"Metric":0.0227},{"Threshold":-3,"Denominator":295.512,"LogDenominator":5.6887,"Numerator":6.8404,"Metric":0.0231},{"Threshold":-3,"Denominator":298.72,"LogDenominator":5.6995,"Numerator":7.0533,"Metric":0.0236},{"Threshold":-3,"Denominator":301.928,"LogDenominator":5.7102,"Numerator":7.2671,"Metric":0.0241},{"Threshold":-3,"Denominator":305.136,"LogDenominator":5.7208,"Numerator":7.4815,"Metric":0.0245},{"Threshold":-3,"Denominator":308.344,"LogDenominator":5.7312,"Numerator":7.6967,"Metric":0.025},{"Threshold":-3,"Denominator":311.552,"LogDenominator":5.7416,"Numerator":7.9125,"Metric":0.0254},{"Threshold":-3,"Denominator":314.76,"LogDenominator":5.7518,"Numerator":8.1291,"Metric":0.0258},{"Threshold":-3,"Denominator":317.968,"LogDenominator":5.762,"Numerator":8.3464,"Metric":0.0262},{"Threshold":-3,"Denominator":321.176,"LogDenominator":5.772,"Numerator":8.5643,"Metric":0.0267},{"Threshold":-3,"Denominator":324.384,"LogDenominator":5.7819,"Numerator":8.7829,"Metric":0.0271},{"Threshold":-3,"Denominator":327.592,"LogDenominator":5.7918,"Numerator":9.0021,"Metric":0.0275},{"Threshold":-3,"Denominator":330.8,"LogDenominator":5.8015,"Numerator":9.222,"Metric":0.0279},{"Threshold":-3,"Denominator":334.008,"LogDenominator":5.8112,"Numerator":9.4425,"Metric":0.0283},{"Threshold":-3,"Denominator":337.216,"LogDenominator":5.8207,"Numerator":9.6636,"Metric":0.0287},{"Threshold":-3,"Denominator":340.424,"LogDenominator":5.8302,"Numerator":9.8854,"Metric":0.029},{"Threshold":-3,"Denominator":343.632,"LogDenominator":5.8396,"Numerator":10.1077,"Metric":0.0294},{"Threshold":-3,"Denominator":346.84,"LogDenominator":5.8489,"Numerator":10.3307,"Metric":0.0298},{"Threshold":-3,"Denominator":350.048,"LogDenominator":5.8581,"Numerator":10.5542,"Metric":0.0302},{"Threshold":-3,"Denominator":353.256,"LogDenominator":5.8672,"Numerator":10.7784,"Metric":0.0305},{"Threshold":-3,"Denominator":356.464,"LogDenominator":5.8762,"Numerator":11.0031,"Metric":0.0309},{"Threshold":-3,"Denominator":359.672,"LogDenominator":5.8852,"Numerator":11.2283,"Metric":0.0312},{"Threshold":-3,"Denominator":362.88,"LogDenominator":5.8941,"Numerator":11.4542,"Metric":0.0316},{"Threshold":-3,"Denominator":366.088,"LogDenominator":5.9029,"Numerator":11.6806,"Metric":0.0319},{"Threshold":-3,"Denominator":369.296,"LogDenominator":5.9116,"Numerator":11.9075,"Metric":0.0322},{"Threshold":-3,"Denominator":372.504,"LogDenominator":5.9202,"Numerator":12.135,"Metric":0.0326},{"Threshold":-3,"Denominator":375.712,"LogDenominator":5.9288,"Numerator":12.363,"Metric":0.0329},{"Threshold":-3,"Denominator":378.92,"LogDenominator":5.9373,"Numerator":12.5915,"Metric":0.0332},{"Threshold":-3,"Denominator":382.128,"LogDenominator":5.9458,"Numerator":12.8205,"Metric":0.0336},{"Threshold":-3,"Denominator":385.336,"LogDenominator":5.9541,"Numerator":13.0501,"Metric":0.0339},{"Threshold":-3,"Denominator":388.544,"LogDenominator":5.9624,"Numerator":13.2801,"Metric":0.0342},{"Threshold":-3,"Denominator":391.752,"LogDenominator":5.9706,"Numerator":13.5107,"Metric":0.0345},{"Threshold":-3,"Denominator":394.96,"LogDenominator":5.9788,"Numerator":13.7417,"Metric":0.0348},{"Threshold":-3,"Denominator":398.168,"LogDenominator":5.9869,"Numerator":13.9733,"Metric":0.0351},{"Threshold":-3,"Denominator":401.376,"LogDenominator":5.9949,"Numerator":14.2053,"Metric":0.0354},{"Threshold":-3,"Denominator":404.584,"LogDenominator":6.0029,"Numerator":14.4377,"Metric":0.0357},{"Threshold":-3,"Denominator":407.792,"LogDenominator":6.0108,"Numerator":14.6707,"Metric":0.036},{"Threshold":-3,"Denominator":411,"LogDenominator":6.0186,"Numerator":14.9041,"Metric":0.0363},{"Threshold":-3,"Denominator":414.208,"LogDenominator":6.0264,"Numerator":15.138,"Metric":0.0365},{"Threshold":-3,"Denominator":417.416,"LogDenominator":6.0341,"Numerator":15.3723,"Metric":0.0368},{"Threshold":-3,"Denominator":420.624,"LogDenominator":6.0417,"Numerator":15.6071,"Metric":0.0371},{"Threshold":-3,"Denominator":423.832,"LogDenominator":6.0493,"Numerator":15.8423,"Metric":0.0374},{"Threshold":-3,"Denominator":427.04,"LogDenominator":6.0569,"Numerator":16.078,"Metric":0.0376},{"Threshold":-3,"Denominator":430.248,"LogDenominator":6.0644,"Numerator":16.314,"Metric":0.0379},{"Threshold":-3,"Denominator":433.456,"LogDenominator":6.0718,"Numerator":16.5506,"Metric":0.0382},{"Threshold":-3,"Denominator":436.664,"LogDenominator":6.0792,"Numerator":16.7875,"Metric":0.0384},{"Threshold":-3,"Denominator":439.872,"LogDenominator":6.0865,"Numerator":17.0249,"Metric":0.0387},{"Threshold":-3,"Denominator":443.08,"LogDenominator":6.0938,"Numerator":17.2626,"Metric":0.039},{"Threshold":-3,"Denominator":446.288,"LogDenominator":6.101,"Numerator":17.5008,"Metric":0.0392},{"Threshold":-3,"Denominator":449.496,"LogDenominator":6.1081,"Numerator":17.7394,"Metric":0.0395},{"Threshold":-3,"Denominator":452.704,"LogDenominator":6.1152,"Numerator":17.9784,"Metric":0.0397},{"Threshold":-3,"Denominator":455.912,"LogDenominator":6.1223,"Numerator":18.2177,"Metric":0.04},{"Threshold":-3,"Denominator":459.12,"LogDenominator":6.1293,"Numerator":18.4575,"Metric":0.0402},{"Threshold":-3,"Denominator":462.328,"LogDenominator":6.1363,"Numerator":18.6977,"Metric":0.0404},{"Threshold":-3,"Denominator":465.536,"LogDenominator":6.1432,"Numerator":18.9382,"Metric":0.0407},{"Threshold":-3,"Denominator":468.744,"LogDenominator":6.1501,"Numerator":19.1791,"Metric":0.0409},{"Threshold":-3,"Denominator":471.952,"LogDenominator":6.1569,"Numerator":19.4204,"Metric":0.0411},{"Threshold":-3,"Denominator":475.16,"LogDenominator":6.1637,"Numerator":19.6621,"Metric":0.0414},{"Threshold":-3,"Denominator":478.368,"LogDenominator":6.1704,"Numerator":19.9041,"Metric":0.0416},{"Threshold":-3,"Denominator":481.576,"LogDenominator":6.1771,"Numerator":20.1465,"Metric":0.0418},{"Threshold":-3,"Denominator":484.784,"LogDenominator":6.1837,"Numerator":20.3893,"Metric":0.0421},{"Threshold":-3,"Denominator":487.992,"LogDenominator":6.1903,"Numerator":20.6324,"Metric":0.0423},{"Threshold":-3,"Denominator":491.2,"LogDenominator":6.1969,"Numerator":20.8759,"Metric":0.0425},{"Threshold":-3,"Denominator":494.408,"LogDenominator":6.2034,"Numerator":21.1197,"Metric":0.0427},{"Threshold":-3,"Denominator":497.616,"LogDenominator":6.2098,"Numerator":21.3639,"Metric":0.0429},{"Threshold":-3,"Denominator":500.824,"LogDenominator":6.2163,"Numerator":21.6084,"Metric":0.0431},{"Threshold":-3,"Denominator":504.032,"LogDenominator":6.2226,"Numerator":21.8533,"Metric":0.0434},{"Threshold":-3,"Denominator":507.24,"LogDenominator":6.229,"Numerator":22.0985,"Metric":0.0436},{"Threshold":-3,"Denominator":510.448,"LogDenominator":6.2353,"Numerator":22.344,"Metric":0.0438},{"Threshold":-3,"Denominator":513.656,"LogDenominator":6.2416,"Numerator":22.5898,"Metric":0.044},{"Threshold":-3,"Denominator":516.864,"LogDenominator":6.2478,"Numerator":22.836,"Metric":0.0442},{"Threshold":-3,"Denominator":520.072,"LogDenominator":6.254,"Numerator":23.0825,"Metric":0.0444},{"Threshold":-3,"Denominator":523.28,"LogDenominator":6.2601,"Numerator":23.3294,"Metric":0.0446},{"Threshold":-3,"Denominator":526.488,"LogDenominator":6.2662,"Numerator":23.5765,"Metric":0.0448},{"Threshold":-3,"Denominator":529.696,"LogDenominator":6.2723,"Numerator":23.824,"Metric":0.045},{"Threshold":-3,"Denominator":532.904,"LogDenominator":6.2783,"Numerator":24.0718,"Metric":0.0452},{"Threshold":-3,"Denominator":536.112,"LogDenominator":6.2843,"Numerator":24.3199,"Metric":0.0454},{"Threshold":-3,"Denominator":539.32,"LogDenominator":6.2903,"Numerator":24.5682,"Metric":0.0456},{"Threshold":-3,"Denominator":542.528,"LogDenominator":6.2962,"Numerator":24.8169,"Metric":0.0457},{"Threshold":-3,"Denominator":545.736,"LogDenominator":6.3021,"Numerator":25.066,"Metric":0.0459},{"Threshold":-3,"Denominator":548.944,"LogDenominator":6.308,"Numerator":25.3153,"Metric":0.0461},{"Threshold":-3,"Denominator":552.152,"LogDenominator":6.3138,"Numerator":25.5649,"Metric":0.0463},{"Threshold":-3,"Denominator":555.36,"LogDenominator":6.3196,"Numerator":25.8147,"Metric":0.0465},{"Threshold":-3,"Denominator":558.568,"LogDenominator":6.3254,"Numerator":26.0649,"Metric":0.0467},{"Threshold":-3,"Denominator":561.776,"LogDenominator":6.3311,"Numerator":26.3154,"Metric":0.0468},{"Threshold":-3,"Denominator":564.984,"LogDenominator":6.3368,"Numerator":26.5662,"Metric":0.047},{"Threshold":-3,"Denominator":568.192,"LogDenominator":6.3425,"Numerator":26.8172,"Metric":0.0472},{"Threshold":-3,"Denominator":571.4,"LogDenominator":6.3481,"Numerator":27.0685,"Metric":0.0474},{"Threshold":-3,"Denominator":574.608,"LogDenominator":6.3537,"Numerator":27.3201,"Metric":0.0475},{"Threshold":-3,"Denominator":577.816,"LogDenominator":6.3593,"Numerator":27.572,"Metric":0.0477},{"Threshold":-3,"Denominator":581.024,"LogDenominator":6.3648,"Numerator":27.8242,"Metric":0.0479},{"Threshold":-3,"Denominator":584.232,"LogDenominator":6.3703,"Numerator":28.0766,"Metric":0.0481},{"Threshold":-3,"Denominator":587.44,"LogDenominator":6.3758,"Numerator":28.3293,"Metric":0.0482},{"Threshold":-3,"Denominator":590.648,"LogDenominator":6.3812,"Numerator":28.5823,"Metric":0.0484},{"Threshold":-3,"Denominator":593.856,"LogDenominator":6.3866,"Numerator":28.8355,"Metric":0.0486},{"Threshold":-3,"Denominator":597.064,"LogDenominator":6.392,"Numerator":29.089,"Metric":0.0487},{"Threshold":-3,"Denominator":600.272,"LogDenominator":6.3974,"Numerator":29.3428,"Metric":0.0489},{"Threshold":-3,"Denominator":603.48,"LogDenominator":6.4027,"Numerator":29.5968,"Metric":0.049},{"Threshold":-3,"Denominator":606.688,"LogDenominator":6.408,"Numerator":29.8511,"Metric":0.0492},{"Threshold":-3,"Denominator":609.896,"LogDenominator":6.4133,"Numerator":30.1056,"Metric":0.0494},{"Threshold":-3,"Denominator":613.104,"LogDenominator":6.4185,"Numerator":30.3604,"Metric":0.0495},{"Threshold":-3,"Denominator":616.312,"LogDenominator":6.4238,"Numerator":30.6154,"Metric":0.0497},{"Threshold":-3,"Denominator":619.52,"LogDenominator":6.4289,"Numerator":30.8707,"Metric":0.0498},{"Threshold":-3,"Denominator":622.728,"LogDenominator":6.4341,"Numerator":31.1262,"Metric":0.05},{"Threshold":-3,"Denominator":625.936,"LogDenominator":6.4392,"Numerator":31.382,"Metric":0.0501},{"Threshold":-3,"Denominator":629.144,"LogDenominator":6.4444,"Numerator":31.638,"Metric":0.0503},{"Threshold":-3,"Denominator":632.352,"LogDenominator":6.4494,"Numerator":31.8943,"Metric":0.0504},{"Threshold":-3,"Denominator":635.56,"LogDenominator":6.4545,"Numerator":32.1508,"Metric":0.0506},{"Threshold":-3,"Denominator":638.768,"LogDenominator":6.4595,"Numerator":32.4075,"Metric":0.0507},{"Threshold":-3,"Denominator":641.976,"LogDenominator":6.4646,"Numerator":32.6645,"Metric":0.0509},{"Threshold":-3,"Denominator":645.184,"LogDenominator":6.4695,"Numerator":32.9217,"Metric":0.051},{"Threshold":-3,"Denominator":648.392,"LogDenominator":6.4745,"Numerator":33.1791,"Metric":0.0512},{"Threshold":-3,"Denominator":651.6,"LogDenominator":6.4794,"Numerator":33.4368,"Metric":0.0513},{"Threshold":-3,"Denominator":654.808,"LogDenominator":6.4843,"Numerator":33.6947,"Metric":0.0515},{"Threshold":-3,"Denominator":658.016,"LogDenominator":6.4892,"Numerator":33.9529,"Metric":0.0516},{"Threshold":-3,"Denominator":661.224,"LogDenominator":6.4941,"Numerator":34.2112,"Metric":0.0517},{"Threshold":-3,"Denominator":664.432,"LogDenominator":6.4989,"Numerator":34.4698,"Metric":0.0519},{"Threshold":-3,"Denominator":667.64,"LogDenominator":6.5037,"Numerator":34.7286,"Metric":0.052},{"Threshold":-3,"Denominator":670.848,"LogDenominator":6.5085,"Numerator":34.9876,"Metric":0.0522},{"Threshold":-3,"Denominator":674.056,"LogDenominator":6.5133,"Numerator":35.2469,"Metric":0.0523},{"Threshold":-3,"Denominator":677.264,"LogDenominator":6.5181,"Numerator":35.5063,"Metric":0.0524},{"Threshold":-3,"Denominator":680.472,"LogDenominator":6.5228,"Numerator":35.766,"Metric":0.0526},{"Threshold":-3,"Denominator":683.68,"LogDenominator":6.5275,"Numerator":36.0259,"Metric":0.0527},{"Threshold":-3,"Denominator":686.888,"LogDenominator":6.5322,"Numerator":36.286,"Metric":0.0528},{"Threshold":-3,"Denominator":690.096,"LogDenominator":6.5368,"Numerator":36.5463,"Metric":0.053},{"Threshold":-3,"Denominator":693.304,"LogDenominator":6.5415,"Numerator":36.8069,"Metric":0.0531},{"Threshold":-3,"Denominator":696.512,"LogDenominator":6.5461,"Numerator":37.0676,"Metric":0.0532},{"Threshold":-3,"Denominator":699.72,"LogDenominator":6.5507,"Numerator":37.3286,"Metric":0.0533},{"Threshold":-3,"Denominator":702.928,"LogDenominator":6.5553,"Numerator":37.5897,"Metric":0.0535},{"Threshold":-3,"Denominator":706.136,"LogDenominator":6.5598,"Numerator":37.8511,"Metric":0.0536},{"Threshold":-3,"Denominator":709.344,"LogDenominator":6.5643,"Numerator":38.1126,"Metric":0.0537},{"Threshold":-3,"Denominator":712.552,"LogDenominator":6.5689,"Numerator":38.3744,"Metric":0.0539},{"Threshold":-3,"Denominator":715.76,"LogDenominator":6.5733,"Numerator":38.6364,"Metric":0.054},{"Threshold":-3,"Denominator":718.968,"LogDenominator":6.5778,"Numerator":38.8985,"Metric":0.0541},{"Threshold":-3,"Denominator":722.176,"LogDenominator":6.5823,"Numerator":39.1609,"Metric":0.0542},{"Threshold":-3,"Denominator":725.384,"LogDenominator":6.5867,"Numerator":39.4234,"Metric":0.0543},{"Threshold":-3,"Denominator":728.592,"LogDenominator":6.5911,"Numerator":39.6862,"Metric":0.0545},{"Threshold":-3,"Denominator":731.8,"LogDenominator":6.5955,"Numerator":39.9491,"Metric":0.0546},{"Threshold":-3,"Denominator":735.008,"LogDenominator":6.5999,"Numerator":40.2123,"Metric":0.0547},{"Threshold":-3,"Denominator":738.216,"LogDenominator":6.6042,"Numerator":40.4756,"Metric":0.0548},{"Threshold":-3,"Denominator":741.424,"LogDenominator":6.6086,"Numerator":40.7391,"Metric":0.0549},{"Threshold":-3,"Denominator":744.632,"LogDenominator":6.6129,"Numerator":41.0028,"Metric":0.0551},{"Threshold":-3,"Denominator":747.84,"LogDenominator":6.6172,"Numerator":41.2667,"Metric":0.0552},{"Threshold":-3,"Denominator":751.048,"LogDenominator":6.6215,"Numerator":41.5308,"Metric":0.0553},{"Threshold":-3,"Denominator":754.256,"LogDenominator":6.6257,"Numerator":41.7951,"Metric":0.0554},{"Threshold":-3,"Denominator":757.464,"LogDenominator":6.63,"Numerator":42.0595,"Metric":0.0555},{"Threshold":-3,"Denominator":760.672,"LogDenominator":6.6342,"Numerator":42.3242,"Metric":0.0556},{"Threshold":-3,"Denominator":763.88,"LogDenominator":6.6384,"Numerator":42.589,"Metric":0.0558},{"Threshold":-3,"Denominator":767.088,"LogDenominator":6.6426,"Numerator":42.854,"Metric":0.0559},{"Threshold":-3,"Denominator":770.296,"LogDenominator":6.6468,"Numerator":43.1192,"Metric":0.056},{"Threshold":-3,"Denominator":773.504,"LogDenominator":6.6509,"Numerator":43.3845,"Metric":0.0561},{"Threshold":-3,"Denominator":776.712,"LogDenominator":6.6551,"Numerator":43.6501,"Metric":0.0562},{"Threshold":-3,"Denominator":779.92,"LogDenominator":6.6592,"Numerator":43.9158,"Metric":0.0563},{"Threshold":-3,"Denominator":783.128,"LogDenominator":6.6633,"Numerator":44.1817,"Metric":0.0564},{"Threshold":-3,"Denominator":786.336,"LogDenominator":6.6674,"Numerator":44.4477,"Metric":0.0565},{"Threshold":-3,"Denominator":789.544,"LogDenominator":6.6715,"Numerator":44.714,"Metric":0.0566},{"Threshold":-3,"Denominator":792.752,"LogDenominator":6.6755,"Numerator":44.9804,"Metric":0.0567},{"Threshold":-3,"Denominator":795.96,"LogDenominator":6.6795,"Numerator":45.2469,"Metric":0.0568},{"Threshold":-3,"Denominator":799.168,"LogDenominator":6.6836,"Numerator":45.5137,"Metric":0.057},{"Threshold":-3,"Denominator":802.376,"LogDenominator":6.6876,"Numerator":45.7806,"Metric":0.0571},{"Threshold":-3,"Denominator":805.584,"LogDenominator":6.6916,"Numerator":46.0477,"Metric":0.0572},{"Threshold":-3,"Denominator":808.792,"LogDenominator":6.6955,"Numerator":46.3149,"Metric":0.0573},{"Threshold":-3,"Denominator":812,"LogDenominator":6.6995,"Numerator":46.5824,"Metric":0.0574},{"Threshold":-3,"Denominator":815.208,"LogDenominator":6.7034,"Numerator":46.8499,"Metric":0.0575},{"Threshold":-2,"Denominator":83.784,"LogDenominator":4.4282,"Numerator":0.118,"Metric":0.0014},{"Threshold":-2,"Denominator":86.992,"LogDenominator":4.4658,"Numerator":0.2974,"Metric":0.0034},{"Threshold":-2,"Denominator":90.2,"LogDenominator":4.502,"Numerator":0.4799,"Metric":0.0053},{"Threshold":-2,"Denominator":93.408,"LogDenominator":4.537,"Numerator":0.6654,"Metric":0.0071},{"Threshold":-2,"Denominator":96.616,"LogDenominator":4.5707,"Numerator":0.8536,"Metric":0.0088},{"Threshold":-2,"Denominator":99.824,"LogDenominator":4.6034,"Numerator":1.0446,"Metric":0.0105},{"Threshold":-2,"Denominator":103.032,"LogDenominator":4.635,"Numerator":1.2381,"Metric":0.012},{"Threshold":-2,"Denominator":106.24,"LogDenominator":4.6657,"Numerator":1.4341,"Metric":0.0135},{"Threshold":-2,"Denominator":109.448,"LogDenominator":4.6954,"Numerator":1.6324,"Metric":0.0149},{"Threshold":-2,"Denominator":112.656,"LogDenominator":4.7243,"Numerator":1.8329,"Metric":0.0163},{"Threshold":-2,"Denominator":115.864,"LogDenominator":4.7524,"Numerator":2.0355,"Metric":0.0176},{"Threshold":-2,"Denominator":119.072,"LogDenominator":4.7797,"Numerator":2.2402,"Metric":0.0188},{"Threshold":-2,"Denominator":122.28,"LogDenominator":4.8063,"Numerator":2.4468,"Metric":0.02},{"Threshold":-2,"Denominator":125.488,"LogDenominator":4.8322,"Numerator":2.6553,"Metric":0.0212},{"Threshold":-2,"Denominator":128.696,"LogDenominator":4.8575,"Numerator":2.8656,"Metric":0.0223},{"Threshold":-2,"Denominator":131.904,"LogDenominator":4.8821,"Numerator":3.0777,"Metric":0.0233},{"Threshold":-2,"Denominator":135.112,"LogDenominator":4.9061,"Numerator":3.2914,"Metric":0.0244},{"Threshold":-2,"Denominator":138.32,"LogDenominator":4.9296,"Numerator":3.5067,"Metric":0.0254},{"Threshold":-2,"Denominator":141.528,"LogDenominator":4.9525,"Numerator":3.7237,"Metric":0.0263},{"Threshold":-2,"Denominator":144.736,"LogDenominator":4.9749,"Numerator":3.9421,"Metric":0.0272},{"Threshold":-2,"Denominator":147.944,"LogDenominator":4.9968,"Numerator":4.162,"Metric":0.0281},{"Threshold":-2,"Denominator":151.152,"LogDenominator":5.0183,"Numerator":4.3833,"Metric":0.029},{"Threshold":-2,"Denominator":154.36,"LogDenominator":5.0393,"Numerator":4.606,"Metric":0.0298},{"Threshold":-2,"Denominator":157.568,"LogDenominator":5.0599,"Numerator":4.83,"Metric":0.0307},{"Threshold":-2,"Denominator":160.776,"LogDenominator":5.08,"Numerator":5.0552,"Metric":0.0314},{"Threshold":-2,"Denominator":163.984,"LogDenominator":5.0998,"Numerator":5.2818,"Metric":0.0322},{"Threshold":-2,"Denominator":167.192,"LogDenominator":5.1191,"Numerator":5.5095,"Metric":0.033},{"Threshold":-2,"Denominator":170.4,"LogDenominator":5.1381,"Numerator":5.7384,"Metric":0.0337},{"Threshold":-2,"Denominator":173.608,"LogDenominator":5.1568,"Numerator":5.9685,"Metric":0.0344},{"Threshold":-2,"Denominator":176.816,"LogDenominator":5.1751,"Numerator":6.1997,"Metric":0.0351},{"Threshold":-2,"Denominator":180.024,"LogDenominator":5.1931,"Numerator":6.4319,"Metric":0.0357},{"Threshold":-2,"Denominator":183.232,"LogDenominator":5.2108,"Numerator":6.6652,"Metric":0.0364},{"Threshold":-2,"Denominator":186.44,"LogDenominator":5.2281,"Numerator":6.8996,"Metric":0.037},{"Threshold":-2,"Denominator":189.648,"LogDenominator":5.2452,"Numerator":7.1349,"Metric":0.0376},{"Threshold":-2,"Denominator":192.856,"LogDenominator":5.2619,"Numerator":7.3712,"Metric":0.0382},{"Threshold":-2,"Denominator":196.064,"LogDenominator":5.2784,"Numerator":7.6085,"Metric":0.0388},{"Threshold":-2,"Denominator":199.272,"LogDenominator":5.2947,"Numerator":7.8467,"Metric":0.0394},{"Threshold":-2,"Denominator":202.48,"LogDenominator":5.3106,"Numerator":8.0858,"Metric":0.0399},{"Threshold":-2,"Denominator":205.688,"LogDenominator":5.3264,"Numerator":8.3257,"Metric":0.0405},{"Threshold":-2,"Denominator":208.896,"LogDenominator":5.3418,"Numerator":8.5666,"Metric":0.041},{"Threshold":-2,"Denominator":212.104,"LogDenominator":5.3571,"Numerator":8.8082,"Metric":0.0415},{"Threshold":-2,"Denominator":215.312,"LogDenominator":5.3721,"Numerator":9.0507,"Metric":0.042},{"Threshold":-2,"Denominator":218.52,"LogDenominator":5.3869,"Numerator":9.294,"Metric":0.0425},{"Threshold":-2,"Denominator":221.728,"LogDenominator":5.4015,"Numerator":9.5381,"Metric":0.043},{"Threshold":-2,"Denominator":224.936,"LogDenominator":5.4158,"Numerator":9.783,"Metric":0.0435},{"Threshold":-2,"Denominator":228.144,"LogDenominator":5.43,"Numerator":10.0286,"Metric":0.044},{"Threshold":-2,"Denominator":231.352,"LogDenominator":5.4439,"Numerator":10.275,"Metric":0.0444},{"Threshold":-2,"Denominator":234.56,"LogDenominator":5.4577,"Numerator":10.522,"Metric":0.0449},{"Threshold":-2,"Denominator":237.768,"LogDenominator":5.4713,"Numerator":10.7698,"Metric":0.0453},{"Threshold":-2,"Denominator":240.976,"LogDenominator":5.4847,"Numerator":11.0183,"Metric":0.0457},{"Threshold":-2,"Denominator":244.184,"LogDenominator":5.4979,"Numerator":11.2675,"Metric":0.0461},{"Threshold":-2,"Denominator":247.392,"LogDenominator":5.511,"Numerator":11.5173,"Metric":0.0466},{"Threshold":-2,"Denominator":250.6,"LogDenominator":5.5239,"Numerator":11.7678,"Metric":0.047},{"Threshold":-2,"Denominator":253.808,"LogDenominator":5.5366,"Numerator":12.0189,"Metric":0.0474},{"Threshold":-2,"Denominator":257.016,"LogDenominator":5.5491,"Numerator":12.2706,"Metric":0.0477},{"Threshold":-2,"Denominator":260.224,"LogDenominator":5.5615,"Numerator":12.523,"Metric":0.0481},{"Threshold":-2,"Denominator":263.432,"LogDenominator":5.5738,"Numerator":12.776,"Metric":0.0485},{"Threshold":-2,"Denominator":266.64,"LogDenominator":5.5859,"Numerator":13.0295,"Metric":0.0489},{"Threshold":-2,"Denominator":269.848,"LogDenominator":5.5979,"Numerator":13.2837,"Metric":0.0492},{"Threshold":-2,"Denominator":273.056,"LogDenominator":5.6097,"Numerator":13.5384,"Metric":0.0496},{"Threshold":-2,"Denominator":276.264,"LogDenominator":5.6214,"Numerator":13.7937,"Metric":0.0499},{"Threshold":-2,"Denominator":279.472,"LogDenominator":5.6329,"Numerator":14.0496,"Metric":0.0503},{"Threshold":-2,"Denominator":282.68,"LogDenominator":5.6443,"Numerator":14.3059,"Metric":0.0506},{"Threshold":-2,"Denominator":285.888,"LogDenominator":5.6556,"Numerator":14.5629,"Metric":0.0509},{"Threshold":-2,"Denominator":289.096,"LogDenominator":5.6668,"Numerator":14.8203,"Metric":0.0513},{"Threshold":-2,"Denominator":292.304,"LogDenominator":5.6778,"Numerator":15.0783,"Metric":0.0516},{"Threshold":-2,"Denominator":295.512,"LogDenominator":5.6887,"Numerator":15.3368,"Metric":0.0519},{"Threshold":-2,"Denominator":298.72,"LogDenominator":5.6995,"Numerator":15.5957,"Metric":0.0522},{"Threshold":-2,"Denominator":301.928,"LogDenominator":5.7102,"Numerator":15.8552,"Metric":0.0525},{"Threshold":-2,"Denominator":305.136,"LogDenominator":5.7208,"Numerator":16.1152,"Metric":0.0528},{"Threshold":-2,"Denominator":308.344,"LogDenominator":5.7312,"Numerator":16.3756,"Metric":0.0531},{"Threshold":-2,"Denominator":311.552,"LogDenominator":5.7416,"Numerator":16.6365,"Metric":0.0534},{"Threshold":-2,"Denominator":314.76,"LogDenominator":5.7518,"Numerator":16.8978,"Metric":0.0537},{"Threshold":-2,"Denominator":317.968,"LogDenominator":5.762,"Numerator":17.1597,"Metric":0.054},{"Threshold":-2,"Denominator":321.176,"LogDenominator":5.772,"Numerator":17.4219,"Metric":0.0542},{"Threshold":-2,"Denominator":324.384,"LogDenominator":5.7819,"Numerator":17.6846,"Metric":0.0545},{"Threshold":-2,"Denominator":327.592,"LogDenominator":5.7918,"Numerator":17.9478,"Metric":0.0548},{"Threshold":-2,"Denominator":330.8,"LogDenominator":5.8015,"Numerator":18.2114,"Metric":0.0551},{"Threshold":-2,"Denominator":334.008,"LogDenominator":5.8112,"Numerator":18.4753,"Metric":0.0553},{"Threshold":-2,"Denominator":337.216,"LogDenominator":5.8207,"Numerator":18.7398,"Metric":0.0556},{"Threshold":-2,"Denominator":340.424,"LogDenominator":5.8302,"Numerator":19.0046,"Metric":0.0558},{"Threshold":-2,"Denominator":343.632,"LogDenominator":5.8396,"Numerator":19.2698,"Metric":0.0561},{"Threshold":-2,"Denominator":346.84,"LogDenominator":5.8489,"Numerator":19.5354,"Metric":0.0563},{"Threshold":-2,"Denominator":350.048,"LogDenominator":5.8581,"Numerator":19.8015,"Metric":0.0566},{"Threshold":-2,"Denominator":353.256,"LogDenominator":5.8672,"Numerator":20.0679,"Metric":0.0568},{"Threshold":-2,"Denominator":356.464,"LogDenominator":5.8762,"Numerator":20.3347,"Metric":0.057},{"Threshold":-2,"Denominator":359.672,"LogDenominator":5.8852,"Numerator":20.6018,"Metric":0.0573},{"Threshold":-2,"Denominator":362.88,"LogDenominator":5.8941,"Numerator":20.8694,"Metric":0.0575},{"Threshold":-2,"Denominator":366.088,"LogDenominator":5.9029,"Numerator":21.1373,"Metric":0.0577},{"Threshold":-2,"Denominator":369.296,"LogDenominator":5.9116,"Numerator":21.4056,"Metric":0.058},{"Threshold":-2,"Denominator":372.504,"LogDenominator":5.9202,"Numerator":21.6742,"Metric":0.0582},{"Threshold":-2,"Denominator":375.712,"LogDenominator":5.9288,"Numerator":21.9432,"Metric":0.0584},{"Threshold":-2,"Denominator":378.92,"LogDenominator":5.9373,"Numerator":22.2125,"Metric":0.0586},{"Threshold":-2,"Denominator":382.128,"LogDenominator":5.9458,"Numerator":22.4822,"Metric":0.0588},{"Threshold":-2,"Denominator":385.336,"LogDenominator":5.9541,"Numerator":22.7522,"Metric":0.059},{"Threshold":-2,"Denominator":388.544,"LogDenominator":5.9624,"Numerator":23.0226,"Metric":0.0593},{"Threshold":-2,"Denominator":391.752,"LogDenominator":5.9706,"Numerator":23.2932,"Metric":0.0595},{"Threshold":-2,"Denominator":394.96,"LogDenominator":5.9788,"Numerator":23.5643,"Metric":0.0597},{"Threshold":-2,"Denominator":398.168,"LogDenominator":5.9869,"Numerator":23.8356,"Metric":0.0599},{"Threshold":-2,"Denominator":401.376,"LogDenominator":5.9949,"Numerator":24.1073,"Metric":0.0601},{"Threshold":-2,"Denominator":404.584,"LogDenominator":6.0029,"Numerator":24.3792,"Metric":0.0603},{"Threshold":-2,"Denominator":407.792,"LogDenominator":6.0108,"Numerator":24.6515,"Metric":0.0605},{"Threshold":-2,"Denominator":411,"LogDenominator":6.0186,"Numerator":24.9241,"Metric":0.0606},{"Threshold":-2,"Denominator":414.208,"LogDenominator":6.0264,"Numerator":25.197,"Metric":0.0608},{"Threshold":-2,"Denominator":417.416,"LogDenominator":6.0341,"Numerator":25.4702,"Metric":0.061},{"Threshold":-2,"Denominator":420.624,"LogDenominator":6.0417,"Numerator":25.7437,"Metric":0.0612},{"Threshold":-2,"Denominator":423.832,"LogDenominator":6.0493,"Numerator":26.0175,"Metric":0.0614},{"Threshold":-2,"Denominator":427.04,"LogDenominator":6.0569,"Numerator":26.2916,"Metric":0.0616},{"Threshold":-2,"Denominator":430.248,"LogDenominator":6.0644,"Numerator":26.566,"Metric":0.0617},{"Threshold":-2,"Denominator":433.456,"LogDenominator":6.0718,"Numerator":26.8407,"Metric":0.0619},{"Threshold":-2,"Denominator":436.664,"LogDenominator":6.0792,"Numerator":27.1156,"Metric":0.0621},{"Threshold":-2,"Denominator":439.872,"LogDenominator":6.0865,"Numerator":27.3908,"Metric":0.0623},{"Threshold":-2,"Denominator":443.08,"LogDenominator":6.0938,"Numerator":27.6663,"Metric":0.0624},{"Threshold":-2,"Denominator":446.288,"LogDenominator":6.101,"Numerator":27.9421,"Metric":0.0626},{"Threshold":-2,"Denominator":449.496,"LogDenominator":6.1081,"Numerator":28.2181,"Metric":0.0628},{"Threshold":-2,"Denominator":452.704,"LogDenominator":6.1152,"Numerator":28.4945,"Metric":0.0629},{"Threshold":-2,"Denominator":455.912,"LogDenominator":6.1223,"Numerator":28.771,"Metric":0.0631},{"Threshold":-2,"Denominator":459.12,"LogDenominator":6.1293,"Numerator":29.0479,"Metric":0.0633},{"Threshold":-2,"Denominator":462.328,"LogDenominator":6.1363,"Numerator":29.325,"Metric":0.0634},{"Threshold":-2,"Denominator":465.536,"LogDenominator":6.1432,"Numerator":29.6023,"Metric":0.0636},{"Threshold":-2,"Denominator":468.744,"LogDenominator":6.1501,"Numerator":29.8799,"Metric":0.0637},{"Threshold":-2,"Denominator":471.952,"LogDenominator":6.1569,"Numerator":30.1578,"Metric":0.0639},{"Threshold":-2,"Denominator":475.16,"LogDenominator":6.1637,"Numerator":30.4359,"Metric":0.0641},{"Threshold":-2,"Denominator":478.368,"LogDenominator":6.1704,"Numerator":30.7142,"Metric":0.0642},{"Threshold":-2,"Denominator":481.576,"LogDenominator":6.1771,"Numerator":30.9928,"Metric":0.0644},{"Threshold":-2,"Denominator":484.784,"LogDenominator":6.1837,"Numerator":31.2716,"Metric":0.0645},{"Threshold":-2,"Denominator":487.992,"LogDenominator":6.1903,"Numerator":31.5507,"Metric":0.0647},{"Threshold":-2,"Denominator":491.2,"LogDenominator":6.1969,"Numerator":31.83,"Metric":0.0648},{"Threshold":-2,"Denominator":494.408,"LogDenominator":6.2034,"Numerator":32.1095,"Metric":0.0649},{"Threshold":-2,"Denominator":497.616,"LogDenominator":6.2098,"Numerator":32.3893,"Metric":0.0651},{"Threshold":-2,"Denominator":500.824,"LogDenominator":6.2163,"Numerator":32.6693,"Metric":0.0652},{"Threshold":-2,"Denominator":504.032,"LogDenominator":6.2226,"Numerator":32.9495,"Metric":0.0654},{"Threshold":-2,"Denominator":507.24,"LogDenominator":6.229,"Numerator":33.23,"Metric":0.0655},{"Threshold":-2,"Denominator":510.448,"LogDenominator":6.2353,"Numerator":33.5106,"Metric":0.0656},{"Threshold":-2,"Denominator":513.656,"LogDenominator":6.2416,"Numerator":33.7915,"Metric":0.0658},{"Threshold":-2,"Denominator":516.864,"LogDenominator":6.2478,"Numerator":34.0726,"Metric":0.0659},{"Threshold":-2,"Denominator":520.072,"LogDenominator":6.254,"Numerator":34.354,"Metric":0.0661},{"Threshold":-2,"Denominator":523.28,"LogDenominator":6.2601,"Numerator":34.6355,"Metric":0.0662},{"Threshold":-2,"Denominator":526.488,"LogDenominator":6.2662,"Numerator":34.9173,"Metric":0.0663},{"Threshold":-2,"Denominator":529.696,"LogDenominator":6.2723,"Numerator":35.1992,"Metric":0.0665},{"Threshold":-2,"Denominator":532.904,"LogDenominator":6.2783,"Numerator":35.4814,"Metric":0.0666},{"Threshold":-2,"Denominator":536.112,"LogDenominator":6.2843,"Numerator":35.7638,"Metric":0.0667},{"Threshold":-2,"Denominator":539.32,"LogDenominator":6.2903,"Numerator":36.0464,"Metric":0.0668},{"Threshold":-2,"Denominator":542.528,"LogDenominator":6.2962,"Numerator":36.3292,"Metric":0.067},{"Threshold":-2,"Denominator":545.736,"LogDenominator":6.3021,"Numerator":36.6121,"Metric":0.0671},{"Threshold":-2,"Denominator":548.944,"LogDenominator":6.308,"Numerator":36.8953,"Metric":0.0672},{"Threshold":-2,"Denominator":552.152,"LogDenominator":6.3138,"Numerator":37.1787,"Metric":0.0673},{"Threshold":-2,"Denominator":555.36,"LogDenominator":6.3196,"Numerator":37.4623,"Metric":0.0675},{"Threshold":-2,"Denominator":558.568,"LogDenominator":6.3254,"Numerator":37.7461,"Metric":0.0676},{"Threshold":-2,"Denominator":561.776,"LogDenominator":6.3311,"Numerator":38.03,"Metric":0.0677},{"Threshold":-2,"Denominator":564.984,"LogDenominator":6.3368,"Numerator":38.3142,"Metric":0.0678},{"Threshold":-2,"Denominator":568.192,"LogDenominator":6.3425,"Numerator":38.5986,"Metric":0.0679},{"Threshold":-2,"Denominator":571.4,"LogDenominator":6.3481,"Numerator":38.8831,"Metric":0.068},{"Threshold":-2,"Denominator":574.608,"LogDenominator":6.3537,"Numerator":39.1678,"Metric":0.0682},{"Threshold":-2,"Denominator":577.816,"LogDenominator":6.3593,"Numerator":39.4527,"Metric":0.0683},{"Threshold":-2,"Denominator":581.024,"LogDenominator":6.3648,"Numerator":39.7378,"Metric":0.0684},{"Threshold":-2,"Denominator":584.232,"LogDenominator":6.3703,"Numerator":40.0231,"Metric":0.0685},{"Threshold":-2,"Denominator":587.44,"LogDenominator":6.3758,"Numerator":40.3085,"Metric":0.0686},{"Threshold":-2,"Denominator":590.648,"LogDenominator":6.3812,"Numerator":40.5942,"Metric":0.0687},{"Threshold":-2,"Denominator":593.856,"LogDenominator":6.3866,"Numerator":40.88,"Metric":0.0688},{"Threshold":-2,"Denominator":597.064,"LogDenominator":6.392,"Numerator":41.166,"Metric":0.0689},{"Threshold":-2,"Denominator":600.272,"LogDenominator":6.3974,"Numerator":41.4521,"Metric":0.0691},{"Threshold":-2,"Denominator":603.48,"LogDenominator":6.4027,"Numerator":41.7385,"Metric":0.0692},{"Threshold":-2,"Denominator":606.688,"LogDenominator":6.408,"Numerator":42.025,"Metric":0.0693},{"Threshold":-2,"Denominator":609.896,"LogDenominator":6.4133,"Numerator":42.3116,"Metric":0.0694},{"Threshold":-2,"Denominator":613.104,"LogDenominator":6.4185,"Numerator":42.5985,"Metric":0.0695},{"Threshold":-2,"Denominator":616.312,"LogDenominator":6.4238,"Numerator":42.8855,"Metric":0.0696},{"Threshold":-2,"Denominator":619.52,"LogDenominator":6.4289,"Numerator":43.1727,"Metric":0.0697},{"Threshold":-2,"Denominator":622.728,"LogDenominator":6.4341,"Numerator":43.46,"Metric":0.0698},{"Threshold":-2,"Denominator":625.936,"LogDenominator":6.4392,"Numerator":43.7475,"Metric":0.0699},{"Threshold":-2,"Denominator":629.144,"LogDenominator":6.4444,"Numerator":44.0352,"Metric":0.07},{"Threshold":-2,"Denominator":632.352,"LogDenominator":6.4494,"Numerator":44.323,"Metric":0.0701},{"Threshold":-2,"Denominator":635.56,"LogDenominator":6.4545,"Numerator":44.611,"Metric":0.0702},{"Threshold":-2,"Denominator":638.768,"LogDenominator":6.4595,"Numerator":44.8991,"Metric":0.0703},{"Threshold":-2,"Denominator":641.976,"LogDenominator":6.4646,"Numerator":45.1874,"Metric":0.0704},{"Threshold":-2,"Denominator":645.184,"LogDenominator":6.4695,"Numerator":45.4759,"Metric":0.0705},{"Threshold":-2,"Denominator":648.392,"LogDenominator":6.4745,"Numerator":45.7645,"Metric":0.0706},{"Threshold":-2,"Denominator":651.6,"LogDenominator":6.4794,"Numerator":46.0533,"Metric":0.0707},{"Threshold":-2,"Denominator":654.808,"LogDenominator":6.4843,"Numerator":46.3422,"Metric":0.0708},{"Threshold":-2,"Denominator":658.016,"LogDenominator":6.4892,"Numerator":46.6313,"Metric":0.0709},{"Threshold":-2,"Denominator":661.224,"LogDenominator":6.4941,"Numerator":46.9205,"Metric":0.071},{"Threshold":-2,"Denominator":664.432,"LogDenominator":6.4989,"Numerator":47.2099,"Metric":0.0711},{"Threshold":-2,"Denominator":667.64,"LogDenominator":6.5037,"Numerator":47.4994,"Metric":0.0711},{"Threshold":-2,"Denominator":670.848,"LogDenominator":6.5085,"Numerator":47.7891,"Metric":0.0712},{"Threshold":-2,"Denominator":674.056,"LogDenominator":6.5133,"Numerator":48.0789,"Metric":0.0713},{"Threshold":-2,"Denominator":677.264,"LogDenominator":6.5181,"Numerator":48.3689,"Metric":0.0714},{"Threshold":-2,"Denominator":680.472,"LogDenominator":6.5228,"Numerator":48.659,"Metric":0.0715},{"Threshold":-2,"Denominator":683.68,"LogDenominator":6.5275,"Numerator":48.9492,"Metric":0.0716},{"Threshold":-2,"Denominator":686.888,"LogDenominator":6.5322,"Numerator":49.2396,"Metric":0.0717},{"Threshold":-2,"Denominator":690.096,"LogDenominator":6.5368,"Numerator":49.5302,"Metric":0.0718},{"Threshold":-2,"Denominator":693.304,"LogDenominator":6.5415,"Numerator":49.8208,"Metric":0.0719},{"Threshold":-2,"Denominator":696.512,"LogDenominator":6.5461,"Numerator":50.1116,"Metric":0.0719},{"Threshold":-2,"Denominator":699.72,"LogDenominator":6.5507,"Numerator":50.4026,"Metric":0.072},{"Threshold":-2,"Denominator":702.928,"LogDenominator":6.5553,"Numerator":50.6937,"Metric":0.0721},{"Threshold":-2,"Denominator":706.136,"LogDenominator":6.5598,"Numerator":50.9849,"Metric":0.0722},{"Threshold":-2,"Denominator":709.344,"LogDenominator":6.5643,"Numerator":51.2763,"Metric":0.0723},{"Threshold":-2,"Denominator":712.552,"LogDenominator":6.5689,"Numerator":51.5678,"Metric":0.0724},{"Threshold":-2,"Denominator":715.76,"LogDenominator":6.5733,"Numerator":51.8594,"Metric":0.0725},{"Threshold":-2,"Denominator":718.968,"LogDenominator":6.5778,"Numerator":52.1512,"Metric":0.0725},{"Threshold":-2,"Denominator":722.176,"LogDenominator":6.5823,"Numerator":52.443,"Metric":0.0726},{"Threshold":-2,"Denominator":725.384,"LogDenominator":6.5867,"Numerator":52.7351,"Metric":0.0727},{"Threshold":-2,"Denominator":728.592,"LogDenominator":6.5911,"Numerator":53.0272,"Metric":0.0728},{"Threshold":-2,"Denominator":731.8,"LogDenominator":6.5955,"Numerator":53.3195,"Metric":0.0729},{"Threshold":-2,"Denominator":735.008,"LogDenominator":6.5999,"Numerator":53.6119,"Metric":0.0729},{"Threshold":-2,"Denominator":738.216,"LogDenominator":6.6042,"Numerator":53.9045,"Metric":0.073},{"Threshold":-2,"Denominator":741.424,"LogDenominator":6.6086,"Numerator":54.1971,"Metric":0.0731},{"Threshold":-2,"Denominator":744.632,"LogDenominator":6.6129,"Numerator":54.4899,"Metric":0.0732},{"Threshold":-2,"Denominator":747.84,"LogDenominator":6.6172,"Numerator":54.7828,"Metric":0.0733},{"Threshold":-2,"Denominator":751.048,"LogDenominator":6.6215,"Numerator":55.0759,"Metric":0.0733},{"Threshold":-2,"Denominator":754.256,"LogDenominator":6.6257,"Numerator":55.3691,"Metric":0.0734},{"Threshold":-2,"Denominator":757.464,"LogDenominator":6.63,"Numerator":55.6623,"Metric":0.0735},{"Threshold":-2,"Denominator":760.672,"LogDenominator":6.6342,"Numerator":55.9558,"Metric":0.0736},{"Threshold":-2,"Denominator":763.88,"LogDenominator":6.6384,"Numerator":56.2493,"Metric":0.0736},{"Threshold":-2,"Denominator":767.088,"LogDenominator":6.6426,"Numerator":56.5429,"Metric":0.0737},{"Threshold":-2,"Denominator":770.296,"LogDenominator":6.6468,"Numerator":56.8367,"Metric":0.0738},{"Threshold":-2,"Denominator":773.504,"LogDenominator":6.6509,"Numerator":57.1306,"Metric":0.0739},{"Threshold":-2,"Denominator":776.712,"LogDenominator":6.6551,"Numerator":57.4246,"Metric":0.0739},{"Threshold":-2,"Denominator":779.92,"LogDenominator":6.6592,"Numerator":57.7187,"Metric":0.074},{"Threshold":-2,"Denominator":783.128,"LogDenominator":6.6633,"Numerator":58.013,"Metric":0.0741},{"Threshold":-2,"Denominator":786.336,"LogDenominator":6.6674,"Numerator":58.3074,"Metric":0.0742},{"Threshold":-2,"Denominator":789.544,"LogDenominator":6.6715,"Numerator":58.6018,"Metric":0.0742},{"Threshold":-2,"Denominator":792.752,"LogDenominator":6.6755,"Numerator":58.8964,"Metric":0.0743},{"Threshold":-2,"Denominator":795.96,"LogDenominator":6.6795,"Numerator":59.1911,"Metric":0.0744},{"Threshold":-2,"Denominator":799.168,"LogDenominator":6.6836,"Numerator":59.4859,"Metric":0.0744},{"Threshold":-2,"Denominator":802.376,"LogDenominator":6.6876,"Numerator":59.7809,"Metric":0.0745},{"Threshold":-2,"Denominator":805.584,"LogDenominator":6.6916,"Numerator":60.0759,"Metric":0.0746},{"Threshold":-2,"Denominator":808.792,"LogDenominator":6.6955,"Numerator":60.3711,"Metric":0.0746},{"Threshold":-2,"Denominator":812,"LogDenominator":6.6995,"Numerator":60.6663,"Metric":0.0747},{"Threshold":-2,"Denominator":815.208,"LogDenominator":6.7034,"Numerator":60.9617,"Metric":0.0748},{"Threshold":2,"Denominator":6.792,"LogDenominator":1.9157,"Numerator":3.3192,"Metric":0.4887},{"Threshold":2,"Denominator":10,"LogDenominator":2.3026,"Numerator":4.2199,"Metric":0.422},{"Threshold":2,"Denominator":13.208,"LogDenominator":2.5808,"Numerator":5.0375,"Metric":0.3814},{"Threshold":2,"Denominator":16.416,"LogDenominator":2.7983,"Numerator":5.801,"Metric":0.3534},{"Threshold":2,"Denominator":19.624,"LogDenominator":2.9768,"Numerator":6.5259,"Metric":0.3325},{"Threshold":2,"Denominator":22.832,"LogDenominator":3.1282,"Numerator":7.2212,"Metric":0.3163},{"Threshold":2,"Denominator":26.04,"LogDenominator":3.2596,"Numerator":7.8931,"Metric":0.3031},{"Threshold":2,"Denominator":29.248,"LogDenominator":3.3758,"Numerator":8.5457,"Metric":0.2922},{"Threshold":2,"Denominator":32.456,"LogDenominator":3.4799,"Numerator":9.1823,"Metric":0.2829},{"Threshold":2,"Denominator":35.664,"LogDenominator":3.5741,"Numerator":9.805,"Metric":0.2749},{"Threshold":2,"Denominator":38.872,"LogDenominator":3.6603,"Numerator":10.4157,"Metric":0.2679},{"Threshold":2,"Denominator":42.08,"LogDenominator":3.7396,"Numerator":11.0159,"Metric":0.2618},{"Threshold":2,"Denominator":45.288,"LogDenominator":3.813,"Numerator":11.6068,"Metric":0.2563},{"Threshold":2,"Denominator":48.496,"LogDenominator":3.8815,"Numerator":12.1894,"Metric":0.2513},{"Threshold":2,"Denominator":51.704,"LogDenominator":3.9455,"Numerator":12.7644,"Metric":0.2469},{"Threshold":2,"Denominator":54.912,"LogDenominator":4.0057,"Numerator":13.3325,"Metric":0.2428},{"Threshold":2,"Denominator":58.12,"LogDenominator":4.0625,"Numerator":13.8944,"Metric":0.2391},{"Threshold":2,"Denominator":61.328,"LogDenominator":4.1162,"Numerator":14.4506,"Metric":0.2356},{"Threshold":2,"Denominator":64.536,"LogDenominator":4.1672,"Numerator":15.0014,"Metric":0.2325},{"Threshold":2,"Denominator":67.744,"LogDenominator":4.2157,"Numerator":15.5474,"Metric":0.2295},{"Threshold":2,"Denominator":70.952,"LogDenominator":4.262,"Numerator":16.0887,"Metric":0.2268},{"Threshold":2,"Denominator":74.16,"LogDenominator":4.3062,"Numerator":16.6258,"Metric":0.2242},{"Threshold":2,"Denominator":77.368,"LogDenominator":4.3486,"Numerator":17.159,"Metric":0.2218},{"Threshold":2,"Denominator":80.576,"LogDenominator":4.3892,"Numerator":17.6884,"Metric":0.2195},{"Threshold":2,"Denominator":83.784,"LogDenominator":4.4282,"Numerator":18.2142,"Metric":0.2174},{"Threshold":2,"Denominator":86.992,"LogDenominator":4.4658,"Numerator":18.7368,"Metric":0.2154},{"Threshold":2,"Denominator":90.2,"LogDenominator":4.502,"Numerator":19.2562,"Metric":0.2135},{"Threshold":2,"Denominator":93.408,"LogDenominator":4.537,"Numerator":19.7727,"Metric":0.2117},{"Threshold":2,"Denominator":96.616,"LogDenominator":4.5707,"Numerator":20.2863,"Metric":0.21},{"Threshold":2,"Denominator":99.824,"LogDenominator":4.6034,"Numerator":20.7972,"Metric":0.2083},{"Threshold":2,"Denominator":103.032,"LogDenominator":4.635,"Numerator":21.3056,"Metric":0.2068},{"Threshold":2,"Denominator":106.24,"LogDenominator":4.6657,"Numerator":21.8116,"Metric":0.2053},{"Threshold":2,"Denominator":109.448,"LogDenominator":4.6954,"Numerator":22.3153,"Metric":0.2039},{"Threshold":2,"Denominator":112.656,"LogDenominator":4.7243,"Numerator":22.8167,"Metric":0.2025},{"Threshold":2,"Denominator":115.864,"LogDenominator":4.7524,"Numerator":23.316,"Metric":0.2012},{"Threshold":2,"Denominator":119.072,"LogDenominator":4.7797,"Numerator":23.8132,"Metric":0.2},{"Threshold":2,"Denominator":122.28,"LogDenominator":4.8063,"Numerator":24.3085,"Metric":0.1988},{"Threshold":2,"Denominator":125.488,"LogDenominator":4.8322,"Numerator":24.802,"Metric":0.1976},{"Threshold":2,"Denominator":128.696,"LogDenominator":4.8575,"Numerator":25.2936,"Metric":0.1965},{"Threshold":2,"Denominator":131.904,"LogDenominator":4.8821,"Numerator":25.7834,"Metric":0.1955},{"Threshold":2,"Denominator":135.112,"LogDenominator":4.9061,"Numerator":26.2716,"Metric":0.1944},{"Threshold":2,"Denominator":138.32,"LogDenominator":4.9296,"Numerator":26.7582,"Metric":0.1935},{"Threshold":2,"Denominator":141.528,"LogDenominator":4.9525,"Numerator":27.2432,"Metric":0.1925},{"Threshold":2,"Denominator":144.736,"LogDenominator":4.9749,"Numerator":27.7267,"Metric":0.1916},{"Threshold":2,"Denominator":147.944,"LogDenominator":4.9968,"Numerator":28.2087,"Metric":0.1907},{"Threshold":2,"Denominator":151.152,"LogDenominator":5.0183,"Numerator":28.6893,"Metric":0.1898},{"Threshold":2,"Denominator":154.36,"LogDenominator":5.0393,"Numerator":29.1686,"Metric":0.189},{"Threshold":2,"Denominator":157.568,"LogDenominator":5.0599,"Numerator":29.6465,"Metric":0.1882},{"Threshold":2,"Denominator":160.776,"LogDenominator":5.08,"Numerator":30.1231,"Metric":0.1874},{"Threshold":2,"Denominator":163.984,"LogDenominator":5.0998,"Numerator":30.5985,"Metric":0.1866},{"Threshold":2,"Denominator":167.192,"LogDenominator":5.1191,"Numerator":31.0727,"Metric":0.1859},{"Threshold":2,"Denominator":170.4,"LogDenominator":5.1381,"Numerator":31.5457,"Metric":0.1851},{"Threshold":2,"Denominator":173.608,"LogDenominator":5.1568,"Numerator":32.0176,"Metric":0.1844},{"Threshold":2,"Denominator":176.816,"LogDenominator":5.1751,"Numerator":32.4883,"Metric":0.1837},{"Threshold":2,"Denominator":180.024,"LogDenominator":5.1931,"Numerator":32.958,"Metric":0.1831},{"Threshold":2,"Denominator":183.232,"LogDenominator":5.2108,"Numerator":33.4266,"Metric":0.1824},{"Threshold":2,"Denominator":186.44,"LogDenominator":5.2281,"Numerator":33.8942,"Metric":0.1818},{"Threshold":2,"Denominator":189.648,"LogDenominator":5.2452,"Numerator":34.3608,"Metric":0.1812},{"Threshold":2,"Denominator":192.856,"LogDenominator":5.2619,"Numerator":34.8264,"Metric":0.1806},{"Threshold":2,"Denominator":196.064,"LogDenominator":5.2784,"Numerator":35.291,"Metric":0.18},{"Threshold":2,"Denominator":199.272,"LogDenominator":5.2947,"Numerator":35.7548,"Metric":0.1794},{"Threshold":2,"Denominator":202.48,"LogDenominator":5.3106,"Numerator":36.2176,"Metric":0.1789},{"Threshold":2,"Denominator":205.688,"LogDenominator":5.3264,"Numerator":36.6796,"Metric":0.1783},{"Threshold":2,"Denominator":208.896,"LogDenominator":5.3418,"Numerator":37.1407,"Metric":0.1778},{"Threshold":2,"Denominator":212.104,"LogDenominator":5.3571,"Numerator":37.6009,"Metric":0.1773},{"Threshold":2,"Denominator":215.312,"LogDenominator":5.3721,"Numerator":38.0603,"Metric":0.1768},{"Threshold":2,"Denominator":218.52,"LogDenominator":5.3869,"Numerator":38.5189,"Metric":0.1763},{"Threshold":2,"Denominator":221.728,"LogDenominator":5.4015,"Numerator":38.9768,"Metric":0.1758},{"Threshold":2,"Denominator":224.936,"LogDenominator":5.4158,"Numerator":39.4338,"Metric":0.1753},{"Threshold":2,"Denominator":228.144,"LogDenominator":5.43,"Numerator":39.8901,"Metric":0.1748},{"Threshold":2,"Denominator":231.352,"LogDenominator":5.4439,"Numerator":40.3457,"Metric":0.1744},{"Threshold":2,"Denominator":234.56,"LogDenominator":5.4577,"Numerator":40.8005,"Metric":0.1739},{"Threshold":2,"Denominator":237.768,"LogDenominator":5.4713,"Numerator":41.2547,"Metric":0.1735},{"Threshold":2,"Denominator":240.976,"LogDenominator":5.4847,"Numerator":41.7081,"Metric":0.1731},{"Threshold":2,"Denominator":244.184,"LogDenominator":5.4979,"Numerator":42.1609,"Metric":0.1727},{"Threshold":2,"Denominator":247.392,"LogDenominator":5.511,"Numerator":42.613,"Metric":0.1722},{"Threshold":2,"Denominator":250.6,"LogDenominator":5.5239,"Numerator":43.0644,"Metric":0.1718},{"Threshold":2,"Denominator":253.808,"LogDenominator":5.5366,"Numerator":43.5152,"Metric":0.1714},{"Threshold":2,"Denominator":257.016,"LogDenominator":5.5491,"Numerator":43.9654,"Metric":0.1711},{"Threshold":2,"Denominator":260.224,"LogDenominator":5.5615,"Numerator":44.415,"Metric":0.1707},{"Threshold":2,"Denominator":263.432,"LogDenominator":5.5738,"Numerator":44.8639,"Metric":0.1703},{"Threshold":2,"Denominator":266.64,"LogDenominator":5.5859,"Numerator":45.3123,"Metric":0.1699},{"Threshold":2,"Denominator":269.848,"LogDenominator":5.5979,"Numerator":45.76,"Metric":0.1696},{"Threshold":2,"Denominator":273.056,"LogDenominator":5.6097,"Numerator":46.2072,"Metric":0.1692},{"Threshold":2,"Denominator":276.264,"LogDenominator":5.6214,"Numerator":46.6539,"Metric":0.1689},{"Threshold":2,"Denominator":279.472,"LogDenominator":5.6329,"Numerator":47.0999,"Metric":0.1685},{"Threshold":2,"Denominator":282.68,"LogDenominator":5.6443,"Numerator":47.5455,"Metric":0.1682},{"Threshold":2,"Denominator":285.888,"LogDenominator":5.6556,"Numerator":47.9905,"Metric":0.1679},{"Threshold":2,"Denominator":289.096,"LogDenominator":5.6668,"Numerator":48.4349,"Metric":0.1675},{"Threshold":2,"Denominator":292.304,"LogDenominator":5.6778,"Numerator":48.8789,"Metric":0.1672},{"Threshold":2,"Denominator":295.512,"LogDenominator":5.6887,"Numerator":49.3224,"Metric":0.1669},{"Threshold":2,"Denominator":298.72,"LogDenominator":5.6995,"Numerator":49.7653,"Metric":0.1666},{"Threshold":2,"Denominator":301.928,"LogDenominator":5.7102,"Numerator":50.2078,"Metric":0.1663},{"Threshold":2,"Denominator":305.136,"LogDenominator":5.7208,"Numerator":50.6497,"Metric":0.166},{"Threshold":2,"Denominator":308.344,"LogDenominator":5.7312,"Numerator":51.0912,"Metric":0.1657},{"Threshold":2,"Denominator":311.552,"LogDenominator":5.7416,"Numerator":51.5322,"Metric":0.1654},{"Threshold":2,"Denominator":314.76,"LogDenominator":5.7518,"Numerator":51.9728,"Metric":0.1651},{"Threshold":2,"Denominator":317.968,"LogDenominator":5.762,"Numerator":52.4129,"Metric":0.1648},{"Threshold":2,"Denominator":321.176,"LogDenominator":5.772,"Numerator":52.8526,"Metric":0.1646},{"Threshold":2,"Denominator":324.384,"LogDenominator":5.7819,"Numerator":53.2918,"Metric":0.1643},{"Threshold":2,"Denominator":327.592,"LogDenominator":5.7918,"Numerator":53.7306,"Metric":0.164},{"Threshold":2,"Denominator":330.8,"LogDenominator":5.8015,"Numerator":54.1689,"Metric":0.1638},{"Threshold":2,"Denominator":334.008,"LogDenominator":5.8112,"Numerator":54.6068,"Metric":0.1635},{"Threshold":2,"Denominator":337.216,"LogDenominator":5.8207,"Numerator":55.0443,"Metric":0.1632},{"Threshold":2,"Denominator":340.424,"LogDenominator":5.8302,"Numerator":55.4814,"Metric":0.163},{"Threshold":2,"Denominator":343.632,"LogDenominator":5.8396,"Numerator":55.9181,"Metric":0.1627},{"Threshold":2,"Denominator":346.84,"LogDenominator":5.8489,"Numerator":56.3544,"Metric":0.1625},{"Threshold":2,"Denominator":350.048,"LogDenominator":5.8581,"Numerator":56.7903,"Metric":0.1622},{"Threshold":2,"Denominator":353.256,"LogDenominator":5.8672,"Numerator":57.2258,"Metric":0.162},{"Threshold":2,"Denominator":356.464,"LogDenominator":5.8762,"Numerator":57.661,"Metric":0.1618},{"Threshold":2,"Denominator":359.672,"LogDenominator":5.8852,"Numerator":58.0957,"Metric":0.1615},{"Threshold":2,"Denominator":362.88,"LogDenominator":5.8941,"Numerator":58.5301,"Metric":0.1613},{"Threshold":2,"Denominator":366.088,"LogDenominator":5.9029,"Numerator":58.9641,"Metric":0.1611},{"Threshold":2,"Denominator":369.296,"LogDenominator":5.9116,"Numerator":59.3978,"Metric":0.1608},{"Threshold":2,"Denominator":372.504,"LogDenominator":5.9202,"Numerator":59.8311,"Metric":0.1606},{"Threshold":2,"Denominator":375.712,"LogDenominator":5.9288,"Numerator":60.264,"Metric":0.1604},{"Threshold":2,"Denominator":378.92,"LogDenominator":5.9373,"Numerator":60.6966,"Metric":0.1602},{"Threshold":2,"Denominator":382.128,"LogDenominator":5.9458,"Numerator":61.1288,"Metric":0.16},{"Threshold":2,"Denominator":385.336,"LogDenominator":5.9541,"Numerator":61.5607,"Metric":0.1598},{"Threshold":2,"Denominator":388.544,"LogDenominator":5.9624,"Numerator":61.9923,"Metric":0.1596},{"Threshold":2,"Denominator":391.752,"LogDenominator":5.9706,"Numerator":62.4235,"Metric":0.1593},{"Threshold":2,"Denominator":394.96,"LogDenominator":5.9788,"Numerator":62.8544,"Metric":0.1591},{"Threshold":2,"Denominator":398.168,"LogDenominator":5.9869,"Numerator":63.285,"Metric":0.1589},{"Threshold":2,"Denominator":401.376,"LogDenominator":5.9949,"Numerator":63.7153,"Metric":0.1587},{"Threshold":2,"Denominator":404.584,"LogDenominator":6.0029,"Numerator":64.1452,"Metric":0.1585},{"Threshold":2,"Denominator":407.792,"LogDenominator":6.0108,"Numerator":64.5749,"Metric":0.1584},{"Threshold":2,"Denominator":411,"LogDenominator":6.0186,"Numerator":65.0042,"Metric":0.1582},{"Threshold":2,"Denominator":414.208,"LogDenominator":6.0264,"Numerator":65.4332,"Metric":0.158},{"Threshold":2,"Denominator":417.416,"LogDenominator":6.0341,"Numerator":65.8619,"Metric":0.1578},{"Threshold":2,"Denominator":420.624,"LogDenominator":6.0417,"Numerator":66.2903,"Metric":0.1576},{"Threshold":2,"Denominator":423.832,"LogDenominator":6.0493,"Numerator":66.7185,"Metric":0.1574},{"Threshold":2,"Denominator":427.04,"LogDenominator":6.0569,"Numerator":67.1463,"Metric":0.1572},{"Threshold":2,"Denominator":430.248,"LogDenominator":6.0644,"Numerator":67.5738,"Metric":0.1571},{"Threshold":2,"Denominator":433.456,"LogDenominator":6.0718,"Numerator":68.0011,"Metric":0.1569},{"Threshold":2,"Denominator":436.664,"LogDenominator":6.0792,"Numerator":68.4281,"Metric":0.1567},{"Threshold":2,"Denominator":439.872,"LogDenominator":6.0865,"Numerator":68.8548,"Metric":0.1565},{"Threshold":2,"Denominator":443.08,"LogDenominator":6.0938,"Numerator":69.2812,"Metric":0.1564},{"Threshold":2,"Denominator":446.288,"LogDenominator":6.101,"Numerator":69.7073,"Metric":0.1562},{"Threshold":2,"Denominator":449.496,"LogDenominator":6.1081,"Numerator":70.1332,"Metric":0.156},{"Threshold":2,"Denominator":452.704,"LogDenominator":6.1152,"Numerator":70.5588,"Metric":0.1559},{"Threshold":2,"Denominator":455.912,"LogDenominator":6.1223,"Numerator":70.9842,"Metric":0.1557},{"Threshold":2,"Denominator":459.12,"LogDenominator":6.1293,"Numerator":71.4093,"Metric":0.1555},{"Threshold":2,"Denominator":462.328,"LogDenominator":6.1363,"Numerator":71.8341,"Metric":0.1554},{"Threshold":2,"Denominator":465.536,"LogDenominator":6.1432,"Numerator":72.2587,"Metric":0.1552},{"Threshold":2,"Denominator":468.744,"LogDenominator":6.1501,"Numerator":72.683,"Metric":0.1551},{"Threshold":2,"Denominator":471.952,"LogDenominator":6.1569,"Numerator":73.1071,"Metric":0.1549},{"Threshold":2,"Denominator":475.16,"LogDenominator":6.1637,"Numerator":73.5309,"Metric":0.1547},{"Threshold":2,"Denominator":478.368,"LogDenominator":6.1704,"Numerator":73.9545,"Metric":0.1546},{"Threshold":2,"Denominator":481.576,"LogDenominator":6.1771,"Numerator":74.3778,"Metric":0.1544},{"Threshold":2,"Denominator":484.784,"LogDenominator":6.1837,"Numerator":74.8009,"Metric":0.1543},{"Threshold":2,"Denominator":487.992,"LogDenominator":6.1903,"Numerator":75.2238,"Metric":0.1541},{"Threshold":2,"Denominator":491.2,"LogDenominator":6.1969,"Numerator":75.6464,"Metric":0.154},{"Threshold":2,"Denominator":494.408,"LogDenominator":6.2034,"Numerator":76.0688,"Metric":0.1539},{"Threshold":2,"Denominator":497.616,"LogDenominator":6.2098,"Numerator":76.4909,"Metric":0.1537},{"Threshold":2,"Denominator":500.824,"LogDenominator":6.2163,"Numerator":76.9128,"Metric":0.1536},{"Threshold":2,"Denominator":504.032,"LogDenominator":6.2226,"Numerator":77.3345,"Metric":0.1534},{"Threshold":2,"Denominator":507.24,"LogDenominator":6.229,"Numerator":77.756,"Metric":0.1533},{"Threshold":2,"Denominator":510.448,"LogDenominator":6.2353,"Numerator":78.1773,"Metric":0.1532},{"Threshold":2,"Denominator":513.656,"LogDenominator":6.2416,"Numerator":78.5983,"Metric":0.153},{"Threshold":2,"Denominator":516.864,"LogDenominator":6.2478,"Numerator":79.0191,"Metric":0.1529},{"Threshold":2,"Denominator":520.072,"LogDenominator":6.254,"Numerator":79.4397,"Metric":0.1527},{"Threshold":2,"Denominator":523.28,"LogDenominator":6.2601,"Numerator":79.8601,"Metric":0.1526},{"Threshold":2,"Denominator":526.488,"LogDenominator":6.2662,"Numerator":80.2802,"Metric":0.1525},{"Threshold":2,"Denominator":529.696,"LogDenominator":6.2723,"Numerator":80.7002,"Metric":0.1524},{"Threshold":2,"Denominator":532.904,"LogDenominator":6.2783,"Numerator":81.12,"Metric":0.1522},{"Threshold":2,"Denominator":536.112,"LogDenominator":6.2843,"Numerator":81.5395,"Metric":0.1521},{"Threshold":2,"Denominator":539.32,"LogDenominator":6.2903,"Numerator":81.9588,"Metric":0.152},{"Threshold":2,"Denominator":542.528,"LogDenominator":6.2962,"Numerator":82.378,"Metric":0.1518},{"Threshold":2,"Denominator":545.736,"LogDenominator":6.3021,"Numerator":82.7969,"Metric":0.1517},{"Threshold":2,"Denominator":548.944,"LogDenominator":6.308,"Numerator":83.2156,"Metric":0.1516},{"Threshold":2,"Denominator":552.152,"LogDenominator":6.3138,"Numerator":83.6342,"Metric":0.1515},{"Threshold":2,"Denominator":555.36,"LogDenominator":6.3196,"Numerator":84.0525,"Metric":0.1513},{"Threshold":2,"Denominator":558.568,"LogDenominator":6.3254,"Numerator":84.4707,"Metric":0.1512},{"Threshold":2,"Denominator":561.776,"LogDenominator":6.3311,"Numerator":84.8886,"Metric":0.1511},{"Threshold":2,"Denominator":564.984,"LogDenominator":6.3368,"Numerator":85.3064,"Metric":0.151},{"Threshold":2,"Denominator":568.192,"LogDenominator":6.3425,"Numerator":85.7239,"Metric":0.1509},{"Threshold":2,"Denominator":571.4,"LogDenominator":6.3481,"Numerator":86.1413,"Metric":0.1508},{"Threshold":2,"Denominator":574.608,"LogDenominator":6.3537,"Numerator":86.5585,"Metric":0.1506},{"Threshold":2,"Denominator":577.816,"LogDenominator":6.3593,"Numerator":86.9755,"Metric":0.1505},{"Threshold":2,"Denominator":581.024,"LogDenominator":6.3648,"Numerator":87.3924,"Metric":0.1504},{"Threshold":2,"Denominator":584.232,"LogDenominator":6.3703,"Numerator":87.809,"Metric":0.1503},{"Threshold":2,"Denominator":587.44,"LogDenominator":6.3758,"Numerator":88.2255,"Metric":0.1502},{"Threshold":2,"Denominator":590.648,"LogDenominator":6.3812,"Numerator":88.6418,"Metric":0.1501},{"Threshold":2,"Denominator":593.856,"LogDenominator":6.3866,"Numerator":89.0579,"Metric":0.15},{"Threshold":2,"Denominator":597.064,"LogDenominator":6.392,"Numerator":89.4738,"Metric":0.1499},{"Threshold":2,"Denominator":600.272,"LogDenominator":6.3974,"Numerator":89.8896,"Metric":0.1497},{"Threshold":2,"Denominator":603.48,"LogDenominator":6.4027,"Numerator":90.3052,"Metric":0.1496},{"Threshold":2,"Denominator":606.688,"LogDenominator":6.408,"Numerator":90.7206,"Metric":0.1495},{"Threshold":2,"Denominator":609.896,"LogDenominator":6.4133,"Numerator":91.1358,"Metric":0.1494},{"Threshold":2,"Denominator":613.104,"LogDenominator":6.4185,"Numerator":91.5509,"Metric":0.1493},{"Threshold":2,"Denominator":616.312,"LogDenominator":6.4238,"Numerator":91.9658,"Metric":0.1492},{"Threshold":2,"Denominator":619.52,"LogDenominator":6.4289,"Numerator":92.3806,"Metric":0.1491},{"Threshold":2,"Denominator":622.728,"LogDenominator":6.4341,"Numerator":92.7952,"Metric":0.149},{"Threshold":2,"Denominator":625.936,"LogDenominator":6.4392,"Numerator":93.2096,"Metric":0.1489},{"Threshold":2,"Denominator":629.144,"LogDenominator":6.4444,"Numerator":93.6238,"Metric":0.1488},{"Threshold":2,"Denominator":632.352,"LogDenominator":6.4494,"Numerator":94.0379,"Metric":0.1487},{"Threshold":2,"Denominator":635.56,"LogDenominator":6.4545,"Numerator":94.4519,"Metric":0.1486},{"Threshold":2,"Denominator":638.768,"LogDenominator":6.4595,"Numerator":94.8656,"Metric":0.1485},{"Threshold":2,"Denominator":641.976,"LogDenominator":6.4646,"Numerator":95.2793,"Metric":0.1484},{"Threshold":2,"Denominator":645.184,"LogDenominator":6.4695,"Numerator":95.6927,"Metric":0.1483},{"Threshold":2,"Denominator":648.392,"LogDenominator":6.4745,"Numerator":96.106,"Metric":0.1482},{"Threshold":2,"Denominator":651.6,"LogDenominator":6.4794,"Numerator":96.5192,"Metric":0.1481},{"Threshold":2,"Denominator":654.808,"LogDenominator":6.4843,"Numerator":96.9322,"Metric":0.148},{"Threshold":2,"Denominator":658.016,"LogDenominator":6.4892,"Numerator":97.345,"Metric":0.1479},{"Threshold":2,"Denominator":661.224,"LogDenominator":6.4941,"Numerator":97.7577,"Metric":0.1478},{"Threshold":2,"Denominator":664.432,"LogDenominator":6.4989,"Numerator":98.1703,"Metric":0.1478},{"Threshold":2,"Denominator":667.64,"LogDenominator":6.5037,"Numerator":98.5827,"Metric":0.1477},{"Threshold":2,"Denominator":670.848,"LogDenominator":6.5085,"Numerator":98.9949,"Metric":0.1476},{"Threshold":2,"Denominator":674.056,"LogDenominator":6.5133,"Numerator":99.407,"Metric":0.1475},{"Threshold":2,"Denominator":677.264,"LogDenominator":6.5181,"Numerator":99.819,"Metric":0.1474},{"Threshold":2,"Denominator":680.472,"LogDenominator":6.5228,"Numerator":100.2308,"Metric":0.1473},{"Threshold":2,"Denominator":683.68,"LogDenominator":6.5275,"Numerator":100.6425,"Metric":0.1472},{"Threshold":2,"Denominator":686.888,"LogDenominator":6.5322,"Numerator":101.054,"Metric":0.1471},{"Threshold":2,"Denominator":690.096,"LogDenominator":6.5368,"Numerator":101.4654,"Metric":0.147},{"Threshold":2,"Denominator":693.304,"LogDenominator":6.5415,"Numerator":101.8766,"Metric":0.1469},{"Threshold":2,"Denominator":696.512,"LogDenominator":6.5461,"Numerator":102.2877,"Metric":0.1469},{"Threshold":2,"Denominator":699.72,"LogDenominator":6.5507,"Numerator":102.6987,"Metric":0.1468},{"Threshold":2,"Denominator":702.928,"LogDenominator":6.5553,"Numerator":103.1095,"Metric":0.1467},{"Threshold":2,"Denominator":706.136,"LogDenominator":6.5598,"Numerator":103.5202,"Metric":0.1466},{"Threshold":2,"Denominator":709.344,"LogDenominator":6.5643,"Numerator":103.9308,"Metric":0.1465},{"Threshold":2,"Denominator":712.552,"LogDenominator":6.5689,"Numerator":104.3412,"Metric":0.1464},{"Threshold":2,"Denominator":715.76,"LogDenominator":6.5733,"Numerator":104.7515,"Metric":0.1464},{"Threshold":2,"Denominator":718.968,"LogDenominator":6.5778,"Numerator":105.1617,"Metric":0.1463},{"Threshold":2,"Denominator":722.176,"LogDenominator":6.5823,"Numerator":105.5717,"Metric":0.1462},{"Threshold":2,"Denominator":725.384,"LogDenominator":6.5867,"Numerator":105.9816,"Metric":0.1461},{"Threshold":2,"Denominator":728.592,"LogDenominator":6.5911,"Numerator":106.3914,"Metric":0.146},{"Threshold":2,"Denominator":731.8,"LogDenominator":6.5955,"Numerator":106.801,"Metric":0.1459},{"Threshold":2,"Denominator":735.008,"LogDenominator":6.5999,"Numerator":107.2105,"Metric":0.1459},{"Threshold":2,"Denominator":738.216,"LogDenominator":6.6042,"Numerator":107.6199,"Metric":0.1458},{"Threshold":2,"Denominator":741.424,"LogDenominator":6.6086,"Numerator":108.0292,"Metric":0.1457},{"Threshold":2,"Denominator":744.632,"LogDenominator":6.6129,"Numerator":108.4383,"Metric":0.1456},{"Threshold":2,"Denominator":747.84,"LogDenominator":6.6172,"Numerator":108.8473,"Metric":0.1455},{"Threshold":2,"Denominator":751.048,"LogDenominator":6.6215,"Numerator":109.2562,"Metric":0.1455},{"Threshold":2,"Denominator":754.256,"LogDenominator":6.6257,"Numerator":109.6649,"Metric":0.1454},{"Threshold":2,"Denominator":757.464,"LogDenominator":6.63,"Numerator":110.0736,"Metric":0.1453},{"Threshold":2,"Denominator":760.672,"LogDenominator":6.6342,"Numerator":110.4821,"Metric":0.1452},{"Threshold":2,"Denominator":763.88,"LogDenominator":6.6384,"Numerator":110.8905,"Metric":0.1452},{"Threshold":2,"Denominator":767.088,"LogDenominator":6.6426,"Numerator":111.2987,"Metric":0.1451},{"Threshold":2,"Denominator":770.296,"LogDenominator":6.6468,"Numerator":111.7069,"Metric":0.145},{"Threshold":2,"Denominator":773.504,"LogDenominator":6.6509,"Numerator":112.1149,"Metric":0.1449},{"Threshold":2,"Denominator":776.712,"LogDenominator":6.6551,"Numerator":112.5228,"Metric":0.1449},{"Threshold":2,"Denominator":779.92,"LogDenominator":6.6592,"Numerator":112.9306,"Metric":0.1448},{"Threshold":2,"Denominator":783.128,"LogDenominator":6.6633,"Numerator":113.3383,"Metric":0.1447},{"Threshold":2,"Denominator":786.336,"LogDenominator":6.6674,"Numerator":113.7458,"Metric":0.1447},{"Threshold":2,"Denominator":789.544,"LogDenominator":6.6715,"Numerator":114.1533,"Metric":0.1446},{"Threshold":2,"Denominator":792.752,"LogDenominator":6.6755,"Numerator":114.5606,"Metric":0.1445},{"Threshold":2,"Denominator":795.96,"LogDenominator":6.6795,"Numerator":114.9678,"Metric":0.1444},{"Threshold":2,"Denominator":799.168,"LogDenominator":6.6836,"Numerator":115.3749,"Metric":0.1444},{"Threshold":2,"Denominator":802.376,"LogDenominator":6.6876,"Numerator":115.7819,"Metric":0.1443},{"Threshold":2,"Denominator":805.584,"LogDenominator":6.6916,"Numerator":116.1888,"Metric":0.1442},{"Threshold":2,"Denominator":808.792,"LogDenominator":6.6955,"Numerator":116.5956,"Metric":0.1442},{"Threshold":2,"Denominator":812,"LogDenominator":6.6995,"Numerator":117.0022,"Metric":0.1441},{"Threshold":2,"Denominator":815.208,"LogDenominator":6.7034,"Numerator":117.4088,"Metric":0.144},{"Threshold":3,"Denominator":6.792,"LogDenominator":1.9157,"Numerator":4.6073,"Metric":0.6783},{"Threshold":3,"Denominator":10,"LogDenominator":2.3026,"Numerator":5.7829,"Metric":0.5783},{"Threshold":3,"Denominator":13.208,"LogDenominator":2.5808,"Numerator":6.8337,"Metric":0.5174},{"Threshold":3,"Denominator":16.416,"LogDenominator":2.7983,"Numerator":7.8036,"Metric":0.4754},{"Threshold":3,"Denominator":19.624,"LogDenominator":2.9768,"Numerator":8.7153,"Metric":0.4441},{"Threshold":3,"Denominator":22.832,"LogDenominator":3.1282,"Numerator":9.5829,"Metric":0.4197},{"Threshold":3,"Denominator":26.04,"LogDenominator":3.2596,"Numerator":10.4152,"Metric":0.4},{"Threshold":3,"Denominator":29.248,"LogDenominator":3.3758,"Numerator":11.2187,"Metric":0.3836},{"Threshold":3,"Denominator":32.456,"LogDenominator":3.4799,"Numerator":11.998,"Metric":0.3697},{"Threshold":3,"Denominator":35.664,"LogDenominator":3.5741,"Numerator":12.7566,"Metric":0.3577},{"Threshold":3,"Denominator":38.872,"LogDenominator":3.6603,"Numerator":13.4972,"Metric":0.3472},{"Threshold":3,"Denominator":42.08,"LogDenominator":3.7396,"Numerator":14.2221,"Metric":0.338},{"Threshold":3,"Denominator":45.288,"LogDenominator":3.813,"Numerator":14.933,"Metric":0.3297},{"Threshold":3,"Denominator":48.496,"LogDenominator":3.8815,"Numerator":15.6313,"Metric":0.3223},{"Threshold":3,"Denominator":51.704,"LogDenominator":3.9455,"Numerator":16.3183,"Metric":0.3156},{"Threshold":3,"Denominator":54.912,"LogDenominator":4.0057,"Numerator":16.9951,"Metric":0.3095},{"Threshold":3,"Denominator":58.12,"LogDenominator":4.0625,"Numerator":17.6624,"Metric":0.3039},{"Threshold":3,"Denominator":61.328,"LogDenominator":4.1162,"Numerator":18.3212,"Metric":0.2987},{"Threshold":3,"Denominator":64.536,"LogDenominator":4.1672,"Numerator":18.9719,"Metric":0.294},{"Threshold":3,"Denominator":67.744,"LogDenominator":4.2157,"Numerator":19.6154,"Metric":0.2896},{"Threshold":3,"Denominator":70.952,"LogDenominator":4.262,"Numerator":20.2519,"Metric":0.2854},{"Threshold":3,"Denominator":74.16,"LogDenominator":4.3062,"Numerator":20.8821,"Metric":0.2816},{"Threshold":3,"Denominator":77.368,"LogDenominator":4.3486,"Numerator":21.5064,"Metric":0.278},{"Threshold":3,"Denominator":80.576,"LogDenominator":4.3892,"Numerator":22.125,"Metric":0.2746},{"Threshold":3,"Denominator":83.784,"LogDenominator":4.4282,"Numerator":22.7383,"Metric":0.2714},{"Threshold":3,"Denominator":86.992,"LogDenominator":4.4658,"Numerator":23.3466,"Metric":0.2684},{"Threshold":3,"Denominator":90.2,"LogDenominator":4.502,"Numerator":23.9503,"Metric":0.2655},{"Threshold":3,"Denominator":93.408,"LogDenominator":4.537,"Numerator":24.5495,"Metric":0.2628},{"Threshold":3,"Denominator":96.616,"LogDenominator":4.5707,"Numerator":25.1444,"Metric":0.2603},{"Threshold":3,"Denominator":99.824,"LogDenominator":4.6034,"Numerator":25.7354,"Metric":0.2578},{"Threshold":3,"Denominator":103.032,"LogDenominator":4.635,"Numerator":26.3225,"Metric":0.2555},{"Threshold":3,"Denominator":106.24,"LogDenominator":4.6657,"Numerator":26.906,"Metric":0.2533},{"Threshold":3,"Denominator":109.448,"LogDenominator":4.6954,"Numerator":27.486,"Metric":0.2511},{"Threshold":3,"Denominator":112.656,"LogDenominator":4.7243,"Numerator":28.0626,"Metric":0.2491},{"Threshold":3,"Denominator":115.864,"LogDenominator":4.7524,"Numerator":28.6361,"Metric":0.2472},{"Threshold":3,"Denominator":119.072,"LogDenominator":4.7797,"Numerator":29.2065,"Metric":0.2453},{"Threshold":3,"Denominator":122.28,"LogDenominator":4.8063,"Numerator":29.774,"Metric":0.2435},{"Threshold":3,"Denominator":125.488,"LogDenominator":4.8322,"Numerator":30.3386,"Metric":0.2418},{"Threshold":3,"Denominator":128.696,"LogDenominator":4.8575,"Numerator":30.9006,"Metric":0.2401},{"Threshold":3,"Denominator":131.904,"LogDenominator":4.8821,"Numerator":31.4599,"Metric":0.2385},{"Threshold":3,"Denominator":135.112,"LogDenominator":4.9061,"Numerator":32.0167,"Metric":0.237},{"Threshold":3,"Denominator":138.32,"LogDenominator":4.9296,"Numerator":32.571,"Metric":0.2355},{"Threshold":3,"Denominator":141.528,"LogDenominator":4.9525,"Numerator":33.1231,"Metric":0.234},{"Threshold":3,"Denominator":144.736,"LogDenominator":4.9749,"Numerator":33.6728,"Metric":0.2326},{"Threshold":3,"Denominator":147.944,"LogDenominator":4.9968,"Numerator":34.2204,"Metric":0.2313},{"Threshold":3,"Denominator":151.152,"LogDenominator":5.0183,"Numerator":34.7658,"Metric":0.23},{"Threshold":3,"Denominator":154.36,"LogDenominator":5.0393,"Numerator":35.3092,"Metric":0.2287},{"Threshold":3,"Denominator":157.568,"LogDenominator":5.0599,"Numerator":35.8506,"Metric":0.2275},{"Threshold":3,"Denominator":160.776,"LogDenominator":5.08,"Numerator":36.3901,"Metric":0.2263},{"Threshold":3,"Denominator":163.984,"LogDenominator":5.0998,"Numerator":36.9277,"Metric":0.2252},{"Threshold":3,"Denominator":167.192,"LogDenominator":5.1191,"Numerator":37.4635,"Metric":0.2241},{"Threshold":3,"Denominator":170.4,"LogDenominator":5.1381,"Numerator":37.9975,"Metric":0.223},{"Threshold":3,"Denominator":173.608,"LogDenominator":5.1568,"Numerator":38.5298,"Metric":0.2219},{"Threshold":3,"Denominator":176.816,"LogDenominator":5.1751,"Numerator":39.0605,"Metric":0.2209},{"Threshold":3,"Denominator":180.024,"LogDenominator":5.1931,"Numerator":39.5895,"Metric":0.2199},{"Threshold":3,"Denominator":183.232,"LogDenominator":5.2108,"Numerator":40.1169,"Metric":0.2189},{"Threshold":3,"Denominator":186.44,"LogDenominator":5.2281,"Numerator":40.6428,"Metric":0.218},{"Threshold":3,"Denominator":189.648,"LogDenominator":5.2452,"Numerator":41.1672,"Metric":0.2171},{"Threshold":3,"Denominator":192.856,"LogDenominator":5.2619,"Numerator":41.6902,"Metric":0.2162},{"Threshold":3,"Denominator":196.064,"LogDenominator":5.2784,"Numerator":42.2117,"Metric":0.2153},{"Threshold":3,"Denominator":199.272,"LogDenominator":5.2947,"Numerator":42.7318,"Metric":0.2144},{"Threshold":3,"Denominator":202.48,"LogDenominator":5.3106,"Numerator":43.2506,"Metric":0.2136},{"Threshold":3,"Denominator":205.688,"LogDenominator":5.3264,"Numerator":43.768,"Metric":0.2128},{"Threshold":3,"Denominator":208.896,"LogDenominator":5.3418,"Numerator":44.2842,"Metric":0.212},{"Threshold":3,"Denominator":212.104,"LogDenominator":5.3571,"Numerator":44.7991,"Metric":0.2112},{"Threshold":3,"Denominator":215.312,"LogDenominator":5.3721,"Numerator":45.3127,"Metric":0.2105},{"Threshold":3,"Denominator":218.52,"LogDenominator":5.3869,"Numerator":45.8252,"Metric":0.2097},{"Threshold":3,"Denominator":221.728,"LogDenominator":5.4015,"Numerator":46.3364,"Metric":0.209},{"Threshold":3,"Denominator":224.936,"LogDenominator":5.4158,"Numerator":46.8465,"Metric":0.2083},{"Threshold":3,"Denominator":228.144,"LogDenominator":5.43,"Numerator":47.3555,"Metric":0.2076},{"Threshold":3,"Denominator":231.352,"LogDenominator":5.4439,"Numerator":47.8634,"Metric":0.2069},{"Threshold":3,"Denominator":234.56,"LogDenominator":5.4577,"Numerator":48.3702,"Metric":0.2062},{"Threshold":3,"Denominator":237.768,"LogDenominator":5.4713,"Numerator":48.8759,"Metric":0.2056},{"Threshold":3,"Denominator":240.976,"LogDenominator":5.4847,"Numerator":49.3806,"Metric":0.2049},{"Threshold":3,"Denominator":244.184,"LogDenominator":5.4979,"Numerator":49.8842,"Metric":0.2043},{"Threshold":3,"Denominator":247.392,"LogDenominator":5.511,"Numerator":50.3869,"Metric":0.2037},{"Threshold":3,"Denominator":250.6,"LogDenominator":5.5239,"Numerator":50.8886,"Metric":0.2031},{"Threshold":3,"Denominator":253.808,"LogDenominator":5.5366,"Numerator":51.3893,"Metric":0.2025},{"Threshold":3,"Denominator":257.016,"LogDenominator":5.5491,"Numerator":51.8891,"Metric":0.2019},{"Threshold":3,"Denominator":260.224,"LogDenominator":5.5615,"Numerator":52.3879,"Metric":0.2013},{"Threshold":3,"Denominator":263.432,"LogDenominator":5.5738,"Numerator":52.8859,"Metric":0.2008},{"Threshold":3,"Denominator":266.64,"LogDenominator":5.5859,"Numerator":53.3829,"Metric":0.2002},{"Threshold":3,"Denominator":269.848,"LogDenominator":5.5979,"Numerator":53.8791,"Metric":0.1997},{"Threshold":3,"Denominator":273.056,"LogDenominator":5.6097,"Numerator":54.3744,"Metric":0.1991},{"Threshold":3,"Denominator":276.264,"LogDenominator":5.6214,"Numerator":54.8689,"Metric":0.1986},{"Threshold":3,"Denominator":279.472,"LogDenominator":5.6329,"Numerator":55.3625,"Metric":0.1981},{"Threshold":3,"Denominator":282.68,"LogDenominator":5.6443,"Numerator":55.8554,"Metric":0.1976},{"Threshold":3,"Denominator":285.888,"LogDenominator":5.6556,"Numerator":56.3474,"Metric":0.1971},{"Threshold":3,"Denominator":289.096,"LogDenominator":5.6668,"Numerator":56.8386,"Metric":0.1966},{"Threshold":3,"Denominator":292.304,"LogDenominator":5.6778,"Numerator":57.3291,"Metric":0.1961},{"Threshold":3,"Denominator":295.512,"LogDenominator":5.6887,"Numerator":57.8188,"Metric":0.1957},{"Threshold":3,"Denominator":298.72,"LogDenominator":5.6995,"Numerator":58.3077,"Metric":0.1952},{"Threshold":3,"Denominator":301.928,"LogDenominator":5.7102,"Numerator":58.7959,"Metric":0.1947},{"Threshold":3,"Denominator":305.136,"LogDenominator":5.7208,"Numerator":59.2834,"Metric":0.1943},{"Threshold":3,"Denominator":308.344,"LogDenominator":5.7312,"Numerator":59.7701,"Metric":0.1938},{"Threshold":3,"Denominator":311.552,"LogDenominator":5.7416,"Numerator":60.2562,"Metric":0.1934},{"Threshold":3,"Denominator":314.76,"LogDenominator":5.7518,"Numerator":60.7415,"Metric":0.193},{"Threshold":3,"Denominator":317.968,"LogDenominator":5.762,"Numerator":61.2262,"Metric":0.1926},{"Threshold":3,"Denominator":321.176,"LogDenominator":5.772,"Numerator":61.7102,"Metric":0.1921},{"Threshold":3,"Denominator":324.384,"LogDenominator":5.7819,"Numerator":62.1936,"Metric":0.1917},{"Threshold":3,"Denominator":327.592,"LogDenominator":5.7918,"Numerator":62.6762,"Metric":0.1913},{"Threshold":3,"Denominator":330.8,"LogDenominator":5.8015,"Numerator":63.1583,"Metric":0.1909},{"Threshold":3,"Denominator":334.008,"LogDenominator":5.8112,"Numerator":63.6397,"Metric":0.1905},{"Threshold":3,"Denominator":337.216,"LogDenominator":5.8207,"Numerator":64.1205,"Metric":0.1901},{"Threshold":3,"Denominator":340.424,"LogDenominator":5.8302,"Numerator":64.6007,"Metric":0.1898},{"Threshold":3,"Denominator":343.632,"LogDenominator":5.8396,"Numerator":65.0802,"Metric":0.1894},{"Threshold":3,"Denominator":346.84,"LogDenominator":5.8489,"Numerator":65.5592,"Metric":0.189},{"Threshold":3,"Denominator":350.048,"LogDenominator":5.8581,"Numerator":66.0376,"Metric":0.1887},{"Threshold":3,"Denominator":353.256,"LogDenominator":5.8672,"Numerator":66.5153,"Metric":0.1883},{"Threshold":3,"Denominator":356.464,"LogDenominator":5.8762,"Numerator":66.9926,"Metric":0.1879},{"Threshold":3,"Denominator":359.672,"LogDenominator":5.8852,"Numerator":67.4692,"Metric":0.1876},{"Threshold":3,"Denominator":362.88,"LogDenominator":5.8941,"Numerator":67.9453,"Metric":0.1872},{"Threshold":3,"Denominator":366.088,"LogDenominator":5.9029,"Numerator":68.4208,"Metric":0.1869},{"Threshold":3,"Denominator":369.296,"LogDenominator":5.9116,"Numerator":68.8958,"Metric":0.1866},{"Threshold":3,"Denominator":372.504,"LogDenominator":5.9202,"Numerator":69.3703,"Metric":0.1862},{"Threshold":3,"Denominator":375.712,"LogDenominator":5.9288,"Numerator":69.8442,"Metric":0.1859},{"Threshold":3,"Denominator":378.92,"LogDenominator":5.9373,"Numerator":70.3176,"Metric":0.1856},{"Threshold":3,"Denominator":382.128,"LogDenominator":5.9458,"Numerator":70.7905,"Metric":0.1853},{"Threshold":3,"Denominator":385.336,"LogDenominator":5.9541,"Numerator":71.2629,"Metric":0.1849},{"Threshold":3,"Denominator":388.544,"LogDenominator":5.9624,"Numerator":71.7347,"Metric":0.1846},{"Threshold":3,"Denominator":391.752,"LogDenominator":5.9706,"Numerator":72.2061,"Metric":0.1843},{"Threshold":3,"Denominator":394.96,"LogDenominator":5.9788,"Numerator":72.677,"Metric":0.184},{"Threshold":3,"Denominator":398.168,"LogDenominator":5.9869,"Numerator":73.1474,"Metric":0.1837},{"Threshold":3,"Denominator":401.376,"LogDenominator":5.9949,"Numerator":73.6173,"Metric":0.1834},{"Threshold":3,"Denominator":404.584,"LogDenominator":6.0029,"Numerator":74.0867,"Metric":0.1831},{"Threshold":3,"Denominator":407.792,"LogDenominator":6.0108,"Numerator":74.5557,"Metric":0.1828},{"Threshold":3,"Denominator":411,"LogDenominator":6.0186,"Numerator":75.0242,"Metric":0.1825},{"Threshold":3,"Denominator":414.208,"LogDenominator":6.0264,"Numerator":75.4922,"Metric":0.1823},{"Threshold":3,"Denominator":417.416,"LogDenominator":6.0341,"Numerator":75.9598,"Metric":0.182},{"Threshold":3,"Denominator":420.624,"LogDenominator":6.0417,"Numerator":76.427,"Metric":0.1817},{"Threshold":3,"Denominator":423.832,"LogDenominator":6.0493,"Numerator":76.8937,"Metric":0.1814},{"Threshold":3,"Denominator":427.04,"LogDenominator":6.0569,"Numerator":77.36,"Metric":0.1812},{"Threshold":3,"Denominator":430.248,"LogDenominator":6.0644,"Numerator":77.8258,"Metric":0.1809},{"Threshold":3,"Denominator":433.456,"LogDenominator":6.0718,"Numerator":78.2912,"Metric":0.1806},{"Threshold":3,"Denominator":436.664,"LogDenominator":6.0792,"Numerator":78.7562,"Metric":0.1804},{"Threshold":3,"Denominator":439.872,"LogDenominator":6.0865,"Numerator":79.2208,"Metric":0.1801},{"Threshold":3,"Denominator":443.08,"LogDenominator":6.0938,"Numerator":79.6849,"Metric":0.1798},{"Threshold":3,"Denominator":446.288,"LogDenominator":6.101,"Numerator":80.1487,"Metric":0.1796},{"Threshold":3,"Denominator":449.496,"LogDenominator":6.1081,"Numerator":80.612,"Metric":0.1793},{"Threshold":3,"Denominator":452.704,"LogDenominator":6.1152,"Numerator":81.0749,"Metric":0.1791},{"Threshold":3,"Denominator":455.912,"LogDenominator":6.1223,"Numerator":81.5375,"Metric":0.1788},{"Threshold":3,"Denominator":459.12,"LogDenominator":6.1293,"Numerator":81.9996,"Metric":0.1786},{"Threshold":3,"Denominator":462.328,"LogDenominator":6.1363,"Numerator":82.4614,"Metric":0.1784},{"Threshold":3,"Denominator":465.536,"LogDenominator":6.1432,"Numerator":82.9228,"Metric":0.1781},{"Threshold":3,"Denominator":468.744,"LogDenominator":6.1501,"Numerator":83.3838,"Metric":0.1779},{"Threshold":3,"Denominator":471.952,"LogDenominator":6.1569,"Numerator":83.8444,"Metric":0.1777},{"Threshold":3,"Denominator":475.16,"LogDenominator":6.1637,"Numerator":84.3047,"Metric":0.1774},{"Threshold":3,"Denominator":478.368,"LogDenominator":6.1704,"Numerator":84.7645,"Metric":0.1772},{"Threshold":3,"Denominator":481.576,"LogDenominator":6.1771,"Numerator":85.2241,"Metric":0.177},{"Threshold":3,"Denominator":484.784,"LogDenominator":6.1837,"Numerator":85.6832,"Metric":0.1767},{"Threshold":3,"Denominator":487.992,"LogDenominator":6.1903,"Numerator":86.142,"Metric":0.1765},{"Threshold":3,"Denominator":491.2,"LogDenominator":6.1969,"Numerator":86.6005,"Metric":0.1763},{"Threshold":3,"Denominator":494.408,"LogDenominator":6.2034,"Numerator":87.0586,"Metric":0.1761},{"Threshold":3,"Denominator":497.616,"LogDenominator":6.2098,"Numerator":87.5163,"Metric":0.1759},{"Threshold":3,"Denominator":500.824,"LogDenominator":6.2163,"Numerator":87.9737,"Metric":0.1757},{"Threshold":3,"Denominator":504.032,"LogDenominator":6.2226,"Numerator":88.4308,"Metric":0.1754},{"Threshold":3,"Denominator":507.24,"LogDenominator":6.229,"Numerator":88.8875,"Metric":0.1752},{"Threshold":3,"Denominator":510.448,"LogDenominator":6.2353,"Numerator":89.3439,"Metric":0.175},{"Threshold":3,"Denominator":513.656,"LogDenominator":6.2416,"Numerator":89.8,"Metric":0.1748},{"Threshold":3,"Denominator":516.864,"LogDenominator":6.2478,"Numerator":90.2557,"Metric":0.1746},{"Threshold":3,"Denominator":520.072,"LogDenominator":6.254,"Numerator":90.7111,"Metric":0.1744},{"Threshold":3,"Denominator":523.28,"LogDenominator":6.2601,"Numerator":91.1662,"Metric":0.1742},{"Threshold":3,"Denominator":526.488,"LogDenominator":6.2662,"Numerator":91.621,"Metric":0.174},{"Threshold":3,"Denominator":529.696,"LogDenominator":6.2723,"Numerator":92.0754,"Metric":0.1738},{"Threshold":3,"Denominator":532.904,"LogDenominator":6.2783,"Numerator":92.5296,"Metric":0.1736},{"Threshold":3,"Denominator":536.112,"LogDenominator":6.2843,"Numerator":92.9834,"Metric":0.1734},{"Threshold":3,"Denominator":539.32,"LogDenominator":6.2903,"Numerator":93.4369,"Metric":0.1732},{"Threshold":3,"Denominator":542.528,"LogDenominator":6.2962,"Numerator":93.8902,"Metric":0.1731},{"Threshold":3,"Denominator":545.736,"LogDenominator":6.3021,"Numerator":94.3431,"Metric":0.1729},{"Threshold":3,"Denominator":548.944,"LogDenominator":6.308,"Numerator":94.7957,"Metric":0.1727},{"Threshold":3,"Denominator":552.152,"LogDenominator":6.3138,"Numerator":95.248,"Metric":0.1725},{"Threshold":3,"Denominator":555.36,"LogDenominator":6.3196,"Numerator":95.7001,"Metric":0.1723},{"Threshold":3,"Denominator":558.568,"LogDenominator":6.3254,"Numerator":96.1518,"Metric":0.1721},{"Threshold":3,"Denominator":561.776,"LogDenominator":6.3311,"Numerator":96.6032,"Metric":0.172},{"Threshold":3,"Denominator":564.984,"LogDenominator":6.3368,"Numerator":97.0544,"Metric":0.1718},{"Threshold":3,"Denominator":568.192,"LogDenominator":6.3425,"Numerator":97.5053,"Metric":0.1716},{"Threshold":3,"Denominator":571.4,"LogDenominator":6.3481,"Numerator":97.9559,"Metric":0.1714},{"Threshold":3,"Denominator":574.608,"LogDenominator":6.3537,"Numerator":98.4062,"Metric":0.1713},{"Threshold":3,"Denominator":577.816,"LogDenominator":6.3593,"Numerator":98.8562,"Metric":0.1711},{"Threshold":3,"Denominator":581.024,"LogDenominator":6.3648,"Numerator":99.306,"Metric":0.1709},{"Threshold":3,"Denominator":584.232,"LogDenominator":6.3703,"Numerator":99.7555,"Metric":0.1707},{"Threshold":3,"Denominator":587.44,"LogDenominator":6.3758,"Numerator":100.2047,"Metric":0.1706},{"Threshold":3,"Denominator":590.648,"LogDenominator":6.3812,"Numerator":100.6537,"Metric":0.1704},{"Threshold":3,"Denominator":593.856,"LogDenominator":6.3866,"Numerator":101.1024,"Metric":0.1702},{"Threshold":3,"Denominator":597.064,"LogDenominator":6.392,"Numerator":101.5508,"Metric":0.1701},{"Threshold":3,"Denominator":600.272,"LogDenominator":6.3974,"Numerator":101.999,"Metric":0.1699},{"Threshold":3,"Denominator":603.48,"LogDenominator":6.4027,"Numerator":102.4469,"Metric":0.1698},{"Threshold":3,"Denominator":606.688,"LogDenominator":6.408,"Numerator":102.8945,"Metric":0.1696},{"Threshold":3,"Denominator":609.896,"LogDenominator":6.4133,"Numerator":103.3419,"Metric":0.1694},{"Threshold":3,"Denominator":613.104,"LogDenominator":6.4185,"Numerator":103.789,"Metric":0.1693},{"Threshold":3,"Denominator":616.312,"LogDenominator":6.4238,"Numerator":104.2359,"Metric":0.1691},{"Threshold":3,"Denominator":619.52,"LogDenominator":6.4289,"Numerator":104.6826,"Metric":0.169},{"Threshold":3,"Denominator":622.728,"LogDenominator":6.4341,"Numerator":105.129,"Metric":0.1688},{"Threshold":3,"Denominator":625.936,"LogDenominator":6.4392,"Numerator":105.5751,"Metric":0.1687},{"Threshold":3,"Denominator":629.144,"LogDenominator":6.4444,"Numerator":106.021,"Metric":0.1685},{"Threshold":3,"Denominator":632.352,"LogDenominator":6.4494,"Numerator":106.4667,"Metric":0.1684},{"Threshold":3,"Denominator":635.56,"LogDenominator":6.4545,"Numerator":106.9121,"Metric":0.1682},{"Threshold":3,"Denominator":638.768,"LogDenominator":6.4595,"Numerator":107.3573,"Metric":0.1681},{"Threshold":3,"Denominator":641.976,"LogDenominator":6.4646,"Numerator":107.8022,"Metric":0.1679},{"Threshold":3,"Denominator":645.184,"LogDenominator":6.4695,"Numerator":108.2469,"Metric":0.1678},{"Threshold":3,"Denominator":648.392,"LogDenominator":6.4745,"Numerator":108.6914,"Metric":0.1676},{"Threshold":3,"Denominator":651.6,"LogDenominator":6.4794,"Numerator":109.1356,"Metric":0.1675},{"Threshold":3,"Denominator":654.808,"LogDenominator":6.4843,"Numerator":109.5797,"Metric":0.1673},{"Threshold":3,"Denominator":658.016,"LogDenominator":6.4892,"Numerator":110.0235,"Metric":0.1672},{"Threshold":3,"Denominator":661.224,"LogDenominator":6.4941,"Numerator":110.467,"Metric":0.1671},{"Threshold":3,"Denominator":664.432,"LogDenominator":6.4989,"Numerator":110.9104,"Metric":0.1669},{"Threshold":3,"Denominator":667.64,"LogDenominator":6.5037,"Numerator":111.3535,"Metric":0.1668},{"Threshold":3,"Denominator":670.848,"LogDenominator":6.5085,"Numerator":111.7964,"Metric":0.1666},{"Threshold":3,"Denominator":674.056,"LogDenominator":6.5133,"Numerator":112.2391,"Metric":0.1665},{"Threshold":3,"Denominator":677.264,"LogDenominator":6.5181,"Numerator":112.6815,"Metric":0.1664},{"Threshold":3,"Denominator":680.472,"LogDenominator":6.5228,"Numerator":113.1238,"Metric":0.1662},{"Threshold":3,"Denominator":683.68,"LogDenominator":6.5275,"Numerator":113.5658,"Metric":0.1661},{"Threshold":3,"Denominator":686.888,"LogDenominator":6.5322,"Numerator":114.0076,"Metric":0.166},{"Threshold":3,"Denominator":690.096,"LogDenominator":6.5368,"Numerator":114.4492,"Metric":0.1658},{"Threshold":3,"Denominator":693.304,"LogDenominator":6.5415,"Numerator":114.8906,"Metric":0.1657},{"Threshold":3,"Denominator":696.512,"LogDenominator":6.5461,"Numerator":115.3318,"Metric":0.1656},{"Threshold":3,"Denominator":699.72,"LogDenominator":6.5507,"Numerator":115.7727,"Metric":0.1655},{"Threshold":3,"Denominator":702.928,"LogDenominator":6.5553,"Numerator":116.2135,"Metric":0.1653},{"Threshold":3,"Denominator":706.136,"LogDenominator":6.5598,"Numerator":116.6541,"Metric":0.1652},{"Threshold":3,"Denominator":709.344,"LogDenominator":6.5643,"Numerator":117.0944,"Metric":0.1651},{"Threshold":3,"Denominator":712.552,"LogDenominator":6.5689,"Numerator":117.5346,"Metric":0.1649},{"Threshold":3,"Denominator":715.76,"LogDenominator":6.5733,"Numerator":117.9746,"Metric":0.1648},{"Threshold":3,"Denominator":718.968,"LogDenominator":6.5778,"Numerator":118.4143,"Metric":0.1647},{"Threshold":3,"Denominator":722.176,"LogDenominator":6.5823,"Numerator":118.8539,"Metric":0.1646},{"Threshold":3,"Denominator":725.384,"LogDenominator":6.5867,"Numerator":119.2932,"Metric":0.1645},{"Threshold":3,"Denominator":728.592,"LogDenominator":6.5911,"Numerator":119.7324,"Metric":0.1643},{"Threshold":3,"Denominator":731.8,"LogDenominator":6.5955,"Numerator":120.1714,"Metric":0.1642},{"Threshold":3,"Denominator":735.008,"LogDenominator":6.5999,"Numerator":120.6102,"Metric":0.1641},{"Threshold":3,"Denominator":738.216,"LogDenominator":6.6042,"Numerator":121.0488,"Metric":0.164},{"Threshold":3,"Denominator":741.424,"LogDenominator":6.6086,"Numerator":121.4872,"Metric":0.1639},{"Threshold":3,"Denominator":744.632,"LogDenominator":6.6129,"Numerator":121.9254,"Metric":0.1637},{"Threshold":3,"Denominator":747.84,"LogDenominator":6.6172,"Numerator":122.3634,"Metric":0.1636},{"Threshold":3,"Denominator":751.048,"LogDenominator":6.6215,"Numerator":122.8012,"Metric":0.1635},{"Threshold":3,"Denominator":754.256,"LogDenominator":6.6257,"Numerator":123.2389,"Metric":0.1634},{"Threshold":3,"Denominator":757.464,"LogDenominator":6.63,"Numerator":123.6764,"Metric":0.1633},{"Threshold":3,"Denominator":760.672,"LogDenominator":6.6342,"Numerator":124.1136,"Metric":0.1632},{"Threshold":3,"Denominator":763.88,"LogDenominator":6.6384,"Numerator":124.5507,"Metric":0.1631},{"Threshold":3,"Denominator":767.088,"LogDenominator":6.6426,"Numerator":124.9877,"Metric":0.1629},{"Threshold":3,"Denominator":770.296,"LogDenominator":6.6468,"Numerator":125.4244,"Metric":0.1628},{"Threshold":3,"Denominator":773.504,"LogDenominator":6.6509,"Numerator":125.861,"Metric":0.1627},{"Threshold":3,"Denominator":776.712,"LogDenominator":6.6551,"Numerator":126.2974,"Metric":0.1626},{"Threshold":3,"Denominator":779.92,"LogDenominator":6.6592,"Numerator":126.7336,"Metric":0.1625},{"Threshold":3,"Denominator":783.128,"LogDenominator":6.6633,"Numerator":127.1696,"Metric":0.1624},{"Threshold":3,"Denominator":786.336,"LogDenominator":6.6674,"Numerator":127.6055,"Metric":0.1623},{"Threshold":3,"Denominator":789.544,"LogDenominator":6.6715,"Numerator":128.0412,"Metric":0.1622},{"Threshold":3,"Denominator":792.752,"LogDenominator":6.6755,"Numerator":128.4767,"Metric":0.1621},{"Threshold":3,"Denominator":795.96,"LogDenominator":6.6795,"Numerator":128.912,"Metric":0.162},{"Threshold":3,"Denominator":799.168,"LogDenominator":6.6836,"Numerator":129.3472,"Metric":0.1619},{"Threshold":3,"Denominator":802.376,"LogDenominator":6.6876,"Numerator":129.7822,"Metric":0.1617},{"Threshold":3,"Denominator":805.584,"LogDenominator":6.6916,"Numerator":130.217,"Metric":0.1616},{"Threshold":3,"Denominator":808.792,"LogDenominator":6.6955,"Numerator":130.6517,"Metric":0.1615},{"Threshold":3,"Denominator":812,"LogDenominator":6.6995,"Numerator":131.0862,"Metric":0.1614},{"Threshold":3,"Denominator":815.208,"LogDenominator":6.7034,"Numerator":131.5206,"Metric":0.1613},{"Threshold":0,"Denominator":6.792,"LogDenominator":1.9157,"Numerator":0.7431,"Metric":0.1094},{"Threshold":0,"Denominator":10,"LogDenominator":2.3026,"Numerator":1.094,"Metric":0.1094},{"Threshold":0,"Denominator":13.208,"LogDenominator":2.5808,"Numerator":1.445,"Metric":0.1094},{"Threshold":0,"Denominator":16.416,"LogDenominator":2.7983,"Numerator":1.7959,"Metric":0.1094},{"Threshold":0,"Denominator":19.624,"LogDenominator":2.9768,"Numerator":2.1469,"Metric":0.1094},{"Threshold":0,"Denominator":22.832,"LogDenominator":3.1282,"Numerator":2.4979,"Metric":0.1094},{"Threshold":0,"Denominator":26.04,"LogDenominator":3.2596,"Numerator":2.8488,"Metric":0.1094},{"Threshold":0,"Denominator":29.248,"LogDenominator":3.3758,"Numerator":3.1998,"Metric":0.1094},{"Threshold":0,"Denominator":32.456,"LogDenominator":3.4799,"Numerator":3.5507,"Metric":0.1094},{"Threshold":0,"Denominator":35.664,"LogDenominator":3.5741,"Numerator":3.9017,"Metric":0.1094},{"Threshold":0,"Denominator":38.872,"LogDenominator":3.6603,"Numerator":4.2527,"Metric":0.1094},{"Threshold":0,"Denominator":42.08,"LogDenominator":3.7396,"Numerator":4.6036,"Metric":0.1094},{"Threshold":0,"Denominator":45.288,"LogDenominator":3.813,"Numerator":4.9546,"Metric":0.1094},{"Threshold":0,"Denominator":48.496,"LogDenominator":3.8815,"Numerator":5.3056,"Metric":0.1094},{"Threshold":0,"Denominator":51.704,"LogDenominator":3.9455,"Numerator":5.6565,"Metric":0.1094},{"Threshold":0,"Denominator":54.912,"LogDenominator":4.0057,"Numerator":6.0075,"Metric":0.1094},{"Threshold":0,"Denominator":58.12,"LogDenominator":4.0625,"Numerator":6.3584,"Metric":0.1094},{"Threshold":0,"Denominator":61.328,"LogDenominator":4.1162,"Numerator":6.7094,"Metric":0.1094},{"Threshold":0,"Denominator":64.536,"LogDenominator":4.1672,"Numerator":7.0604,"Metric":0.1094},{"Threshold":0,"Denominator":67.744,"LogDenominator":4.2157,"Numerator":7.4113,"Metric":0.1094},{"Threshold":0,"Denominator":70.952,"LogDenominator":4.262,"Numerator":7.7623,"Metric":0.1094},{"Threshold":0,"Denominator":74.16,"LogDenominator":4.3062,"Numerator":8.1132,"Metric":0.1094},{"Threshold":0,"Denominator":77.368,"LogDenominator":4.3486,"Numerator":8.4642,"Metric":0.1094},{"Threshold":0,"Denominator":80.576,"LogDenominator":4.3892,"Numerator":8.8152,"Metric":0.1094},{"Threshold":0,"Denominator":83.784,"LogDenominator":4.4282,"Numerator":9.1661,"Metric":0.1094},{"Threshold":0,"Denominator":86.992,"LogDenominator":4.4658,"Numerator":9.5171,"Metric":0.1094},{"Threshold":0,"Denominator":90.2,"LogDenominator":4.502,"Numerator":9.868,"Metric":0.1094},{"Threshold":0,"Denominator":93.408,"LogDenominator":4.537,"Numerator":10.219,"Metric":0.1094},{"Threshold":0,"Denominator":96.616,"LogDenominator":4.5707,"Numerator":10.57,"Metric":0.1094},{"Threshold":0,"Denominator":99.824,"LogDenominator":4.6034,"Numerator":10.9209,"Metric":0.1094},{"Threshold":0,"Denominator":103.032,"LogDenominator":4.635,"Numerator":11.2719,"Metric":0.1094},{"Threshold":0,"Denominator":106.24,"LogDenominator":4.6657,"Numerator":11.6229,"Metric":0.1094},{"Threshold":0,"Denominator":109.448,"LogDenominator":4.6954,"Numerator":11.9738,"Metric":0.1094},{"Threshold":0,"Denominator":112.656,"LogDenominator":4.7243,"Numerator":12.3248,"Metric":0.1094},{"Threshold":0,"Denominator":115.864,"LogDenominator":4.7524,"Numerator":12.6757,"Metric":0.1094},{"Threshold":0,"Denominator":119.072,"LogDenominator":4.7797,"Numerator":13.0267,"Metric":0.1094},{"Threshold":0,"Denominator":122.28,"LogDenominator":4.8063,"Numerator":13.3777,"Metric":0.1094},{"Threshold":0,"Denominator":125.488,"LogDenominator":4.8322,"Numerator":13.7286,"Metric":0.1094},{"Threshold":0,"Denominator":128.696,"LogDenominator":4.8575,"Numerator":14.0796,"Metric":0.1094},{"Threshold":0,"Denominator":131.904,"LogDenominator":4.8821,"Numerator":14.4305,"Metric":0.1094},{"Threshold":0,"Denominator":135.112,"LogDenominator":4.9061,"Numerator":14.7815,"Metric":0.1094},{"Threshold":0,"Denominator":138.32,"LogDenominator":4.9296,"Numerator":15.1325,"Metric":0.1094},{"Threshold":0,"Denominator":141.528,"LogDenominator":4.9525,"Numerator":15.4834,"Metric":0.1094},{"Threshold":0,"Denominator":144.736,"LogDenominator":4.9749,"Numerator":15.8344,"Metric":0.1094},{"Threshold":0,"Denominator":147.944,"LogDenominator":4.9968,"Numerator":16.1853,"Metric":0.1094},{"Threshold":0,"Denominator":151.152,"LogDenominator":5.0183,"Numerator":16.5363,"Metric":0.1094},{"Threshold":0,"Denominator":154.36,"LogDenominator":5.0393,"Numerator":16.8873,"Metric":0.1094},{"Threshold":0,"Denominator":157.568,"LogDenominator":5.0599,"Numerator":17.2382,"Metric":0.1094},{"Threshold":0,"Denominator":160.776,"LogDenominator":5.08,"Numerator":17.5892,"Metric":0.1094},{"Threshold":0,"Denominator":163.984,"LogDenominator":5.0998,"Numerator":17.9402,"Metric":0.1094},{"Threshold":0,"Denominator":167.192,"LogDenominator":5.1191,"Numerator":18.2911,"Metric":0.1094},{"Threshold":0,"Denominator":170.4,"LogDenominator":5.1381,"Numerator":18.6421,"Metric":0.1094},{"Threshold":0,"Denominator":173.608,"LogDenominator":5.1568,"Numerator":18.993,"Metric":0.1094},{"Threshold":0,"Denominator":176.816,"LogDenominator":5.1751,"Numerator":19.344,"Metric":0.1094},{"Threshold":0,"Denominator":180.024,"LogDenominator":5.1931,"Numerator":19.695,"Metric":0.1094},{"Threshold":0,"Denominator":183.232,"LogDenominator":5.2108,"Numerator":20.0459,"Metric":0.1094},{"Threshold":0,"Denominator":186.44,"LogDenominator":5.2281,"Numerator":20.3969,"Metric":0.1094},{"Threshold":0,"Denominator":189.648,"LogDenominator":5.2452,"Numerator":20.7478,"Metric":0.1094},{"Threshold":0,"Denominator":192.856,"LogDenominator":5.2619,"Numerator":21.0988,"Metric":0.1094},{"Threshold":0,"Denominator":196.064,"LogDenominator":5.2784,"Numerator":21.4498,"Metric":0.1094},{"Threshold":0,"Denominator":199.272,"LogDenominator":5.2947,"Numerator":21.8007,"Metric":0.1094},{"Threshold":0,"Denominator":202.48,"LogDenominator":5.3106,"Numerator":22.1517,"Metric":0.1094},{"Threshold":0,"Denominator":205.688,"LogDenominator":5.3264,"Numerator":22.5026,"Metric":0.1094},{"Threshold":0,"Denominator":208.896,"LogDenominator":5.3418,"Numerator":22.8536,"Metric":0.1094},{"Threshold":0,"Denominator":212.104,"LogDenominator":5.3571,"Numerator":23.2046,"Metric":0.1094},{"Threshold":0,"Denominator":215.312,"LogDenominator":5.3721,"Numerator":23.5555,"Metric":0.1094},{"Threshold":0,"Denominator":218.52,"LogDenominator":5.3869,"Numerator":23.9065,"Metric":0.1094},{"Threshold":0,"Denominator":221.728,"LogDenominator":5.4015,"Numerator":24.2574,"Metric":0.1094},{"Threshold":0,"Denominator":224.936,"LogDenominator":5.4158,"Numerator":24.6084,"Metric":0.1094},{"Threshold":0,"Denominator":228.144,"LogDenominator":5.43,"Numerator":24.9594,"Metric":0.1094},{"Threshold":0,"Denominator":231.352,"LogDenominator":5.4439,"Numerator":25.3103,"Metric":0.1094},{"Threshold":0,"Denominator":234.56,"LogDenominator":5.4577,"Numerator":25.6613,"Metric":0.1094},{"Threshold":0,"Denominator":237.768,"LogDenominator":5.4713,"Numerator":26.0123,"Metric":0.1094},{"Threshold":0,"Denominator":240.976,"LogDenominator":5.4847,"Numerator":26.3632,"Metric":0.1094},{"Threshold":0,"Denominator":244.184,"LogDenominator":5.4979,"Numerator":26.7142,"Metric":0.1094},{"Threshold":0,"Denominator":247.392,"LogDenominator":5.511,"Numerator":27.0651,"Metric":0.1094},{"Threshold":0,"Denominator":250.6,"LogDenominator":5.5239,"Numerator":27.4161,"Metric":0.1094},{"Threshold":0,"Denominator":253.808,"LogDenominator":5.5366,"Numerator":27.7671,"Metric":0.1094},{"Threshold":0,"Denominator":257.016,"LogDenominator":5.5491,"Numerator":28.118,"Metric":0.1094},{"Threshold":0,"Denominator":260.224,"LogDenominator":5.5615,"Numerator":28.469,"Metric":0.1094},{"Threshold":0,"Denominator":263.432,"LogDenominator":5.5738,"Numerator":28.8199,"Metric":0.1094},{"Threshold":0,"Denominator":266.64,"LogDenominator":5.5859,"Numerator":29.1709,"Metric":0.1094},{"Threshold":0,"Denominator":269.848,"LogDenominator":5.5979,"Numerator":29.5219,"Metric":0.1094},{"Threshold":0,"Denominator":273.056,"LogDenominator":5.6097,"Numerator":29.8728,"Metric":0.1094},{"Threshold":0,"Denominator":276.264,"LogDenominator":5.6214,"Numerator":30.2238,"Metric":0.1094},{"Threshold":0,"Denominator":279.472,"LogDenominator":5.6329,"Numerator":30.5747,"Metric":0.1094},{"Threshold":0,"Denominator":282.68,"LogDenominator":5.6443,"Numerator":30.9257,"Metric":0.1094},{"Threshold":0,"Denominator":285.888,"LogDenominator":5.6556,"Numerator":31.2767,"Metric":0.1094},{"Threshold":0,"Denominator":289.096,"LogDenominator":5.6668,"Numerator":31.6276,"Metric":0.1094},{"Threshold":0,"Denominator":292.304,"LogDenominator":5.6778,"Numerator":31.9786,"Metric":0.1094},{"Threshold":0,"Denominator":295.512,"LogDenominator":5.6887,"Numerator":32.3296,"Metric":0.1094},{"Threshold":0,"Denominator":298.72,"LogDenominator":5.6995,"Numerator":32.6805,"Metric":0.1094},{"Threshold":0,"Denominator":301.928,"LogDenominator":5.7102,"Numerator":33.0315,"Metric":0.1094},{"Threshold":0,"Denominator":305.136,"LogDenominator":5.7208,"Numerator":33.3824,"Metric":0.1094},{"Threshold":0,"Denominator":308.344,"LogDenominator":5.7312,"Numerator":33.7334,"Metric":0.1094},{"Threshold":0,"Denominator":311.552,"LogDenominator":5.7416,"Numerator":34.0844,"Metric":0.1094},{"Threshold":0,"Denominator":314.76,"LogDenominator":5.7518,"Numerator":34.4353,"Metric":0.1094},{"Threshold":0,"Denominator":317.968,"LogDenominator":5.762,"Numerator":34.7863,"Metric":0.1094},{"Threshold":0,"Denominator":321.176,"LogDenominator":5.772,"Numerator":35.1372,"Metric":0.1094},{"Threshold":0,"Denominator":324.384,"LogDenominator":5.7819,"Numerator":35.4882,"Metric":0.1094},{"Threshold":0,"Denominator":327.592,"LogDenominator":5.7918,"Numerator":35.8392,"Metric":0.1094},{"Threshold":0,"Denominator":330.8,"LogDenominator":5.8015,"Numerator":36.1901,"Metric":0.1094},{"Threshold":0,"Denominator":334.008,"LogDenominator":5.8112,"Numerator":36.5411,"Metric":0.1094},{"Threshold":0,"Denominator":337.216,"LogDenominator":5.8207,"Numerator":36.892,"Metric":0.1094},{"Threshold":0,"Denominator":340.424,"LogDenominator":5.8302,"Numerator":37.243,"Metric":0.1094},{"Threshold":0,"Denominator":343.632,"LogDenominator":5.8396,"Numerator":37.594,"Metric":0.1094},{"Threshold":0,"Denominator":346.84,"LogDenominator":5.8489,"Numerator":37.9449,"Metric":0.1094},{"Threshold":0,"Denominator":350.048,"LogDenominator":5.8581,"Numerator":38.2959,"Metric":0.1094},{"Threshold":0,"Denominator":353.256,"LogDenominator":5.8672,"Numerator":38.6469,"Metric":0.1094},{"Threshold":0,"Denominator":356.464,"LogDenominator":5.8762,"Numerator":38.9978,"Metric":0.1094},{"Threshold":0,"Denominator":359.672,"LogDenominator":5.8852,"Numerator":39.3488,"Metric":0.1094},{"Threshold":0,"Denominator":362.88,"LogDenominator":5.8941,"Numerator":39.6997,"Metric":0.1094},{"Threshold":0,"Denominator":366.088,"LogDenominator":5.9029,"Numerator":40.0507,"Metric":0.1094},{"Threshold":0,"Denominator":369.296,"LogDenominator":5.9116,"Numerator":40.4017,"Metric":0.1094},{"Threshold":0,"Denominator":372.504,"LogDenominator":5.9202,"Numerator":40.7526,"Metric":0.1094},{"Threshold":0,"Denominator":375.712,"LogDenominator":5.9288,"Numerator":41.1036,"Metric":0.1094},{"Threshold":0,"Denominator":378.92,"LogDenominator":5.9373,"Numerator":41.4545,"Metric":0.1094},{"Threshold":0,"Denominator":382.128,"LogDenominator":5.9458,"Numerator":41.8055,"Metric":0.1094},{"Threshold":0,"Denominator":385.336,"LogDenominator":5.9541,"Numerator":42.1565,"Metric":0.1094},{"Threshold":0,"Denominator":388.544,"LogDenominator":5.9624,"Numerator":42.5074,"Metric":0.1094},{"Threshold":0,"Denominator":391.752,"LogDenominator":5.9706,"Numerator":42.8584,"Metric":0.1094},{"Threshold":0,"Denominator":394.96,"LogDenominator":5.9788,"Numerator":43.2093,"Metric":0.1094},{"Threshold":0,"Denominator":398.168,"LogDenominator":5.9869,"Numerator":43.5603,"Metric":0.1094},{"Threshold":0,"Denominator":401.376,"LogDenominator":5.9949,"Numerator":43.9113,"Metric":0.1094},{"Threshold":0,"Denominator":404.584,"LogDenominator":6.0029,"Numerator":44.2622,"Metric":0.1094},{"Threshold":0,"Denominator":407.792,"LogDenominator":6.0108,"Numerator":44.6132,"Metric":0.1094},{"Threshold":0,"Denominator":411,"LogDenominator":6.0186,"Numerator":44.9642,"Metric":0.1094},{"Threshold":0,"Denominator":414.208,"LogDenominator":6.0264,"Numerator":45.3151,"Metric":0.1094},{"Threshold":0,"Denominator":417.416,"LogDenominator":6.0341,"Numerator":45.6661,"Metric":0.1094},{"Threshold":0,"Denominator":420.624,"LogDenominator":6.0417,"Numerator":46.017,"Metric":0.1094},{"Threshold":0,"Denominator":423.832,"LogDenominator":6.0493,"Numerator":46.368,"Metric":0.1094},{"Threshold":0,"Denominator":427.04,"LogDenominator":6.0569,"Numerator":46.719,"Metric":0.1094},{"Threshold":0,"Denominator":430.248,"LogDenominator":6.0644,"Numerator":47.0699,"Metric":0.1094},{"Threshold":0,"Denominator":433.456,"LogDenominator":6.0718,"Numerator":47.4209,"Metric":0.1094},{"Threshold":0,"Denominator":436.664,"LogDenominator":6.0792,"Numerator":47.7718,"Metric":0.1094},{"Threshold":0,"Denominator":439.872,"LogDenominator":6.0865,"Numerator":48.1228,"Metric":0.1094},{"Threshold":0,"Denominator":443.08,"LogDenominator":6.0938,"Numerator":48.4738,"Metric":0.1094},{"Threshold":0,"Denominator":446.288,"LogDenominator":6.101,"Numerator":48.8247,"Metric":0.1094},{"Threshold":0,"Denominator":449.496,"LogDenominator":6.1081,"Numerator":49.1757,"Metric":0.1094},{"Threshold":0,"Denominator":452.704,"LogDenominator":6.1152,"Numerator":49.5266,"Metric":0.1094},{"Threshold":0,"Denominator":455.912,"LogDenominator":6.1223,"Numerator":49.8776,"Metric":0.1094},{"Threshold":0,"Denominator":459.12,"LogDenominator":6.1293,"Numerator":50.2286,"Metric":0.1094},{"Threshold":0,"Denominator":462.328,"LogDenominator":6.1363,"Numerator":50.5795,"Metric":0.1094},{"Threshold":0,"Denominator":465.536,"LogDenominator":6.1432,"Numerator":50.9305,"Metric":0.1094},{"Threshold":0,"Denominator":468.744,"LogDenominator":6.1501,"Numerator":51.2815,"Metric":0.1094},{"Threshold":0,"Denominator":471.952,"LogDenominator":6.1569,"Numerator":51.6324,"Metric":0.1094},{"Threshold":0,"Denominator":475.16,"LogDenominator":6.1637,"Numerator":51.9834,"Metric":0.1094},{"Threshold":0,"Denominator":478.368,"LogDenominator":6.1704,"Numerator":52.3343,"Metric":0.1094},{"Threshold":0,"Denominator":481.576,"LogDenominator":6.1771,"Numerator":52.6853,"Metric":0.1094},{"Threshold":0,"Denominator":484.784,"LogDenominator":6.1837,"Numerator":53.0363,"Metric":0.1094},{"Threshold":0,"Denominator":487.992,"LogDenominator":6.1903,"Numerator":53.3872,"Metric":0.1094},{"Threshold":0,"Denominator":491.2,"LogDenominator":6.1969,"Numerator":53.7382,"Metric":0.1094},{"Threshold":0,"Denominator":494.408,"LogDenominator":6.2034,"Numerator":54.0891,"Metric":0.1094},{"Threshold":0,"Denominator":497.616,"LogDenominator":6.2098,"Numerator":54.4401,"Metric":0.1094},{"Threshold":0,"Denominator":500.824,"LogDenominator":6.2163,"Numerator":54.7911,"Metric":0.1094},{"Threshold":0,"Denominator":504.032,"LogDenominator":6.2226,"Numerator":55.142,"Metric":0.1094},{"Threshold":0,"Denominator":507.24,"LogDenominator":6.229,"Numerator":55.493,"Metric":0.1094},{"Threshold":0,"Denominator":510.448,"LogDenominator":6.2353,"Numerator":55.8439,"Metric":0.1094},{"Threshold":0,"Denominator":513.656,"LogDenominator":6.2416,"Numerator":56.1949,"Metric":0.1094},{"Threshold":0,"Denominator":516.864,"LogDenominator":6.2478,"Numerator":56.5459,"Metric":0.1094},{"Threshold":0,"Denominator":520.072,"LogDenominator":6.254,"Numerator":56.8968,"Metric":0.1094},{"Threshold":0,"Denominator":523.28,"LogDenominator":6.2601,"Numerator":57.2478,"Metric":0.1094},{"Threshold":0,"Denominator":526.488,"LogDenominator":6.2662,"Numerator":57.5988,"Metric":0.1094},{"Threshold":0,"Denominator":529.696,"LogDenominator":6.2723,"Numerator":57.9497,"Metric":0.1094},{"Threshold":0,"Denominator":532.904,"LogDenominator":6.2783,"Numerator":58.3007,"Metric":0.1094},{"Threshold":0,"Denominator":536.112,"LogDenominator":6.2843,"Numerator":58.6516,"Metric":0.1094},{"Threshold":0,"Denominator":539.32,"LogDenominator":6.2903,"Numerator":59.0026,"Metric":0.1094},{"Threshold":0,"Denominator":542.528,"LogDenominator":6.2962,"Numerator":59.3536,"Metric":0.1094},{"Threshold":0,"Denominator":545.736,"LogDenominator":6.3021,"Numerator":59.7045,"Metric":0.1094},{"Threshold":0,"Denominator":548.944,"LogDenominator":6.308,"Numerator":60.0555,"Metric":0.1094},{"Threshold":0,"Denominator":552.152,"LogDenominator":6.3138,"Numerator":60.4064,"Metric":0.1094},{"Threshold":0,"Denominator":555.36,"LogDenominator":6.3196,"Numerator":60.7574,"Metric":0.1094},{"Threshold":0,"Denominator":558.568,"LogDenominator":6.3254,"Numerator":61.1084,"Metric":0.1094},{"Threshold":0,"Denominator":561.776,"LogDenominator":6.3311,"Numerator":61.4593,"Metric":0.1094},{"Threshold":0,"Denominator":564.984,"LogDenominator":6.3368,"Numerator":61.8103,"Metric":0.1094},{"Threshold":0,"Denominator":568.192,"LogDenominator":6.3425,"Numerator":62.1612,"Metric":0.1094},{"Threshold":0,"Denominator":571.4,"LogDenominator":6.3481,"Numerator":62.5122,"Metric":0.1094},{"Threshold":0,"Denominator":574.608,"LogDenominator":6.3537,"Numerator":62.8632,"Metric":0.1094},{"Threshold":0,"Denominator":577.816,"LogDenominator":6.3593,"Numerator":63.2141,"Metric":0.1094},{"Threshold":0,"Denominator":581.024,"LogDenominator":6.3648,"Numerator":63.5651,"Metric":0.1094},{"Threshold":0,"Denominator":584.232,"LogDenominator":6.3703,"Numerator":63.9161,"Metric":0.1094},{"Threshold":0,"Denominator":587.44,"LogDenominator":6.3758,"Numerator":64.267,"Metric":0.1094},{"Threshold":0,"Denominator":590.648,"LogDenominator":6.3812,"Numerator":64.618,"Metric":0.1094},{"Threshold":0,"Denominator":593.856,"LogDenominator":6.3866,"Numerator":64.9689,"Metric":0.1094},{"Threshold":0,"Denominator":597.064,"LogDenominator":6.392,"Numerator":65.3199,"Metric":0.1094},{"Threshold":0,"Denominator":600.272,"LogDenominator":6.3974,"Numerator":65.6709,"Metric":0.1094},{"Threshold":0,"Denominator":603.48,"LogDenominator":6.4027,"Numerator":66.0218,"Metric":0.1094},{"Threshold":0,"Denominator":606.688,"LogDenominator":6.408,"Numerator":66.3728,"Metric":0.1094},{"Threshold":0,"Denominator":609.896,"LogDenominator":6.4133,"Numerator":66.7237,"Metric":0.1094},{"Threshold":0,"Denominator":613.104,"LogDenominator":6.4185,"Numerator":67.0747,"Metric":0.1094},{"Threshold":0,"Denominator":616.312,"LogDenominator":6.4238,"Numerator":67.4257,"Metric":0.1094},{"Threshold":0,"Denominator":619.52,"LogDenominator":6.4289,"Numerator":67.7766,"Metric":0.1094},{"Threshold":0,"Denominator":622.728,"LogDenominator":6.4341,"Numerator":68.1276,"Metric":0.1094},{"Threshold":0,"Denominator":625.936,"LogDenominator":6.4392,"Numerator":68.4785,"Metric":0.1094},{"Threshold":0,"Denominator":629.144,"LogDenominator":6.4444,"Numerator":68.8295,"Metric":0.1094},{"Threshold":0,"Denominator":632.352,"LogDenominator":6.4494,"Numerator":69.1805,"Metric":0.1094},{"Threshold":0,"Denominator":635.56,"LogDenominator":6.4545,"Numerator":69.5314,"Metric":0.1094},{"Threshold":0,"Denominator":638.768,"LogDenominator":6.4595,"Numerator":69.8824,"Metric":0.1094},{"Threshold":0,"Denominator":641.976,"LogDenominator":6.4646,"Numerator":70.2334,"Metric":0.1094},{"Threshold":0,"Denominator":645.184,"LogDenominator":6.4695,"Numerator":70.5843,"Metric":0.1094},{"Threshold":0,"Denominator":648.392,"LogDenominator":6.4745,"Numerator":70.9353,"Metric":0.1094},{"Threshold":0,"Denominator":651.6,"LogDenominator":6.4794,"Numerator":71.2862,"Metric":0.1094},{"Threshold":0,"Denominator":654.808,"LogDenominator":6.4843,"Numerator":71.6372,"Metric":0.1094},{"Threshold":0,"Denominator":658.016,"LogDenominator":6.4892,"Numerator":71.9882,"Metric":0.1094},{"Threshold":0,"Denominator":661.224,"LogDenominator":6.4941,"Numerator":72.3391,"Metric":0.1094},{"Threshold":0,"Denominator":664.432,"LogDenominator":6.4989,"Numerator":72.6901,"Metric":0.1094},{"Threshold":0,"Denominator":667.64,"LogDenominator":6.5037,"Numerator":73.041,"Metric":0.1094},{"Threshold":0,"Denominator":670.848,"LogDenominator":6.5085,"Numerator":73.392,"Metric":0.1094},{"Threshold":0,"Denominator":674.056,"LogDenominator":6.5133,"Numerator":73.743,"Metric":0.1094},{"Threshold":0,"Denominator":677.264,"LogDenominator":6.5181,"Numerator":74.0939,"Metric":0.1094},{"Threshold":0,"Denominator":680.472,"LogDenominator":6.5228,"Numerator":74.4449,"Metric":0.1094},{"Threshold":0,"Denominator":683.68,"LogDenominator":6.5275,"Numerator":74.7958,"Metric":0.1094},{"Threshold":0,"Denominator":686.888,"LogDenominator":6.5322,"Numerator":75.1468,"Metric":0.1094},{"Threshold":0,"Denominator":690.096,"LogDenominator":6.5368,"Numerator":75.4978,"Metric":0.1094},{"Threshold":0,"Denominator":693.304,"LogDenominator":6.5415,"Numerator":75.8487,"Metric":0.1094},{"Threshold":0,"Denominator":696.512,"LogDenominator":6.5461,"Numerator":76.1997,"Metric":0.1094},{"Threshold":0,"Denominator":699.72,"LogDenominator":6.5507,"Numerator":76.5507,"Metric":0.1094},{"Threshold":0,"Denominator":702.928,"LogDenominator":6.5553,"Numerator":76.9016,"Metric":0.1094},{"Threshold":0,"Denominator":706.136,"LogDenominator":6.5598,"Numerator":77.2526,"Metric":0.1094},{"Threshold":0,"Denominator":709.344,"LogDenominator":6.5643,"Numerator":77.6035,"Metric":0.1094},{"Threshold":0,"Denominator":712.552,"LogDenominator":6.5689,"Numerator":77.9545,"Metric":0.1094},{"Threshold":0,"Denominator":715.76,"LogDenominator":6.5733,"Numerator":78.3055,"Metric":0.1094},{"Threshold":0,"Denominator":718.968,"LogDenominator":6.5778,"Numerator":78.6564,"Metric":0.1094},{"Threshold":0,"Denominator":722.176,"LogDenominator":6.5823,"Numerator":79.0074,"Metric":0.1094},{"Threshold":0,"Denominator":725.384,"LogDenominator":6.5867,"Numerator":79.3583,"Metric":0.1094},{"Threshold":0,"Denominator":728.592,"LogDenominator":6.5911,"Numerator":79.7093,"Metric":0.1094},{"Threshold":0,"Denominator":731.8,"LogDenominator":6.5955,"Numerator":80.0603,"Metric":0.1094},{"Threshold":0,"Denominator":735.008,"LogDenominator":6.5999,"Numerator":80.4112,"Metric":0.1094},{"Threshold":0,"Denominator":738.216,"LogDenominator":6.6042,"Numerator":80.7622,"Metric":0.1094},{"Threshold":0,"Denominator":741.424,"LogDenominator":6.6086,"Numerator":81.1131,"Metric":0.1094},{"Threshold":0,"Denominator":744.632,"LogDenominator":6.6129,"Numerator":81.4641,"Metric":0.1094},{"Threshold":0,"Denominator":747.84,"LogDenominator":6.6172,"Numerator":81.8151,"Metric":0.1094},{"Threshold":0,"Denominator":751.048,"LogDenominator":6.6215,"Numerator":82.166,"Metric":0.1094},{"Threshold":0,"Denominator":754.256,"LogDenominator":6.6257,"Numerator":82.517,"Metric":0.1094},{"Threshold":0,"Denominator":757.464,"LogDenominator":6.63,"Numerator":82.868,"Metric":0.1094},{"Threshold":0,"Denominator":760.672,"LogDenominator":6.6342,"Numerator":83.2189,"Metric":0.1094},{"Threshold":0,"Denominator":763.88,"LogDenominator":6.6384,"Numerator":83.5699,"Metric":0.1094},{"Threshold":0,"Denominator":767.088,"LogDenominator":6.6426,"Numerator":83.9208,"Metric":0.1094},{"Threshold":0,"Denominator":770.296,"LogDenominator":6.6468,"Numerator":84.2718,"Metric":0.1094},{"Threshold":0,"Denominator":773.504,"LogDenominator":6.6509,"Numerator":84.6228,"Metric":0.1094},{"Threshold":0,"Denominator":776.712,"LogDenominator":6.6551,"Numerator":84.9737,"Metric":0.1094},{"Threshold":0,"Denominator":779.92,"LogDenominator":6.6592,"Numerator":85.3247,"Metric":0.1094},{"Threshold":0,"Denominator":783.128,"LogDenominator":6.6633,"Numerator":85.6756,"Metric":0.1094},{"Threshold":0,"Denominator":786.336,"LogDenominator":6.6674,"Numerator":86.0266,"Metric":0.1094},{"Threshold":0,"Denominator":789.544,"LogDenominator":6.6715,"Numerator":86.3776,"Metric":0.1094},{"Threshold":0,"Denominator":792.752,"LogDenominator":6.6755,"Numerator":86.7285,"Metric":0.1094},{"Threshold":0,"Denominator":795.96,"LogDenominator":6.6795,"Numerator":87.0795,"Metric":0.1094},{"Threshold":0,"Denominator":799.168,"LogDenominator":6.6836,"Numerator":87.4304,"Metric":0.1094},{"Threshold":0,"Denominator":802.376,"LogDenominator":6.6876,"Numerator":87.7814,"Metric":0.1094},{"Threshold":0,"Denominator":805.584,"LogDenominator":6.6916,"Numerator":88.1324,"Metric":0.1094},{"Threshold":0,"Denominator":808.792,"LogDenominator":6.6955,"Numerator":88.4833,"Metric":0.1094},{"Threshold":0,"Denominator":812,"LogDenominator":6.6995,"Numerator":88.8343,"Metric":0.1094},{"Threshold":0,"Denominator":815.208,"LogDenominator":6.7034,"Numerator":89.1853,"Metric":0.1094}],"lChartConfig":{"Metric":"Adverse Event Rate","Numerator":"Adverse Events","Denominator":"Days on Study"},"bAddGroupSelect":true,"strShinyGroupSelectID":"GroupID","strFootnote":"","bDebug":false},"evals":[],"jsHooks":[]}</script>
</div>
</div>
</div>
<div id="example-2.2---run-country-level-metric" class="section level2">
<h2>Example 2.2 - Run Country-Level Metric</h2>
<p>This example shows how to modify an existing workflow to analyze data
at a different grouping level (country instead of site).</p>
<pre class="r"><code>AE_country_workflow &lt;- AE_workflow
AE_country_workflow$meta$GroupLevel &lt;- &quot;Country&quot;
AE_country_workflow$steps[[2]]$params$strGroupCol &lt;- &quot;country&quot;

AE_country_KRI &lt;- RunWorkflow(lWorkflow = AE_country_workflow, lData = AE_data)</code></pre>
<pre><code>#&gt; </code></pre>
<pre><code>#&gt;  Initializing `Analysis_kri0001` Workflow </code></pre>
<pre><code>#&gt; </code></pre>
<pre><code>#&gt;  Checking data against spec</code></pre>
<pre><code>#&gt;  All 2 data.frame(s) in the spec are present in the data: Mapped_AE, Mapped_SUBJ</code></pre>
<pre><code>#&gt;  All specified columns in Mapped_AE are in the expected format</code></pre>
<pre><code>#&gt;  All specified columns in Mapped_SUBJ are in the expected format</code></pre>
<pre><code>#&gt;  All 4 specified column(s) in the spec are present in the data: Mapped_AE$subjid, Mapped_SUBJ$subjid, Mapped_SUBJ$invid, Mapped_SUBJ$timeonstudy</code></pre>
<pre><code>#&gt; </code></pre>
<pre><code>#&gt;  Workflow Step 1 of 7: `ParseThreshold` </code></pre>
<pre><code>#&gt; </code></pre>
<pre><code>#&gt;  Evaluating 1 parameter(s) for `ParseThreshold`</code></pre>
<pre><code>#&gt;  strThreshold = Threshold: Passing lMeta$Threshold.</code></pre>
<pre><code>#&gt; </code></pre>
<pre><code>#&gt;  Calling `ParseThreshold`</code></pre>
<pre><code>#&gt; Parsed -2,-1,2,3 to numeric vector: -2, -1, 2, 3
#&gt; 
#&gt; 
#&gt;  double of length 4 saved as `lData$vThreshold`. 
#&gt; 
#&gt; 
#&gt; 
#&gt;  Workflow Step 2 of 7: `Input_Rate` 
#&gt; 
#&gt; 
#&gt; 
#&gt;  Evaluating 9 parameter(s) for `Input_Rate` 
#&gt; 
#&gt;  dfSubjects = Mapped_SUBJ: Passing lData$Mapped_SUBJ.
#&gt; 
#&gt;  dfNumerator = Mapped_AE: Passing lData$Mapped_AE.
#&gt; 
#&gt;  dfDenominator = Mapped_SUBJ: Passing lData$Mapped_SUBJ.
#&gt; 
#&gt;  strSubjectCol = subjid: No matching data found. Passing &#39;subjid&#39; as a string.
#&gt; 
#&gt;  strGroupCol = country: No matching data found. Passing &#39;country&#39; as a string.
#&gt; 
#&gt;  strGroupLevel = GroupLevel: Passing lMeta$GroupLevel.
#&gt; 
#&gt;  strNumeratorMethod = Count: No matching data found. Passing &#39;Count&#39; as a string.
#&gt; 
#&gt;  strDenominatorMethod = Sum: No matching data found. Passing &#39;Sum&#39; as a string.
#&gt; 
#&gt;  strDenominatorCol = timeonstudy: No matching data found. Passing &#39;timeonstudy&#39; as a string.
#&gt; 
#&gt; 
#&gt; 
#&gt;  Calling `Input_Rate` 
#&gt; 
#&gt; 
#&gt; 
#&gt;  1000x6 data.frame saved as `lData$Analysis_Input`. 
#&gt; 
#&gt; 
#&gt; 
#&gt;  Workflow Step 3 of 7: `Transform_Rate` 
#&gt; 
#&gt; 
#&gt; 
#&gt;  Evaluating 1 parameter(s) for `Transform_Rate` 
#&gt; 
#&gt;  dfInput = Analysis_Input: Passing lData$Analysis_Input.
#&gt; 
#&gt; 
#&gt; 
#&gt;  Calling `Transform_Rate` 
#&gt; 
#&gt; 
#&gt; 
#&gt;  3x5 data.frame saved as `lData$Analysis_Transformed`. 
#&gt; 
#&gt; 
#&gt; 
#&gt;  Workflow Step 4 of 7: `Analyze_NormalApprox` 
#&gt; 
#&gt; 
#&gt; 
#&gt;  Evaluating 2 parameter(s) for `Analyze_NormalApprox` 
#&gt; 
#&gt;  dfTransformed = Analysis_Transformed: Passing lData$Analysis_Transformed.
#&gt; 
#&gt;  strType = AnalysisType: Passing lMeta$AnalysisType.
#&gt; 
#&gt; 
#&gt; 
#&gt;  Calling `Analyze_NormalApprox` 
#&gt; 
#&gt; `OverallMetric`, `Factor`, and `Score` columns created from normal approximation.
#&gt; 
#&gt; 
#&gt;  3x8 data.frame saved as `lData$Analysis_Analyzed`. 
#&gt; 
#&gt; 
#&gt; 
#&gt;  Workflow Step 5 of 7: `Flag` 
#&gt; 
#&gt; 
#&gt; 
#&gt;  Evaluating 4 parameter(s) for `Flag` 
#&gt; 
#&gt;  dfAnalyzed = Analysis_Analyzed: Passing lData$Analysis_Analyzed.
#&gt; 
#&gt;  vThreshold = vThreshold: Passing lData$vThreshold.
#&gt; 
#&gt;  nAccrualThreshold = AccrualThreshold: Passing lMeta$AccrualThreshold.
#&gt; 
#&gt;  strAccrualMetric = AccrualMetric: Passing lMeta$AccrualMetric.
#&gt; 
#&gt; 
#&gt; 
#&gt;  Calling `Flag` 
#&gt; 
#&gt;  0 Group(s) have insufficient sample size due to KRI denominator less than 30: 
#&gt; These group(s) will not have KRI score and flag summarized.
#&gt; 
#&gt;  Sorted dfFlagged using custom Flag order: 2.Sorted dfFlagged using custom Flag order: -2.Sorted dfFlagged using custom Flag order: 1.Sorted dfFlagged using custom Flag order: -1.Sorted dfFlagged using custom Flag order: 0.
#&gt; 
#&gt; 
#&gt; 
#&gt;  3x9 data.frame saved as `lData$Analysis_Flagged`. 
#&gt; 
#&gt; 
#&gt; 
#&gt;  Workflow Step 6 of 7: `Summarize` 
#&gt; 
#&gt; 
#&gt; 
#&gt;  Evaluating 1 parameter(s) for `Summarize` 
#&gt; 
#&gt;  dfFlagged = Analysis_Flagged: Passing lData$Analysis_Flagged.
#&gt; 
#&gt; 
#&gt; 
#&gt;  Calling `Summarize` 
#&gt; 
#&gt; 
#&gt; 
#&gt;  3x7 data.frame saved as `lData$Analysis_Summary`. 
#&gt; 
#&gt; 
#&gt; 
#&gt;  Workflow Step 7 of 7: `list` 
#&gt; 
#&gt; 
#&gt; 
#&gt;  Evaluating 6 parameter(s) for `list` 
#&gt; 
#&gt;  ID = ID: Passing lMeta$ID.
#&gt; 
#&gt;  Analysis_Input = Analysis_Input: Passing lData$Analysis_Input.
#&gt; 
#&gt;  Analysis_Transformed = Analysis_Transformed: Passing lData$Analysis_Transformed.
#&gt; 
#&gt;  Analysis_Analyzed = Analysis_Analyzed: Passing lData$Analysis_Analyzed.
#&gt; 
#&gt;  Analysis_Flagged = Analysis_Flagged: Passing lData$Analysis_Flagged.
#&gt; 
#&gt;  Analysis_Summary = Analysis_Summary: Passing lData$Analysis_Summary.
#&gt; 
#&gt; 
#&gt; 
#&gt;  Calling `list` 
#&gt; 
#&gt; 
#&gt; 
#&gt;  list of length 6 saved as `lData$lAnalysis`. 
#&gt; 
#&gt; 
#&gt; 
#&gt;  Returning results from final step: list of length 6`. 
#&gt; 
#&gt; 
#&gt; 
#&gt;  Completed `Analysis_kri0001` Workflow </code></pre>
<pre class="r"><code>Widget_BarChart(dfResults = AE_country_KRI$Analysis_Summary, lMetric = AE_country_workflow$meta)</code></pre>
<div class="Widget_BarChart html-widget html-fill-item" id="htmlwidget-49b8265eb01cf5cf6f9d" style="width:672px;height:480px;"></div>
<script type="application/json" data-for="htmlwidget-49b8265eb01cf5cf6f9d">{"x":{"dfResults":[{"GroupID":"US","GroupLevel":"Country","Numerator":1049,"Denominator":10663,"Metric":0.0984,"Score":-1.2532,"Flag":-1},{"GroupID":"UK","GroupLevel":"Country","Numerator":1027,"Denominator":8458,"Metric":0.1214,"Score":1.1716,"Flag":0},{"GroupID":"Japan","GroupLevel":"Country","Numerator":924,"Denominator":8246,"Metric":0.1121,"Score":0.2385,"Flag":0}],"lMetric":{"Type":"Analysis","ID":"kri0001","GroupLevel":"Country","Abbreviation":"AE","Metric":"Adverse Event Rate","Numerator":"Adverse Events","Denominator":"Days on Study","Model":"Normal Approximation","Score":"Adjusted Z-Score","AnalysisType":"rate","Threshold":"-2,-1,2,3","AccrualThreshold":30,"AccrualMetric":"Denominator"},"dfGroups":null,"vThreshold":null,"lChartConfig":{"Type":"Analysis","ID":"kri0001","GroupLevel":"Country","Abbreviation":"AE","Metric":"Adverse Event Rate","Numerator":"Adverse Events","Denominator":"Days on Study","Model":"Normal Approximation","Score":"Adjusted Z-Score","AnalysisType":"rate","Threshold":"-2,-1,2,3","AccrualThreshold":30,"AccrualMetric":"Denominator","y":"Score"},"strOutcome":"Score","bAddGroupSelect":true,"strShinyGroupSelectID":"GroupID","bDebug":false},"evals":[],"jsHooks":[]}</script>
</div>
<div id="example-2.3---create-sae-workflow" class="section level2">
<h2>Example 2.3 - Create SAE Workflow</h2>
<p>This example demonstrates how to extend a workflow by adding a
filtering step to analyze only serious adverse events.</p>
<pre class="r"><code># Tweak AE workflow metadata
SAE_workflow &lt;- AE_workflow
SAE_workflow$meta$File &lt;- &quot;SAE_KRI&quot;
SAE_workflow$meta$Metric &lt;- &quot;Serious Adverse Event Rate&quot;
SAE_workflow$meta$Numerator &lt;- &quot;Serious Adverse Events&quot;

# Add a step to filter out non-serious AEs `RunQuery`
filterStep &lt;- list(list(
  name = &quot;RunQuery&quot;,
  output = &quot;Mapped_AE&quot;,
  params= list(
    df= &quot;Mapped_AE&quot;,
    strQuery = &quot;SELECT * FROM df WHERE aeser = &#39;Y&#39;&quot;
  ))
)
SAE_workflow$steps &lt;- SAE_workflow$steps %&gt;% append(filterStep, after=0)

# Run the updated workflow
SAE_KRI &lt;- RunWorkflow(lWorkflow = SAE_workflow, lData = AE_data)</code></pre>
<pre><code>#&gt; </code></pre>
<pre><code>#&gt;  Initializing `Analysis_kri0001` Workflow </code></pre>
<pre><code>#&gt; </code></pre>
<pre><code>#&gt;  Checking data against spec</code></pre>
<pre><code>#&gt;  All 2 data.frame(s) in the spec are present in the data: Mapped_AE, Mapped_SUBJ</code></pre>
<pre><code>#&gt;  All specified columns in Mapped_AE are in the expected format</code></pre>
<pre><code>#&gt;  All specified columns in Mapped_SUBJ are in the expected format</code></pre>
<pre><code>#&gt;  All 4 specified column(s) in the spec are present in the data: Mapped_AE$subjid, Mapped_SUBJ$subjid, Mapped_SUBJ$invid, Mapped_SUBJ$timeonstudy</code></pre>
<pre><code>#&gt; </code></pre>
<pre><code>#&gt;  Workflow Step 1 of 8: `RunQuery` </code></pre>
<pre><code>#&gt; </code></pre>
<pre><code>#&gt;  Evaluating 2 parameter(s) for `RunQuery`</code></pre>
<pre><code>#&gt;  df = Mapped_AE: Passing lData$Mapped_AE.</code></pre>
<pre><code>#&gt;  strQuery = SELECT * FROM df WHERE aeser = &#39;Y&#39;: No matching data found. Passing &#39;SELECT * FROM df WHERE aeser = &#39;Y&#39;&#39; as a string.</code></pre>
<pre><code>#&gt; </code></pre>
<pre><code>#&gt;  Calling `RunQuery`</code></pre>
<pre><code>#&gt; Creating a new temporary DuckDB connection.</code></pre>
<pre><code>#&gt;  SQL Query complete: 1526 rows returned.</code></pre>
<pre><code>#&gt; Disconnected from temporary DuckDB connection.</code></pre>
<pre><code>#&gt; Warning: Overwriting existing data in `lData`.</code></pre>
<pre><code>#&gt; </code></pre>
<pre><code>#&gt;  1526x11 data.frame saved as `lData$Mapped_AE`.</code></pre>
<pre><code>#&gt; </code></pre>
<pre><code>#&gt;  Workflow Step 2 of 8: `ParseThreshold` </code></pre>
<pre><code>#&gt; </code></pre>
<pre><code>#&gt;  Evaluating 1 parameter(s) for `ParseThreshold`</code></pre>
<pre><code>#&gt;  strThreshold = Threshold: Passing lMeta$Threshold.</code></pre>
<pre><code>#&gt; </code></pre>
<pre><code>#&gt;  Calling `ParseThreshold`</code></pre>
<pre><code>#&gt; Parsed -2,-1,2,3 to numeric vector: -2, -1, 2, 3
#&gt; 
#&gt; 
#&gt;  double of length 4 saved as `lData$vThreshold`. 
#&gt; 
#&gt; 
#&gt; 
#&gt;  Workflow Step 3 of 8: `Input_Rate` 
#&gt; 
#&gt; 
#&gt; 
#&gt;  Evaluating 9 parameter(s) for `Input_Rate` 
#&gt; 
#&gt;  dfSubjects = Mapped_SUBJ: Passing lData$Mapped_SUBJ.
#&gt; 
#&gt;  dfNumerator = Mapped_AE: Passing lData$Mapped_AE.
#&gt; 
#&gt;  dfDenominator = Mapped_SUBJ: Passing lData$Mapped_SUBJ.
#&gt; 
#&gt;  strSubjectCol = subjid: No matching data found. Passing &#39;subjid&#39; as a string.
#&gt; 
#&gt;  strGroupCol = invid: No matching data found. Passing &#39;invid&#39; as a string.
#&gt; 
#&gt;  strGroupLevel = GroupLevel: Passing lMeta$GroupLevel.
#&gt; 
#&gt;  strNumeratorMethod = Count: No matching data found. Passing &#39;Count&#39; as a string.
#&gt; 
#&gt;  strDenominatorMethod = Sum: No matching data found. Passing &#39;Sum&#39; as a string.
#&gt; 
#&gt;  strDenominatorCol = timeonstudy: No matching data found. Passing &#39;timeonstudy&#39; as a string.
#&gt; 
#&gt; 
#&gt; 
#&gt;  Calling `Input_Rate` 
#&gt; 
#&gt; 
#&gt; 
#&gt;  1000x6 data.frame saved as `lData$Analysis_Input`. 
#&gt; 
#&gt; 
#&gt; 
#&gt;  Workflow Step 4 of 8: `Transform_Rate` 
#&gt; 
#&gt; 
#&gt; 
#&gt;  Evaluating 1 parameter(s) for `Transform_Rate` 
#&gt; 
#&gt;  dfInput = Analysis_Input: Passing lData$Analysis_Input.
#&gt; 
#&gt; 
#&gt; 
#&gt;  Calling `Transform_Rate`</code></pre>
<pre><code>#&gt; Warning: 4 values of [ GroupID ] with a [ Denominator ] value of 0 removed.</code></pre>
<pre><code>#&gt; 
#&gt;  145x5 data.frame saved as `lData$Analysis_Transformed`. 
#&gt; 
#&gt;  Workflow Step 5 of 8: `Analyze_NormalApprox` 
#&gt; 
#&gt;  Evaluating 2 parameter(s) for `Analyze_NormalApprox` 
#&gt;  dfTransformed = Analysis_Transformed: Passing lData$Analysis_Transformed.
#&gt;  strType = AnalysisType: Passing lMeta$AnalysisType.
#&gt; 
#&gt;  Calling `Analyze_NormalApprox` 
#&gt; `OverallMetric`, `Factor`, and `Score` columns created from normal approximation.
#&gt;  145x8 data.frame saved as `lData$Analysis_Analyzed`. 
#&gt; 
#&gt;  Workflow Step 6 of 8: `Flag` 
#&gt; 
#&gt;  Evaluating 4 parameter(s) for `Flag` 
#&gt;  dfAnalyzed = Analysis_Analyzed: Passing lData$Analysis_Analyzed.
#&gt;  vThreshold = vThreshold: Passing lData$vThreshold.
#&gt;  nAccrualThreshold = AccrualThreshold: Passing lMeta$AccrualThreshold.
#&gt;  strAccrualMetric = AccrualMetric: Passing lMeta$AccrualMetric.
#&gt; 
#&gt;  Calling `Flag` 
#&gt;  20 Group(s) have insufficient sample size due to KRI denominator less than 30: 0X7147, 0X2508, 0X5182, 0X5503, 0X1800, 0X4185, 0X3857, 0X6041, 0X155, 0X5579, 0X8547, 0X3556, 0X8592, 0X3565, 0X3777, 0X283, 0X9364, 0X3214, 0X439, 0X7844
#&gt; These group(s) will not have KRI score and flag summarized.
#&gt;  Sorted dfFlagged using custom Flag order: 2.Sorted dfFlagged using custom Flag order: -2.Sorted dfFlagged using custom Flag order: 1.Sorted dfFlagged using custom Flag order: -1.Sorted dfFlagged using custom Flag order: 0.
#&gt; 
#&gt;  145x9 data.frame saved as `lData$Analysis_Flagged`. 
#&gt; 
#&gt;  Workflow Step 7 of 8: `Summarize` 
#&gt; 
#&gt;  Evaluating 1 parameter(s) for `Summarize` 
#&gt;  dfFlagged = Analysis_Flagged: Passing lData$Analysis_Flagged.
#&gt; 
#&gt;  Calling `Summarize` 
#&gt; 
#&gt;  145x7 data.frame saved as `lData$Analysis_Summary`. 
#&gt; 
#&gt;  Workflow Step 8 of 8: `list` 
#&gt; 
#&gt;  Evaluating 6 parameter(s) for `list` 
#&gt;  ID = ID: Passing lMeta$ID.
#&gt;  Analysis_Input = Analysis_Input: Passing lData$Analysis_Input.
#&gt;  Analysis_Transformed = Analysis_Transformed: Passing lData$Analysis_Transformed.
#&gt;  Analysis_Analyzed = Analysis_Analyzed: Passing lData$Analysis_Analyzed.
#&gt;  Analysis_Flagged = Analysis_Flagged: Passing lData$Analysis_Flagged.
#&gt;  Analysis_Summary = Analysis_Summary: Passing lData$Analysis_Summary.
#&gt; 
#&gt;  Calling `list` 
#&gt; 
#&gt;  list of length 6 saved as `lData$lAnalysis`. 
#&gt; 
#&gt;  Returning results from final step: list of length 6`. 
#&gt; 
#&gt;  Completed `Analysis_kri0001` Workflow </code></pre>
<pre class="r"><code>Widget_BarChart(dfResults = SAE_KRI$Analysis_Summary, lMetric = SAE_workflow$meta)</code></pre>
<div class="Widget_BarChart html-widget html-fill-item" id="htmlwidget-12f52a7d7bfa60c875ca" style="width:672px;height:480px;"></div>
<script type="application/json" data-for="htmlwidget-12f52a7d7bfa60c875ca">{"x":{"dfResults":[{"GroupID":"0X8351","GroupLevel":"Site","Numerator":51,"Denominator":448,"Metric":0.1138,"Score":3.9934,"Flag":2},{"GroupID":"0X414","GroupLevel":"Site","Numerator":9,"Denominator":68,"Metric":0.1324,"Score":2.0505,"Flag":1},{"GroupID":"0X3909","GroupLevel":"Site","Numerator":22,"Denominator":216,"Metric":0.1019,"Score":2.202,"Flag":1},{"GroupID":"0X101","GroupLevel":"Site","Numerator":20,"Denominator":197,"Metric":0.1015,"Score":2.0879,"Flag":1},{"GroupID":"0X6405","GroupLevel":"Site","Numerator":20,"Denominator":521,"Metric":0.0384,"Score":-1.2741,"Flag":-1},{"GroupID":"0X958","GroupLevel":"Site","Numerator":12,"Denominator":316,"Metric":0.038,"Score":-1.0161,"Flag":-1},{"GroupID":"0X9814","GroupLevel":"Site","Numerator":10,"Denominator":288,"Metric":0.0347,"Score":-1.1489,"Flag":-1},{"GroupID":"0X3585","GroupLevel":"Site","Numerator":9,"Denominator":270,"Metric":0.0333,"Score":-1.1863,"Flag":-1},{"GroupID":"0X4323","GroupLevel":"Site","Numerator":22,"Denominator":675,"Metric":0.0326,"Score":-1.9381,"Flag":-1},{"GroupID":"0X4264","GroupLevel":"Site","Numerator":12,"Denominator":369,"Metric":0.0325,"Score":-1.4375,"Flag":-1},{"GroupID":"0X9737","GroupLevel":"Site","Numerator":15,"Denominator":467,"Metric":0.0321,"Score":-1.6452,"Flag":-1},{"GroupID":"0X3136","GroupLevel":"Site","Numerator":5,"Denominator":170,"Metric":0.0294,"Score":-1.107,"Flag":-1},{"GroupID":"0X7447","GroupLevel":"Site","Numerator":4,"Denominator":140,"Metric":0.0286,"Score":-1.0368,"Flag":-1},{"GroupID":"0X4629","GroupLevel":"Site","Numerator":12,"Denominator":435,"Metric":0.0276,"Score":-1.8942,"Flag":-1},{"GroupID":"0X334","GroupLevel":"Site","Numerator":5,"Denominator":188,"Metric":0.0266,"Score":-1.2893,"Flag":-1},{"GroupID":"0X8382","GroupLevel":"Site","Numerator":3,"Denominator":125,"Metric":0.024,"Score":-1.1453,"Flag":-1},{"GroupID":"0X9862","GroupLevel":"Site","Numerator":3,"Denominator":157,"Metric":0.0191,"Score":-1.4822,"Flag":-1},{"GroupID":"0X5362","GroupLevel":"Site","Numerator":1,"Denominator":110,"Metric":0.0091,"Score":-1.5811,"Flag":-1},{"GroupID":"0X5048","GroupLevel":"Site","Numerator":0,"Denominator":42,"Metric":0,"Score":-1.1679,"Flag":-1},{"GroupID":"0X9860","GroupLevel":"Site","Numerator":0,"Denominator":41,"Metric":0,"Score":-1.1539,"Flag":-1},{"GroupID":"0X8494","GroupLevel":"Site","Numerator":0,"Denominator":40,"Metric":0,"Score":-1.1397,"Flag":-1},{"GroupID":"0X7438","GroupLevel":"Site","Numerator":0,"Denominator":36,"Metric":0,"Score":-1.0813,"Flag":-1},{"GroupID":"0X3197","GroupLevel":"Site","Numerator":7,"Denominator":57,"Metric":0.1228,"Score":1.6438,"Flag":0},{"GroupID":"0X8551","GroupLevel":"Site","Numerator":12,"Denominator":105,"Metric":0.1143,"Score":1.9481,"Flag":0},{"GroupID":"0X3639","GroupLevel":"Site","Numerator":5,"Denominator":44,"Metric":0.1136,"Score":1.2471,"Flag":0},{"GroupID":"0X6367","GroupLevel":"Site","Numerator":5,"Denominator":44,"Metric":0.1136,"Score":1.2471,"Flag":0},{"GroupID":"0X9520","GroupLevel":"Site","Numerator":11,"Denominator":97,"Metric":0.1134,"Score":1.8442,"Flag":0},{"GroupID":"0X3736","GroupLevel":"Site","Numerator":11,"Denominator":102,"Metric":0.1078,"Score":1.7092,"Flag":0},{"GroupID":"0X567","GroupLevel":"Site","Numerator":9,"Denominator":90,"Metric":0.1,"Score":1.3644,"Flag":0},{"GroupID":"0X8764","GroupLevel":"Site","Numerator":12,"Denominator":120,"Metric":0.1,"Score":1.5755,"Flag":0},{"GroupID":"0X2397","GroupLevel":"Site","Numerator":10,"Denominator":105,"Metric":0.0952,"Score":1.3157,"Flag":0},{"GroupID":"0X7983","GroupLevel":"Site","Numerator":23,"Denominator":243,"Metric":0.0947,"Score":1.9718,"Flag":0},{"GroupID":"0X5787","GroupLevel":"Site","Numerator":17,"Denominator":185,"Metric":0.0919,"Score":1.5989,"Flag":0},{"GroupID":"0X3252","GroupLevel":"Site","Numerator":4,"Denominator":44,"Metric":0.0909,"Score":0.7586,"Flag":0},{"GroupID":"0X4874","GroupLevel":"Site","Numerator":15,"Denominator":173,"Metric":0.0867,"Score":1.3251,"Flag":0},{"GroupID":"0X1257","GroupLevel":"Site","Numerator":14,"Denominator":163,"Metric":0.0859,"Score":1.2525,"Flag":0},{"GroupID":"0X180","GroupLevel":"Site","Numerator":24,"Denominator":281,"Metric":0.0854,"Score":1.6184,"Flag":0},{"GroupID":"0X5384","GroupLevel":"Site","Numerator":34,"Denominator":399,"Metric":0.0852,"Score":1.9158,"Flag":0},{"GroupID":"0X9210","GroupLevel":"Site","Numerator":3,"Denominator":37,"Metric":0.0811,"Score":0.502,"Flag":0},{"GroupID":"0X5033","GroupLevel":"Site","Numerator":17,"Denominator":210,"Metric":0.081,"Score":1.1898,"Flag":0},{"GroupID":"0X3090","GroupLevel":"Site","Numerator":17,"Denominator":213,"Metric":0.0798,"Score":1.1443,"Flag":0},{"GroupID":"0X6521","GroupLevel":"Site","Numerator":4,"Denominator":52,"Metric":0.0769,"Score":0.4979,"Flag":0},{"GroupID":"0X3289","GroupLevel":"Site","Numerator":21,"Denominator":275,"Metric":0.0764,"Score":1.115,"Flag":0},{"GroupID":"0X6384","GroupLevel":"Site","Numerator":14,"Denominator":184,"Metric":0.0761,"Score":0.8999,"Flag":0},{"GroupID":"0X9580","GroupLevel":"Site","Numerator":18,"Denominator":238,"Metric":0.0756,"Score":1.0006,"Flag":0},{"GroupID":"0X9381","GroupLevel":"Site","Numerator":4,"Denominator":56,"Metric":0.0714,"Score":0.3835,"Flag":0},{"GroupID":"0X8823","GroupLevel":"Site","Numerator":8,"Denominator":112,"Metric":0.0714,"Score":0.5423,"Flag":0},{"GroupID":"0X6603","GroupLevel":"Site","Numerator":17,"Denominator":239,"Metric":0.0711,"Score":0.7772,"Flag":0},{"GroupID":"0X6301","GroupLevel":"Site","Numerator":6,"Denominator":86,"Metric":0.0698,"Score":0.4253,"Flag":0},{"GroupID":"0X1910","GroupLevel":"Site","Numerator":21,"Denominator":305,"Metric":0.0689,"Score":0.7491,"Flag":0},{"GroupID":"0X7789","GroupLevel":"Site","Numerator":3,"Denominator":44,"Metric":0.0682,"Score":0.2701,"Flag":0},{"GroupID":"0X7938","GroupLevel":"Site","Numerator":8,"Denominator":119,"Metric":0.0672,"Score":0.4105,"Flag":0},{"GroupID":"0X2532","GroupLevel":"Site","Numerator":31,"Denominator":466,"Metric":0.0665,"Score":0.7631,"Flag":0},{"GroupID":"0X5386","GroupLevel":"Site","Numerator":3,"Denominator":46,"Metric":0.0652,"Score":0.211,"Flag":0},{"GroupID":"0X905","GroupLevel":"Site","Numerator":3,"Denominator":46,"Metric":0.0652,"Score":0.211,"Flag":0},{"GroupID":"0X2376","GroupLevel":"Site","Numerator":8,"Denominator":123,"Metric":0.065,"Score":0.3388,"Flag":0},{"GroupID":"0X5782","GroupLevel":"Site","Numerator":4,"Denominator":62,"Metric":0.0645,"Score":0.2271,"Flag":0},{"GroupID":"0X1839","GroupLevel":"Site","Numerator":12,"Denominator":190,"Metric":0.0632,"Score":0.3369,"Flag":0},{"GroupID":"0X7513","GroupLevel":"Site","Numerator":12,"Denominator":191,"Metric":0.0628,"Score":0.323,"Flag":0},{"GroupID":"0X1109","GroupLevel":"Site","Numerator":2,"Denominator":32,"Metric":0.0625,"Score":0.1262,"Flag":0},{"GroupID":"0X8669","GroupLevel":"Site","Numerator":4,"Denominator":64,"Metric":0.0625,"Score":0.1785,"Flag":0},{"GroupID":"0X2355","GroupLevel":"Site","Numerator":8,"Denominator":128,"Metric":0.0625,"Score":0.2524,"Flag":0},{"GroupID":"0X2574","GroupLevel":"Site","Numerator":10,"Denominator":161,"Metric":0.0621,"Score":0.2671,"Flag":0},{"GroupID":"0X8799","GroupLevel":"Site","Numerator":28,"Denominator":458,"Metric":0.0611,"Score":0.3829,"Flag":0},{"GroupID":"0X1982","GroupLevel":"Site","Numerator":10,"Denominator":164,"Metric":0.061,"Score":0.2225,"Flag":0},{"GroupID":"0X9834","GroupLevel":"Site","Numerator":9,"Denominator":149,"Metric":0.0604,"Score":0.1894,"Flag":0},{"GroupID":"0X7011","GroupLevel":"Site","Numerator":25,"Denominator":416,"Metric":0.0601,"Score":0.2962,"Flag":0},{"GroupID":"0X5788","GroupLevel":"Site","Numerator":11,"Denominator":184,"Metric":0.0598,"Score":0.1832,"Flag":0},{"GroupID":"0X7656","GroupLevel":"Site","Numerator":6,"Denominator":101,"Metric":0.0594,"Score":0.1235,"Flag":0},{"GroupID":"0X8091","GroupLevel":"Site","Numerator":17,"Denominator":287,"Metric":0.0592,"Score":0.1987,"Flag":0},{"GroupID":"0X4485","GroupLevel":"Site","Numerator":23,"Denominator":396,"Metric":0.0581,"Score":0.159,"Flag":0},{"GroupID":"0X7809","GroupLevel":"Site","Numerator":21,"Denominator":366,"Metric":0.0574,"Score":0.1093,"Flag":0},{"GroupID":"0X2123","GroupLevel":"Site","Numerator":8,"Denominator":140,"Metric":0.0571,"Score":0.0586,"Flag":0},{"GroupID":"0X8354","GroupLevel":"Site","Numerator":10,"Denominator":175,"Metric":0.0571,"Score":0.0655,"Flag":0},{"GroupID":"0X2192","GroupLevel":"Site","Numerator":36,"Denominator":633,"Metric":0.0569,"Score":0.1025,"Flag":0},{"GroupID":"0X6980","GroupLevel":"Site","Numerator":8,"Denominator":141,"Metric":0.0567,"Score":0.0432,"Flag":0},{"GroupID":"0X8517","GroupLevel":"Site","Numerator":21,"Denominator":378,"Metric":0.0556,"Score":-0.0037,"Flag":0},{"GroupID":"0X9142","GroupLevel":"Site","Numerator":45,"Denominator":812,"Metric":0.0554,"Score":-0.0181,"Flag":0},{"GroupID":"0X2002","GroupLevel":"Site","Numerator":4,"Denominator":73,"Metric":0.0548,"Score":-0.0227,"Flag":0},{"GroupID":"0X6590","GroupLevel":"Site","Numerator":9,"Denominator":165,"Metric":0.0545,"Score":-0.0445,"Flag":0},{"GroupID":"0X9346","GroupLevel":"Site","Numerator":25,"Denominator":461,"Metric":0.0542,"Score":-0.0963,"Flag":0},{"GroupID":"0X2170","GroupLevel":"Site","Numerator":23,"Denominator":428,"Metric":0.0537,"Score":-0.1258,"Flag":0},{"GroupID":"0X1750","GroupLevel":"Site","Numerator":18,"Denominator":336,"Metric":0.0536,"Score":-0.1213,"Flag":0},{"GroupID":"0X8508","GroupLevel":"Site","Numerator":13,"Denominator":245,"Metric":0.0531,"Score":-0.1295,"Flag":0},{"GroupID":"0X213","GroupLevel":"Site","Numerator":39,"Denominator":742,"Metric":0.0526,"Score":-0.2695,"Flag":0},{"GroupID":"0X956","GroupLevel":"Site","Numerator":8,"Denominator":153,"Metric":0.0523,"Score":-0.1333,"Flag":0},{"GroupID":"0X5895","GroupLevel":"Site","Numerator":27,"Denominator":526,"Metric":0.0513,"Score":-0.3183,"Flag":0},{"GroupID":"0X2901","GroupLevel":"Site","Numerator":16,"Denominator":319,"Metric":0.0502,"Score":-0.3159,"Flag":0},{"GroupID":"0X8625","GroupLevel":"Site","Numerator":24,"Denominator":481,"Metric":0.0499,"Score":-0.4064,"Flag":0},{"GroupID":"0X4590","GroupLevel":"Site","Numerator":24,"Denominator":483,"Metric":0.0497,"Score":-0.4219,"Flag":0},{"GroupID":"0X4130","GroupLevel":"Site","Numerator":6,"Denominator":122,"Metric":0.0492,"Score":-0.2303,"Flag":0},{"GroupID":"0X2513","GroupLevel":"Site","Numerator":2,"Denominator":41,"Metric":0.0488,"Score":-0.1418,"Flag":0},{"GroupID":"0X203","GroupLevel":"Site","Numerator":5,"Denominator":103,"Metric":0.0485,"Score":-0.2325,"Flag":0},{"GroupID":"0X3574","GroupLevel":"Site","Numerator":8,"Denominator":166,"Metric":0.0482,"Score":-0.3098,"Flag":0},{"GroupID":"0X8633","GroupLevel":"Site","Numerator":30,"Denominator":633,"Metric":0.0474,"Score":-0.6702,"Flag":0},{"GroupID":"0X8786","GroupLevel":"Site","Numerator":19,"Denominator":401,"Metric":0.0474,"Score":-0.5342,"Flag":0},{"GroupID":"0X2638","GroupLevel":"Site","Numerator":6,"Denominator":128,"Metric":0.0469,"Score":-0.3204,"Flag":0},{"GroupID":"0X7228","GroupLevel":"Site","Numerator":10,"Denominator":225,"Metric":0.0444,"Score":-0.5429,"Flag":0},{"GroupID":"0X6930","GroupLevel":"Site","Numerator":2,"Denominator":45,"Metric":0.0444,"Score":-0.2428,"Flag":0},{"GroupID":"0X2323","GroupLevel":"Site","Numerator":13,"Denominator":295,"Metric":0.0441,"Score":-0.6426,"Flag":0},{"GroupID":"0X759","GroupLevel":"Site","Numerator":23,"Denominator":523,"Metric":0.044,"Score":-0.8624,"Flag":0},{"GroupID":"0X9683","GroupLevel":"Site","Numerator":3,"Denominator":69,"Metric":0.0435,"Score":-0.3267,"Flag":0},{"GroupID":"0X6792","GroupLevel":"Site","Numerator":11,"Denominator":257,"Metric":0.0428,"Score":-0.6656,"Flag":0},{"GroupID":"0X4959","GroupLevel":"Site","Numerator":13,"Denominator":304,"Metric":0.0428,"Score":-0.7261,"Flag":0},{"GroupID":"0X9017","GroupLevel":"Site","Numerator":7,"Denominator":164,"Metric":0.0427,"Score":-0.5366,"Flag":0},{"GroupID":"0X8788","GroupLevel":"Site","Numerator":13,"Denominator":310,"Metric":0.0419,"Score":-0.7804,"Flag":0},{"GroupID":"0X9360","GroupLevel":"Site","Numerator":18,"Denominator":430,"Metric":0.0419,"Score":-0.9242,"Flag":0},{"GroupID":"0X4324","GroupLevel":"Site","Numerator":5,"Denominator":120,"Metric":0.0417,"Score":-0.4951,"Flag":0},{"GroupID":"0X3083","GroupLevel":"Site","Numerator":2,"Denominator":48,"Metric":0.0417,"Score":-0.3131,"Flag":0},{"GroupID":"0X7349","GroupLevel":"Site","Numerator":2,"Denominator":48,"Metric":0.0417,"Score":-0.3131,"Flag":0},{"GroupID":"0X9858","GroupLevel":"Site","Numerator":5,"Denominator":122,"Metric":0.041,"Score":-0.5236,"Flag":0},{"GroupID":"0X6900","GroupLevel":"Site","Numerator":16,"Denominator":396,"Metric":0.0404,"Score":-0.9808,"Flag":0},{"GroupID":"0X3989","GroupLevel":"Site","Numerator":6,"Denominator":150,"Metric":0.04,"Score":-0.6197,"Flag":0},{"GroupID":"0X2309","GroupLevel":"Site","Numerator":10,"Denominator":255,"Metric":0.0392,"Score":-0.8485,"Flag":0},{"GroupID":"0X5478","GroupLevel":"Site","Numerator":8,"Denominator":216,"Metric":0.037,"Score":-0.8847,"Flag":0},{"GroupID":"0X2318","GroupLevel":"Site","Numerator":5,"Denominator":138,"Metric":0.0362,"Score":-0.7378,"Flag":0},{"GroupID":"0X1137","GroupLevel":"Site","Numerator":7,"Denominator":196,"Metric":0.0357,"Score":-0.9028,"Flag":0},{"GroupID":"0X8591","GroupLevel":"Site","Numerator":1,"Denominator":30,"Metric":0.0333,"Score":-0.3954,"Flag":0},{"GroupID":"0X4561","GroupLevel":"Site","Numerator":5,"Denominator":151,"Metric":0.0331,"Score":-0.896,"Flag":0},{"GroupID":"0X1548","GroupLevel":"Site","Numerator":3,"Denominator":93,"Metric":0.0323,"Score":-0.7299,"Flag":0},{"GroupID":"0X4707","GroupLevel":"Site","Numerator":3,"Denominator":97,"Metric":0.0309,"Score":-0.7878,"Flag":0},{"GroupID":"0X2865","GroupLevel":"Site","Numerator":2,"Denominator":71,"Metric":0.0282,"Score":-0.7494,"Flag":0},{"GroupID":"0X2814","GroupLevel":"Site","Numerator":2,"Denominator":78,"Metric":0.0256,"Score":-0.8578,"Flag":0},{"GroupID":"0X5137","GroupLevel":"Site","Numerator":1,"Denominator":39,"Metric":0.0256,"Score":-0.6065,"Flag":0},{"GroupID":"0X5808","GroupLevel":"Site","Numerator":1,"Denominator":56,"Metric":0.0179,"Score":-0.9156,"Flag":0},{"GroupID":"0X7844","GroupLevel":"Site","Numerator":3,"Denominator":14,"Metric":0.2143,"Score":"NA","Flag":"NA"},{"GroupID":"0X439","GroupLevel":"Site","Numerator":4,"Denominator":23,"Metric":0.1739,"Score":"NA","Flag":"NA"},{"GroupID":"0X283","GroupLevel":"Site","Numerator":2,"Denominator":12,"Metric":0.1667,"Score":"NA","Flag":"NA"},{"GroupID":"0X3214","GroupLevel":"Site","Numerator":4,"Denominator":25,"Metric":0.16,"Score":"NA","Flag":"NA"},{"GroupID":"0X3777","GroupLevel":"Site","Numerator":2,"Denominator":13,"Metric":0.1538,"Score":"NA","Flag":"NA"},{"GroupID":"0X9364","GroupLevel":"Site","Numerator":4,"Denominator":29,"Metric":0.1379,"Score":"NA","Flag":"NA"},{"GroupID":"0X3565","GroupLevel":"Site","Numerator":2,"Denominator":16,"Metric":0.125,"Score":"NA","Flag":"NA"},{"GroupID":"0X8592","GroupLevel":"Site","Numerator":3,"Denominator":28,"Metric":0.1071,"Score":"NA","Flag":"NA"},{"GroupID":"0X3556","GroupLevel":"Site","Numerator":1,"Denominator":10,"Metric":0.1,"Score":"NA","Flag":"NA"},{"GroupID":"0X5579","GroupLevel":"Site","Numerator":1,"Denominator":12,"Metric":0.0833,"Score":"NA","Flag":"NA"},{"GroupID":"0X155","GroupLevel":"Site","Numerator":1,"Denominator":13,"Metric":0.0769,"Score":"NA","Flag":"NA"},{"GroupID":"0X8547","GroupLevel":"Site","Numerator":2,"Denominator":26,"Metric":0.0769,"Score":"NA","Flag":"NA"},{"GroupID":"0X6041","GroupLevel":"Site","Numerator":2,"Denominator":29,"Metric":0.069,"Score":"NA","Flag":"NA"},{"GroupID":"0X3857","GroupLevel":"Site","Numerator":1,"Denominator":17,"Metric":0.0588,"Score":"NA","Flag":"NA"},{"GroupID":"0X4185","GroupLevel":"Site","Numerator":1,"Denominator":20,"Metric":0.05,"Score":"NA","Flag":"NA"},{"GroupID":"0X1800","GroupLevel":"Site","Numerator":1,"Denominator":24,"Metric":0.0417,"Score":"NA","Flag":"NA"},{"GroupID":"0X5503","GroupLevel":"Site","Numerator":1,"Denominator":25,"Metric":0.04,"Score":"NA","Flag":"NA"},{"GroupID":"0X7147","GroupLevel":"Site","Numerator":0,"Denominator":18,"Metric":0,"Score":"NA","Flag":"NA"},{"GroupID":"0X2508","GroupLevel":"Site","Numerator":0,"Denominator":17,"Metric":0,"Score":"NA","Flag":"NA"},{"GroupID":"0X5182","GroupLevel":"Site","Numerator":0,"Denominator":14,"Metric":0,"Score":"NA","Flag":"NA"}],"lMetric":{"Type":"Analysis","ID":"kri0001","GroupLevel":"Site","Abbreviation":"AE","Metric":"Serious Adverse Event Rate","Numerator":"Serious Adverse Events","Denominator":"Days on Study","Model":"Normal Approximation","Score":"Adjusted Z-Score","AnalysisType":"rate","Threshold":"-2,-1,2,3","AccrualThreshold":30,"AccrualMetric":"Denominator","File":"SAE_KRI"},"dfGroups":null,"vThreshold":null,"lChartConfig":{"Type":"Analysis","ID":"kri0001","GroupLevel":"Site","Abbreviation":"AE","Metric":"Serious Adverse Event Rate","Numerator":"Serious Adverse Events","Denominator":"Days on Study","Model":"Normal Approximation","Score":"Adjusted Z-Score","AnalysisType":"rate","Threshold":"-2,-1,2,3","AccrualThreshold":30,"AccrualMetric":"Denominator","File":"SAE_KRI","y":"Score"},"strOutcome":"Score","bAddGroupSelect":true,"strShinyGroupSelectID":"GroupID","bDebug":false},"evals":[],"jsHooks":[]}</script>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
